</UpdateVariable>
```
<!DOCTYPE html>
<!-- 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 -->
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>归墟 - 宿命轮回</title>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
      <link rel="stylesheet" href="http://localhost:5500/vue/src/归墟plus/index.css"><!--本地测试用，下面那个是分发的emm应该是吧，小团体内部测试用，勿外传-->
    <!--<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mengxing-yes/mengxing@main/guixu.css">-->
  </head>
  <body>
    <!-- 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 -->
    <div class="guixu-root-container">
      <!-- 浮动按钮 -->
      <button id="floating-character-btn" class="floating-toggle-btn" title="角色面板">角色</button>
      <button id="floating-interaction-btn" class="floating-toggle-btn" title="功能面板">功能</button>
      
      <div class="game-container">
        <!-- 顶部状态栏 -->
        <!-- 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 -->
        <div class="top-status">
          <!-- 左侧容器：全屏按钮和当前世数 -->
          <div class="status-left-container">
            <!-- 全屏按钮 -->
            <div class="fullscreen-control-left">
              <button id="top-fullscreen-btn" class="fullscreen-toggle-btn" title="进入全屏模式">
                <span class="fullscreen-icon">⛶</span>
              </button>
              <button id="top-exit-fullscreen-btn" class="fullscreen-toggle-btn" style="display: none;" title="退出全屏模式">
                <span class="fullscreen-icon">⛶</span>
              </button>
            </div>
            
            <!-- 当前世数 -->
            <div class="status-item">
              <div class="status-label">当前世数</div>
              <div id="val-current-world" class="status-value">...</div>
            </div>
          </div>
          
          <!-- 当前纪年（居中） -->
          <div class="status-center">
            <div class="status-item">
              <div class="status-label">当前纪年</div>
              <div id="val-jinian" class="status-value">...</div>
            </div>
          </div>
          
          <!-- 归真数（右侧） -->
          <div class="status-right">
            <div class="status-item">
              <div class="status-label">归真数</div>
              <div id="val-guixu-charge-text" class="status-value">...</div>
              <div id="bar-guixu-charge" class="guixu-charge">
                <div class="guixu-fill"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- 左侧角色面板 -->
        <!-- 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 -->
        <div class="character-panel">
          <!-- 左侧面板折叠控制按钮 -->
          <button class="panel-toggle-btn left-panel-toggle" id="left-panel-toggle" title="折叠/展开左侧面板">
            <span class="toggle-arrow">◀</span>
          </button>
          <div class="panel-section">
            <div class="section-title">核心属性 <span style="font-size: 10px; color: #8b7355">(当前/上限)</span></div>
            <div class="attributes-list">
              <div class="attribute-item">
                <span class="attribute-name">血量</span><span id="attr-xueliang" class="attribute-value">...</span>
              </div>
              <div class="attribute-item">
                <span class="attribute-name">法力</span><span id="attr-fali" class="attribute-value">...</span>
              </div>
              <div class="attribute-item">
                <span class="attribute-name">神海</span><span id="attr-shenhai" class="attribute-value">...</span>
              </div>
              <div class="attribute-item">
                <span class="attribute-name">道心</span><span id="attr-daoxin" class="attribute-value">...</span>
              </div>
              <div class="attribute-item">
                <span class="attribute-name">空速</span><span id="attr-kongsu" class="attribute-value">...</span>
              </div>
              <div class="attribute-item">
                <span class="attribute-name">气运</span><span id="attr-qiyun" class="attribute-value">...</span>
              </div>
              <div class="attribute-item">
                <span class="attribute-name">悟性</span><span id="attr-wuxing" class="attribute-value">...</span>
              </div>
              <div class="attribute-item">
                <span class="attribute-name">魅力</span><span id="attr-meili" class="attribute-value">...</span>
              </div>
            </div>
          </div>
          <div class="panel-section">
            <div class="section-title">修为详情</div>
            <div class="attributes-list" id="xiuwei-details-list">
              <div class="attribute-item">
                <span class="attribute-name">当前境界</span>
                <span id="val-jingjie" class="attribute-value">...</span>
              </div>
              <div class="attribute-item">
                <span class="attribute-name">境界映射</span>
                <span id="attr-jingjie-yingshe" class="attribute-value">1</span>
              </div>
              <div class="attribute-item">
                <span class="attribute-name">修为进度</span>
                <span id="attr-xiuxing-jindu" class="attribute-value">0%</span>
              </div>
              <div class="progress-bar" style="margin-top: 5px;">
                <div id="progress-xiuxing" class="progress-fill" style="width: 0%;"></div>
              </div>
              <div class="attribute-item">
                <span class="attribute-name">当前瓶颈</span>
                <span id="attr-xiuxing-pingjing" class="attribute-value">无</span>
              </div>
            </div>
          </div>
          <div class="panel-section">
            <div class="section-title">天赋灵根</div>
            <div id="talent-linggen-list" class="attributes-list-tianfu">
              <!-- 天赋和灵根将动态填充在这里 -->
            </div>
          </div>
          <div class="panel-section">
            <div class="section-title">当前装备</div>
            <div class="equipment-grid">
              <div id="equip-wuqi" class="equipment-slot">武器</div>
              <div id="equip-fangju" class="equipment-slot">防具</div>
              <div id="equip-shipin" class="equipment-slot">饰品</div>
              <div id="equip-fabao1" class="equipment-slot">法宝</div>
              <div id="equip-zhuxiuGongfa" class="equipment-slot">主修功法</div>
              <div id="equip-fuxiuXinfa" class="equipment-slot">辅修心法</div>
            </div>
          </div>
        </div>

        <!-- 中央内容区 -->
        <!-- 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 -->
        <div id="main-content" class="main-content">
          <!-- 滚动导航按钮（已移动到右侧面板） -->
          <div id="historical-text-container" class="game-text-container" style="display: none;">
            <!-- 历史正文内容将在这里显示 -->
          </div>

          <!-- 新增：当前章节标题显示 -->
          <div id="current-chapter-title" class="current-chapter-title" style="display: none;">
            <!-- 当前章节标题将在这里显示 -->
          </div>

          <!-- 新增：思维过程显示区域（长条式设计） -->
          <div id="thinking-process-container" class="thinking-process-container" style="display: none;">
            <div class="thinking-process-header" id="thinking-process-header">
              <div class="thinking-process-title">
                <span class="thinking-process-icon" id="thinking-process-icon">▼</span>
                <span>查看思维过程</span>
              </div>
            </div>
            <div class="thinking-process-content" id="thinking-process-content">
              <!-- 思维过程内容将在这里显示 -->
            </div>
          </div>
          <div id="game-text-display" class="game-text-container">
            <!-- AI生成的主要游戏文本将显示在这里 -->
            <gametxt> 欢迎来到《归墟》的世界。你的宿命，由此开始————如果你这边显示了这些信息，一般是前端炸了hhh </gametxt>
          </div>
          <!-- 新增:本世历程折叠框 -->
          <div id="current-life-container" class="current-life-container" style="display: none;">
            <div class="current-life-header" id="current-life-header">
              <div class="current-life-title">
                <span class="current-life-icon" id="current-life-icon">▼</span>
                <span>本世历程</span>
              </div>
            </div>
            <div class="current-life-content" id="current-life-content">
              <!-- 本世历程内容将在这里显示 -->
            </div>
          </div>
          <!-- 新增:往世涟漪折叠框 -->
          <div id="past-lives-container" class="past-lives-container" style="display: none;">
            <div class="past-lives-header" id="past-lives-header">
              <div class="past-lives-title">
                <span class="past-lives-icon" id="past-lives-icon">▼</span>
                <span>往世涟漪</span>
              </div>
            </div>
            <div class="past-lives-content" id="past-lives-content">
              <!-- 往世涟漪内容将在这里显示 -->
            </div>
          </div>
          <!-- 新增:变量改变提醒 -->
          <div id="variable-changes-reminder" class="variable-changes-reminder" style="display: none;">
            <div class="variable-changes-header" id="variable-changes-header">
              <div class="variable-changes-title">
                <span class="variable-changes-icon" id="variable-changes-icon">▼</span>
                <span>变量改变</span>
                <span class="variable-changes-count" id="variable-changes-count">0</span>
              </div>
            </div>
            <div class="variable-changes-content" id="variable-changes-content">
              <!-- 变量改变内容将在这里显示 -->
            </div>
          </div>
          <!-- 新增：行动选项容器 -->
          <div id="action-options-container"></div>
        </div>

        <!-- 右侧交互面板 -->
        <div class="interaction-panel">
          <!-- 右侧面板折叠控制按钮 -->
          <button class="panel-toggle-btn right-panel-toggle" id="right-panel-toggle" title="折叠/展开右侧面板">
            <span class="toggle-arrow">▶</span>
          </button>
          <div class="main-buttons-container">
            <button id="btn-inventory" class="interaction-btn">背包</button>
            <button id="btn-relationships" class="interaction-btn">人物关系</button>
            <button id="btn-sects" class="interaction-btn">宗门</button>
            <button id="btn-world-events" class="interaction-btn" onclick="GuixuManager.showWorldEvents()">世界大事</button>
            <!--<button id="btn-variable-editor" class="interaction-btn" onclick="GuixuManager.showVariableEditor()">变量编辑</button>-->
            <button id="btn-guixu-system" class="interaction-btn">归墟系统</button>
            <button id="btn-segmented-memory" class="interaction-btn" onclick="GuixuManager.showSegmentedMemoryModal()">分段记忆</button>
            <button id="btn-save-load-manager" class="interaction-btn">存档/读档</button>
            <!-- <button id="btn-novel-mode" class="interaction-btn">小说模式</button> -->
            <button id="btn-reprocess-variables" class="interaction-btn">重新处理变量</button>
            <button id="btn-settings" class="interaction-btn">设置</button>
            <!-- 滚动与章节导航按钮 -->
            <div class="nav-buttons-group" style="display: none;"><!-- 把style="display: none;删掉，然后手动注释某些按钮，就可以隐藏了 -->
              <button id="prev-chapter-btn" class="interaction-btn" title="上一章">上一章</button>
              <button id="next-chapter-btn" class="interaction-btn" title="下一章">下一章</button>
              <button id="scroll-to-top-btn" class="interaction-btn" title="回到顶部">回顶</button>
              <button id="scroll-to-bottom-btn" class="interaction-btn" title="回到本章">本章</button>
              <button id="scroll-to-real-bottom-btn" class="interaction-btn" title="回到底部">回底</button>
            </div>
            <div class="world-line-section">
              <div class="world-line-title">世界线回顾</div>
              <div style="display: flex; gap: 10px; justify-content: center;">
                  <button id="btn-view-journey-main" class="interaction-btn primary-btn" style="flex-grow: 1; white-space: nowrap;">本世历程</button>
                  <button id="btn-view-past-lives-main" class="interaction-btn primary-btn" style="flex-grow: 1; white-space: nowrap;">往世涟漪</button>
              </div>
            </div>
                 </div>
        </div>

        <!-- 底部状态效果 -->
        <div id="bottom-status-container" class="bottom-status">
          <div style="display: flex; align-items: center; gap: 15px; flex-shrink: 0;">
            <!-- 修改：将状态列表改为一个可点击的摘要按钮 -->
            <div id="status-summary-button" class="status-effect">
              <div class="effect-icon"></div>
              <span id="status-summary-text">当前无状态效果</span>
            </div>
            <!-- 新增：流式开关 -->
            <div style="display: flex; align-items: center; gap: 5px;">
                <input type="checkbox" id="streaming-enabled-checkbox" style="cursor: pointer;">
                <label for="streaming-enabled-checkbox" class="auto-write-label" style="font-size: 12px;">开启流式</label>
            </div>
          </div>

          <div class="quick-send-container" style="display: flex; align-items: center; gap: 10px;">
            <!-- 新增：正文字数统计 -->
            <div id="game-text-word-count" style="flex-shrink: 0; color: #bfa88c; font-size: 12px; white-space: nowrap;">正文：0字</div>
            <!-- 输入框 -->
            <textarea id="quick-send-input" class="quick-send-input" placeholder="请在此输入回复..." style="flex-grow: 1;"></textarea>
          </div>

          <!-- 发送按钮行：历史记录在左边，发送在右边 -->
          <div class="send-button-row">
            <button id="btn-show-cache" class="interaction-btn bottom-bar-btn">历史记录</button>
            <button id="btn-quick-send" class="interaction-btn bottom-bar-btn">发送</button>
          </div>
        </div>
      </div>

      <!-- 各种模态窗口 -->
      <div id="inventory-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content inventory-modal-content">
          <div class="modal-header">
            <h2 class="modal-title">我的背包</h2>
            <button class="modal-close-btn">&times;</button>
          </div>
          <div class="modal-body inventory-modal-body">
            <div class="inventory-sidebar">
              <div class="inventory-search-container">
                <input type="text" id="inventory-search-input" class="inventory-search-input" placeholder="搜索物品...">
                <button id="inventory-search-clear" class="inventory-search-clear" style="display: none;">&times;</button>
              </div>
              <div class="inventory-tabs">
                <!-- Tab按钮将由JS动态填充 -->
              </div>
            </div>
            <div class="inventory-content">
              <div class="inventory-content-area">
                <!-- 背包内容将由JS动态填充 -->
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id="relationships-modal" class="modal-overlay">
        <div class="modal-content">
          <div class="modal-body">
            <div class="relationships-container">
              <button class="modal-close-btn relationships-close-btn">&times;</button>
              <!-- 左侧人物选择列表 -->
              <div class="character-list-panel">
                <div class="character-list-header">
                  <div class="header-top">
                    <div class="title">角色档案</div>
                    <div class="header-icons">
                      <span class="header-icon" title="搜索">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                      </span>
                      <div class="sort-dropdown">
                          <span class="header-icon" title="排序">
                              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>
                          </span>
                          <div class="sort-menu">
                              <div class="sort-option" data-sort="default">默认排序 <span class="check-icon">✓</span></div>
                              <div class="sort-option" data-sort="cultivation-desc">修为 (高到低) <span class="check-icon">✓</span></div>
                              <div class="sort-option" data-sort="cultivation-asc">修为 (低到高) <span class="check-icon">✓</span></div>
                              <div class="sort-option" data-sort="favor-desc">好感度 (高到低) <span class="check-icon">✓</span></div>
                              <div class="sort-option" data-sort="favor-asc">好感度 (低到高) <span class="check-icon">✓</span></div>
                          </div>
                      </div>
                      <span class="header-icon" title="添加">
                         <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                      </span>
                    </div>
                  </div>
                  <div class="subtitle">共 0 个角色</div>
                  <div class="character-search-container">
                    <input type="text" class="character-search-input" placeholder="搜索角色...">
                  </div>
                </div>
                <div class="character-list">
                  <!-- 人物列表将由JS动态填充 -->
                </div>
              </div>
              <!-- 右侧详细信息面板 -->
              <div class="character-details-panel">
                <!-- 详细信息将由JS动态填充 -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 宗门模态框 -->
      <div id="sects-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
          <div class="modal-body">
            <div class="sects-container">
              <button class="modal-close-btn sects-close-btn">&times;</button>
              <!-- 左侧宗门选择列表 -->
              <div class="sect-list-panel">
                <div class="sect-list-header">
                  <div class="header-top">
                    <div class="title">宗门档案</div>
                    <div class="header-icons">
                      <span class="header-icon" title="搜索">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                      </span>
                      <div class="sort-dropdown">
                        <span class="header-icon" title="排序">
                          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>
                        </span>
                        <div class="sort-menu">
                          <div class="sort-option selected" data-sort="default">默认排序 <span class="check-icon">✓</span></div>
                          <div class="sort-option" data-sort="level-desc">等级 (高到低) <span class="check-icon">✓</span></div>
                          <div class="sort-option" data-sort="level-asc">等级 (低到高) <span class="check-icon">✓</span></div>
                          <div class="sort-option" data-sort="reputation-desc">声望 (高到低) <span class="check-icon">✓</span></div>
                          <div class="sort-option" data-sort="reputation-asc">声望 (低到高) <span class="check-icon">✓</span></div>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="subtitle">共 0 个宗门</div>
                  <div class="sect-search-container">
                    <input type="text" class="sect-search-input" placeholder="搜索宗门...">
                  </div>
                </div>
                <div class="sect-list">
                  <!-- 宗门列表将由JS动态填充 -->
                </div>
              </div>
              <!-- 右侧详细信息面板 -->
              <div class="sect-details-panel">
                <!-- 详细信息将由JS动态填充 -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="history-modal" class="modal-overlay">
        <div class="modal-content">
          <div class="modal-header">
            <h2 id="history-modal-title" class="modal-title">历史回顾</h2>
            <div style="display: flex; align-items: center; gap: 10px; margin-left: auto;"></div>
            <button class="modal-close-btn" style="margin-left: 15px;">&times;</button>
          </div>
          <div id="history-modal-body" class="modal-body">
             <!-- 新增：修剪控制台 -->
            <div id="trim-console" class="panel-section" style="display: none; margin-bottom: 20px;">
                <div class="section-title">修剪控制台</div>
                <div style="padding: 10px; display: flex; flex-direction: column; gap: 15px;">
                    
                    <!-- 修剪字段选择 -->
                    <div id="trim-fields-container" style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
                        <span style="font-size: 12px; color: #a09c91;">修剪字段:</span>
                        <label style="font-size: 12px; color: #c9aa71;"><input type="checkbox" class="trim-field-checkbox" value="人物" checked> 人物</label>
                        <label style="font-size: 12px; color: #c9aa71;"><input type="checkbox" class="trim-field-checkbox" value="人物关系" checked> 人物关系</label>
                        <label style="font-size: 12px; color: #c9aa71;"><input type="checkbox" class="trim-field-checkbox" value="重要信息" checked> 重要信息</label>
                        <label style="font-size: 12px; color: #c9aa71;"><input type="checkbox" class="trim-field-checkbox" value="暗线与伏笔" checked> 暗线与伏笔</label>
                        <label style="font-size: 12px; color: #c9aa71;"><input type="checkbox" class="trim-field-checkbox" value="地点"> 地点</label>
                        <label style="font-size: 12px; color: #c9aa71;"><input type="checkbox" class="trim-field-checkbox" value="标签"> 标签</label>
                        <label style="font-size: 12px; color: #c9aa71;"><input type="checkbox" class="trim-field-checkbox" value="自动化系统"> 自动化系统</label>
                    </div>

                    <hr style="border-color: rgba(201, 170, 113, 0.2);">

                    <!-- 自动化和手动操作 -->
                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap;">
                        <!-- 左侧：自动化批量操作 -->
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="trim-keep-count" style="font-size: 12px; color: #a09c91;">保留最近</label>
                            <input type="number" id="trim-keep-count" value="10" min="1" style="width: 60px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 4px; padding: 4px; font-size: 12px;">
                            <span style="font-size: 12px; color: #a09c91;">条，其余的:</span>
                            <button id="btn-auto-trim" class="interaction-btn" style="padding: 4px 8px; font-size: 12px;">修剪勾选字段</button>
                            <button id="btn-full-trim" class="interaction-btn btn-danger" style="padding: 4px 8px; font-size: 12px;">永久删除</button>
                        </div>
                        
                        <!-- 右侧：手动精准操作 -->
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label style="font-size: 12px; color: #a09c91;">对于历程中勾选的条目:</label>
                            <button id="btn-precise-trim" class="interaction-btn" style="padding: 4px 8px; font-size: 12px;">修剪上方勾选字段</button>
                        </div>
                    </div>
                </div>
            </div>
            <!-- 历程/涟漪内容将由JS动态填充 -->
          </div>
        </div>
      </div>
      
      <!-- 世界大事模态框 -->
      <div id="world-events-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
          <div class="modal-header world-events-header">
            <div class="world-events-header-left">
              <input type="text" id="world-events-search" class="world-events-search-input" placeholder="搜索事件...">
              <button id="world-events-edit-btn" class="world-events-edit-btn" onclick="GuixuManager.toggleWorldEventsEditMode()">编辑</button>
            </div>
            <h4 class="modal-title world-events-title">世界大事</h4>
            <div class="world-events-header-right">
              <button id="world-events-tabs-toggle" class="world-events-layout-toggle" onclick="GuixuManager.toggleWorldEventsTabs()" title="展开/折叠侧边栏">
              <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 18 9 12 15 6"></polyline>
              </svg>

              </button>
              <button id="world-events-layout-toggle" class="world-events-layout-toggle" onclick="GuixuManager.toggleWorldEventsLayout()" title="切换布局">
                <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                  <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                  <line x1="12" y1="22.08" x2="12" y2="12"></line>
                </svg>
              </button>
              <button class="modal-close-btn">&times;</button>
            </div>
          </div>
          <div id="world-events-modal-body" class="modal-body">
            <!-- 世界大事内容将由JS动态填充 -->
            <div id="world-events-container" class="world-events-main-container">
              <!-- 内容将由renderWorldEventsUI动态生成 -->
            </div>
          </div>
        </div>
      </div>
      
      <div id="novel-mode-modal" class="modal-overlay">
        <div class="modal-content">
          <div class="modal-header">
            <h2 id="novel-mode-modal-title" class="modal-title">小说模式</h2>
            <div style="display: flex; align-items: center; gap: 10px; margin-left: auto;">
              <label for="novel-mode-index-input" style="font-size: 12px; color: #8b7355;">读写序号:</label>
              <input type="number" id="novel-mode-index-input" value="1" min="1" style="width: 60px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 4px; padding: 4px; font-size: 12px;">
            </div>
            <button class="modal-close-btn" style="margin-left: 15px;">&times;</button>
          </div>
          
          <!-- 新增：章节导航栏 -->
          <div id="novel-chapter-nav" style="display: none; padding: 10px; border-bottom: 1px solid #8b7355; background: rgba(26, 26, 46, 0.8);">
            <!-- 显示模式选择 -->
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
              <span style="font-size: 12px; color: #c9aa71;">显示模式:</span>
              <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; color: #8b7355;">
                <input type="radio" name="novel-display-mode" value="single" checked style="margin: 0;">
                单章节
              </label>
              <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; color: #8b7355;">
                <input type="radio" name="novel-display-mode" value="continuous" style="margin: 0;">
                连贯显示
              </label>
              <button id="novel-background-btn" class="interaction-btn" style="padding: 4px 8px; font-size: 11px; margin-left: auto;">背景设置</button>
            </div>
            
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
              <span style="font-size: 12px; color: #c9aa71;">章节导航:</span>
              <select id="chapter-select" style="flex: 1; padding: 4px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 4px; font-size: 12px;">
                <option value="">选择章节...</option>
              </select>
              <button id="prev-chapter-btn" class="interaction-btn" style="padding: 4px 8px; font-size: 11px;">上一章</button>
              <button id="next-chapter-btn" class="interaction-btn" style="padding: 4px 8px; font-size: 11px;">下一章</button>
            </div>
            
            <!-- 新增：书签功能 -->
            <div style="display: flex; align-items: center; gap: 10px;">
              <span style="font-size: 12px; color: #c9aa71;">书签:</span>
              <button id="add-bookmark-btn" class="interaction-btn" style="padding: 4px 8px; font-size: 11px;">添加书签</button>
              <select id="bookmark-select" style="flex: 1; padding: 4px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 4px; font-size: 12px;">
                <option value="">选择书签...</option>
              </select>
              <button id="goto-bookmark-btn" class="interaction-btn" style="padding: 4px 8px; font-size: 11px;">跳转</button>
              <button id="delete-bookmark-btn" class="interaction-btn" style="padding: 4px 8px; font-size: 11px; background: #8b4513;">删除</button>
            </div>
          </div>
          
          <div id="novel-mode-modal-body" class="modal-body">
            <!-- Novel mode content will be dynamically filled here -->
          </div>
        </div>
      </div>
      <div id="command-center-modal" class="modal-overlay">
        <div class="modal-content">
          <div class="modal-header">
            <h2 class="modal-title">指令中心</h2>
            <button class="modal-close-btn">&times;</button>
          </div>
          <div class="modal-body">
            <!-- 指令将由JS动态填充 -->
          </div>
          <div class="command-center-footer">
            <div>
              <button id="btn-clear-commands" class="interaction-btn">清空指令</button>
              <button id="btn-execute-commands" class="interaction-btn primary-btn" style="margin-left: 10px;">
                执行指令
              </button>
            </div>
         </div>
        </div>
      </div>
      <div id="extracted-content-modal" class="modal-overlay">
        <div class="modal-content">
          <div class="modal-header">
            <h2 class="modal-title">最后一次提取的AI内容</h2>
            <div style="display: flex; align-items: center; gap: 10px; margin-left: auto;"></div>
            <button class="modal-close-btn" style="margin-left: 15px;">&times;</button>
          </div>
          <div class="modal-body">
            <div class="panel-section">
              <div class="section-title" style="display: flex; justify-content: space-between; align-items: center">
                <span>本世历程</span>
                <button
                  id="btn-write-journey"
                  class="interaction-btn"
                  style="padding: 4px 8px; font-size: 12px; margin-left: 10px"
                >
                  写入世界书
                </button>
              </div>
              <pre
                id="extracted-journey"
                style="
                  white-space: pre-wrap;
                  word-wrap: break-word;
                  color: #e0dcd1;
                  font-size: 12px;
                  padding: 10px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  min-height: 50px;
                "
              >
无内容</pre
              >
            </div>
            <div class="panel-section">
              <div class="section-title" style="display: flex; justify-content: space-between; align-items: center">
                <span>往世涟漪</span>
                <button
                  id="btn-write-past-lives"
                  class="interaction-btn"
                  style="padding: 4px 8px; font-size: 12px; margin-left: 10px"
                >
                  写入世界书
                </button>
              </div>
              <pre
                id="extracted-past-lives"
                style="
                  white-space: pre-wrap;
                  word-wrap: break-word;
                  color: #e0dcd1;
                  font-size: 12px;
                  padding: 10px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  min-height: 50px;
                "
              >
无内容</pre
              >
            </div>
            <div class="panel-section">
              <div class="section-title" style="display: flex; justify-content: space-between; align-items: center">
                <span>小说模式</span>
                <button
                  id="btn-write-novel-mode"
                  class="interaction-btn"
                  style="padding: 4px 8px; font-size: 12px; margin-left: 10px"
                >
                  写入世界书
                </button>
              </div>
              <pre
                id="extracted-novel-mode"
                style="
                  white-space: pre-wrap;
                  word-wrap: break-word;
                  color: #e0dcd1;
                  font-size: 12px;
                  padding: 10px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  min-height: 50px;
                "
              >
小说模式已关闭</pre
              >
            </div>
            <div class="panel-section">
              <div class="section-title" style="display: flex; justify-content: space-between; align-items: center">
                <span>提取角色</span>
                <button
                  id="btn-write-character-card"
                  class="interaction-btn"
                  style="padding: 4px 8px; font-size: 12px; margin-left: 10px"
                >
                  写入世界书
                </button>
              </div>
              <pre
                id="extracted-character-card"
                style="
                  white-space: pre-wrap;
                  word-wrap: break-word;
                  color: #e0dcd1;
                  font-size: 12px;
                  padding: 10px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  min-height: 50px;
                "
              >
无内容</pre
              >
            </div>
            <details class="panel-section" style="margin-top: 15px">
              <summary class="section-title" style="cursor: pointer; list-style: none">
                <span>本次变量改变</span>
              </summary>
              <pre
                id="extracted-variable-changes"
                style="
                  white-space: pre-wrap;
                  word-wrap: break-word;
                  color: #e0dcd1;
                  font-size: 12px;
                  padding: 10px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  min-height: 50px;
                "
              >
无内容</pre
              >
            </details>
            <details class="panel-section" style="margin-top: 15px;">
              <summary class="section-title" style="cursor: pointer; list-style: none;">
                <span>当前变量</span>
              </summary>
              <pre id="current-mvu-variables" style="white-space: pre-wrap; word-wrap: break-word; color: #e0dcd1; font-size: 12px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px; max-height: 300px; overflow-y: auto;">加载中...</pre>
            </details>
          </div>
        </div>
      </div>

      <!-- 变量编辑器模态框 -->
      <div id="variable-editor-modal" class="modal-overlay">
        <div class="modal-content">
          <div class="modal-header">
            <h2 class="modal-title">变量编辑器</h2>
            <button class="modal-close-btn" onclick="GuixuManager.closeModal('variable-editor-modal')">&times;</button>
          </div>
          <div class="modal-body">
            <div class="variable-editor-container">
              <!-- Tab导航 -->
              <div class="variable-tabs">
                <button class="tab-btn active" data-category="system">系统变量</button>
                <button class="tab-btn" data-category="player">玩家数据</button>
                <button class="tab-btn" data-category="npc">人物关系</button>
              </div>
              
              <!-- 搜索栏 -->
              <div class="variable-search">
                <input type="text" id="variable-search-input" placeholder="搜索变量名...">
              </div>
              
              <!-- 变量显示区域 -->
              <div class="variable-display-area" id="variable-display-area">
                <!-- 变量将在此处以人类可读形式显示 -->
              </div>
              
              <!-- 操作按钮 -->
              <div class="variable-editor-footer">
                <button class="action-btn" id="add-new-variable-btn">添加新变量</button>
                <div style="flex-grow: 1;"></div> <!-- 占位符 -->
                <button class="action-btn primary" id="save-variable-changes-btn">保存修改</button>
                <button class="action-btn" onclick="GuixuManager.closeModal('variable-editor-modal')">关闭</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 装备详情悬浮提示框 (移至body末尾) -->
      <div id="equipment-tooltip"></div>
      <!-- 新增：快速指令弹出菜单 -->
      <div id="quick-command-popup">
        <!-- 内容将由JS动态填充 -->
      </div>
      <!-- 新增：状态效果详情弹出窗口 -->
      <div id="status-effects-popup" class="status-effects-popup">
        <div class="status-effects-popup-header">
          <span>当前状态效果</span>
          <button id="status-effects-popup-close">&times;</button>
        </div>
        <div id="status-effects-popup-list" class="status-effects-popup-list">
          <!-- 状态列表将由JS动态填充 -->
        </div>
      </div>
    </div>


    <!-- 新增：归墟系统模态窗口 - 重构为全屏左右布局 -->
    <div id="guixu-system-modal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-body">
          <div class="guixu-system-container">
            <button class="modal-close-btn guixu-system-close-btn">&times;</button>
            
            <!-- 左侧Tab导航栏 -->
            <div class="guixu-tab-panel">
              <div class="guixu-tab-header">
                <div class="title">归墟系统</div>
              </div>
              <div class="guixu-tab-list">
                <button class="guixu-tab-btn active" data-tab="character">
                  <span class="tab-label">人物详情</span>
                </button>
                <button class="guixu-tab-btn" data-tab="gacha">
                  <span class="tab-label">抽卡</span>
                </button>
                <button class="guixu-tab-btn" data-tab="shop">
                  <span class="tab-label">商店</span>
                </button>
                <button class="guixu-tab-btn" data-tab="quest">
                  <span class="tab-label">任务</span>
                </button>
              </div>
            </div>
            
            <!-- 右侧内容区 -->
          <div class="guixu-content-panel">
            <!-- 人物详情内容 -->
            <div id="guixu-tab-character" class="guixu-tab-content active">
              <div class="character-fullscreen-container">
                  <!-- 左栏:核心属性 -->
                  <div class="character-details-panel-left">
                    <div class="section-header" style="color: #c9aa71;">核心属性</div>
                    <div id="guixu-char-health-container" class="attributes-progress-container"></div>
                    <div id="guixu-char-attributes-container" class="attributes-progress-container" style="margin-top: 6px;"></div>
                    
                    <!-- 当前状态 -->
                    <div class="section-header" style="color: #c9aa71; margin-top: 12px;">当前状态</div>
                    <div id="guixu-char-current-status" class="current-status-list">
                      <div class="status-placeholder" style="color: #8b7355; font-size: 12px; padding: 8px;">暂无状态</div>
                    </div>
                    
                    <!-- 当前战力 -->
                    <div class="section-header" style="color: #c9aa71; margin-top: 12px;">当前战力</div>
                    <div class="combat-power-display">
                      <div id="guixu-char-combat-power" class="combat-power-value">0</div>
                      <div class="combat-power-formula">* 战力 = 法力×0.5 + 神海×1 + 空速×2 + 道心×2</div>
                    </div>
                  </div>
                  
                  <!-- 右栏:修炼与成长信息 -->
                  <div class="character-details-panel-right">
                    <!-- 境界与修炼进度 -->
                    <div class="section-header" style="color: #c9aa71;">境界与修炼</div>
                    <div class="realm-cultivation-section">
                      <div class="realm-display">
                        <span class="realm-label">当前境界</span>
                        <span id="guixu-char-realm" class="realm-value">练气一层</span>
                      </div>
                      <div class="cultivation-progress-wrapper">
                        <div class="cultivation-progress-header">
                          <span class="progress-label">修炼进度</span>
                          <span id="guixu-char-cultivation-percent" class="progress-percent">0%</span>
                        </div>
                        <div class="cultivation-progress-bar">
                          <div id="guixu-char-cultivation-fill" class="cultivation-progress-fill" style="width: 0%"></div>
                        </div>
                      </div>
                      <div class="cultivation-bottleneck">
                        <span class="bottleneck-label">修为瓶颈</span>
                        <span id="guixu-char-bottleneck" class="bottleneck-value">无</span>
                      </div>
                    </div>

                    <!-- 灵根与天赋 -->
                    <div class="section-header" style="color: #c9aa71; margin-top: 12px;">灵根与天赋</div>
                    <div class="talent-root-section">
                      <div class="info-row">
                        <span class="info-label">灵根</span>
                        <span id="guixu-char-linggen" class="info-value">无</span>
                      </div>
                      <div class="info-row">
                        <span class="info-label">天赋</span>
                        <span id="guixu-char-talents" class="info-value-wrap">无</span>
                      </div>
                    </div>

                    <!-- 当前百分比加成 -->
                    <div class="section-header" style="color: #c9aa71; margin-top: 12px;">百分比加成</div>
                    <div class="bonus-grid">
                      <div class="bonus-item">
                        <span class="bonus-label">法力</span>
                        <span id="guixu-char-bonus-fali" class="bonus-value">+0%</span>
                      </div>
                      <div class="bonus-item">
                        <span class="bonus-label">神海</span>
                        <span id="guixu-char-bonus-shenhai" class="bonus-value">+0%</span>
                      </div>
                      <div class="bonus-item">
                        <span class="bonus-label">道心</span>
                        <span id="guixu-char-bonus-daoxin" class="bonus-value">+0%</span>
                      </div>
                      <div class="bonus-item">
                        <span class="bonus-label">空速</span>
                        <span id="guixu-char-bonus-kongsu" class="bonus-value">+0%</span>
                      </div>
                      <div class="bonus-item">
                        <span class="bonus-label">修炼</span>
                        <span id="guixu-char-bonus-xiulian" class="bonus-value">+0%</span>
                      </div>
                    </div>

                    <!-- 辅助属性 -->
                    <div class="section-header" style="color: #c9aa71; margin-top: 12px;">辅助属性</div>
                    <div class="compact-attrs-grid">
                      <div class="compact-attr-item">
                        <span class="attr-label">气运</span>
                        <span id="guixu-char-qiyun" class="attr-value">0</span>
                      </div>
                      <div class="compact-attr-item">
                        <span class="attr-label">悟性</span>
                        <span id="guixu-char-wuxing" class="attr-value">0</span>
                      </div>
                      <div class="compact-attr-item">
                        <span class="attr-label">魅力</span>
                        <span id="guixu-char-meili" class="attr-value">0</span>
                      </div>
                      <div class="compact-attr-item">
                        <span class="attr-label">仙灵之气</span>
                        <span id="guixu-char-xianling" class="attr-value">0</span>
                      </div>
                      <div class="compact-attr-item">
                        <span class="attr-label">生理年龄</span>
                        <span id="guixu-char-age-physical" class="attr-value">0 / 0</span>
                      </div>
                      <div class="compact-attr-item">
                        <span class="attr-label">心理年龄</span>
                        <span id="guixu-char-age-mental" class="attr-value">0 / 0</span>
                      </div>
                    </div>
                    
                    <!-- 归墟信息 -->
                    <div class="section-header" style="color: #c9aa71; margin-top: 12px;">归墟信息</div>
                    <div class="compact-attrs-grid">
                      <div class="compact-attr-item">
                        <span class="attr-label">当前时间纪年</span>
                        <span id="guixu-char-time" class="attr-value">玄昊历1年1月1日</span>
                      </div>
                      <div class="compact-attr-item">
                        <span class="attr-label">当前世数</span>
                        <span id="guixu-char-world" class="attr-value">第 1 世</span>
                      </div>
                      <div class="compact-attr-item">
                        <span class="attr-label">归墟点</span>
                        <span id="guixu-char-guixu-point" class="attr-value">0</span>
                      </div>
                      <div class="compact-attr-item">
                        <span class="attr-label">归真点</span>
                        <span id="guixu-char-guizhen" class="attr-value">0</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
              
              <!-- 衍梦尘内容 -->
              <div id="guixu-tab-gacha" class="guixu-tab-content">
                <!-- 衍梦尘界面将由JS动态填充 -->
                <div id="gacha-embedded-container"></div>
              </div>
              
              <!-- 归墟空间内容 -->
              <div id="guixu-tab-shop" class="guixu-tab-content">
                <!-- 归墟空间界面将由JS动态填充 -->
                <div id="shop-embedded-container"></div>
              </div>
              
              <!-- 任务内容 -->
              <div id="guixu-tab-quest" class="guixu-tab-content">
                <div class="quest-layout">
                  <!-- 左侧状态筛选 -->
                  <div class="quest-status-tabs">
                    <div class="panel-tab-header">任务状态</div>
                    <button class="panel-tab-btn" data-status="unclaimed">待接取</button>
                    <button class="panel-tab-btn active" data-status="unfinished">未完成</button>
                    <button class="panel-tab-btn" data-status="completed">已完成</button>
                  </div>
                  
                  <!-- 右侧任务列表 -->
                  <div class="quest-list-panel">
                    <div class="panel-tab-header">任务列表</div>
                    <div id="quest-list-container" class="quest-list-container">
                      <!-- 任务列表将由JS动态填充 -->
                      <div class="quest-placeholder">
                        <div class="placeholder-icon">📜</div>
                        <div class="placeholder-text">暂无任务</div>
                        <div class="placeholder-desc">完成主线剧情可获得任务</div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 新增：归墟空间模态窗口 -->
    <div id="guixu-space-modal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">归墟空间</h2>
          <button class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <!-- 归墟空间内容将由JS动态填充 -->
        </div>
      </div>
    </div>

    <!-- 新增：自定义确认模态框 -->
    <div id="custom-confirm-modal" class="modal-overlay">
      <div class="modal-content confirm-modal-content">
        <div class="modal-header">
          <h3 class="modal-title">确认操作</h3>
          <button class="modal-close-btn" onclick="GuixuManager.closeModal('custom-confirm-modal')">&times;</button>
        </div>
        <div id="custom-confirm-message" class="confirm-modal-message">
          <!-- 消息将由JS填充 -->
        </div>
        <div class="confirm-modal-buttons">
          <button id="custom-confirm-btn-ok" class="interaction-btn primary-btn">确认</button>
          <button id="custom-confirm-btn-cancel" class="interaction-btn">取消</button>
        </div>
      </div>
    </div>

    <!-- 新增：格式审查详情模态框 -->
    <div id="format-validation-modal" class="modal-overlay">
      <div class="modal-content" style="max-width: 90%; max-height: 90vh;">
        <div class="modal-header">
          <h2 class="modal-title">🔍 格式审查详情</h2>
          <button class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-body" style="max-height: calc(90vh - 120px); overflow-y: auto;">
          <div class="format-validation-section">
            <h3 style="color: #c9aa71; margin-bottom: 15px;">检测到的格式问题：</h3>
            <div id="format-errors-list" class="format-errors-container">
              <!-- 格式错误列表将由JS动态填充 -->
            </div>
          </div>
          
          <!-- 新增：原始文本显示和编辑区域 -->
          <div class="format-validation-section" style="margin-top: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
              <h3 style="color: #c9aa71; margin: 0;">AI回复原始文本：</h3>
              <button id="format-text-edit-toggle" class="interaction-btn" style="padding: 5px 15px; font-size: 12px;">
                <span id="format-text-edit-icon">✏️ 编辑</span>
              </button>
            </div>
            <div id="format-raw-text-container" style="position: relative;">
              <!-- 显示模式 -->
              <div id="format-text-display" style="
                background: rgba(26, 26, 46, 0.8);
                border: 1px solid #8b7355;
                border-radius: 6px;
                padding: 15px;
                color: #c9aa71;
                font-family: monospace;
                font-size: 13px;
                line-height: 1.6;
                max-height: 300px;
                overflow-y: auto;
                white-space: pre-wrap;
                word-wrap: break-word;
              "></div>
              <!-- 编辑模式 -->
              <textarea id="format-text-editor" style="
                display: none;
                width: 100%;
                min-height: 300px;
                background: rgba(26, 26, 46, 0.9);
                border: 2px solid #c9aa71;
                border-radius: 6px;
                padding: 15px;
                color: #c9aa71;
                font-family: monospace;
                font-size: 13px;
                line-height: 1.6;
                resize: vertical;
              "></textarea>
            </div>
            <div id="format-edit-hint" style="
              display: none;
              margin-top: 8px;
              padding: 8px 12px;
              background: rgba(201, 170, 113, 0.1);
              border-left: 3px solid #c9aa71;
              color: #8b7355;
              font-size: 12px;
            ">
              💡 提示：编辑后的文本将替换原文本，并传递给后续处理逻辑
            </div>
          </div>
          
          <div class="format-validation-actions" style="margin-top: 20px; text-align: center;">
            <button id="format-validation-rollback" class="interaction-btn primary-btn" style="margin-right: 10px;">回退到上一条内容</button>
            <button id="format-validation-continue" class="interaction-btn">保留并继续处理</button>
          </div>
        </div>
      </div>
    </div>

    <!-- 新增：输入缓存模态窗口 -->
    <div id="input-cache-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">输入历史</h2>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="input-cache-section">
                    <h3 class="section-title" style="text-align: left; margin-bottom: 10px;">最近两次输入</h3>
                    <ul id="recent-inputs-list" class="input-cache-list">
                        <li class="empty-category-text">暂无记录</li>
                    </ul>
                </div>
                <details class="input-cache-section">
                    <summary class="section-title" style="text-align: left; margin-bottom: 10px;">所有历史记录</summary>
                    <ul id="all-inputs-list" class="input-cache-list">
                        <li class="empty-category-text">暂无记录</li>
                    </ul>
                </details>
            </div>
        </div>
    </div>


    <!-- 重构:存档/读档管理模态窗口 -->
    <div id="save-load-modal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">存档管理</h2>
          <div style="display: flex; gap: 10px; align-items: center; margin-left: auto;">
            <div class="series-selector-container">
              <label for="current-series-select">当前系列:</label>
              <select id="current-series-select" class="series-select">
                <option value="">无系列</option>
              </select>
            </div>
            <div class="auto-save-toggle">
              <label for="auto-save-checkbox">自动存档(必开)</label>
              <input type="checkbox" id="auto-save-checkbox" />
            </div>
            <button id="btn-manual-save" class="interaction-btn primary-btn">手动存档</button>
            <button id="btn-import-save" class="interaction-btn">导入存档</button>
            <button id="btn-clear-all-saves" class="clear-saves-btn">清除所有存档</button>
          </div>
          <button class="modal-close-btn" style="margin-left: 15px;">&times;</button>
        </div>
        <div class="modal-body save-load-split-container">
          <!-- 左侧:系列列表 -->
          <div class="series-sidebar">
            <div class="series-sidebar-header">
              <h3>系列列表</h3>
              <button id="btn-manage-series" class="interaction-btn">管理系列</button>
            </div>
            <div class="series-tabs-container" id="series-tabs">
              <!-- 系列tab将由JS动态填充 -->
            </div>
          </div>
          <!-- 右侧:存档列表 -->
          <div class="saves-content-area" id="new-save-load-container">
            <!-- 存档列表将由JS动态填充 -->
          </div>
        </div>
      </div>
    </div>

   <!-- 新增：用于文件导入的隐藏input -->
  <input type="file" id="import-file-input" style="display: none;" accept=".json" />

   <!-- 新增：系列管理模态框 -->
   <div id="series-manager-modal" class="modal-overlay">
     <div class="modal-content" style="width: 600px; max-height: 70vh;">
       <div class="modal-header">
         <h2 class="modal-title">系列管理</h2>
         <button class="modal-close-btn" onclick="GuixuManager.closeSeriesManager()">&times;</button>
       </div>
       <div class="modal-body">
         <div class="series-manager-container">
           <div class="series-manager-header">
             <button id="btn-add-series" class="interaction-btn primary-btn">添加新系列</button>
           </div>
           <div class="series-list" id="series-list">
             <!-- 系列列表将由JS动态填充 -->
           </div>
         </div>
    <!-- 新增：系列命名模态框 -->
    <div id="series-name-modal" class="modal-overlay">
      <div class="modal-content" style="width: 400px; height: auto;">
        <div class="modal-header">
          <h2 class="modal-title" id="series-name-modal-title">系列命名</h2>
          <button class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <input type="text" id="series-name-input" class="series-name-input" placeholder="输入系列名称...">
        </div>
        <div class="modal-footer">
          <button id="series-name-cancel-btn" class="interaction-btn">取消</button>
          <button id="series-name-confirm-btn" class="interaction-btn primary-btn">确认</button>
        </div>
      </div>
    </div>
       </div>
     </div>
   </div>

   <!-- 新增：自动化系统修剪模态框 -->
   <div id="trim-journey-modal" class="modal-overlay">
     <div class="modal-content" style="width: 500px; height: auto;">
       <div class="modal-header">
         <h2 class="modal-title">自动化系统修剪</h2>
         <button class="modal-close-btn">&times;</button>
       </div>
       <div class="modal-body" style="padding: 20px;">
         <p style="color: #a09c91; font-size: 14px; margin-bottom: 20px;">
           此功能将移除"本世历程"中除最近两个事件外的所有"自动化系统"内容，以优化性能和减少干扰。
         </p>
         <div class="panel-section">
             <div class="section-title">修剪选项</div>
             <div class="attributes-list" style="padding: 10px;">
                 <div class="attribute-item">
                     <span class="attribute-name">读取/写入序号</span>
                     <input type="number" id="trim-journey-index-input" value="1" min="1" style="width: 80px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 4px; padding: 4px; font-size: 12px;">
                 </div>
             </div>
         </div>
         <div class="confirm-modal-buttons" style="margin-top: 20px;">
           <button id="btn-confirm-trim" class="interaction-btn primary-btn">确认修剪</button>
           <button id="btn-cancel-trim" class="interaction-btn">取消</button>
         </div>
       </div>
     </div>
   </div>

   <!-- 新增：设置模态框 -->
   <div id="settings-modal" class="modal-overlay" style="display: none !important;">
     <div class="modal-content">
       <div class="modal-header">
         <h2 class="modal-title">设置</h2>
         <button class="modal-close-btn">&times;</button>
       </div>
       <div class="modal-body">
         <!-- 新的左右布局结构 -->
         <div class="settings-layout">
           <!-- 左侧导航 -->
           <div class="settings-sidebar">
             <button class="sidebar-nav-btn active" data-category="interface">界面设置</button>
             <button class="sidebar-nav-btn" data-category="text">文字设置</button>
             <button class="sidebar-nav-btn" data-category="worldbook">世界书控制</button>
             <button class="sidebar-nav-btn" data-category="aux-model">第二API</button>
             <button class="sidebar-nav-btn" data-category="system">系统</button>
           </div>

           <!-- 右侧内容区 -->
           <div class="settings-content">
             
             <!-- 界面设置内容 -->
             <div class="settings-panel active" id="interface-panel">
               <div class="panel-section">
                 <div class="section-title">窗口与视图</div>
                 <div style="display: flex; flex-direction: column; gap: 10px; padding: 10px;">
                   <button id="view-toggle-btn" class="interaction-btn" style="display: flex; align-items: center; justify-content: flex-start; text-align: left;">
                     <span style="margin-right: 8px;">📱</span>
                     <div style="flex-grow: 1;">
                       <div>切换视图模式</div>
                       <div style="font-size: 11px; color: #8b7355;">在桌面和移动视图间切换</div>
                     </div>
                   </button>
                   <button id="fullscreen-btn" class="interaction-btn" style="display: flex; align-items: center; justify-content: flex-start; text-align: left;">
                     <span style="margin-right: 8px;">↔️</span>
                     <div style="flex-grow: 1;">
                       <div>进入全屏模式</div>
                       <div style="font-size: 11px; color: #8b7355;">全屏显示游戏界面</div>
                     </div>
                   </button>
                   <button id="exit-fullscreen-btn" class="interaction-btn" style="display: none; align-items: center; justify-content: flex-start; text-align: left;">
                     <span style="margin-right: 8px;">↘️</span>
                     <div style="flex-grow: 1;">
                       <div>退出全屏模式</div>
                       <div style="font-size: 11px; color: #8b7355;">返回窗口模式</div>
                     </div>
                   </button>
                   <button id="background-settings-btn" class="interaction-btn" style="display: flex; align-items: center; justify-content: flex-start; text-align: left;">
                     <span style="margin-right: 8px;">🖼️</span>
                     <div style="flex-grow: 1;">
                       <div>背景图设置</div>
                       <div style="font-size: 11px; color: #8b7355;">管理自定义背景图片</div>
                     </div>
                   </button>
                   <div style="padding: 8px 10px 0px 10px;">
                     <div style="display: flex; align-items: center; gap: 10px;">
                       <span style="color: #8b7355; font-size: 12px; min-width: 50px;">背景清晰</span>
                       <input type="range" id="opacity-slider" min="0" max="100" value="100" style="flex-grow: 1; height: 6px; background: #1a1a2e; border-radius: 3px; outline: none; -webkit-appearance: none;">
                       <span style="color: #8b7355; font-size: 12px; min-width: 50px;">界面清晰</span>
                     </div>
                     <div style="text-align: center; margin-top: 4px;">
                       <span id="opacity-value" style="color: #c9aa71; font-size: 12px;">当前设置: 100%</span>
                     </div>
                   </div>
                 </div>
                 <div style="display: flex; flex-direction: column; gap: 8px; padding: 10px;">
                   <!-- 界面与面板尺寸控制 -->
                   <div style="display: flex; flex-direction: column; gap: 8px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355;">
                     <div style="color: #c9aa71; font-size: 13px; font-weight: bold; margin-bottom: 5px;">
                       <span style="margin-right: 8px;">📏</span>界面尺寸调整
                     </div>
                     <!-- 主界面尺寸 -->
                     <div class="panel-width-setting-item">
                       <label for="width-slider">界面宽度: <span id="width-display">900px</span></label>
                       <input type="range" id="width-slider" min="600" max="1400" value="900" step="50">
                     </div>
                     <div class="panel-width-setting-item">
                       <label for="height-slider">界面高度: <span id="height-display">600px</span></label>
                       <input type="range" id="height-slider" min="400" max="1000" value="600" step="50">
                     </div>
                     <!-- 模态框尺寸 -->
                     <div style="border-top: 1px solid rgba(139, 115, 85, 0.3); padding-top: 8px; margin-top: 8px;">
                       <div style="color: #c9aa71; font-size: 12px; margin-bottom: 8px;">模态框尺寸</div>
                       <div class="panel-width-setting-item">
                         <label for="modal-width-slider">模态框宽度: <span id="modal-width-display">800px</span></label>
                         <input type="range" id="modal-width-slider" min="400" max="1200" value="800" step="50">
                       </div>
                       <div class="panel-width-setting-item">
                         <label for="modal-height-slider">模态框高度: <span id="modal-height-display">600px</span></label>
                         <input type="range" id="modal-height-slider" min="300" max="900" value="600" step="50">
                       </div>
                     </div>
                      <div style="border-top: 1px solid rgba(139, 115, 85, 0.3); padding-top: 8px; margin-top: 8px;">
                       <div style="color: #c9aa71; font-size: 13px; font-weight: bold; margin-bottom: 5px;">
                         <span style="margin-right: 8px;">📐</span>面板宽度调整
                       </div>
                       <div class="panel-width-setting-item">
                         <label for="left-panel-width-slider">左侧面板宽度:</label>
                         <input type="range" id="left-panel-width-slider" min="15" max="40" value="20">
                         <span id="left-panel-width-value">20%</span>
                       </div>
                       <div class="panel-width-setting-item">
                         <label for="right-panel-width-slider">右侧面板宽度:</label>
                         <input type="range" id="right-panel-width-slider" min="15" max="40" value="20">
                         <span id="right-panel-width-value">20%</span>
                       </div>
                     </div>
                     <div style="display: flex; gap: 8px; margin-top: 8px;">
                       <button id="reset-size-btn" class="interaction-btn" style="flex: 1; padding: 4px 8px; font-size: 11px;">重置主界面</button>
                       <button id="reset-modal-size-btn" class="interaction-btn" style="flex: 1; padding: 4px 8px; font-size: 11px;">重置模态框</button>
                       <button id="reset-panel-width-btn" class="interaction-btn" style="flex: 1; padding: 4px 8px; font-size: 11px;">重置面板</button>
                     </div>
                   </div>
                 </div>
               </div>
             </div>

             <!-- 文字设置内容 -->
             <div class="settings-panel" id="text-panel">
               <div class="panel-section">
                 <div class="section-title">字体颜色、大小</div>
                 <div style="display: flex; flex-direction: column; gap: 15px; padding: 10px;">
                   <!-- 文字颜色与字体大小设置 -->
                   <div>
                     <div style="font-size: 12px; color: #c9aa71; margin-bottom: 8px;">文字颜色与字体大小</div>
                     <div style="display: flex; flex-direction: column; gap: 8px;">
                       <!-- 正文设置 -->
                       <div style="display: flex; align-items: center; gap: 8px; padding: 6px; background: rgba(26, 26, 46, 0.4); border-radius: 4px;">
                         <span style="font-size: 11px; color: #8b7355; min-width: 50px;">正文:</span>
                         <input type="color" id="text-color-normal" value="#e8dcc6" style="width: 30px; height: 20px; border: 1px solid #8b7355; background: transparent; cursor: pointer;">
                         <input type="range" id="font-size-normal" min="10" max="28" value="14" style="flex: 1; background: #8b7355;" title="正文字体大小">
                         <span id="font-size-normal-value" style="font-size: 10px; color: #8b7355; min-width: 30px;">14px</span>
                       </div>
                       
                       <!-- 对话设置 -->
                       <div style="display: flex; align-items: center; gap: 8px; padding: 6px; background: rgba(26, 26, 46, 0.4); border-radius: 4px;">
                         <span style="font-size: 11px; color: #8b7355; min-width: 50px;">对话:</span>
                         <input type="color" id="text-color-dialogue" value="#ff1493" style="width: 30px; height: 20px; border: 1px solid #8b7355; background: transparent; cursor: pointer;">
                         <input type="range" id="font-size-dialogue" min="10" max="28" value="14" style="flex: 1; background: #8b7355;" title="对话字体大小">
                         <span id="font-size-dialogue-value" style="font-size: 10px; color: #8b7355; min-width: 30px;">14px</span>
                       </div>
                       
                       <!-- 心理活动设置 -->
                       <div style="display: flex; align-items: center; gap: 8px; padding: 6px; background: rgba(26, 26, 46, 0.4); border-radius: 4px;">
                         <span style="font-size: 11px; color: #8b7355; min-width: 50px;">心理:</span>
                         <input type="color" id="text-color-psychology" value="#808080" style="width: 30px; height: 20px; border: 1px solid #8b7355; background: transparent; cursor: pointer;">
                         <input type="range" id="font-size-psychology" min="10" max="28" value="13" style="flex: 1; background: #8b7355;" title="心理活动字体大小">
                         <span id="font-size-psychology-value" style="font-size: 10px; color: #8b7355; min-width: 30px;">13px</span>
                       </div>
                       
                       <!-- 景物描写设置 -->
                       <div style="display: flex; align-items: center; gap: 8px; padding: 6px; background: rgba(26, 26, 46, 0.4); border-radius: 4px;">
                         <span style="font-size: 11px; color: #8b7355; min-width: 50px;">景物:</span>
                         <input type="color" id="text-color-scenery" value="#98fb98" style="width: 30px; height: 20px; border: 1px solid #8b7355; background: transparent; cursor: pointer;">
                         <input type="range" id="font-size-scenery" min="10" max="28" value="15" style="flex: 1; background: #8b7355;" title="景物描写字体大小">
                         <span id="font-size-scenery-value" style="font-size: 10px; color: #8b7355; min-width: 30px;">15px</span>
                       </div>

                       <!-- 人物名称设置 -->
                       <div style="display: flex; align-items: center; gap: 8px; padding: 6px; background: rgba(26, 26, 46, 0.4); border-radius: 4px;">
                         <span style="font-size: 11px; color: #8b7355; min-width: 50px;">人物:</span>
                         <input type="color" id="text-color-character" value="#87CEFA" style="width: 30px; height: 20px; border: 1px solid #8b7355; background: transparent; cursor: pointer;">
                         <input type="range" id="font-size-character" min="10" max="28" value="14" style="flex: 1; background: #8b7355;" title="人物名称字体大小">
                         <span id="font-size-character-value" style="font-size: 10px; color: #8b7355; min-width: 30px;">14px</span>
                       </div>
                     </div>
                   </div>
                   
                   <!-- 重置按钮 -->
                   <div style="display: flex; gap: 10px; margin-top: 10px;">
                     <button id="reset-text-settings-btn" class="interaction-btn" style="flex: 1; padding: 6px 12px; font-size: 11px; background: #8b0000; border-color: #ff6b6b;">重置默认</button>
                     <button id="preview-text-settings-btn" class="interaction-btn" style="flex: 1; padding: 6px 12px; font-size: 11px;">预览效果</button>
                   </div>
                 </div>
               </div>
               
               <div class="panel-section">
                 <div class="section-title">字体选择</div>
                 <div style="display: flex; flex-direction: column; gap: 15px; padding: 10px;">
                   <!-- 字体选择 -->
                   <div>
                     <div style="font-size: 12px; color: #c9aa71; margin-bottom: 8px;">字体选择</div>
                     <select id="font-family-select" style="width: 100%; padding: 5px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 4px;">
                       <!-- 选项将通过JavaScript动态生成 -->
                     </select>
                     <div style="font-size: 10px; color: #8b7355; margin-top: 5px;">
                       <div>• 支持格式：TTF, OTF, WOFF, WOFF2</div>
                       <div>• 文件大小限制：10MB（推荐2MB以下）</div>
                       <div>• 选择"+ 上传新字体"来添加自定义字体</div>
                     </div>
                   </div>
                   
                   <!-- 自定义字体管理 -->
                   <div id="custom-font-section">
                     <div style="font-size: 12px; color: #c9aa71; margin-bottom: 8px;">自定义字体管理</div>
                     <div id="uploaded-fonts-list" style="max-height: 80px; overflow-y: auto;"></div>
                     <input type="file" id="font-file-input" accept=".ttf,.otf,.woff,.woff2" style="display: none;">
                   </div>
                 </div>
               </div>
             </div>

             <!-- 世界书控制内容 -->
             <div class="settings-panel" id="worldbook-panel">
               <div class="panel-section" style="display: none;">
                 <div class="section-title">读写序号</div>
                 <div style="display: flex; align-items: center; justify-content: space-between; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355; margin: 10px;">
                   <label for="unified-index-input" style="color: #c9aa71; font-size: 13px; font-weight: bold;">读写序号:</label>
                   <input type="number" id="unified-index-input" value="1" min="1" style="width: 80px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 4px; padding: 6px 8px; font-size: 13px;">
                 </div>
               </div>
               
               <div class="panel-section" style="display: none;">
                 <div class="section-title">自动开关世界书</div>
                 <div style="display: flex; flex-direction: column; gap: 10px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355; margin: 10px;">
                   <div style="display: flex; flex-direction: column; gap: 8px;">
                     <div style="display: flex; align-items: center; gap: 8px;">
                       <input type="checkbox" id="auto-toggle-lorebook-checkbox" style="cursor: pointer; width: 16px; height: 16px;">
                       <label for="auto-toggle-lorebook-checkbox" style="color: #c9aa71; font-size: 13px; cursor: pointer; flex-grow: 1;">自动开关世界书</label>
                       <button id="toggle-worldbook-advanced" style="background: none; border: none; color: #8b7355; cursor: pointer; font-size: 12px; padding: 4px 8px;">
                         <span id="worldbook-advanced-arrow">▶</span> 高级设置
                       </button>
                     </div>
                     <!-- 高级设置区域（移动到这里） -->
                     <div id="worldbook-advanced-settings" style="display: none; margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 4px;">
                       <div style="font-size: 12px; color: #8b7355; margin-bottom: 10px;">世界书条目创建参数</div>
                                   
                       <!-- 本世历程设置 -->
                       <details class="worldbook-entry-settings" style="margin-bottom: 10px;">
                         <summary style="cursor: pointer; color: #c9aa71; font-size: 12px; padding: 5px;">📖 本世历程</summary>
                         <div style="padding: 10px; margin-top: 5px;">
                           <div style="display: grid; grid-template-columns: 100px 1fr; gap: 8px; align-items: center;">
                             <label style="color: #8b7355; font-size: 11px;">默认启用:</label>
                             <input type="checkbox" id="journey-enabled" style="cursor: pointer; width: 16px; height: 16px; justify-self: start;">
                   
                             <label style="color: #8b7355; font-size: 11px;">位置:</label>
                             <select id="journey-position" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                               <option value="before_character_definition">角色定义之前</option>
                               <option value="after_character_definition">角色定义之后</option>
                               <option value="before_example_messages">↑ EM</option>
                               <option value="after_example_messages">↓ EM</option>
                               <option value="before_author_note">作者注释之前</option>
                               <option value="after_author_note">作者注释之后</option>
                               <option value="at_depth_as_system">@D ⚙️</option>
                               <option value="at_depth_as_assistant">@D 🤖</option>
                               <option value="at_depth_as_user">@D 👤</option>
                             </select>
                             
                             <label style="color: #8b7355; font-size: 11px;">顺序:</label>
                             <input type="number" id="journey-order" value="17" min="1" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                             
                             <div id="journey-depth-container" style="display: contents;">
                               <label for="journey-depth" style="color: #8b7355; font-size: 11px;">深度:</label>
                               <input type="number" id="journey-depth" value="1" min="1" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                             </div>
                             
                             <label style="color: #8b7355; font-size: 11px;">触发策略:</label>
                             <select id="journey-type" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                               <option value="selective">关键词</option>
                               <option value="constant">永久</option>
                             </select>
                           </div>
                         </div>
                       </details>
                                   
                       <!-- 往世涟漪设置 -->
                       <details class="worldbook-entry-settings" style="margin-bottom: 10px;">
                         <summary style="cursor: pointer; color: #c9aa71; font-size: 12px; padding: 5px;">🌊 往世涟漪</summary>
                         <div style="padding: 10px; margin-top: 5px;">
                           <div style="display: grid; grid-template-columns: 100px 1fr; gap: 8px; align-items: center;">
                             <label style="color: #8b7355; font-size: 11px;">默认启用:</label>
                             <input type="checkbox" id="past-lives-enabled" style="cursor: pointer; width: 16px; height: 16px; justify-self: start;">
                   
                             <label style="color: #8b7355; font-size: 11px;">位置:</label>
                             <select id="past-lives-position" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                               <option value="before_character_definition">角色定义之前</option>
                               <option value="after_character_definition">角色定义之后</option>
                               <option value="before_example_messages">↑ EM</option>
                               <option value="after_example_messages">↓ EM</option>
                               <option value="before_author_note">作者注释之前</option>
                               <option value="after_author_note">作者注释之后</option>
                               <option value="at_depth_as_system">@D ⚙️</option>
                               <option value="at_depth_as_assistant">@D 🤖</option>
                               <option value="at_depth_as_user">@D 👤</option>
                             </select>
                             
                             <label style="color: #8b7355; font-size: 11px;">顺序:</label>
                             <input type="number" id="past-lives-order" value="16" min="1" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                             
                             <div id="past-lives-depth-container" style="display: contents;">
                               <label for="past-lives-depth" style="color: #8b7355; font-size: 11px;">深度:</label>
                               <input type="number" id="past-lives-depth" value="1" min="1" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                             </div>
                             
                             <label style="color: #8b7355; font-size: 11px;">触发策略:</label>
                             <select id="past-lives-type" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                               <option value="selective">关键词</option>
                               <option value="constant">永久</option>
                             </select>
                           </div>
                         </div>
                       </details>
                                   
                       <!-- 小说模式设置 -->
                       <details class="worldbook-entry-settings" style="margin-bottom: 10px;">
                         <summary style="cursor: pointer; color: #c9aa71; font-size: 12px; padding: 5px;">📚 小说模式</summary>
                         <div style="padding: 10px; margin-top: 5px;">
                           <div style="display: grid; grid-template-columns: 100px 1fr; gap: 8px; align-items: center;">
                             <label style="color: #8b7355; font-size: 11px;">默认启用:</label>
                             <input type="checkbox" id="novel-enabled" style="cursor: pointer; width: 16px; height: 16px; justify-self: start;">
                   
                             <label style="color: #8b7355; font-size: 11px;">位置:</label>
                             <select id="novel-position" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                               <option value="before_character_definition">角色定义之前</option>
                               <option value="after_character_definition">角色定义之后</option>
                               <option value="before_example_messages">↑ EM</option>
                               <option value="after_example_messages">↓ EM</option>
                               <option value="before_author_note">作者注释之前</option>
                               <option value="after_author_note">作者注释之后</option>
                               <option value="at_depth_as_system">@D ⚙️</option>
                               <option value="at_depth_as_assistant">@D 🤖</option>
                               <option value="at_depth_as_user">@D 👤</option>
                             </select>
                             
                             <label style="color: #8b7355; font-size: 11px;">顺序:</label>
                             <input type="number" id="novel-order" value="18" min="1" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                             
                             <div id="novel-depth-container" style="display: contents;">
                               <label for="novel-depth" style="color: #8b7355; font-size: 11px;">深度:</label>
                               <input type="number" id="novel-depth" value="1" min="1" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                             </div>
                             
                             <label style="color: #8b7355; font-size: 11px;">触发策略:</label>
                             <select id="novel-type" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                               <option value="selective">关键词</option>
                               <option value="constant">永久</option>
                             </select>
                           </div>
                         </div>
                       </details>
                                   
                       <!-- 新增：分段正文设置 -->
                       <details class="worldbook-entry-settings" style="margin-bottom: 10px;">
                         <summary style="cursor: pointer; color: #c9aa71; font-size: 12px; padding: 5px;">🧠 分段正文</summary>
                         <div style="padding: 10px; margin-top: 5px;">
                           <div style="display: grid; grid-template-columns: 100px 1fr; gap: 8px; align-items: center;">
                             <label style="color: #8b7355; font-size: 11px;">默认启用:</label>
                             <input type="checkbox" id="segmented-enabled" style="cursor: pointer; width: 16px; height: 16px; justify-self: start;">
                   
                             <label style="color: #8b7355; font-size: 11px;">位置:</label>
                             <select id="segmented-position" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                               <option value="before_character_definition">角色定义之前</option>
                               <option value="after_character_definition">角色定义之后</option>
                               <option value="before_example_messages">↑ EM</option>
                               <option value="after_example_messages">↓ EM</option>
                               <option value="before_author_note">作者注释之前</option>
                               <option value="after_author_note">作者注释之后</option>
                               <option value="at_depth_as_system">@D ⚙️</option>
                               <option value="at_depth_as_assistant">@D 🤖</option>
                               <option value="at_depth_as_user">@D 👤</option>
                             </select>
                             
                             <label style="color: #8b7355; font-size: 11px;">顺序:</label>
                             <input type="number" id="segmented-order" value="21" min="1" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                             
                             <div id="segmented-depth-container" style="display: contents;">
                               <label for="segmented-depth" style="color: #8b7355; font-size: 11px;">深度:</label>
                               <input type="number" id="segmented-depth" value="1" min="1" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                             </div>
                             
                             <label style="color: #8b7355; font-size: 11px;">触发策略:</label>
                             <select id="segmented-type" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                               <option value="selective">关键词</option>
                               <option value="constant">永久</option>
                             </select>
                           </div>
                         </div>
                       </details>
                   
                       <!-- 大总结设置 -->
                       <details class="worldbook-entry-settings" style="margin-bottom: 10px;">
                         <summary style="cursor: pointer; color: #c9aa71; font-size: 12px; padding: 5px;">📜 大总结</summary>
                         <div style="padding: 10px; margin-top: 5px;">
                           <div style="display: grid; grid-template-columns: 100px 1fr; gap: 8px; align-items: center;">
                             <label style="color: #8b7355; font-size: 11px;">默认启用:</label>
                             <input type="checkbox" id="large-summary-enabled" style="cursor: pointer; width: 16px; height: 16px; justify-self: start;">
                   
                             <label style="color: #8b7355; font-size: 11px;">位置:</label>
                             <select id="large-summary-position" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                               <option value="before_character_definition">角色定义之前</option>
                               <option value="after_character_definition">角色定义之后</option>
                               <option value="before_example_messages">↑ EM</option>
                               <option value="after_example_messages">↓ EM</option>
                               <option value="before_author_note">作者注释之前</option>
                               <option value="after_author_note">作者注释之后</option>
                               <option value="at_depth_as_system">@D ⚙️</option>
                               <option value="at_depth_as_assistant">@D 🤖</option>
                               <option value="at_depth_as_user">@D 👤</option>
                             </select>
                             
                             <label style="color: #8b7355; font-size: 11px;">顺序:</label>
                             <input type="number" id="large-summary-order" value="20" min="1" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                             
                             <div id="large-summary-depth-container" style="display: contents;">
                               <label for="large-summary-depth" style="color: #8b7355; font-size: 11px;">深度:</label>
                               <input type="number" id="large-summary-depth" value="1" min="1" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                             </div>
                             
                             <label style="color: #8b7355; font-size: 11px;">触发策略:</label>
                             <select id="large-summary-type" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                               <option value="selective">关键词</option>
                               <option value="constant">永久</option>
                             </select>
                           </div>
                         </div>
                       </details>
                   
                       <!-- 小总结设置 -->
                       <details class="worldbook-entry-settings" style="margin-bottom: 10px;">
                         <summary style="cursor: pointer; color: #c9aa71; font-size: 12px; padding: 5px;">📝 小总结</summary>
                         <div style="padding: 10px; margin-top: 5px;">
                           <div style="display: grid; grid-template-columns: 100px 1fr; gap: 8px; align-items: center;">
                             <label style="color: #8b7355; font-size: 11px;">默认启用:</label>
                             <input type="checkbox" id="small-summary-enabled" style="cursor: pointer; width: 16px; height: 16px; justify-self: start;">
                   
                             <label style="color: #8b7355; font-size: 11px;">位置:</label>
                             <select id="small-summary-position" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                               <option value="before_character_definition">角色定义之前</option>
                               <option value="after_character_definition">角色定义之后</option>
                               <option value="before_example_messages">↑ EM</option>
                               <option value="after_example_messages">↓ EM</option>
                               <option value="before_author_note">作者注释之前</option>
                               <option value="after_author_note">作者注释之后</option>
                               <option value="at_depth_as_system">@D ⚙️</option>
                               <option value="at_depth_as_assistant">@D 🤖</option>
                               <option value="at_depth_as_user">@D 👤</option>
                             </select>
                             
                             <label style="color: #8b7355; font-size: 11px;">顺序:</label>
                             <input type="number" id="small-summary-order" value="19" min="1" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                             
                             <div id="small-summary-depth-container" style="display: contents;">
                               <label for="small-summary-depth" style="color: #8b7355; font-size: 11px;">深度:</label>
                               <input type="number" id="small-summary-depth" value="1" min="1" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                             </div>
                             
                             <label style="color: #8b7355; font-size: 11px;">触发策略:</label>
                             <select id="small-summary-type" style="background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 3px; padding: 4px; font-size: 11px;">
                               <option value="selective">关键词</option>
                               <option value="constant">永久</option>
                             </select>
                           </div>
                         </div>
                       </details>
                   
                       <div style="text-align: right; margin-top: 10px; display: flex; gap: 10px;">
                         <button id="save-worldbook-settings" class="interaction-btn" style="flex: 1; padding: 6px 12px; font-size: 12px;">保存设置</button>
                         <button id="reset-worldbook-settings" class="interaction-btn" style="flex: 1; font-size: 12px; padding: 6px; background: #8b0000; border-color: #ff6b6b;">恢复默认</button>
                       </div>
                     </div>
                   </div>
                 </div>
               </div>
               
               <div class="panel-section">
                 <div class="section-title">世界书管理</div>
                 <div style="display: flex; flex-direction: column; gap: 10px; padding: 10px;">
                   <button id="btn-worldbook-manager-from-settings" class="interaction-btn" style="display: flex; align-items: center; justify-content: flex-start; text-align: left;">
                     <span style="margin-right: 8px;">📚</span>
                     <div style="flex-grow: 1;">
                       <div>世界书管理</div>
                       <div style="font-size: 11px; color: #8b7355;">管理世界书条目</div>
                     </div>
                   </button>
                   <button id="btn-presets-manager" class="interaction-btn" style="display: flex; align-items: center; justify-content: flex-start; text-align: left;">
                     <span style="margin-right: 8px;">📋</span>
                     <div style="flex-grow: 1;">
                       <div>预设管理</div>
                       <div style="font-size: 11px; color: #8b7355;">创建和管理预设组合</div>
                     </div>
                   </button>
                   
                   <!-- 预设列表容器 -->
                   <div id="worldbook-presets-container" style="display: flex; flex-direction: column; gap: 8px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355;">
                     <div style="color: #8b7355; font-size: 12px; text-align: center; padding: 10px;">
                       暂无预设，点击上方按钮创建预设
                     </div>
                   </div>
                 </div>
               </div>
             </div>

             <!-- 系统内容 -->
             <div class="settings-panel" id="system-panel">
               <div class="panel-section">
                 <div class="section-title">功能开关</div>
                 <div style="display: flex; flex-direction: column; gap: 10px; padding: 10px;">
                   
                   <!-- 自动写入历程/涟漪 -->
                   <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355;">
                     <input type="checkbox" id="auto-write-checkbox" checked style="cursor: pointer; width: 16px; height: 16px;">
                     <label for="auto-write-checkbox" style="color: #c9aa71; font-size: 13px; cursor: pointer; flex-grow: 1;">
                       <div>自动写入历程/涟漪</div>
                       <div style="font-size: 11px; color: #8b7355; margin-top: 2px;">自动将AI生成的历程和涟漪内容写入世界书</div>
                     </label>
                   </div>
                   
                   <!-- 显示行动选项 -->
                   <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355;">
                     <input type="checkbox" id="action-options-enabled-checkbox" checked style="cursor: pointer; width: 16px; height: 16px;">
                     <label for="action-options-enabled-checkbox" style="color: #c9aa71; font-size: 13px; cursor: pointer; flex-grow: 1;">
                       <div>显示行动选项</div>
                       <div style="font-size: 11px; color: #8b7355; margin-top: 2px;">在游戏文本下方显示AI生成的行动选项按钮</div>
                     </label>
                   </div>
                   
                   <!-- 行动选项-点击即发送 -->
                   <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355;">
                     <input type="checkbox" id="auto-send-action-checkbox" checked style="cursor: pointer; width: 16px; height: 16px;">
                     <label for="auto-send-action-checkbox" style="color: #c9aa71; font-size: 13px; cursor: pointer; flex-grow: 1;">
                       <div>行动选项-点击即发送</div>
                       <div style="font-size: 11px; color: #8b7355; margin-top: 2px;">点击行动选项后直接发送，无需再点击发送按钮</div>
                     </label>
                   </div>
                   
                   <!-- 格式审查 -->
                   <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355;">
                     <input type="checkbox" id="format-validation-enabled-checkbox" checked style="cursor: pointer; width: 16px; height: 16px;">
                     <label for="format-validation-enabled-checkbox" style="color: #c9aa71; font-size: 13px; cursor: pointer; flex-grow: 1;">
                       <div>格式审查</div>
                       <div style="font-size: 11px; color: #8b7355; margin-top: 2px;">检查AI回复的标签格式，确保内容结构正确</div>
                     </label>
                   </div>
                   
                   <!-- 回车发送 -->
                   <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355;">
                     <input type="checkbox" id="enter-send-checkbox" style="cursor: pointer; width: 16px; height: 16px;">
                     <label for="enter-send-checkbox" style="color: #c9aa71; font-size: 13px; cursor: pointer; flex-grow: 1;">
                       <div>回车发送</div>
                       <div style="font-size: 11px; color: #8b7355; margin-top: 2px;">开启后按回车键即可发送消息</div>
                     </label>
                   </div>
                   
                   <!-- 手机输入框适配设置 -->
                   <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355;">
                     <input type="checkbox" id="mobile-input-adapt-checkbox" style="cursor: pointer; width: 16px; height: 16px;">
                     <label for="mobile-input-adapt-checkbox" style="color: #c9aa71; font-size: 13px; cursor: pointer; flex-grow: 1;">
                       <div>手机输入框适配</div>
                       <div style="font-size: 11px; color: #8b7355; margin-top: 2px;">开启后点击输入框时会将其移动到屏幕顶部，避免被键盘遮挡</div>
                     </label>
                   </div>
                   
                   <!-- 历史正文显示数量设置 -->
                   <div style="display: flex; flex-direction: column; gap: 8px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355;">
                     <label for="historical-text-count" style="color: #c9aa71; font-size: 13px;">
                       <div>历史正文显示数量</div>
                       <div style="font-size: 11px; color: #8b7355; margin-top: 2px;">设置在思维过程上方显示多少条历史正文（0=不显示，-1=全部）</div>
                     </label>
                     <input type="number" id="historical-text-count" value="3" min="-1" step="1"
                            style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 4px; padding: 6px 8px; font-size: 13px;">
                   </div>
                   
                    <!-- 自动阅读设置 -->
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355;">
                      <input type="checkbox" id="auto-read-checkbox" style="cursor: pointer; width: 16px; height: 16px;">
                      <label for="auto-read-checkbox" style="color: #c9aa71; font-size: 13px; cursor: pointer; flex-grow: 1;">
                        <div>自动阅读</div>
                        <div style="font-size: 11px; color: #8b7355; margin-top: 2px;">开启后自动向下滚动页面</div>
                      </label>
                    </div>
                    
                    <!-- 自动阅读速度设置 -->
                    <div style="display: flex; flex-direction: column; gap: 8px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355;">
                      <label for="auto-read-speed" style="color: #c9aa71; font-size: 13px;">
                        <div>自动阅读速度</div>
                        <div style="font-size: 11px; color: #8b7355; margin-top: 2px;">调整自动滚动的速度（数值越大速度越快）</div>
                      </label>
                      <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="auto-read-speed" min="1" max="10" value="3" step="1"
                               style="flex: 1; cursor: pointer;">
                        <span id="auto-read-speed-value" style="color: #c9aa71; font-size: 13px; min-width: 30px; text-align: center;">3</span>
                      </div>
                    </div>
                    
                   <!-- 键盘快捷键设置 -->
                   <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(26, 26, 46, 0.6); border-radius: 6px; border: 1px solid #8b7355;">
                     <input type="checkbox" id="keyboard-shortcuts-checkbox" style="cursor: pointer; width: 16px; height: 16px;" checked>
                     <label for="keyboard-shortcuts-checkbox" style="color: #c9aa71; font-size: 13px; cursor: pointer; flex-grow: 1;">
                       <div>键盘快捷键</div>
                       <div style="font-size: 11px; color: #8b7355; margin-top: 2px;">启用键盘快捷键功能</div>
                     </label>
                     <span id="keyboard-shortcuts-toggle" style="color: #c9aa71; cursor: pointer; font-size: 12px; padding: 2px 4px; user-select: none; transition: transform 0.2s ease;">▼</span>
                   </div>

                   <!-- 快捷键说明（默认折叠） -->
                   <div id="keyboard-shortcuts-details" style="display: none; margin-top: 8px; padding: 8px; background: rgba(26, 26, 46, 0.4); border-radius: 6px; border: 1px solid rgba(139, 115, 85, 0.3);">
                     <div style="display: grid; grid-template-columns: auto 1fr auto 1fr; gap: 8px 15px; font-size: 12px;">
                        <span style="color: #c9aa71; font-family: monospace;"></span><span></span> <!-- 占位符 -->
                        <span style="color: #c9aa71; font-family: monospace;"></span><span></span> <!-- 占位符 -->
                        <span style="color: #c9aa71; font-family: monospace;">1（上）</span><span style="color: #8b7355;">回顶</span>
                        <span style="color: #c9aa71; font-family: monospace;">3（下）</span><span style="color: #8b7355;">回底</span>
                        <span style="color: #c9aa71; font-family: monospace;">5（左）</span><span style="color: #8b7355;">上一章</span>
                        <span style="color: #c9aa71; font-family: monospace;">6（右）</span><span style="color: #8b7355;">下一章</span>
                        <span style="color: #c9aa71; font-family: monospace;">2（本）</span><span style="color: #8b7355;">本章</span>
                        <span style="color: #c9aa71; font-family: monospace;">Y（yuedu）</span><span style="color: #8b7355;">自动阅读</span>
                        <div style="grid-column: 1 / -1; height: 1px; background-color: rgba(139, 115, 85, 0.3); margin: 8px 0;"></div>
                        <span style="color: #c9aa71; font-family: monospace;">X（xiao）</span><span style="color: #8b7355;">小说模式</span>
                        <span style="color: #c9aa71; font-family: monospace;">F（fen）</span><span style="color: #8b7355;">分段记忆</span>
                        <span style="color: #c9aa71; font-family: monospace;">G（gui）</span><span style="color: #8b7355;">归墟系统</span>
                        <span style="color: #c9aa71; font-family: monospace;">E（wdsj）</span><span style="color: #8b7355;">物品栏</span>
                        <span style="color: #c9aa71; font-family: monospace;">R（ren）</span><span style="color: #8b7355;">人物关系</span>
                        <span style="color: #c9aa71; font-family: monospace;">C（cun）</span><span style="color: #8b7355;">存档/读档</span>
                        <span style="color: #c9aa71; font-family: monospace;">T（忘了）</span><span style="color: #8b7355;">设置界面</span>
                        <span style="color: #c9aa71; font-family: monospace;">Z（zhi）</span><span style="color: #8b7355;">指令中心</span>
                        <span style="color: #c9aa71; font-family: monospace;">B（bei）</span><span style="color: #8b7355;">背景图设置</span>
                        <span style="color: #c9aa71; font-family: monospace;">4（分割）</span><span style="color: #8b7355;">变量编辑器</span>         
                        <span style="color: #c9aa71; font-family: monospace;">L（随便写的）</span><span style="color: #8b7355;">查看提取内容</span>
                        <div style="grid-column: 1 / -1; height: 1px; background-color: rgba(139, 115, 85, 0.3); margin: 8px 0;"></div>
                        <span style="color: #c9aa71; font-family: monospace;">Ctrl+A（左）</span><span style="color: #8b7355;">收起/展开左面板</span>
                        <span style="color: #c9aa71; font-family: monospace;">Ctrl+D（右）</span><span style="color: #8b7355;">收起/展开右面板</span>
                     </div>
                     <div style="text-align: center; margin-top: 8px;">
                       <span style="color: #c9aa71; font-size: 11px;">* 在输入框中输入文字时快捷键不会生效</span>
                     </div>
                   </div>
               <div class="panel-section">
                 <div class="section-title">功能入口</div>
                 <div style="display: flex; flex-direction: column; gap: 10px; padding: 10px;">
                   <button id="btn-command-center-from-settings" class="interaction-btn">指令中心</button>
                   <button id="btn-show-extracted-from-settings" class="interaction-btn">查看提取内容</button>
                   <button id="btn-novel-mode-from-settings" class="interaction-btn">小说模式</button>
                   <button id="btn-variable-editor" class="interaction-btn" onclick="GuixuManager.showVariableEditor()">变量编辑</button>
                 </div>
               </div>


                 </div>
               </div>
             </div>

             <!-- 第二API配置内容 -->
             <div class="settings-panel" id="aux-model-panel">
               <div class="panel-section">
                 <div class="section-title">第二API配置</div>
                 <div style="padding: 15px; background: rgba(26, 26, 46, 0.4); border-radius: 8px; margin-bottom: 15px;">
                   <p style="color: #c9aa71; font-size: 13px; line-height: 1.6; margin: 0;">
                     🔌 第二API是一个独立的AI接口配置，可用于：<br>
                     • "步进式变量更新"模式中的第二步变量生成<br>
                     • 其他需要独立API调用的功能模块<br>
                   </p>
                 </div>

                 <!-- 总开关 -->
                 <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: rgba(201, 170, 113, 0.1); border-radius: 6px; margin-bottom: 15px;">
                   <div>
                     <div style="color: #c9aa71; font-weight: bold; font-size: 14px;">启用第二API</div>
                     <div style="color: #8b7355; font-size: 11px; margin-top: 3px;">全局开关，控制是否使用第二API</div>
                   </div>
                   <label class="toggle-switch">
                     <input type="checkbox" id="toggle-aux-model-enabled">
                     <span class="toggle-slider"></span>
                   </label>
                 </div>

                 <!-- API配置 -->
                 <div id="aux-model-config-section" style="display: none;">
                   <div style="display: flex; flex-direction: column; gap: 12px;">
                     
                     <!-- API Base URL -->
                     <div>
                       <label style="color: #c9aa71; font-size: 13px; font-weight: bold; display: block; margin-bottom: 6px;">
                         API Base URL
                       </label>
                       <input type="text"
                              id="aux-model-api-url"
                              placeholder="https://api.example.com/v1"
                              style="width: 100%; padding: 8px 12px; background: rgba(26, 26, 46, 0.6); border: 1px solid #8b7355; border-radius: 4px; color: #c9aa71; font-size: 13px;">
                       <div style="color: #8b7355; font-size: 11px; margin-top: 4px;">
                         辅助模型的API地址
                       </div>
                     </div>

                     <!-- API Key -->
                     <div>
                       <label style="color: #c9aa71; font-size: 13px; font-weight: bold; display: block; margin-bottom: 6px;">
                         API Key
                       </label>
                       <input type="password"
                              id="aux-model-api-key"
                              placeholder="sk-..."
                              style="width: 100%; padding: 8px 12px; background: rgba(26, 26, 46, 0.6); border: 1px solid #8b7355; border-radius: 4px; color: #c9aa71; font-size: 13px;">
                       <div style="color: #8b7355; font-size: 11px; margin-top: 4px;">
                         API密钥，用于身份验证
                       </div>
                     </div>

                     <!-- 模型列表 -->
                     <div>
                       <label style="color: #c9aa71; font-size: 13px; font-weight: bold; display: block; margin-bottom: 6px;">
                         模型列表
                       </label>
                       <select id="aux-model-name"
                               style="width: 100%; padding: 8px 12px; background: rgba(26, 26, 46, 0.6); border: 1px solid #8b7355; border-radius: 4px; color: #c9aa71; font-size: 13px; cursor: pointer;">
                         <option value="">请先连接API获取模型列表</option>
                       </select>
                       <div style="color: #8b7355; font-size: 11px; margin-top: 4px;">
                         点击"连接"按钮后自动获取
                       </div>
                     </div>

                     <!-- API源选择 -->
                     <div>
                       <label style="color: #c9aa71; font-size: 13px; font-weight: bold; display: block; margin-bottom: 6px;">
                         API源类型
                       </label>
                       <select id="aux-model-source"
                               style="width: 100%; padding: 8px 12px; background: rgba(26, 26, 46, 0.6); border: 1px solid #8b7355; border-radius: 4px; color: #c9aa71; font-size: 13px; cursor: pointer;">
                         <option value="openai">OpenAI</option>
                         <option value="anthropic">Anthropic (Claude)</option>
                         <option value="google">Google (Gemini)</option>
                         <option value="custom">自定义</option>
                       </select>
                       <div style="color: #8b7355; font-size: 11px; margin-top: 4px;">
                         选择API提供商类型
                       </div>
                     </div>

                     <!-- 流式输出开关 -->
                     <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: rgba(26, 26, 46, 0.6); border-radius: 6px;">
                       <div>
                         <div style="color: #c9aa71; font-size: 13px; font-weight: bold;">流式输出</div>
                       </div>
                       <label class="toggle-switch">
                         <input type="checkbox" id="toggle-aux-model-streaming" checked>
                         <span class="toggle-slider"></span>
                       </label>
                     </div>

                     <!-- 功能按钮组 -->
                     <div style="display: flex; gap: 10px; margin-top: 10px;">
                       <button id="btn-connect-aux-model"
                               class="interaction-btn"
                               style="flex: 1; background: rgba(100, 150, 200, 0.3); border: 1px solid #6496c8;">
                         连接
                       </button>
                       <button id="btn-test-aux-model"
                               class="interaction-btn"
                               style="flex: 1; background: rgba(150, 200, 100, 0.3); border: 1px solid #96c864;">
                          消息测试
                       </button>
                     </div>
                   </div>
                 </div>
               </div>

               <!-- 变量更新方式设置 -->
               <div class="panel-section" style="margin-top: 20px;">
                 <div class="section-title">变量更新模式</div>
                 <div style="padding: 15px; background: rgba(26, 26, 46, 0.4); border-radius: 8px; margin-bottom: 15px;">


                 
                 <!-- 更新方式选择 -->
                 <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px;">
                   <label style="display: flex; align-items: center; padding: 12px; background: rgba(26, 26, 46, 0.6); border: 2px solid #8b7355; border-radius: 6px; cursor: pointer; transition: all 0.3s;">
                     <input type="radio" name="mvu-update-mode" value="随AI输出" id="mvu-mode-with-ai" checked style="margin-right: 12px; width: 18px; height: 18px; cursor: pointer;">
                     <div>
                       <div style="color: #c9aa71; font-weight: bold; font-size: 14px;">单次生成模式</div>
                       <div style="color: #8b7355; font-size: 11px; margin-top: 3px;">AI一次性生成正文和变量</div>
                     </div>
                   </label>

                   <label style="display: flex; align-items: center; padding: 12px; background: rgba(26, 26, 46, 0.6); border: 2px solid #8b7355; border-radius: 6px; cursor: pointer; transition: all 0.3s;">
                     <input type="radio" name="mvu-update-mode" value="分步变量更新" id="mvu-mode-stepwise" style="margin-right: 12px; width: 18px; height: 18px; cursor: pointer;">
                     <div>
                       <div style="color: #c9aa71; font-weight: bold; font-size: 14px;">分步变量更新</div>
                       <div style="color: #8b7355; font-size: 11px; margin-top: 3px;">正文生成后额外调用AI分析并更新变量。正文和变量的更新质量都有所提升</div>
                     </div>
                   </label>
                 </div>

                 <!-- 分步变量更新配置（仅在选择"分步变量更新"时显示） -->
                 <div id="stepwise-config-section" style="display: none;">
                   <div style="border-top: 1px solid rgba(201, 170, 113, 0.3); padding-top: 15px;">
                     <div style="color: #c9aa71; font-size: 13px; font-weight: bold; margin-bottom: 12px;">
                       分步变量更新配置
                     </div>

                     <!-- 模型来源选择 -->
                     <div style="margin-bottom: 10px;">
                       <div style="display: flex; flex-direction: column; gap: 8px;">
                         <label style="display: flex; align-items: center; padding: 10px; background: rgba(26, 26, 46, 0.4); border: 1px solid #8b7355; border-radius: 4px; cursor: pointer;">
                           <input type="radio" name="stepwise-model-source" value="与插头相同" id="stepwise-source-same" checked style="margin-right: 10px; cursor: pointer;">
                           <div style="color: #c9aa71; font-size: 13px;">与插头相同</div>
                         </label>
                         <label style="display: flex; align-items: center; padding: 10px; background: rgba(26, 26, 46, 0.4); border: 1px solid #8b7355; border-radius: 4px; cursor: pointer;">
                           <input type="radio" name="stepwise-model-source" value="自定义" id="stepwise-source-custom" style="margin-right: 10px; cursor: pointer;">
                           <div>
                             <div style="color: #c9aa71; font-size: 13px;">使用"第二API"</div>
                           </div>
                         </label>
                       </div>
                     </div>

                     <!-- 世界书筛选 -->
                     <div style="margin-bottom: 10px;">
                       <div style="padding: 10px; background: rgba(26, 26, 46, 0.6); border: 1px solid #8b7355; border-radius: 4px;">
                         <div style="color: #c9aa71; font-size: 12px; line-height: 1.8;">
                           <div style="margin-bottom: 6px;">
                             <span style="color: #9664c8;">▸ 第一步（主API）</span>接收：
                           </div>
                           <div style="padding-left: 15px; color: #8b7355; font-size: 11px; margin-bottom: 8px;">
                             • 【only剧情】前缀的条目<br>
                             • 无前缀的条目
                           </div>
                           <div style="margin-bottom: 6px;">
                             <span style="color: #6464c8;">▸ 第二步（步进式API）</span>接收：
                           </div>
                           <div style="padding-left: 15px; color: #8b7355; font-size: 11px;">
                             • 【only变量】前缀的条目<br>
                             • 无前缀的条目
                           </div>
                         </div>
                       </div>
                     </div>
                   </div>
                 </div>
               </div>
             </div>

           </div>
         </div>
       </div>
    </div>
  </div>

  <!-- 新增：背景图设置模态框 -->
  <div id="background-settings-modal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">背景图设置</h2>
        <button class="modal-close-btn">&times;</button>
      </div>
      <div class="modal-body">
       <!-- 图片来源选择 -->
       <div class="panel-section">
         <div class="section-title">图片来源</div>
         <div style="padding: 10px; display: flex; flex-direction: column; gap: 10px;">
           <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
             <input type="radio" name="gallery-source" value="library" id="gallery-source-library" checked>
             <span style="color: #c9aa71;">📚 图库</span>
             <span style="font-size: 11px; color: #8b7355; margin-left: 10px;">使用已上传的背景图片</span>
           </label>
           <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
             <input type="radio" name="gallery-source" value="output" id="gallery-source-output">
             <span style="color: #c9aa71;">📁 Output文件夹</span>
             <span style="font-size: 11px; color: #8b7355; margin-left: 10px;">从本地output文件夹读取图片</span>
           </label>
         </div>
         <div id="output-folder-controls" style="padding: 10px; display: none; border-top: 1px solid rgba(201, 170, 113, 0.3); margin-top: 10px;">
           <button id="select-output-folder-btn" class="interaction-btn" style="width: 100%; margin-bottom: 10px;">
             <i class="fas fa-folder-open"></i> 选择Output文件夹
           </button>
           <div id="output-folder-status" style="font-size: 12px; color: #8b7355; text-align: center;">
             未选择文件夹
           </div>
           <button id="refresh-output-folder-btn" class="interaction-btn" style="width: 100%; margin-top: 10px; display: none;">
             <i class="fas fa-sync-alt"></i> 刷新文件夹内容
           </button>
         </div>
       </div>

       <!-- 显示模式选择 -->
       <div class="panel-section">
         <div class="section-title">显示模式</div>
         <div style="padding: 10px; display: flex; flex-direction: column; gap: 10px;">
           <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
             <input type="radio" name="background-mode" value="random" id="bg-mode-random" checked>
             <span style="color: #c9aa71;">随机显示</span>
             <span style="font-size: 11px; color: #8b7355; margin-left: 10px;">每次回复后随机选择一张背景图</span>
           </label>
           <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
             <input type="radio" name="background-mode" value="fixed" id="bg-mode-fixed">
             <span style="color: #c9aa71;">固定显示</span>
             <span style="font-size: 11px; color: #8b7355; margin-left: 10px;">始终显示选中的背景图</span>
           </label>
         </div>
       </div>

        <!-- 上传区域 -->
        <div class="panel-section">
          <div class="section-title">添加背景图</div>
          <div style="padding: 10px;">
            <!-- 本地文件上传 -->
            <div id="background-upload-area" style="
              border: 2px dashed #8b7355;
              border-radius: 8px;
              padding: 30px;
              text-align: center;
              cursor: pointer;
              transition: all 0.3s ease;
              background: rgba(0,0,0,0.2);
              margin-bottom: 15px;
            ">
              <div style="color: #c9aa71; font-size: 16px; margin-bottom: 10px;">📁</div>
              <div style="color: #c9aa71; margin-bottom: 5px;">点击选择图片文件</div>
              <div style="color: #8b7355; font-size: 12px;">支持 JPG、PNG、GIF 格式</div>
            </div>
            <input type="file" id="background-file-input" accept="image/*" multiple style="display: none;">
            
            <!-- 外链图床输入 -->
            <div style="border-top: 1px solid rgba(201, 170, 113, 0.3); padding-top: 15px;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <span style="color: #c9aa71; font-size: 14px;">🔗 或添加外链图床</span>
                <button id="manage-url-images-btn" class="interaction-btn" style="padding: 4px 10px; font-size: 12px;">管理外链</button>
              </div>
              <textarea id="image-url-input" placeholder="请输入一个或多个图片链接，每行一个"
                        rows="4"
                        style="width: 100%; padding: 8px 12px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355;
                               color: #e0dcd1; border-radius: 4px; font-size: 12px; resize: vertical;"></textarea>
              <button id="add-url-image-btn" class="interaction-btn" style="width: 100%; margin-top: 10px; padding: 8px 15px; font-size: 12px;">添加链接</button>
              <div style="color: #8b7355; font-size: 11px; margin-top: 5px;">
                支持常见图床：imgur、postimg、sm.ms 等，确保链接可直接访问
              </div>
            </div>
          </div>
        </div>

       <!-- 背景图列表 -->
       <div class="panel-section">
         <div class="section-title">
           <span>背景图列表</span>
           <span id="background-count" style="font-size: 12px; color: #8b7355; margin-left: 10px;">(0张)</span>
         </div>
         <!-- 分页控制 -->
         <div id="gallery-pagination-controls" style="padding: 10px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(139, 115, 85, 0.3);">
           <button id="gallery-prev-page" class="interaction-btn" style="padding: 5px 15px; font-size: 12px;">
             <i class="fas fa-chevron-left"></i> 上一页
           </button>
           <span id="gallery-page-info" style="color: #c9aa71; font-size: 12px;">第 1 页 / 共 1 页</span>
           <button id="gallery-next-page" class="interaction-btn" style="padding: 5px 15px; font-size: 12px;">
             下一页 <i class="fas fa-chevron-right"></i>
           </button>
         </div>
         <div id="background-list" style="
           max-height: 300px;
           overflow-y: auto;
           padding: 10px;
           display: grid;
           grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
           gap: 10px;
         ">
           <!-- 背景图项目将动态添加到这里 -->
         </div>
       </div>
     </div>
   </div>
 </div>
  <!-- 头像图库选择模态框的HTML结构将被JS动态创建 -->


 <!-- 图床链接管理模态框 -->
 <div id="url-images-manage-modal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">🔗 图床链接管理</h2>
        <button class="modal-close-btn" onclick="GuixuManager.closeModal('url-images-manage-modal')">&times;</button>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <span style="color: #c9aa71; font-size: 16px;">外链图片列表</span>
            <span id="url-images-count" style="color: #8b7355; font-size: 14px;">(0张)</span>
          </div>
          
          <!-- 外链图片列表 -->
          <div id="url-images-list" style="max-height: 400px; overflow-y: auto; border: 1px solid rgba(201, 170, 113, 0.3); border-radius: 6px; padding: 10px;">
            <div style="text-align: center; color: #8b7355; padding: 40px 20px;">暂无外链图片</div>
          </div>
        </div>
        
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
          <button class="interaction-btn" onclick="GuixuManager.closeModal('url-images-manage-modal')" style="background: rgba(139, 115, 85, 0.3);">关闭</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 编辑图片名称模态框 -->
  <div id="edit-image-name-modal" class="modal-overlay">
    <div class="modal-content" style="width: 400px;">
      <div class="modal-header">
        <h2 class="modal-title">✏️ 编辑图片名称</h2>
        <button class="modal-close-btn" onclick="GuixuManager.closeModal('edit-image-name-modal')">&times;</button>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 20px;">
          <label style="display: block; color: #c9aa71; margin-bottom: 8px; font-size: 14px;">图片名称：</label>
          <input type="text" id="edit-image-name-input" placeholder="请输入新的图片名称" 
                 style="width: 100%; padding: 8px 12px; background: rgba(26, 26, 46, 0.8); 
                        border: 1px solid rgba(201, 170, 113, 0.3); border-radius: 4px; 
                        color: #e0dcd1; font-size: 14px;">
        </div>
        
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
          <button class="interaction-btn" onclick="GuixuManager.closeModal('edit-image-name-modal')" 
                  style="background: rgba(139, 115, 85, 0.3);">取消</button>
          <button id="save-image-name-btn" class="interaction-btn">保存</button>
        </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      
        <!-- 世界书管理模态框 -->
        <div id="worldbook-manager-modal" class="modal-overlay">
          <div class="modal-content" style="width: 95vw; height: 90vh; max-width: none; max-height: none;">
            <div class="modal-header" id="worldbook-manager-header" style="padding: 6px 8px;">
              <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 10px; flex-wrap: wrap;">
                <div style="flex: 1; min-width: 0;">
                  <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; flex-wrap: wrap;">
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <label style="color: #c9aa71; font-size: 11px; white-space: nowrap;">类型:</label>
                      <select id="worldbook-filter-type" style="padding: 2px 4px; background: rgba(26, 26, 46, 0.8); border: 1px solid #8b7355; border-radius: 3px; color: #c9aa71; font-size: 10px; min-width: 80px;">
                        <option value="all">全部</option>
                        <option value="journey">本世</option>
                        <option value="pastlife">往世</option>
                        <option value="bracket">【】</option>
                        <option value="enabled">启用</option>
                        <option value="disabled">禁用</option>
                      </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <label style="color: #c9aa71; font-size: 11px; white-space: nowrap;">搜索:</label>
                      <input type="text" id="worldbook-prefix-filter" placeholder="关键词..." style="padding: 2px 4px; background: rgba(26, 26, 46, 0.8); border: 1px solid #8b7355; border-radius: 3px; color: #c9aa71; font-size: 10px; width: 80px; min-width: 60px;">
                    </div>
                    <div class="worldbook-manager-stats" style="display: flex; gap: 8px; flex-wrap: wrap; padding: 0; margin: 0;">
                      <span style="color: #c9aa71; font-size: 10px; white-space: nowrap;">总:<strong id="stats-total">0</strong></span>
                      <span style="color: #90ee90; font-size: 10px; white-space: nowrap;">启:<strong id="stats-enabled">0</strong></span>
                      <span style="color: #ff6b6b; font-size: 10px; white-space: nowrap;">禁:<strong id="stats-disabled">0</strong></span>
                      <span style="color: #4a9eff; font-size: 10px; white-space: nowrap;">筛:<strong id="stats-filtered">0</strong></span>
                    </div>
                  </div>
                </div>
                <div style="display: flex; align-items: center; gap: 4px; flex-shrink: 0;">
                  <button id="enable-filtered-btn" class="interaction-btn" style="padding: 2px 4px; font-size: 9px; background: rgba(40, 167, 69, 0.2); border-color: #28a745; color: #28a745; white-space: nowrap; height: 20px; line-height: 1; min-width: 0;">启用</button>
                  <button id="disable-filtered-btn" class="interaction-btn" style="padding: 2px 4px; font-size: 9px; background: rgba(108, 117, 125, 0.2); border-color: #6c757d; color: #6c757d; white-space: nowrap; height: 20px; line-height: 1; min-width: 0;">禁用</button>
                  <button id="show-delete-history-btn" class="interaction-btn" style="padding: 2px 4px; font-size: 9px; background: rgba(74, 158, 255, 0.2); border-color: #4a9eff; color: #4a9eff; white-space: nowrap; height: 20px; line-height: 1; min-width: 0;">历史</button>
                  <button id="worldbook-presets-btn" class="interaction-btn" style="padding: 2px 4px; font-size: 9px; background: rgba(201, 170, 113, 0.2); border-color: #c9aa71; color: #c9aa71; white-space: nowrap; height: 20px; line-height: 1; min-width: 0;">预设</button>
                  <button id="delete-filtered-btn-header" class="interaction-btn" style="padding: 2px 4px; font-size: 9px; background: rgba(255, 107, 107, 0.3); border: 1px solid #ff6b6b; color: #ff6b6b; border-radius: 3px; white-space: nowrap; height: 20px; line-height: 1; min-width: 0;">删除</button>
                  <button id="close-worldbook-manager" class="modal-close-btn" style="width: 20px; height: 20px; font-size: 12px; line-height: 1; padding: 0;">&times;</button>
                </div>
              </div>
            </div>
            <div class="modal-body" style="height: calc(100% - 45px); padding: 0;">
              <!-- 条目列表容器 -->
              <div id="worldbook-entries-list" style="height: 100%; overflow-y: auto; background: rgba(26, 26, 46, 0.2); border: 1px solid #8b7355; border-top: none; border-radius: 0 0 6px 6px;">
                <!-- 条目将在这里动态生成 -->
              </div>
            </div>
          </div>
        </div>

        <!-- 世界书预设管理模态框 -->
        <div id="worldbook-presets-modal" class="modal-overlay">
          <div class="modal-content" style="width: 90vw; height: 85vh; max-width: 1200px; max-height: none;">
            <div class="modal-header" style="padding: 10px 15px;">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <h2 class="modal-title" style="color: #c9aa71; font-size: 18px;">📋 世界书预设管理</h2>
                <div style="display: flex; align-items: center; gap: 8px;">
                  <button id="create-preset-btn" class="interaction-btn" style="padding: 6px 12px; font-size: 12px; background: rgba(40, 167, 69, 0.2); border-color: #28a745; color: #28a745;">新建预设</button>
                  <button id="close-presets-modal" class="modal-close-btn">&times;</button>
                </div>
              </div>
            </div>
            <div class="modal-body" style="height: calc(100% - 60px); padding: 15px;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: 100%;">
                <!-- 左侧：预设列表 -->
                <div style="display: flex; flex-direction: column;">
                  <div style="color: #c9aa71; font-size: 14px; font-weight: bold; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #8b7355;">
                    📚 预设列表
                  </div>
                  <div id="presets-list" style="flex: 1; overflow-y: auto; background: rgba(26, 26, 46, 0.3); border: 1px solid #8b7355; border-radius: 6px; padding: 10px;">
                    <!-- 预设列表将在这里动态生成 -->
                  </div>
                </div>
                
                <!-- 右侧：预设详情/编辑 -->
                <div style="display: flex; flex-direction: column;">
                  <div style="color: #c9aa71; font-size: 14px; font-weight: bold; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #8b7355;">
                    ⚙️ 预设详情
                  </div>
                  <div id="preset-details" style="flex: 1; background: rgba(26, 26, 46, 0.3); border: 1px solid #8b7355; border-radius: 6px; padding: 15px; overflow-y: auto;">
                    <div style="text-align: center; color: #8b7355; padding: 40px 20px;">
                      <div style="font-size: 48px; margin-bottom: 15px;">📋</div>
                      <div style="font-size: 16px; margin-bottom: 8px;">选择预设查看详情</div>
                      <div style="font-size: 12px; opacity: 0.8;">点击左侧预设项目查看和编辑详细信息</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- 创建/编辑预设模态框 -->
        <div id="preset-edit-modal" class="modal-overlay">
          <div class="modal-content" style="width: 80vw; height: 80vh; max-width: 900px;">
            <div class="modal-header">
              <h2 class="modal-title" id="preset-edit-title">📝 新建预设</h2>
              <button id="close-preset-edit" class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body" style="height: calc(100% - 60px); padding: 20px;">
              <div style="display: flex; flex-direction: column; gap: 20px; height: 100%;">
                <!-- 预设基本信息 -->
                <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 15px; align-items: start;">
                  <div>
                    <label style="color: #c9aa71; font-size: 14px; font-weight: bold; display: block; margin-bottom: 8px;">预设名称:</label>
                    <input type="text" id="preset-name-input" placeholder="输入预设名称..." style="width: 100%; padding: 10px; background: rgba(26, 26, 46, 0.8); border: 1px solid #8b7355; border-radius: 6px; color: #e0dcd1; font-size: 14px;">
                  </div>
                  <div>
                    <label style="color: #c9aa71; font-size: 14px; font-weight: bold; display: block; margin-bottom: 8px;">预设描述:</label>
                    <textarea id="preset-description-input" placeholder="输入预设描述..." style="width: 100%; height: 60px; padding: 10px; background: rgba(26, 26, 46, 0.8); border: 1px solid #8b7355; border-radius: 6px; color: #e0dcd1; font-size: 14px; resize: vertical;"></textarea>
                  </div>
                </div>
                
                <!-- 条目选择区域 -->
                <div style="flex: 1; display: flex; flex-direction: column;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label style="color: #c9aa71; font-size: 14px; font-weight: bold;">选择条目:</label>
                    <div style="display: flex; gap: 8px;">
                      <button id="select-all-entries" class="interaction-btn" style="padding: 4px 8px; font-size: 12px;">全选</button>
                      <button id="deselect-all-entries" class="interaction-btn" style="padding: 4px 8px; font-size: 12px;">全不选</button>
                      <button id="select-enabled-entries" class="interaction-btn" style="padding: 4px 8px; font-size: 12px;">选择已启用</button>
                    </div>
                  </div>
                  
                  <!-- 搜索筛选控件 -->
                  <div class="preset-entries-filters" style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px; padding: 8px; background: rgba(0, 0, 0, 0.2); border-radius: 4px; border: 1px solid #8b7355;">
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <label style="color: #c9aa71; font-size: 11px; white-space: nowrap;">类型:</label>
                      <select id="preset-filter-type" style="padding: 2px 4px; background: rgba(26, 26, 46, 0.8); border: 1px solid #8b7355; border-radius: 3px; color: #c9aa71; font-size: 10px; min-width: 80px;">
                        <option value="all">全部</option>
                        <option value="journey">本世</option>
                        <option value="pastlife">往世</option>
                        <option value="bracket">【】</option>
                        <option value="enabled">启用</option>
                        <option value="disabled">禁用</option>
                      </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <label style="color: #c9aa71; font-size: 11px; white-space: nowrap;">搜索:</label>
                      <input type="text" id="preset-prefix-filter" placeholder="关键词..." style="padding: 2px 4px; background: rgba(26, 26, 46, 0.8); border: 1px solid #8b7355; border-radius: 3px; color: #c9aa71; font-size: 10px; width: 80px; min-width: 60px;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 4px; margin-left: auto;">
                      <span id="preset-filter-stats" style="color: #8b7355; font-size: 10px;">显示: 0/0</span>
                    </div>
                  </div>
                  <div id="preset-entries-selection" style="flex: 1; background: rgba(26, 26, 46, 0.3); border: 1px solid #8b7355; border-radius: 6px; padding: 15px; overflow-y: auto;">
                    <!-- 条目选择列表将在这里动态生成 -->
                  </div>
                </div>
                
                <!-- 操作按钮 -->
                <div style="display: flex; justify-content: flex-end; gap: 10px; padding-top: 15px; border-top: 1px solid #8b7355;">
                  <button id="cancel-preset-edit" class="interaction-btn" style="padding: 10px 20px;">取消</button>
                  <button id="save-preset" class="interaction-btn" style="padding: 10px 20px; background: rgba(40, 167, 69, 0.2); border-color: #28a745; color: #28a745;">保存预设</button>
                </div>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- 世界书删除确认模态框 -->
  <div id="worldbook-delete-confirm-modal" class="modal-overlay">
    <div class="modal-content" style="width: 500px; max-width: 90vw;">
      <div class="modal-header" style="background: rgba(139, 0, 0, 0.2); border-bottom: 2px solid #dc3545;">
        <h2 class="modal-title" style="color: #dc3545; font-weight: bold;">⚠️ 危险操作警告</h2>
        <button id="close-delete-confirm" class="modal-close-btn" style="color: #dc3545;">&times;</button>
      </div>
      <div class="modal-body" style="padding: 30px;">
        
        <!-- 第一步确认 -->
        <div id="delete-step-1" style="text-align: center;">
          <div style="font-size: 64px; color: #dc3545; margin-bottom: 20px;">🗑️</div>
          <div style="color: #dc3545; font-size: 18px; font-weight: bold; margin-bottom: 15px;">
            您即将删除世界书条目
          </div>
          <div id="delete-item-info" style="background: rgba(220, 53, 69, 0.1); border: 2px solid #dc3545; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
            <div style="color: #dc3545; font-weight: bold; margin-bottom: 8px;">删除信息：</div>
            <div id="delete-item-details" style="color: #333; font-size: 14px;"></div>
          </div>
          <div style="color: #dc3545; font-size: 16px; font-weight: bold; margin-bottom: 20px; line-height: 1.5;">
            ⚠️ 警告：此操作不可撤销！<br>
            删除后将永久丢失该条目的所有内容！
          </div>
          <div style="display: flex; gap: 15px; justify-content: center;">
            <button id="cancel-delete-btn" class="interaction-btn" style="padding: 10px 20px; background: rgba(108, 117, 125, 0.2); border-color: #6c757d; color: #6c757d;">取消</button>
            <button id="confirm-delete-step1-btn" class="interaction-btn" style="padding: 10px 20px; background: rgba(220, 53, 69, 0.2); border-color: #dc3545; color: #dc3545; font-weight: bold;">确认删除</button>
          </div>
        </div>

        <!-- 第二步确认 -->
        <div id="delete-step-2" style="display: none; text-align: center;">
          <div style="font-size: 64px; color: #dc3545; margin-bottom: 20px;">⚠️</div>
          <div style="color: #dc3545; font-size: 20px; font-weight: bold; margin-bottom: 20px;">
            最后确认
          </div>
          <div style="background: rgba(220, 53, 69, 0.15); border: 3px solid #dc3545; border-radius: 8px; padding: 20px; margin-bottom: 25px;">
            <div style="color: #dc3545; font-size: 18px; font-weight: bold; margin-bottom: 15px;">
              🚨 最后警告 🚨
            </div>
            <div style="color: #dc3545; font-size: 16px; line-height: 1.6; margin-bottom: 15px;">
              您确定要删除这个世界书条目吗？<br>
              <strong>删除后无法恢复！</strong>
            </div>
            <div style="color: #666; font-size: 14px; margin-bottom: 15px;">
              请在下方输入框中输入 <strong style="color: #dc3545;">"确认删除"</strong> 来完成删除操作：
            </div>
            <input type="text" id="delete-confirmation-input" placeholder="请输入：确认删除"
                   style="width: 100%; padding: 10px; border: 2px solid #dc3545; border-radius: 4px; text-align: center; font-size: 14px; margin-bottom: 15px;">
            <div id="delete-input-error" style="color: #dc3545; font-size: 12px; display: none;">
              输入不正确，请输入"确认删除"
            </div>
          </div>
          <div style="display: flex; gap: 15px; justify-content: center;">
            <button id="back-delete-step-btn" class="interaction-btn" style="padding: 10px 20px; background: rgba(108, 117, 125, 0.2); border-color: #6c757d; color: #6c757d;">返回</button>
            <button id="final-delete-btn" class="interaction-btn" style="padding: 10px 20px; background: rgba(220, 53, 69, 0.3); border-color: #dc3545; color: #dc3545; font-weight: bold;">执行删除</button>
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- 世界书删除历史模态框 -->
  <div id="worldbook-delete-history-modal" class="modal-overlay">
    <div class="modal-content" style="width: 800px; max-width: 95vw;">
      <div class="modal-header">
        <h2 class="modal-title">🗂️ 删除历史管理</h2>
        <button id="close-delete-history" class="modal-close-btn">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <div class="delete-history-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #8b7355;">
          <div class="delete-history-info">
            <p style="color: #c9aa71; margin: 0 0 8px 0; font-size: 14px;">
              <span style="color: #4a9eff;">💾</span>
              系统自动保存最近10次的删除记录，您可以随时恢复误删的条目
            </p>
            <div class="delete-history-stats">
              <span id="delete-history-count" style="color: #8b7355; font-size: 12px;">加载中...</span>
            </div>
          </div>
          <div class="delete-history-actions">
            <button id="clear-delete-history-btn" class="interaction-btn" style="background: rgba(255, 107, 107, 0.2); border-color: #ff6b6b; color: #ff6b6b; font-size: 12px; padding: 8px 16px;">
              🗑️ 清空历史
            </button>
          </div>
        </div>        
        <div id="delete-history-list" class="delete-history-list" style="max-height: 500px; overflow-y: auto;">
          <!-- 删除历史条目将在这里显示 -->
        </div>
      </div>
    </div>
  </div>

  <!-- 通用确认模态框 -->
  <div id="worldbook-confirm-modal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="confirm-modal-title">确认操作</h2>
        <button class="modal-close-btn" onclick="GuixuManager.closeModal('worldbook-confirm-modal')">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <div id="confirm-modal-message" style="margin-bottom: 20px; line-height: 1.6; color: #c9aa71;">
          <!-- 确认消息将在这里显示 -->
        </div>
        <div class="modal-actions" style="display: flex; gap: 10px; justify-content: flex-end;">
          <button id="confirm-modal-cancel" class="interaction-btn" style="background: rgba(139, 115, 85, 0.2); border-color: #8b7355; color: #8b7355;">取消</button>
          <button id="confirm-modal-confirm" class="interaction-btn" style="background: rgba(74, 158, 255, 0.2); border-color: #4a9eff; color: #4a9eff;">确认</button>
        </div>
      </div>
    </div>
  <!-- 新增：分段记忆模态框 -->
  <div id="segmented-memory-modal" class="modal-overlay">
    <div class="modal-content" style="width: 450px; max-width: 90vw;">
      <div class="modal-header">
        <h2 class="modal-title">分段记忆设置</h2>
        <button class="modal-close-btn">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <div class="modal-section-container">
          <!-- 区域一：分段记忆 -->
          <div class="modal-section">
            <h4 class="modal-section-title">分段记忆</h4>
            <div class="modal-control-group">
                <label for="auto-segmented-memory-checkbox" class="modal-label">
                    分段记忆开关
                    <span class="modal-label-desc">很推荐你开,推荐配置:3,25</span>
                </label>
                <input type="checkbox" id="auto-segmented-memory-checkbox" class="modal-checkbox">
            </div>
            <div class="modal-control-group horizontal">
              <label for="segmented-memory-count" class="modal-label" style="flex-basis: 120px;">分段正文数:</label>
              <input type="number" id="segmented-memory-count" value="3" min="0" class="modal-input-number">
            </div>
            <div class="modal-control-group horizontal">
              <label for="small-summary-count" class="modal-label" style="flex-basis: 120px;">小总结数:</label>
              <input type="number" id="small-summary-count" value="25" min="0" class="modal-input-number">
            </div>
            <button id="btn-generate-segmented-memory" class="interaction-btn modal-button">立即生成/更新</button>
            <div id="segmented-memory-status" class="modal-status"></div>
          </div>
          <!-- 统一预览区域 -->
          <div class="modal-section">
            <h4 class="modal-section-title">分段记忆直观预览</h4>
            <div id="unified-summary-display" class="modal-display-area" style="max-height: 450px; overflow-y: auto;">
              <!-- 统一的、带标签的事件列表将在这里渲染 -->
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 新增：总结编辑器模态框 -->
  <div id="summary-editor-modal" class="modal-overlay">
    <div class="modal-content" style="width: 600px; max-width: 95vw;">
      <div class="modal-header">
        <h2 class="modal-title" id="summary-editor-title">编辑总结</h2>
        <button class="modal-close-btn">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <textarea id="summary-editor-textarea" style="width: 100%; height: 400px; background: #1a1a2e; border: 1px solid #8b7355; color: #e0dcd1; border-radius: 4px; padding: 10px; font-size: 13px;"></textarea>
        <div class="modal-actions" style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
          <button id="summary-editor-cancel" class="interaction-btn" style="background: rgba(139, 115, 85, 0.2); border-color: #8b7355; color: #8b7355;">取消</button>
          <button id="summary-editor-save" class="interaction-btn" style="background: rgba(74, 158, 255, 0.2); border-color: #4a9eff; color: #4a9eff;">保存更改</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 世界书恢复确认小弹窗 -->
  <div id="worldbook-restore-confirm-modal" class="modal-overlay">
    <div class="modal-content" style="width: 400px; max-width: 90vw;">
      <div class="modal-header">
        <h2 class="modal-title">🔄 恢复确认</h2>
        <button class="modal-close-btn" onclick="GuixuManager.closeModal('worldbook-restore-confirm-modal'); GuixuManager.showWorldbookManager();">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <div id="restore-confirm-message" style="margin-bottom: 20px; line-height: 1.6; color: #c9aa71;">
          确定要恢复这些删除的条目吗？
        </div>
        <div class="modal-actions" style="display: flex; gap: 10px; justify-content: flex-end;">
          <button id="restore-confirm-cancel" class="interaction-btn" style="background: rgba(139, 115, 85, 0.2); border-color: #8b7355; color: #8b7355;">取消</button>
          <button id="restore-confirm-confirm" class="interaction-btn" style="background: rgba(74, 158, 255, 0.2); border-color: #4a9eff; color: #4a9eff;">恢复</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 世界书移除历史确认小弹窗 -->
  <div id="worldbook-remove-history-confirm-modal" class="modal-overlay">
    <div class="modal-content" style="width: 450px; max-width: 90vw;">
      <div class="modal-header">
        <h2 class="modal-title">⚠️ 移除确认</h2>
        <button class="modal-close-btn" onclick="GuixuManager.closeModal('worldbook-remove-history-confirm-modal'); GuixuManager.showWorldbookManager();">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <div id="remove-history-confirm-message" style="margin-bottom: 20px; line-height: 1.6; color: #c9aa71;">
          确定要从历史记录中移除这条记录吗？<br>
          <span style="color: #ff6b6b; font-weight: bold;">移除后将无法恢复。</span>
        </div>
        <div class="modal-actions" style="display: flex; gap: 10px; justify-content: flex-end;">
          <button id="remove-history-confirm-cancel" class="interaction-btn" style="background: rgba(139, 115, 85, 0.2); border-color: #8b7355; color: #8b7355;">取消</button>
          <button id="remove-history-confirm-confirm" class="interaction-btn" style="background: rgba(255, 107, 107, 0.2); border-color: #ff6b6b; color: #ff6b6b;">移除</button>
        </div>
      </div>
    </div>
    

      
      
      

      
      <div id="gacha-modal" class="modal-overlay">
        <div id="gacha-modal-content" class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" style="flex-shrink: 0;">衍梦尘</h2>
                <div id="gacha-pool-switcher-header" class="gacha-pool-switcher-header"></div>
                
                <div class="header-right-controls">
                    <div id="gacha-currency-header"></div> 
                    <button class="modal-close-btn">&times;</button>
                </div>
            </div>
            <div id="gacha-main-container" class="gacha-main-container">
                
            </div>
        </div>
    </div>

    
    <div id="gacha-results-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header"><h2 class="modal-title">召唤结果</h2><button class="modal-close-btn">&times;</button></div>
            <div class="modal-body"><div id="gacha-results-grid" class="gacha-results-grid"></div></div>
        </div>
    </div>

    
    <div id="gacha-history-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header"><h2 class="modal-title">召唤记录</h2><button class="modal-close-btn">&times;</button></div>
            <div class="modal-body">
                <div id="gacha-history-list" class="gacha-history-list"></div>
                <div class="history-pagination">
                    <button id="gacha-history-prev-btn" class="interaction-btn">上一页</button>
                    <span id="gacha-history-page-indicator"></span>
                    <button id="gacha-history-next-btn" class="interaction-btn">下一页</button>
                </div>
            </div>
        </div>
    </div> 

    
    <div id="gacha-details-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="gacha-details-title" class="modal-title">详情</h2>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div id="gacha-details-body" class="modal-body gacha-details-body"></div>
            <div id="gacha-details-footer" class="gacha-details-footer"></div>
        </div>
    <div id="gacha-gallery-popup" class="modal-overlay">
        <div class="modal-content gacha-gallery-popup">
            <div class="modal-header">
                <h2 id="gacha-gallery-title" class="modal-title">图鉴</h2>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                
                <div id="gallery-pool-preview"></div>
                
                <div class="gallery-obtained-container">
                    <h4 class="section-title">已获得</h4>
                    <div id="gallery-obtained-grid"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="gacha-settings-popup" class="modal-overlay">
        <div class="modal-content gacha-settings-popup">
            <div class="modal-header">
                <h2 class="modal-title">设置与指令中心</h2>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body" style="display: flex; flex-direction: column;">
                
                <div class="gacha-settings-tabs">
                    <button class="gacha-settings-tab active" data-tab="command_center">指令中心</button>
                    <button class="gacha-settings-tab" data-tab="archives">卡池预览</button>
                    <button class="gacha-settings-tab" data-tab="pool_editor">卡池编辑</button>
                    <button class="gacha-settings-tab" data-tab="redeem">兑换</button>
                </div>
                
                <div id="gacha-settings-content-container" class="gacha-settings-content-container">
                    
                </div>
            </div>
        </div>
    </div>


    <!-- 自动阅读悬浮窗 -->
    <div id="auto-read-float" class="auto-read-float" style="display: none;">
      <div class="auto-read-float-header">
        <span class="auto-read-title">自动阅读</span>
        <button class="auto-read-close" id="auto-read-close-btn">&times;</button>
      </div>
      <div class="auto-read-float-body">
        <div class="auto-read-controls">
          <label for="auto-read-float-speed" style="color: #c9aa71; font-size: 12px;">速度</label>
          <input type="range" id="auto-read-float-speed" min="1" max="10" value="3" step="1" class="auto-read-slider">
          <span id="auto-read-float-speed-value" class="auto-read-speed-value">3</span>
        </div>
        <button id="auto-read-toggle-btn" class="auto-read-toggle-btn">暂停</button>
      </div>
    </div>
    </div>   </div>
 <script>
    // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享
    // --- SillyTavern Global API ---
    // These are provided by the SillyTavern environment at runtime.
      // We will check for their existence before using them.
      /* global TavernHelper, eventOn, tavern_events, getChatMessages, getCurrentMessageId, _ */
      // --- Main Application Logic ---
      (function () {
    // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享
    const AppStorage = (() => {
    const STORAGE_NAMESPACE = 'GUIXU_GACHA_';
    const getNamespacedKey = (key) => `${STORAGE_NAMESPACE}${key}`;
    const getCircularReplacer = () => {
        const seen = new WeakSet();
        return (key, value) => {
            if (typeof value === 'undefined') return null;
            if (typeof value === 'object' && value !== null) {
                if (seen.has(value)) return;
                seen.add(value);
            }
            return value;
        };
    };
    const saveData = (key, value) => {
        if (typeof key !== 'string') return;
        try {
            const namespacedKey = getNamespacedKey(key);
            const stringifiedValue = JSON.stringify(value, getCircularReplacer());
            localStorage.setItem(namespacedKey, stringifiedValue);
        } catch (error) {
            console.error(`AppStorage Error: Failed to save data for key \"${key}\".`, error);
        }
    };
    const loadData = (key, defaultValue = null) => {
        if (typeof key !== 'string') return defaultValue;
        try {
            const namespacedKey = getNamespacedKey(key);
            const stringifiedValue = localStorage.getItem(namespacedKey);
            if (stringifiedValue === null) return defaultValue;
            return JSON.parse(stringifiedValue);
        } catch (error) {
            console.error(`AppStorage Error: Failed to load data for key \"${key}\".`, error);
            return defaultValue;
        }
    };
    return { saveData, loadData };
})();



        // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享
        const GuixuManager = {
              isInitialized: false, // 初始化状态标志
// ===清理模块开始===
    destroy() {
            // 清理逻辑将在这里逐步添加
            console.log('[归墟] GuixuManager.destroy() 被调用');

            // 1. 移除键盘快捷键监听器
            if (this.boundHandleKeydown) {
              document.removeEventListener('keydown', this.boundHandleKeydown);
              this.boundHandleKeydown = null;
            }

            // 2. 清除自动保存定时器
            if (this.autoSaveInterval) {
              clearInterval(this.autoSaveInterval);
              this.autoSaveInterval = null;
            }
            if (this.periodicAutoSaveIntervalId) {
              clearInterval(this.periodicAutoSaveIntervalId);
              this.periodicAutoSaveIntervalId = null;
            }

            // 3. 移除动态添加的DOM元素
            const rootContainer = document.querySelector('.guixu-root-container');
            if (rootContainer) {
              rootContainer.remove();
            }
            const modals = document.querySelectorAll('.modal-overlay');
            modals.forEach(modal => modal.remove());

            // 4. 重置所有状态
            this.isInitialized = false;
            this.currentMvuState = null;
            this.db = null;
            this.dbPromise = null;
            this.pendingActions = [];
            this.guixuStoreItems = [];
            this.baseAttributes = {};
            this.calculatedMaxAttributes = {};
            this.lastExtractedJourney = null;
            this.lastExtractedPastLives = null;
            this.gachaState = {};
            this.gachaCollection = {};
            this.gachaHistory = [];
            this.gachaPools = { character: { ssr: [], sr: [], r: [] }, item: { ssr: [], sr: [], r: [] }, talent: { ssr: [], sr: [], r: [] } };
          },
 
          // --- 衍梦尘 Gacha系统状态变量 ---
          isFromGuixuSystem: false,
          currentGachaPoolType: 'character', // 新增：跟踪当前显示的卡池类型
          gachaState: {
              mengChen: 1600, // 初始赠送
              pitySSR_char: 0,
              pitySR_char: 0,
              pitySSR_item: 0,
              pitySR_item: 0,
              pitySSR_talent: 0,
              pitySR_talent: 0,
              redeemedCodes: [],
                  activeCompanions: [],
          },
          gachaCollection: {},
          gachaHistory: [],
          gachaPools: { // 修改为三卡池结构
              character: { ssr: [], sr: [], r: [] },
              item:      { ssr: [], sr: [], r: [] },
              talent:    { ssr: [], sr: [], r: [] }
          },
   
          isGachaCheatMode: false, // 新增：作弊模式开关   
          pendingCompanionJoin: null, // 新增：等待加入世界的伙伴信息
          pendingCharacterCardGeneration: null, // 新增：等待AI生成角色卡的任务
          listenersBound: false, // 新增：防止事件监听器重复绑定的标志
          isSegmentedMemoryAutoOn: false, // 新增：分段记忆自动生成开关
          segmentedMemoryPollTimer: null, // 新增：分段记忆轮询定时器ID
          isSmallSummaryAutoOn: false, // 新增：小总结自动生成开关
          smallSummaryPollTimer: null, // 新增：小总结轮询定时器ID
          isLargeSummaryAutoOn: false, // 新增：大总结自动生成开关
          largeSummaryPollTimer: null, // 新增：大总结轮询定时器ID
          isFromSettingsModal: false,
          worldEventsViewMode: 'timeline', // 新增：世界大事视图模式,
          mainOpacity: 100, // 默认100%不透明
          leftPanelWidth: 20, // 新增：左侧面板宽度
          rightPanelWidth: 20, // 新增：右侧面板宽度
          intimateCharacters: new Set(), // 新增：用于存储亲密角色的Set态
          leftPanelCollapsed: false,

          // --- IndexedDB 数据库实例缓存 ---
          db: null,
          dbPromise: null,
          dbAvailable: false, // 标记数据库是否可用
          rightPanelCollapsed: false,

          // --- 自动阅读 ---
          isAutoReading: false,
          autoReadSpeed: 3,
          autoReadInterval: null,
          
          // 追踪已装备物品的状态
          //equippedItems 现在存储完整的物品对象，而不仅仅是ID
          equippedItems: {
            wuqi: null,
            fangju: null,
            shipin: null,
            fabao1: null,
            zhuxiuGongfa: null,
            fuxiuXinfa: null,
          },
          currentMvuState: null, // 新增：用于缓存当前最新的mvu状态
          currentSeries: '', // 当前选中的系列ID(空字符串代表"无系列")
          activeSeries: '', // 存档界面中当前激活显示的系列
          pendingActions: [], // 指令队列 - 存储纯文本指令
          guixuStoreItems: [], // 归墟空间商品缓存
          baseAttributes: {}, // 存储从mvu加载的原始属性
          calculatedMaxAttributes: {}, // 新增：用于缓存计算后的属性上限
          lastExtractedJourney: null,
          lastExtractedPastLives: null,
          lastExtractedNovelText: null, // 新增：用于存储提取的原始正文
          lastExtractedCharacterCard: null, // 新增：用于存储提取的角色卡
          lastExtractedThinking: null, // 新增：用于存储提取的思维过程
          lastExtractedVariables: null, // 新增：用于存储变量改变
          lastSentPrompt: null, // 新增：用于存储发送给AI的完整提示
          isNovelModeEnabled: false, // 新增：小说模式开关状态
          isAutoWriteEnabled: true, // 默认开启自动写入
          autoWriteIntervalId: null, // 用于存储轮询计时器ID
          
          // 新增：世界书预设管理状态
          worldbookPresets: {}, // 存储所有预设
          currentEditingPreset: null, // 当前正在编辑的预设
          presetManagerState: {
            selectedPresetId: null,
            isEditing: false
          },
          isFromWorldbookManager: false, // 新增：跟踪是否从世界书管理界面进入预设管理
          novelModeAutoWriteIntervalId: null, // 新增：小说模式的自动写入轮询ID
          isMobileView: false, // 新增：追踪移动视图状态
          isCharacterPanelVisible: false, // 新增：追踪角色面板的显示状态
          relationshipSortType: 'default', // 新增: 人物关系排序类型
          isInteractionPanelVisible: false, // 新增：追踪交互面板的显示状态
          currentRelationshipTab: 'attributes', // 新增：记录当前激活的tab
          lastSelectedCharacter: null, // 新增：记录上次选择的人物
          unifiedIndex: 1, // 新增：统一的读写序号
          novelModeIndex: 1, // 保留：用于向后兼容，但小说模式现在使用unifiedIndex
          isAutoToggleLorebookEnabled: false, // 新增：自动开关世界书状态
          autoToggleIntervalId: null, // 新增：轮询计时器ID
          periodicAutoSaveIntervalId: null, // 新增：轮询自动存档计时器ID
          isAutoSaveEnabled: true, // 新增：自动存档开关状态
          isActionOptionsEnabled: true, // 新增：行动选项开关状态
          isActionAutoSend: true, // 新增：行动选项自动发送开关状态
          isAutoTrimEnabled: false, // 新增：自动修剪开关状态
          isStreamingGametxt: false, // 新增：跟踪<gametxt>流式状态
          auxModelSettings: null, // 第二API设置缓存
          mvuUpdateMode: '随AI输出', // MVU更新方式：'随AI输出' 或 '分步变量更新'
          generationMode: 'once', // 生成模式：'once' 一次性 或 'stepwise' 步进式
          stepwiseConfig: null, // 分步变量更新配置 {modelSource, worldbookFilterMode}
          isStreamingEnabled: true, // 新增：流式开关状态
          isStepwiseAppendMode: false, // 新增：步进式追加模式标志
          stepwiseDisplayedMainContent: '', // 新增：步进式已显示的主内容
          isStepwiseFirstStep: false, // 新增：标记是否处于步进式第一步
          isStepwiseSecondStep: false, // 新增：标记是否处于步进式第二步
          cachedFirstStepText: null, // 新增：缓存第一步的完整原始文本（不提取标签）
          cachedStepwiseWorldbookEntries: null, // 新增：缓存第二步筛选后的世界书条目
          isFormatValidationEnabled: true, // 新增：格式审查开关状态
          isEnterSendEnabled: true, // 新增：回车发送开关状态
          isKeyboardShortcutsEnabled: true, // 新增：键盘快捷键开关状态
          isMobileInputAdaptEnabled: false, // 新增：手机输入框适配开关状态
          lastValidGametxtHTML: '', // 新增：用于备份上一次有效的正文HTML
          floatingInputContainer: null, // 新增：浮动输入框容器
          historicalTextCount: 3, // 新增：历史正文显示数量（0=不显示，-1=全部，其他正数=显示数量）
          
          // --- 新增：文字设置状态 ---
          textSettings: {
            colors: {
              normal: '#e8dcc6',        // 正文颜色
              dialogue: '#ff1493',      // 对话颜色
              psychology: '#808080',    // 心理活动颜色：灰色
              scenery: '#98fb98',      // 景物描写颜色
              character: '#87CEFA'     // 人物名称颜色：淡蓝色
            },
            fontSizes: {               // 单独字体大小设置
              normal: 14,             // 正文字体大小
              dialogue: 14,           // 对话字体大小
              psychology: 13,         // 心理活动字体大小
              scenery: 15,            // 景物描写字体大小
              character: 14           // 人物名称字体大小
            },
            fontFamily: "'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif", // 字体族
            customFonts: []            // 用户上传的自定义字体
          },
          backgroundImages: [], // 存储用户上传的背景图
          backgroundMode: 'random', // 'random' 或 'fixed'
          selectedBackgroundId: null, // 固定模式下选中的背景图ID
          gallerySource: 'library', // 'library' 或 'output'
          outputFolderHandle: null, // 用于存储 output 文件夹的句柄
          outputFolderImages: [], // 存储从 output 文件夹加载的图片
          outputFolderMonitoringInterval: null, // 存储文件夹监听定时器ID
          // 图库分页相关
          galleryCurrentPage: 1, // 当前页码
          galleryPageSize: 20, // 每页显示数量（改为20张）
          // --- 新增：处理所有动作的核心函数 ---
          waitingMessages: [
            '呜呜呜呜伟大的梦星大人啊，请给你虔诚的信徒<user>回复吧......',
            '梦星大人，我们敬爱你口牙！！请给我回复吧！！',
            '梦星大人正在回应你的请求，七个工作日给你回复',
            '正在向伟大梦星祈祷......呜呜呜你快一点好不好'
          ],
// ===清理模块结束===



// ===等待信息处理模块开始===



          showWaitingMessage() {
            this.hideWaitingMessage(); 
            const message = this.waitingMessages[Math.floor(Math.random() * this.waitingMessages.length)];
            const msgElement = document.createElement('div');
            msgElement.id = 'waiting-popup';
            msgElement.className = 'waiting-popup';
            msgElement.innerHTML = `
              <div class="waiting-spinner"></div>
              <span>${message}</span>
            `;
            const container = document.querySelector('.guixu-root-container');
            if (container) {
                container.appendChild(msgElement);
            }
          },

          hideWaitingMessage() {
              const existingMsg = document.getElementById('waiting-popup');
              if (existingMsg) {
                  existingMsg.remove();
              }
          },

          updateWaitingMessage(text) {
             const popup = document.getElementById('waiting-popup');
             if (popup) {
                 const span = popup.querySelector('span');
                 if (span) {
                     span.textContent = text;
                 }
             }
          },



// ===等待信息处理模块结束===



// ===手机/电脑界面切换模块开始===
          toggleViewMode() {
            this.isMobileView = !this.isMobileView;
            const container = document.querySelector('.guixu-root-container');
            const btn = document.getElementById('view-toggle-btn');
            if (container && btn) {
              if (this.isMobileView) {
                container.classList.add('mobile-view');
                btn.textContent = '💻'; // 切换到桌面图标
                btn.title = '切换到桌面视图';
              } else {
                container.classList.remove('mobile-view');
                btn.textContent = '📱'; // 切换到手机图标
                btn.title = '切换到移动视图';
              }
            }
            this.saveViewMode();
          },

          saveViewMode() {
            try {
              localStorage.setItem('guixu_view_mode', this.isMobileView ? 'mobile' : 'desktop');
            } catch (e) {
              console.error('保存视图模式失败:', e);
            }
          },

          loadViewMode() {
            try {
              const savedMode = localStorage.getItem('guixu_view_mode');
              // 仅当保存的模式为 'mobile' 时，才在加载时切换到移动视图
              if (savedMode === 'mobile') {
                this.isMobileView = true; // 设置初始状态
                const container = document.querySelector('.guixu-root-container');
                const btn = document.getElementById('view-toggle-btn');
                if (container && btn) {
                  container.classList.add('mobile-view');
                  btn.textContent = '💻';
                  btn.title = '切换到桌面视图';
                }
              } else {
                this.isMobileView = false; // 确保默认是桌面视图
              }
            } catch (e) {
              console.error('加载视图模式失败:', e);
            }
          },



// ===手机/电脑界面切换模块开始===




// ===detail标签处理模块===
  convertDetailTagsToHTML(text) {
    if (!text) return text;
    let counter = 0;
    return text.replace(/<detail>([\s\S]*?)<\/detail>/g, (match, content) => {
      const id = `detail-${Date.now()}-${counter++}`;
      const onclickAction = `const wrapper=document.getElementById('${id}'); if(wrapper) { wrapper.classList.toggle('expanded'); const icon=wrapper.querySelector('.detail-icon'); if(icon) { icon.classList.toggle('collapsed'); icon.textContent = wrapper.classList.contains('expanded') ? '▼' : '▶'; } }`;
      return `<span class="detail-wrapper" id="${id}"><span class="detail-trigger" onclick="${onclickAction}"><span class="detail-icon">▶</span><span>查看详情</span></span><div class="detail-content-wrapper"><div class="detail-content">${content.trim()}</div></div></span>`;
    });
  },

// ===正文染色模块开始===
  formatMessageContent(text) {
            if (!text) return '';

            // 预处理detail标签：转换为可折叠的HTML结构
            text = this.convertDetailTagsToHTML(text);

            // 预处理：仅处理章节标题和换行
            let processedText = text.replace(/\\n/g, '<br />');
            processedText = processedText.replace(/(^\s*第.*?章.*$)/gm, (match) => `<h3 class="novel-chapter-title">${match}</h3>`);

            // 基于AST的解析器
            const parseAndStyle = (str) => {
                // 1. 分词
                // 将字符串分解为标记符号和纯文本块
                const tokens = str.match(/(\*\*|\*|【【|】】|【|】|《|》|「|」|『|』|“|”|"[^"]*"|'[^']*')|([^【】\*《》「」『』“”'"]+)/g) || [];

                // 2. 定义规则
                const tokenRules = {
                    '**': { type: 'psychology', symmetric: true },
                    '*': { type: 'psychology', symmetric: true },
                    '【【': { type: 'scenery-double', open: '【【', close: '】】' },
                    '】】': { type: 'scenery-double', open: '【【', close: '】】' },
                    '【': { type: 'scenery', open: '【', close: '】' },
                    '】': { type: 'scenery', open: '【', close: '】' },
                    '《': { type: 'language', open: '《', close: '》' },
                    '》': { type: 'language', open: '《', close: '》' },
                    '「': { type: 'language', open: '「', close: '」' },
                    '」': { type: 'language', open: '「', close: '」' },
                    '『': { type: 'language', open: '『', close: '』' },
                    '』': { type: 'language', open: '『', close: '』' },
                    '“': { type: 'language', open: '“', close: '”' },
                    '”': { type: 'language', open: '“', close: '”' },
                    '"': { type: 'language', symmetric: true },
                    "'": { type: 'language', symmetric: true }
                };
                const classMap = { psychology: 'text-psychology', scenery: 'text-scenery', 'scenery-double': 'text-scenery', language: 'text-language' };

                // 3. 解析-> 构建抽象语法树 (AST)
                let root = { type: 'root', children: [] };
                let stack = [root]; // 节点栈

                for (const token of tokens) {
                    const rule = tokenRules[token];
                    let currentNode = stack[stack.length - 1];

                    if (rule) {
                        if (rule.symmetric) {
                            if (currentNode.type === rule.type && currentNode.token === token) {
                                stack.pop(); // 闭合对称标签
                            } else {
                                const newNode = { type: rule.type, token: token, children: [] };
                                currentNode.children.push(newNode);
                                stack.push(newNode); // 开启对称标签
                            }
                        } else if (token === rule.open) { // 开启非对称标签
                            const newNode = { type: rule.type, children: [] };
                            currentNode.children.push(newNode);
                            stack.push(newNode);
                        } else if (token === rule.close) { // 闭合非对称标签
                            if (currentNode.type === rule.type) {
                                stack.pop();
                            } else { // 容错：如果标签不匹配，则作为纯文本处理
                                currentNode.children.push(token);
                            }
                        }
                    } else { // 纯文本
                        currentNode.children.push(token);
                    }
                }

                // 4. 代码生成 
                const generateHTML = (node) => {
                    if (typeof node === 'string') {
                        // 在最终生成时才进行HTML实体转义
                        return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    const childrenHTML = node.children.map(generateHTML).join('');
                    if (node.type === 'root') {
                        return childrenHTML;
                    }
                    // 在这里，我们将标记符号本身也包含在span内部，以实现对符号的染色
                    const openToken = node.token || Object.keys(tokenRules).find(k => tokenRules[k].type === node.type && tokenRules[k].open === k) || '';
                    const closeToken = node.token || Object.keys(tokenRules).find(k => tokenRules[k].type === node.type && tokenRules[k].close === k) || '';
                    
                    return `<span class="${classMap[node.type]}">${openToken}${childrenHTML}${closeToken}</span>`;
                };
                
                // 在生成HTML时，我们应该只包裹内容，而不是再次添加标记
                const generateCorrectHTML = (node) => {
                     if (typeof node === 'string') {
                        return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    const childrenHTML = node.children.map(generateCorrectHTML).join('');
                    if (node.type === 'root') {
                        return childrenHTML;
                    }
                    // 只包裹内容
                    return `<span class="${classMap[node.type]}">${childrenHTML}</span>`;
                }
                const generateFinalHTML = (node, parent) => {
                    if (typeof node === 'string') {
                         return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    const childrenHTML = node.children.map(child => generateFinalHTML(child, node)).join('');
                    if (node.type === 'root') return childrenHTML;

                    const open = node.token || Object.keys(tokenRules).find(k => tokenRules[k].type === node.type && tokenRules[k].open) || '';
                    const close = node.token || Object.keys(tokenRules).find(k => tokenRules[k].type === node.type && tokenRules[k].close) || '';

                    return `<span class="${classMap[node.type]}">${open}${childrenHTML}${close}</span>`;
                };
                
                // 最终版生成器
                const finalGenerator = (node) => {
                    if (typeof node === 'string') {
                        return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    
                    const childrenHtml = node.children.map(finalGenerator).join('');
                    
                    if (node.type === 'root') {
                        return childrenHtml;
                    }
                    
                    return `<span class="${classMap[node.type]}">${childrenHtml}</span>`;
                };

                // 将标记也作为节点
                let new_root = { type: 'root', children: [] };
                let new_stack = [new_root];

                for (const token of tokens) {
                    const rule = tokenRules[token];
                    let currentNode = new_stack[new_stack.length - 1];

                    if (rule) {
                        if (rule.symmetric) {
                            if (currentNode.type === rule.type && currentNode.token === token) {
                                new_stack.pop();
                            } else {
                                const newNode = { type: rule.type, token: token, children: [] };
                                currentNode.children.push(newNode);
                                new_stack.push(newNode);
                            }
                        } else if (rule.open === token) {
                            const newNode = { type: rule.type, open: token, close: rule.close, children: [] };
                            currentNode.children.push(newNode);
                            new_stack.push(newNode);
                        } else if (rule.close === token) {
                            if (currentNode.type === rule.type && currentNode.close === token) {
                                new_stack.pop();
                            } else {
                                currentNode.children.push(token); // Mismatch, treat as text
                            }
                        }
                    } else {
                        currentNode.children.push(token);
                    }
                }
                
                const finalHtmlGenerator = (node) => {
                    if (typeof node === 'string') {
                        return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    const childrenHtml = node.children.map(finalHtmlGenerator).join('');
                    if (node.type === 'root') {
                        return childrenHtml;
                    }

                    // 根据类型决定是否保留标记符号
                    if (node.type === 'language') {
                        // 对话类型，保留符号
                        return `<span class="${classMap[node.type]}">${node.open || node.token || ''}${childrenHtml}${node.close || node.token || ''}</span>`;
                    } else if (node.type === 'scenery-double') {
                        // 双层括号景物，保留外层括号并染色
                        return `<span class="${classMap[node.type]}">【${childrenHtml}】</span>`;
                    }
                    else {
                        // 景物和心理类型，移除符号
                        return `<span class="${classMap[node.type]}">${childrenHtml}</span>`;
                    }
                };

                return finalHtmlGenerator(new_root);
            };

            let finalHtml = parseAndStyle(processedText);
            
            // 新增：在HTML生成后进行人物名称检索和链接化
            finalHtml = this.highlightCharacterNames(finalHtml);
            
            return finalHtml;
          },
          // 新增：人物名称高亮和链接化函数
          highlightCharacterNames(html) {
            if (!html || !this.currentMvuState) return html;
            
            try {
              // 获取人物关系列表
              const relationships = this.SafeGetValue(this.currentMvuState.stat_data, '人物关系列表', {});
              
              // 提取所有人物名称（只检索键名）
              const characterNames = Object.keys(relationships).filter(name => name !== '$meta');
              
              if (characterNames.length === 0) return html;
              
              // 按名称长度降序排列，优先匹配较长的名称
              characterNames.sort((a, b) => b.length - a.length);
              
              let result = html;
              
              // 对每个人物名称进行替换
              characterNames.forEach(name => {
                // 创建正则表达式，匹配人物名称但避免在HTML标签内匹配
                // 使用分割和重组的方式，只替换>和<之间的纯文本中的人物名称
                const parts = result.split(/(>[^<]*<)/);
                result = parts.map((part, index) => {
                  // 只处理奇数索引的部分（纯文本内容）
                  if (index % 2 === 1) {
                    // 替换人物名称为带样式的span
                    return part.replace(new RegExp(name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
                      `<span class="character-link" data-character="${name}">${name}</span>`);
                  }
                  return part;
                }).join('');
              });
              
              return result;
              
            } catch (error) {
              // 静默处理错误，不影响正文显示
              return html;
            }
          },


// ===正文染色模块结束===



// ===正文字数获取模块开始===
          updateLiveWordCount() {
            const gameTextDisplay = document.getElementById('game-text-display');
            const wordCountEl = document.getElementById('game-text-word-count');
            if (gameTextDisplay && wordCountEl) {
              // 使用 textContent 来获取纯文本，自动忽略HTML标签
              const wordCount = gameTextDisplay.textContent ? gameTextDisplay.textContent.trim().length : 0;
              wordCountEl.textContent = `正文：${wordCount}字`;
            }
          },
// ===正文字数获取模块结束===


// ===初始化（init）模块开始===
          async init() {


// ===初始化之前===（数据库初始化）

// 数据库初始化

            try {
              await this.initializeDatabase();
              console.log('[归墟Plus] Dexie 数据库初始化完成');
            } catch (error) {
              console.error('[归墟Plus] 数据库初始化失败:', error);
            }
        if (this.isInitialized) {
              console.log('[归墟]初始化完成');
              return;
            }

// ===初始化之前===

            this.isInitialized = true;
            this.loadPanelWidths(); // 加载面板宽度设置
            this.bindStaticListeners();
            this.loadWindowSizeState(); // 加载窗口大小状态
            this.loadModalSizeState(); // 加载模态框大小状态
            this.initBackgroundSystem(); // 初始化背景图系统
            this.loadWorldbookPresets(); // 加载世界书预设
            this.loadGallerySource(); // 加载图库来源设置
            this.loadOutputFolderHandle(); // 加载output文件夹句柄
            this.loadGallerySource(); // 加载图库来源设置
            this.loadOutputFolderHandle(); // 加载output文件夹句柄        
            this.initAutoRead(); // 初始化自动阅读功能
                 await this.updateDynamicData(); // 初始化变量数据
            this.loadAutoWriteState(); // 加载自动写入状态
            this.loadNovelModeState(); // 加载小说模式状态
            this.loadPendingActions(); // 加载待处理指令
            this.loadViewMode(); // 新增：加载用户保存的视图模式
            this.loadUnifiedIndex(); // 新增：加载统一的读写序号
            this.loadAutoToggleState(); // 新增：加载自动开关状态
            this.loadWorldbookSettings(); // 新增：加载世界书高级设置
            this.loadAutoSaveState(); // 新增：加载自动存档状态
            this.loadSegmentedMemoryState(); // 加载统一的开关状态
            this.loadSegmentedMemoryCounts(); // 新增：加载分段记忆保留数
            this.loadSmallSummaryState();
            this.loadLargeSummaryState();
            this.loadActionOptionsState(); // 新增：加载行动选项开关状态
            this.loadActionAutoSendState(); // 新增：加载行动选项自动发送状态
            this.loadHistoricalTextSettings(); // 新增：加载历史正文设置
            this.loadPanelStates(); // 新增：加载面板折叠状态
            this.loadStreamingState(); // 新增：加载流式开关状态
            this.loadFormatValidationState(); // 新增：加载格式审查状态
            this.loadEnterSendState(); // 新增：加载回车发送状态
            this.loadKeyboardShortcutsState(); // 新增：加载键盘快捷键状态
            this.loadMobileInputAdaptState(); // 新增：加载手机输入框适配状态
            this.loadRelationshipSettings(); // 新增：加载人物关系设置
            this.loadLastThinking(); // 新增：加载上次的思维过程
            this.loadTrimFieldsState(); // 新增：加载修剪字段状态
            this.loadTextSettings(); // 新增：加载文字设置
            this.loadGachaState(); // 新增：加载Gacha/衍梦尘数据
            this.loadAuxModelSettings(); // 新增：加载第二API设置
            this.loadMvuUpdateMode(); // 新增：加载MVU更新方式
            this.loadGachaCheatState(); // 新增：加载Gacha作弊模式状态
                 await this.loadCharacterPoolFromLorebook(); // 新增：加载卡池
            this.updateThinkingButtonVisibility(); // 新增：根据加载的数据更新按钮
            this.updateCurrentLifeButtonVisibility(); // 新增:更新本世历程按钮显示
            this.updatePastLivesButtonVisibility(); // 新增:更新往世涟漪按钮显示
            this.setupInputKeyboardHandling();
            this.initQuestSystem(); // 初始化任务系统
            //this.startPeriodicAutoSave(); // 启动轮询自动存档


// ===初始化末尾===（其他逻辑、事件注册等内容）


           eventOn(iframe_events.STREAM_TOKEN_RECEIVED_FULLY, (text) => this.handleStreamUpdate(text));
           eventOn(iframe_events.GENERATION_ENDED, (text) => this.handleStreamEnd(text));
           eventOn('worldinfo_entries_loaded', (lores) => this.handleWorldbookFilter(lores));

            // 将自动阅读悬浮窗移动到body末尾(必须在initAutoRead之前)
            const autoReadFloat = document.getElementById('auto-read-float');
            if (autoReadFloat) {
              document.body.appendChild(autoReadFloat);
            }

            //在初始化最后，手动更新一次章节导航按钮的可见性，确保按钮状态正确
           if (typeof this.updateChapterNavigation === 'function') {
             this.updateChapterNavigation();
           }

            // 首次加载完成后自动跳转到标题/思维链位置
            setTimeout(() => {
              const mainContent = document.getElementById('main-content');
              const titleContainer = document.getElementById('current-chapter-title');
              const thinkingContainer = document.getElementById('thinking-process-container');
              const gameTextDisplay = document.getElementById('game-text-display');
             
              if (mainContent) {
                let targetElement = gameTextDisplay; // 默认目标
                if (titleContainer && titleContainer.style.display !== 'none') {
                 targetElement = titleContainer; // 优先滚动到标题
                } else if (thinkingContainer && thinkingContainer.style.display !== 'none') {
                 targetElement = thinkingContainer; // 其次滚动到思维链
               }
               
               const rect = targetElement.getBoundingClientRect();
               const containerRect = mainContent.getBoundingClientRect();
               const targetPosition = mainContent.scrollTop + rect.top - containerRect.top;
               console.log('[归墟] 首次加载,滚动到:', targetElement.id, '位置:', targetPosition);
               mainContent.scrollTo({ top: targetPosition, behavior: 'smooth' });
             }
            }, 500); // 延迟500ms确保所有初始化完成
           // 【动态注入归墟空间定制化CSS】
            const customStyles = `
                /* 归墟空间确认框定制样式 */
                #custom-confirm-modal.guixu-confirm-modal .modal-content {
                    background: var(--bg-secondary, rgba(15, 15, 35, 0.85));
                    border: 1px solid var(--border-color, #444);
                    border-radius: 8px;
                    box-shadow: var(--shadow-glow, 0 0 12px rgba(201, 170, 113, 0.3)), var(--shadow-elevation-medium, 0 4px 6px rgba(0, 0, 0, 0.2));
                    width: 400px !important; /* 调整宽度并强制覆盖 */
                    max-width: 80vw;
                    height: auto;
                    min-height: 180px; /* 调整最小高度 */
                    padding: 24px;
                    display: flex;
                    flex-direction: column;
                    justify-content: center; /* 垂直居中 */
                    align-items: center; /* 水平居中 */
                    gap: 20px; /* 元素间距 */
                }
                #custom-confirm-modal.guixu-confirm-modal .modal-header {
                    padding: 0;
                    border-bottom: none;
                    position: absolute; /* 将关闭按钮定位到右上角 */
                    top: 10px;
                    right: 10px;
                }
                #custom-confirm-modal.guixu-confirm-modal .modal-title {
                    display: none; /* 隐藏默认标题 */
                }
                #custom-confirm-modal.guixu-confirm-modal .confirm-modal-message {
                    color: var(--text-primary, #e0e0e0);
                    font-size: 16px;
                    text-align: center;
                    line-height: 1.6;
                }
                #custom-confirm-modal.guixu-confirm-modal .confirm-modal-buttons {
                    display: flex;
                    gap: 15px;
                    padding: 0;
                }
                #custom-confirm-modal.guixu-confirm-modal .interaction-btn {
                    min-width: 100px;
                }
                #custom-confirm-modal.guixu-confirm-modal #custom-confirm-btn-ok {
                    background-color: var(--primary-gold, #c9aa71);
                    color: var(--text-on-primary, #1a1a1a);
                    border: none;
                }
                #custom-confirm-modal.guixu-confirm-modal #custom-confirm-btn-ok:hover {
                    background-color: var(--secondary-gold, #daa520);
                }
                #custom-confirm-modal.guixu-confirm-modal #custom-confirm-btn-cancel {
                    background-color: transparent;
                    border: 1px solid var(--border-color-light, #666);
                    color: var(--text-secondary, #b0b0b0);
                }
                #custom-confirm-modal.guixu-confirm-modal #custom-confirm-btn-cancel:hover {
                    background-color: var(--bg-hover, rgba(255, 255, 255, 0.1));
                    border-color: var(--border-color-hover, #888);
                }
            `;
            const styleElement = document.createElement('style');
            styleElement.textContent = customStyles;
            document.head.appendChild(styleElement);
// ===初始化末尾===


          },



// ===初始化（init）模块结束===

        
          // 世界书筛选函数（用于步进式模式）
          handleWorldbookFilter(lores) {
              
              const only_plot_regex = /【only剧情】/;
              const only_variable_regex = /【only变量】/;
              
              // 如果是第二步，在筛选前先缓存所有世界书内容（用于上下文查看）
              if (this.isStepwiseSecondStep) {
                  this.cachedStepwiseWorldbookEntries = {
                      original: {
                          globalLore: lores.globalLore ? [...lores.globalLore] : [],
                          characterLore: lores.characterLore ? [...lores.characterLore] : [],
                          chatLore: lores.chatLore ? [...lores.chatLore] : [],
                          personaLore: lores.personaLore ? [...lores.personaLore] : []
                      },
                      filtered: null  // 稍后填充
                  };
              }
              
              const filterLoreArray = (loreArray, arrayName) => {
                  if (!loreArray || loreArray.length === 0) return;
                  
                  const originalCount = loreArray.length;
                  
                  const removed = _.remove(loreArray, entry => {
                      const entryName = entry.name || entry.comment || '';
                      const hasPlotPrefix = entryName.match(only_plot_regex);
                      const hasVariablePrefix = entryName.match(only_variable_regex);
                      
                      if (this.isStepwiseFirstStep) {
                          // 第一步：移除【only变量】标记的条目
                          return hasVariablePrefix && !hasPlotPrefix;
                      } else if (this.isStepwiseSecondStep) {
                          // 第二步：移除【only剧情】标记的条目
                          return hasPlotPrefix && !hasVariablePrefix;
                      }
                      return false;
                  });
                  
                  if (removed.length > 0) {
                      console.log(`[归墟-世界书筛选] ${arrayName}: 移除了 ${removed.length} 个条目`);
                      removed.forEach(entry => {
                          const entryName = entry.name || entry.comment || 'unnamed';
                          console.log(`  - 移除: ${entryName}`);
                      });
                  }
                  
                  console.log(`[归墟-世界书筛选] ${arrayName}: ${originalCount} → ${loreArray.length} 个条目`);
              };
              
              // 对所有类型的世界书进行筛选
              if (lores.globalLore) filterLoreArray(lores.globalLore, '全局世界书');
              if (lores.characterLore) filterLoreArray(lores.characterLore, '角色世界书');
              if (lores.chatLore) filterLoreArray(lores.chatLore, '聊天世界书');
              if (lores.personaLore) filterLoreArray(lores.personaLore, '人设世界书');
              
              // ✅ 如果是第二步，缓存筛选后的结果（用于上下文查看）
              if (this.isStepwiseSecondStep && this.cachedStepwiseWorldbookEntries) {
                  this.cachedStepwiseWorldbookEntries.filtered = {
                      globalLore: lores.globalLore || [],
                      characterLore: lores.characterLore || [],
                      chatLore: lores.chatLore || [],
                      personaLore: lores.personaLore || []
                  };
                  console.log('[归墟-世界书筛选] 已缓存第二步筛选后的世界书内容');
              }
          },

// ===流式处理模块开始===

          startPeriodicAutoSave() {
            if (this.periodicAutoSaveIntervalId) {
              clearInterval(this.periodicAutoSaveIntervalId);
            }
            this.periodicAutoSaveIntervalId = setInterval(() => {
              this.saveGame(true); // 调用现有的存档函数，isAutoSave=true
            }, 60000); // 60秒
          },

          handleStreamUpdate(text) {
            if (!this.isStreamingGametxt && text.includes('<gametxt>')) {
                this.isStreamingGametxt = true;
                this.updateWaitingMessage('梦星大人正在给你流式生成正文，赞美梦星大人！！！');
                this.hideVariableChangesReminder();
            }
            
            const gameTextDisplay = document.getElementById('game-text-display');
            if (gameTextDisplay) {
              // 步进式第二步不显示流式更新，等待完成后再合并显示
              if (this.isStepwiseAppendMode) {
                return;
              }
              
              // 正常模式或步进式第一步：显示gametxt内容
              const displayText = this._getDisplayText(text);
              gameTextDisplay.innerHTML = this.formatMessageContent(displayText);
              this.updateLiveWordCount();
            }
          },
// ===流式处理模块结束==



// ===格式审查模块开始===



          // 验证步进式第二步的响应格式（只检查UpdateVariable标签）
          validateStep2Response(text) {
            const tagConfig = {
              // 第二步只需要UpdateVariable标签
              required: ['UpdateVariable'],
              optional: []
            };
            const errors = [];
            // 智能过滤掉<thinking>...</thinking>标签内容
            const thinkingRegex = /<thinking>[\s\S]*?<\/thinking>/gi;
            let cleanedText = text.replace(thinkingRegex, '');
            
            // 检查所有标签
            const allTags = [...tagConfig.required, ...tagConfig.optional];
            for (const tag of allTags) {
              const openTagCount = (cleanedText.match(new RegExp(`<${tag}>`, 'gi')) || []).length;
              const closeTagCount = (cleanedText.match(new RegExp(`</${tag}>`, 'gi')) || []).length;
              const isRequired = tagConfig.required.includes(tag);
              
              console.log(`[格式验证-步骤2] 标签 ${tag} (${isRequired ? '必需' : '可选'}): 开始=${openTagCount}, 结束=${closeTagCount}`);
              
              // 检查必需标签是否完全缺失
              if (isRequired && openTagCount === 0 && closeTagCount === 0) {
                errors.push({
                  tag: tag,
                  type: 'missing',
                  message: `&lt;${tag}&gt;没有`
                });
              }
              // 检查标签闭合情况
              else if (openTagCount > 0 && closeTagCount === 0) {
                errors.push({
                  tag: tag,
                  type: 'unclosed',
                  message: `&lt;${tag}&gt;标签没闭合`
                });
              }
              else if (openTagCount === 0 && closeTagCount > 0) {
                errors.push({
                  tag: tag,
                  type: 'incomplete',
                  message: `&lt;${tag}&gt;标签缺失开始标签`
                });
              }
              else if (openTagCount > 0 && closeTagCount > 0 && openTagCount !== closeTagCount) {
                errors.push({
                  tag: tag,
                  type: 'mismatch',
                  message: `&lt;${tag}&gt;标签没闭合`
                });
              }
            }
            
            return {
              isValid: errors.length === 0,
              errors: errors,
              summary: {
                total: errors.length,
                missing: errors.filter(e => e.type === 'missing').length,
                unclosed: errors.filter(e => e.type === 'unclosed').length,
                incomplete: errors.filter(e => e.type === 'incomplete').length,
                mismatch: errors.filter(e => e.type === 'mismatch').length
              }
            };
          },

          validateResponseFormat(text) {
            // 定义标签检查配置
            const tagConfig = {
              // 必需标签：必须存在且正确闭合
              required: ['gametxt', '本世历程'],
              // 可选标签：如果存在则必须正确闭合
              optional: ['UpdateVariable', 'thinking', 'action']
            };
            const errors = [];
            // 智能过滤掉<thinking>...</thinking>标签内容，避免其中的内容干扰格式验证
            const thinkingRegex = /<thinking>[\s\S]*?<\/thinking>/gi;
            let cleanedText = text.replace(thinkingRegex, '');
            // 检查所有标签（必需 + 可选）
            const allTags = [...tagConfig.required, ...tagConfig.optional];        
            for (const tag of allTags) {
              const openTagCount = (cleanedText.match(new RegExp(`<${tag}>`, 'gi')) || []).length;
              const closeTagCount = (cleanedText.match(new RegExp(`</${tag}>`, 'gi')) || []).length;
              const isRequired = tagConfig.required.includes(tag);              
              console.log(`[格式验证] 标签 ${tag} (${isRequired ? '必需' : '可选'}): 开始=${openTagCount}, 结束=${closeTagCount}`);              
              // 1. 检查必需标签是否完全缺失
              if (isRequired && openTagCount === 0 && closeTagCount === 0) {
                const errorMsg = `&lt;${tag}&gt;没有`;
                console.log(`[格式验证] 添加错误: ${errorMsg}`);
                errors.push({
                  tag: tag,
                  type: 'missing',
                  message: errorMsg
                });
              }
              // 2. 检查标签闭合情况（对所有存在的标签）
              else if (openTagCount > 0 && closeTagCount === 0) {
                const errorMsg = `&lt;${tag}&gt;标签没闭合`;
                console.log(`[格式验证] 添加错误: ${errorMsg}`);
                errors.push({
                  tag: tag,
                  type: 'unclosed',
                  message: errorMsg
                });
              }
              // 3. 检查只有结束标签的情况
              else if (openTagCount === 0 && closeTagCount > 0) {
                const errorMsg = `&lt;${tag}&gt;标签缺失开始标签`;
                console.log(`[格式验证] 添加错误: ${errorMsg}`);
                errors.push({
                  tag: tag,
                  type: 'incomplete',
                  message: errorMsg
                });
              }
              // 4. 检查标签数量不匹配的情况
              else if (openTagCount > 0 && closeTagCount > 0 && openTagCount !== closeTagCount) {
                const errorMsg = `&lt;${tag}&gt;标签没闭合`;
                console.log(`[格式验证] 添加错误: ${errorMsg}`);
                errors.push({
                  tag: tag,
                  type: 'mismatch',
                  message: errorMsg
                });
              }
            }
            
            return {
              isValid: errors.length === 0,
              errors: errors,
              summary: {
                total: errors.length,
                missing: errors.filter(e => e.type === 'missing').length,
                unclosed: errors.filter(e => e.type === 'unclosed').length,
                incomplete: errors.filter(e => e.type === 'incomplete').length,
                mismatch: errors.filter(e => e.type === 'mismatch').length
              }
            };
          },


          // 显示格式审查详情界面（增强版：支持文本显示和编辑）
          showFormatValidationDetails(errors, finalText, options = {}) {
            const modal = document.getElementById('format-validation-modal');
            const errorsList = document.getElementById('format-errors-list');
            const rollbackBtn = document.getElementById('format-validation-rollback');
            const continueBtn = document.getElementById('format-validation-continue');
            
            if (!modal || !errorsList || !rollbackBtn || !continueBtn) return;
            
            // 存储当前文本和选项到实例变量，供编辑功能使用
            this.currentValidationText = finalText;
            this.currentValidationOptions = options;
            
            // 清空并填充错误列表
            errorsList.innerHTML = '';
            
            // 按错误类型分组显示
            const errorsByType = {
              missing: errors.filter(e => e.type === 'missing'),
              unclosed: errors.filter(e => e.type === 'unclosed'),
              incomplete: errors.filter(e => e.type === 'incomplete'),
              mismatch: errors.filter(e => e.type === 'mismatch')
            };
            
            // 定义错误类型的显示信息
            const typeInfo = {
              missing: { icon: '❌', title: '缺失必需标签', priority: 1 },
              unclosed: { icon: '⚠️', title: '标签未闭合', priority: 2 },
              incomplete: { icon: '🔧', title: '标签不完整', priority: 3 },
              mismatch: { icon: '🔄', title: '标签数量不匹配', priority: 4 }
            };
            
            // 按优先级显示错误
            Object.keys(typeInfo)
              .sort((a, b) => typeInfo[a].priority - typeInfo[b].priority)
              .forEach(type => {
                const typeErrors = errorsByType[type];
                if (typeErrors.length > 0) {
                  // 创建错误类型标题
                  const typeHeader = document.createElement('div');
                  typeHeader.className = 'format-error-type-header';
                  typeHeader.innerHTML = `
                    <span class="error-type-icon">${typeInfo[type].icon}</span>
                    <span class="error-type-title">${typeInfo[type].title} (${typeErrors.length})</span>
                  `;
                  errorsList.appendChild(typeHeader);
                  
                  // 显示该类型的所有错误
                  typeErrors.forEach(error => {
                    console.log(`[格式验证显示] 错误对象:`, error);
                    console.log(`[格式验证显示] 错误信息: "${error.message}"`);
                    const errorItem = document.createElement('div');
                    errorItem.className = 'format-error-item';
                    
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'format-error-message';
                    // 使用textContent而不是innerHTML，避免HTML解析
                    messageDiv.textContent = error.message.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                    
                    errorItem.appendChild(messageDiv);
                    console.log(`[格式验证显示] 生成的HTML: ${errorItem.innerHTML}`);
                    errorsList.appendChild(errorItem);
                  });
                }
              });
            
            // 如果没有错误，显示占位信息
            if (errors.length === 0) {
              errorsList.innerHTML = '<div class="format-no-errors">✅ 所有标签格式正确</div>';
            }
            // 更新模态框标题以显示错误统计和步骤信息
            const modalTitle = modal.querySelector('.modal-title');
            if (modalTitle) {
              const summary = [];
              if (errorsByType.missing.length > 0) summary.push(`${errorsByType.missing.length}个缺失`);
              if (errorsByType.unclosed.length > 0) summary.push(`${errorsByType.unclosed.length}个未闭合`);
              if (errorsByType.incomplete.length > 0) summary.push(`${errorsByType.incomplete.length}个不完整`);
              if (errorsByType.mismatch.length > 0) summary.push(`${errorsByType.mismatch.length}个不匹配`);
              
              const summaryText = summary.length > 0 ? ` (${summary.join(', ')})` : '';
              const stepInfo = options.stepInfo ? ` - ${options.stepInfo}` : '';
              modalTitle.textContent = `🔍 格式审查详情${stepInfo} - 发现 ${errors.length} 个问题${summaryText}`;
            }
            
            // 初始化文本显示和编辑功能
            this.initFormatTextEditor(finalText);
            
            // 绑定按钮事件
            // 1.点击回退
            rollbackBtn.onclick = () => {
              const gameTextDisplay = document.getElementById('game-text-display');
              if (gameTextDisplay && this.lastValidGametxtHTML) {

// 【恢复到上一次有效的内容和相关后续数据逻辑处理】

                gameTextDisplay.innerHTML = this.lastValidGametxtHTML;
                this.updateLiveWordCount(); // 1.调用字数统计函数
                this.showTemporaryMessage('内容已回退。');
                this.lastExtractedThinking = this._extractLastTagContent('thinking', this.lastValidGametxtHTML, true);// 恢复思维链
                this.saveLastThinking(); // 2.持久化恢复的思维内容
                const thinkingProcessContainer = document.getElementById('thinking-process-container');
                const thinkingProcessContent = document.getElementById('thinking-process-content');
                if (this.lastExtractedThinking && this.lastExtractedThinking.trim() !== '') {
                    if (thinkingProcessContainer) {
                        thinkingProcessContainer.style.display = 'block'; // 强制显示容器
                    }
                    if (thinkingProcessContent) {
                        try {
                            if (typeof formatAsDisplayedMessage === 'function') {
                                const cleanedContent = this.lastExtractedThinking
                                    .replace(/<thinking>/g, '')
                                    .replace(/<\/thinking>/g, '');
                                thinkingProcessContent.innerHTML = formatAsDisplayedMessage(cleanedContent);
                            } else {
                                thinkingProcessContent.innerHTML = this.simpleMarkdownParse(this.lastExtractedThinking);
                            }
                        } catch (error) {
                            console.error('Error formatting thinking content on rollback:', error);
                            thinkingProcessContent.textContent = this.lastExtractedThinking;
                        }
                        thinkingProcessContent.classList.add('expanded'); // 默认展开
                        const thinkingProcessIcon = document.getElementById('thinking-process-icon');
                        if (thinkingProcessIcon) {
                            thinkingProcessIcon.classList.remove('collapsed');
                            thinkingProcessIcon.textContent = '▼';
                        }
                    }
                } else {
                    if (thinkingProcessContainer) {
                        thinkingProcessContainer.style.display = 'none'; // 如果没有内容则隐藏
                    }
                }

                // 3.恢复变量改变提醒
                this.updateVariableChangesReminder();

                // 4.恢复行动选项
                this.isActionOptionsEnabled = true; // 强制开启行动选项显示
                const actionOptionsContainer = document.getElementById('action-options-container');
                if (actionOptionsContainer) {
                    actionOptionsContainer.style.display = 'flex'; // 确保容器可见
                }
                const lastActionOptions = this._extractLastTagContent('行动选项', this.lastValidGametxtHTML) || this._extractLastTagContent('action', this.lastValidGametxtHTML);
                this.renderActionOptions(lastActionOptions);
              }
              this.closeModal('format-validation-modal'); 
              this.hideWaitingMessage();// 5.关闭等待消息
            };

            // 2.点击继续
            continueBtn.onclick = () => {
              // 获取可能被编辑过的文本
              const finalTextToProcess = this.currentValidationText || finalText;
              
              this.closeModal('format-validation-modal');
              
              // 更新缓存，以便下次出错时回退到这个版本
              const gameTextDisplay = document.getElementById('game-text-display');
              if (gameTextDisplay) {
                this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
              }
              
              // 如果是步进式模式，需要特殊处理
              if (options.isStepwise) {
                if (options.step === 1) {
                  // 第一步：更新缓存并继续第二步，保持等待消息显示
                  this.updateWaitingMessage('分步变量更新ing');
                  this.cachedFirstStepText = finalTextToProcess;
                  this.generateVariablesStep(finalTextToProcess);
                } else if (options.step === 2) {
                  // 第二步：合并文本并继续处理，关闭等待消息
                  this.hideWaitingMessage();
                  this.showTemporaryMessage('已保留内容，将继续进行数据处理。');
                  const processedSecondStepText = this._processSecondStepResponse(finalTextToProcess);
                  const fusedFinalText = this._mergeStepwiseTexts(this.cachedFirstStepText, processedSecondStepText);
                  this.continueProcessingWithAutoFix(fusedFinalText);
                }
              } else {
                // 普通模式：关闭等待消息并继续处理
                this.hideWaitingMessage();
                this.continueProcessingWithAutoFix(finalTextToProcess);
              }
            };
            
            this.openModal('format-validation-modal');
          },

          // 初始化格式审查文本编辑器（新增：模块化、可复用组件）
          initFormatTextEditor(text) {
            const textDisplay = document.getElementById('format-text-display');
            const textEditor = document.getElementById('format-text-editor');
            const editToggle = document.getElementById('format-text-edit-toggle');
            const editIcon = document.getElementById('format-text-edit-icon');
            const editHint = document.getElementById('format-edit-hint');
            
            if (!textDisplay || !textEditor || !editToggle) return;
            
            // 初始化显示文本
            textDisplay.textContent = text;
            textEditor.value = text;
            
            // 重置为显示模式
            textDisplay.style.display = 'block';
            textEditor.style.display = 'none';
            if (editHint) editHint.style.display = 'none';
            editIcon.textContent = '✏️ 编辑';
            
            let isEditMode = false;
            
            // 编辑/保存切换
            editToggle.onclick = () => {
              isEditMode = !isEditMode;
              
              if (isEditMode) {
                // 切换到编辑模式
                textDisplay.style.display = 'none';
                textEditor.style.display = 'block';
                if (editHint) editHint.style.display = 'block';
                editIcon.textContent = '💾 保存';
                textEditor.focus();
              } else {
                // 切换到显示模式，保存编辑
                const editedText = textEditor.value;
                textDisplay.textContent = editedText;
                textDisplay.style.display = 'block';
                textEditor.style.display = 'none';
                if (editHint) editHint.style.display = 'none';
                editIcon.textContent = '✏️ 编辑';
                
                // 更新当前验证文本
                this.currentValidationText = editedText;
                
                // 重新验证格式
                const validationResult = this.validateResponseFormat(editedText);
                const errorsList = document.getElementById('format-errors-list');
                const modalTitle = document.querySelector('#format-validation-modal .modal-title');
                
                if (validationResult.isValid) {
                  errorsList.innerHTML = '<div class="format-no-errors">✅ 所有标签格式正确</div>';
                  if (modalTitle) {
                    const stepInfo = this.currentValidationOptions?.stepInfo ? ` - ${this.currentValidationOptions.stepInfo}` : '';
                    modalTitle.textContent = `🔍 格式审查详情${stepInfo} - 格式正确`;
                  }
                  this.showTemporaryMessage('文本已保存，格式验证通过！', 2000);
                } else {
                  // 重新渲染错误列表
                  this.renderFormatErrors(validationResult.errors, errorsList);
                  if (modalTitle) {
                    const summary = [];
                    const errorsByType = {
                      missing: validationResult.errors.filter(e => e.type === 'missing'),
                      unclosed: validationResult.errors.filter(e => e.type === 'unclosed'),
                      incomplete: validationResult.errors.filter(e => e.type === 'incomplete'),
                      mismatch: validationResult.errors.filter(e => e.type === 'mismatch')
                    };
                    if (errorsByType.missing.length > 0) summary.push(`${errorsByType.missing.length}个缺失`);
                    if (errorsByType.unclosed.length > 0) summary.push(`${errorsByType.unclosed.length}个未闭合`);
                    if (errorsByType.incomplete.length > 0) summary.push(`${errorsByType.incomplete.length}个不完整`);
                    if (errorsByType.mismatch.length > 0) summary.push(`${errorsByType.mismatch.length}个不匹配`);
                    const summaryText = summary.length > 0 ? ` (${summary.join(', ')})` : '';
                    const stepInfo = this.currentValidationOptions?.stepInfo ? ` - ${this.currentValidationOptions.stepInfo}` : '';
                    modalTitle.textContent = `🔍 格式审查详情${stepInfo} - 发现 ${validationResult.errors.length} 个问题${summaryText}`;
                  }
                  this.showTemporaryMessage('文本已保存，但仍有格式问题', 2000);
                }
              }
            };
          },

          // 渲染格式错误列表（提取为独立方法，便于复用）
          renderFormatErrors(errors, errorsList) {
            errorsList.innerHTML = '';
            
            const errorsByType = {
              missing: errors.filter(e => e.type === 'missing'),
              unclosed: errors.filter(e => e.type === 'unclosed'),
              incomplete: errors.filter(e => e.type === 'incomplete'),
              mismatch: errors.filter(e => e.type === 'mismatch')
            };
            
            const typeInfo = {
              missing: { icon: '❌', title: '缺失必需标签', priority: 1 },
              unclosed: { icon: '⚠️', title: '标签未闭合', priority: 2 },
              incomplete: { icon: '🔧', title: '标签不完整', priority: 3 },
              mismatch: { icon: '🔄', title: '标签数量不匹配', priority: 4 }
            };
            
            Object.keys(typeInfo)
              .sort((a, b) => typeInfo[a].priority - typeInfo[b].priority)
              .forEach(type => {
                const typeErrors = errorsByType[type];
                if (typeErrors.length > 0) {
                  const typeHeader = document.createElement('div');
                  typeHeader.className = 'format-error-type-header';
                  typeHeader.innerHTML = `
                    <span class="error-type-icon">${typeInfo[type].icon}</span>
                    <span class="error-type-title">${typeInfo[type].title} (${typeErrors.length})</span>
                  `;
                  errorsList.appendChild(typeHeader);
                  
                  typeErrors.forEach(error => {
                    const errorItem = document.createElement('div');
                    errorItem.className = 'format-error-item';
                    
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'format-error-message';
                    messageDiv.textContent = error.message.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                    
                    errorItem.appendChild(messageDiv);
                    errorsList.appendChild(errorItem);
                  });
                }
              });
            
            if (errors.length === 0) {
              errorsList.innerHTML = '<div class="format-no-errors">✅ 所有标签格式正确</div>';
            }
          },

          // --- 新增：带自动修复的继续处理函数 ---
          async continueProcessingWithAutoFix(textToProcess) {
            if (!textToProcess || textToProcess.trim() === '') {
              console.error('[归墟] continueProcessingWithAutoFix 接收到空文本，停止处理');
              this.hideWaitingMessage();
              this.showTemporaryMessage('错误：接收到空内容，无法继续处理。');
              return;
            }
            
            // 检查并自动补全UpdateVariable标签
            let fixedText = this.autoFixUpdateVariable(textToProcess);
            
            // 调用原有的处理逻辑
            await this.continueProcessing(fixedText);
          },



// ===格式审查模块结束===



// ===标签自动补全模块开始===



          autoFixUpdateVariable(text) {
            // 只检查是否存在</UpdateVariable>，如果不存在，则在末尾添加一个
            if (text.includes('<UpdateVariable>') && text.indexOf('</UpdateVariable>') === -1) {
              console.log('[归墟] 未找到 </UpdateVariable> 标签，自动在末尾添加。');
              this.showTemporaryMessage('已自动补全UpdateVariable结束标签', 3000);
              return text + '</UpdateVariable>';
            }
            return text;
          },


          /**
           * 标签补全函数：在格式审查前对文本进行标签补全
           * @param {string} text - 原始文本
           * @param {boolean} isSecondStep - 是否是第二步(变量生成步骤)
           * @returns {string} - 补全后的文本
           */
          autoFixTags(text, isSecondStep = false) {
            if (!text || text.trim() === '') {
              return text;
            }

            let fixedText = text;

            // 第二步：只处理UpdateVariable标签补全
            if (isSecondStep) {
              // 如果只有<UpdateVariable>而没有</UpdateVariable>，在结尾添加
              if (fixedText.includes('<UpdateVariable>') && fixedText.indexOf('</UpdateVariable>') === -1) {
                console.log('[标签补全] 第二步：补全</UpdateVariable>标签');
                fixedText = fixedText + '</UpdateVariable>';
              }
              return fixedText;
            }

            // 第一步：处理thinking和gametxt标签

            // 1. 补全<thinking>开始标签
            const hasClosingThinking = /<\/thinking>/i.test(fixedText);
            const hasOpeningThinking = /<thinking>/i.test(fixedText);

            if (hasClosingThinking && !hasOpeningThinking) {
              console.log('[标签补全] 第一步：在开头补全<thinking>标签');
              fixedText = '<thinking>' + fixedText;
            }

            // 2. 清理最后一个闭合的<gametxt>之前的非法标签
            // 分成<gametxt>之前和之后两部分，清理之前的全部标签，除了<thinking>和</thinking>
            
            const lastClosingGametxtRegex = /<\/gametxt>/gi;
            let lastClosingGametxtIndex = -1;
            let match;
            while ((match = lastClosingGametxtRegex.exec(fixedText)) !== null) {
              lastClosingGametxtIndex = match.index;
            }

            if (lastClosingGametxtIndex !== -1) {
              const textBeforeClosing = fixedText.substring(0, lastClosingGametxtIndex);
              const openingGametxtRegex = /<gametxt>/gi;
              let lastOpeningGametxtIndex = -1;
              let openMatch;
              while ((openMatch = openingGametxtRegex.exec(textBeforeClosing)) !== null) {
                lastOpeningGametxtIndex = openMatch.index;
              }

              if (lastOpeningGametxtIndex !== -1) {
                // 分成两部分：<gametxt>之前 和 <gametxt>之后
                const beforeGametxt = fixedText.substring(0, lastOpeningGametxtIndex);
                const afterGametxt = fixedText.substring(lastOpeningGametxtIndex);

                // 清理beforeGametxt中除了<thinking>和</thinking>之外的所有标签
                // 使用正则替换，排除<thinking>和</thinking>
                const cleaned = beforeGametxt.replace(/<(?!\/?thinking>)[^>]+>/gi, '【fw哈基米又在正文思考加入标签】');
                fixedText = cleaned + afterGametxt;
              }
            }

            return fixedText;
          },

// ===标签自动补全模块结束===



// ===归墟整体关键数据流程处理和0层游玩逻辑相关模块开始===



          // 专门用于格式验证后继续处理的函数
          async continueProcessing(textToProcess) {
            console.log('[归墟] continueProcessing 被调用，文本长度:', textToProcess ? textToProcess.length : 0);
            // 在处理主要逻辑前，先准备好清理过的文本，用于后续计算
            const thinkingRegex = /<thinking>[\s\S]*?<\/thinking>/gi;
            const cleanedText = textToProcess.replace(thinkingRegex, '');

            // 1. 提取所有数据
            this.lastExtractedNovelText = this._extractLastTagContent('gametxt', textToProcess);
            this.lastExtractedJourney = this._extractLastTagContent('本世历程', textToProcess);
            this.lastExtractedPastLives = this._extractLastTagContent('往世涟漪', textToProcess);
            this.lastExtractedThinking = this._extractLastTagContent('thinking', textToProcess, true);
            this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', textToProcess, true);
            this.lastExtractedCharacterCard = this._extractLastTagContent('角色提取', textToProcess);

            this.saveLastThinking();
            this.updateThinkingButtonVisibility();
            this.updateCurrentLifeButtonVisibility(); // 新增:更新本世历程按钮显示
            this.updatePastLivesButtonVisibility(); // 新增:更新往世涟漪按钮显示
            this.updateVariableChangesReminder();
            await this.updateHistoricalText(); // 更新历史正文
            
            // AI回复后自动跳转到当前正文开头,通过模拟点击“本章”按钮实现
            setTimeout(() => {
              const scrollToBottomBtn = document.getElementById('scroll-to-bottom-btn');
              if (scrollToBottomBtn) {
                console.log('[归墟] AI回复完成,触发“本章”按钮的点击事件进行跳转。');
                scrollToBottomBtn.click();
             } else {
                console.error('[归墟] 未找到“本章”按钮(scroll-to-bottom-btn),无法执行自动跳转。');
              }
              
              // 更新章节导航按钮状态
              if (typeof this.updateChapterNavigation === 'function') {
                this.updateChapterNavigation();
              }
            }, 100); // 延迟100ms确保DOM已更新

            // 2. 更新变量
            const updateScript = textToProcess;
            if (updateScript && this.currentMvuState) {
                const inputData = { old_variables: this.currentMvuState };
                let mvuSucceeded = false;
                try {
                    const mvuPromise = eventEmit('mag_invoke_mvu', updateScript, inputData);
                    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('MVU event timeout')), 3000));
                    await Promise.race([mvuPromise, timeoutPromise]);

                    if (inputData.new_variables) {
                      this.currentMvuState = this._safeLoadMvuData(inputData.new_variables);
                      this.renderUI(this.currentMvuState.stat_data);
                        mvuSucceeded = true;
                    } else {
                        console.log('[归墟] mvu 未返回新状态，尝试前端备用方案。');
                    }
                } catch (eventError) {
                    console.error('[归墟] 调用 mag_invoke_mvu 事件时发生错误或超时，尝试前端备用方案:', eventError);
                }

                if (!mvuSucceeded) {
                    console.log('[归墟] 尝试使用 Mvu API 作为备用方案');
                    try {
                        // 使用 Mvu API 作为备用方案
                        const mvu_data = Mvu.getMvuData({ type: 'message', message_id: 'latest' });
                        const updatedMvuData = await Mvu.parseMessage(updateScript, mvu_data);
                        
                        if (updatedMvuData) {
                            await Mvu.replaceMvuData(updatedMvuData, { type: 'message', message_id: 'latest' });
                            this.currentMvuState = updatedMvuData;
                            this.renderUI(this.currentMvuState.stat_data);
                            console.log('[归墟] Mvu API 备用方案执行成功');
                        }
                    } catch (mvuApiError) {
                        console.warn('[归墟] Mvu API 备用方案也失败，使用前端解析器:', mvuApiError);
                        // 最后的备用方案：使用前端解析器
                        const modifiedState = this._applyUpdateFallback(updateScript, this.currentMvuState);
                        if (modifiedState) {
                            this.currentMvuState = modifiedState;
                            this.renderUI(this.currentMvuState.stat_data);
                        }
                    }
                }
            }

            // 3. 更新行动选项
            let actionOptionsContent = this._extractLastTagContent('行动选项', textToProcess);
            if (!actionOptionsContent) {
               actionOptionsContent = this._extractLastTagContent('action', textToProcess);
            }
            this.renderActionOptions(actionOptionsContent);

            // 4. 静默保存到第0层
            const messages = await getChatMessages('0');
            if (messages && messages.length > 0) {
                const messageZero = messages[0];
                messageZero.message = textToProcess;
                messageZero.data = this.currentMvuState;
                await TavernHelper.setChatMessages([messageZero], { refresh: 'none' });
            }

            // 5. 清理工作
            const input = document.getElementById('quick-send-input');
            if (input) input.value = '';
            this.pendingActions = [];
            this.savePendingActions();
            // this.showTemporaryMessage('伟大梦星已回应。');

            // 6. 自动存档
            if (this.isAutoSaveEnabled) {
                await this.performAutoSave();     
                        this.lastUserMessage = '';  
                        this.showTemporaryMessage('自动存档成功了！！！好欸！！！','success');
       }

            // 7.渲染主界面的正文内容
            const gameTextDisplay = document.getElementById('game-text-display');
            if (gameTextDisplay && this.lastExtractedNovelText) {
                gameTextDisplay.innerHTML = this.formatMessageContent(this.lastExtractedNovelText);
                this.updateLiveWordCount();
            }

            // 8. 最终刷新UI
            await this.updateDynamicData();
            
            // 9. 如果是随机模式，切换背景图
            if (this.backgroundMode === 'random') {
              this.applyRandomBackground();
            }
            
            this.hideWaitingMessage();
          },

          async handleStreamEnd(finalText) {
            if (typeof TavernHelper.stopGeneration === 'function') {
              TavernHelper.stopGeneration();
              console.log('[归墟] 已调用 TavernHelper.stopGeneration()');
            }

            this.isStreamingGametxt = false; // 重置流式状态

            // ====== 步进式生成模式优先处理 ======
            // 必须在所有其他逻辑之前检查和处理步进式模式
            
            // 步进式第一步完成
            if (this.generationStep === 1) {
                this.cachedFirstStepText = finalText;
                if (!this.cachedFirstStepText || this.cachedFirstStepText.trim() === '') {
                    console.error('[归墟] ❌ 步进式生成：第一步返回空文本！');
                    this.showTemporaryMessage('错误：第一步返回空内容', 3000);
                    this.generationStep = 0;
                    this.isStepwiseFirstStep = false;
                    this.hideWaitingMessage();
                    return;
                }
                const gameTextDisplay = document.getElementById('game-text-display');
                if (gameTextDisplay) {
                    this.stepwiseDisplayedMainContent = gameTextDisplay.innerHTML;
                }

                // 新增：第一步格式审查前先进行标签补全
                let processedText = finalText;
                if (this.isFormatValidationEnabled) {
                    // 在格式审查前先进行标签补全（第一步）
                    processedText = this.autoFixTags(finalText, false);
                    const validationResult = this.validateResponseFormat(processedText);
                    if (!validationResult.isValid) {
                        console.log('[归墟] 步进式第一步：格式验证失败，显示审查界面');
                        this.showFormatValidationDetails(validationResult.errors, processedText, {
                            isStepwise: true,
                            step: 1,
                            stepInfo: '步进式第一步（主内容生成）'
                        });
                        return; // 等待用户操作
                    }
                }

                // 关键：在调用第二步之前设置标志
                this.isStepwiseFirstStep = false;
                this.isStepwiseSecondStep = true;
                
                // 触发第二步：生成变量（使用处理后的文本）
                this.cachedFirstStepText = processedText;
                await this.generateVariablesStep(processedText);
                return; // 关键：直接返回，不执行后续任何逻辑
            }
            
            // 步进式第二步完成
            if (this.generationStep === 2) {
                console.log('==================== 第二步生成内容开始 ====================');
                console.log(finalText);
                console.log('==================== 第二步生成内容结束 ====================');
                
                // 新增：第二步格式审查前先进行标签补全
                let processedStep2Text = finalText;
                if (this.isFormatValidationEnabled) {
                    // 在格式审查前先进行标签补全（第二步）
                    processedStep2Text = this.autoFixTags(finalText, true);
                    // 为第二步创建特殊的验证配置（只检查UpdateVariable）
                    const step2ValidationResult = this.validateStep2Response(processedStep2Text);
                    if (!step2ValidationResult.isValid) {
                        console.log('[归墟] 步进式第二步：格式验证失败，显示审查界面');
                        this.showFormatValidationDetails(step2ValidationResult.errors, processedStep2Text, {
                            isStepwise: true,
                            step: 2,
                            stepInfo: '步进式第二步（变量生成）'
                        });
                        return; // 等待用户操作
                    }
                }
                
                const processedSecondStepText = this._processSecondStepResponse(processedStep2Text);
                console.log('[归墟] 📄 处理后的第二步内容:');
                console.log(processedSecondStepText);
                // 合并第一步和第二步的文本
                const fusedFinalText = this._mergeStepwiseTexts(this.cachedFirstStepText, processedSecondStepText);
                this.generationStep = 0;
                this.cachedFirstStepText = null;
                this.isStepwiseAppendMode = false;
                this.stepwiseDisplayedMainContent = '';
                this.isStepwiseFirstStep = false;
                this.isStepwiseSecondStep = false;
                finalText = fusedFinalText;
            }
            
            // ====== 步进式模式处理结束 ======

            // 10.处理AI生成的角色卡（衍梦尘）
            if (this.pendingCharacterCardGeneration) {
                const charName = this.pendingCharacterCardGeneration;
                const tagName = 'CharacterCard';
                const cardContent = this._extractLastTagContent(tagName, finalText);

                if (cardContent) {
                    try {
                        const bookName = '1归墟';
                        const allEntries = await TavernHelper.getLorebookEntries(bookName);
                        const targetEntry = allEntries.find(entry => entry.comment === charName);
                        if (targetEntry) {
                            await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: cardContent }]);
                            this.showTemporaryMessage(`已成功为“${charName}”生成并写入角色卡！`, 3000);
                        } else {
                            throw new Error(`未找到名为“${charName}”的世界书条目。`);
                        }
                    } catch (error) {
                        console.error('写入生成的角色卡失败:', error);
                        this.showTemporaryMessage(`错误：写入“${charName}”的角色卡失败！`, 4000);
                    }
                } else {
                    this.showTemporaryMessage(`警告：AI回复中未找到“${charName}”的角色卡标签，请手动检查并填入世界书。`, 5000);
                }
                this.pendingCharacterCardGeneration = null; // 处理完毕，重置追踪变量
            }


            // 11.格式验证逻辑（在格式审查前先进行标签补全）
            let processedFinalText = finalText;
            if (this.isFormatValidationEnabled) {
                // 在格式审查前先进行标签补全（一次性生成）
                processedFinalText = this.autoFixTags(finalText, false);
                const validationResult = this.validateResponseFormat(processedFinalText);
                if (!validationResult.isValid) {
                    // 显示详细的格式审查界面，让用户决定如何操作
                    this.showFormatValidationDetails(validationResult.errors, processedFinalText);
                } else {
                    // 格式正确，缓存有效HTML，然后继续处理
                    const gameTextDisplay = document.getElementById('game-text-display');
                    if (gameTextDisplay) {
                        this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
                    }
                    // 直接调用带有自动修复功能的处理函数（使用处理后的文本）
                    await this.continueProcessingWithAutoFix(processedFinalText);
                }
            } else {
                // 禁用审查时也进行标签补全
                processedFinalText = this.autoFixTags(finalText, false);
                const gameTextDisplay = document.getElementById('game-text-display');
                if (gameTextDisplay) {
                    this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
                }
                // 直接调用带有自动修复功能的处理函数（使用处理后的文本）
                await this.continueProcessingWithAutoFix(processedFinalText);
            }

            // 12.AI生成结束后，触发一次分段记忆更新
            if (this.isSegmentedMemoryAutoGenerateEnabled) {
                console.log('[归墟] 分段记忆更新ing...');
                await this.generateSegmentedMemory(false);
            }
            if (this.isSmallSummaryAutoOn) {
                await this.generateSmallSummary(false);
            }
            if (this.isLargeSummaryAutoOn) {
                await this.generateLargeSummary(false);
            }
          },


// ===归墟整体关键数据流程处理和0层游玩逻辑相关模块结束===




// ===全屏模块开始===



          toggleFullScreen() {
            const elem = document.querySelector('.guixu-root-container');
            if (!document.fullscreenElement) {
              elem.requestFullscreen().catch(err => {
                alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
              });
            } else {
              document.exitFullscreen();
            }
          },

          exitFullScreen() {
              if (document.fullscreenElement) {
                  document.exitFullscreen();
              }
          },



// ===全屏模块结束===




// ===面板折叠模块开始===



          toggleLeftPanel() {
            this.leftPanelCollapsed = !this.leftPanelCollapsed;
            this.updatePanelStates();
            this.savePanelStates();
          },

          toggleRightPanel() {
            this.rightPanelCollapsed = !this.rightPanelCollapsed;
            this.updatePanelStates();
            this.savePanelStates();
          },

          updatePanelStates() {
            this.applyPanelWidths(); // 新增：应用面板宽度
            const gameContainer = document.querySelector('.game-container');
            const leftPanel = document.querySelector('.character-panel');
            const rightPanel = document.querySelector('.interaction-panel');
            
            if (!gameContainer || !leftPanel || !rightPanel) return;

            // 更新game-container的CSS类
            gameContainer.classList.toggle('left-panel-collapsed', this.leftPanelCollapsed);
            gameContainer.classList.toggle('right-panel-collapsed', this.rightPanelCollapsed);
            gameContainer.classList.toggle('both-panels-collapsed', this.leftPanelCollapsed && this.rightPanelCollapsed);

            // 更新面板的折叠状态
            leftPanel.classList.toggle('collapsed', this.leftPanelCollapsed);
            rightPanel.classList.toggle('collapsed', this.rightPanelCollapsed);

            // 更新箭头方向 - 隐藏/显示模式
            const leftArrow = document.querySelector('.left-panel-toggle .toggle-arrow');
            const rightArrow = document.querySelector('.right-panel-toggle .toggle-arrow');
            
            if (leftArrow) {
              leftArrow.textContent = this.leftPanelCollapsed ? '▶' : '◀';
            }
            if (rightArrow) {
              rightArrow.textContent = this.rightPanelCollapsed ? '◀' : '▶';
            }
          },

          loadPanelStates() {
            try {
              const savedStates = localStorage.getItem('guixu_panel_states');
              if (savedStates) {
                const states = JSON.parse(savedStates);
                this.leftPanelCollapsed = states.leftPanelCollapsed || false;
                this.rightPanelCollapsed = states.rightPanelCollapsed || false;
                this.updatePanelStates();
              }
            } catch (e) {
              console.error('加载面板状态失败:', e);
            }
          },

          savePanelStates() {
            try {
              const states = {
                leftPanelCollapsed: this.leftPanelCollapsed,
                rightPanelCollapsed: this.rightPanelCollapsed
              };
              localStorage.setItem('guixu_panel_states', JSON.stringify(states));
            } catch (e) {
              console.error('保存面板状态失败:', e);
            }
          },

          toggleCharacterPanel() {
              this.isCharacterPanelVisible = !this.isCharacterPanelVisible;
              const container = document.querySelector('.guixu-root-container');
              const floatingBtn = document.getElementById('floating-character-btn');

              if (container) {
                  container.classList.toggle('character-panel-visible', this.isCharacterPanelVisible);
              }

              if (floatingBtn) {
                  floatingBtn.classList.toggle('active', this.isCharacterPanelVisible);
                  floatingBtn.textContent = this.isCharacterPanelVisible ? '收起' : '角色';
              }
          },

          toggleInteractionPanel() {
              this.isInteractionPanelVisible = !this.isInteractionPanelVisible;
              const container = document.querySelector('.guixu-root-container');
              const floatingBtn = document.getElementById('floating-interaction-btn');

              if (container) {
                  container.classList.toggle('interaction-panel-visible', this.isInteractionPanelVisible);
              }

              if (floatingBtn) {
                  floatingBtn.classList.toggle('active', this.isInteractionPanelVisible);
                  floatingBtn.textContent = this.isInteractionPanelVisible ? '收起' : '功能';
              }
          },



// ===面板折叠模块结束===



// ===重新处理变量模块开始===



          async reprocessVariables() {
            this.showWaitingMessage('正在重新处理变量...');
            try {
              const messages = await getChatMessages(getCurrentMessageId());
              if (messages && messages.length > 0) {
                const lastMessageContent = messages[0].message;
                await this.continueProcessingWithAutoFix(lastMessageContent);
                // this.showTemporaryMessage('变量已重新处理。');
              } else {
                this.showTemporaryMessage('错误：找不到当前消息以重新处理。', 5000, true);
              }
            } catch (error) {
              console.error('重新处理变量时出错:', error);
              this.showTemporaryMessage('重新处理变量时发生错误，请查看控制台。', 5000, true);
            } finally {
              this.hideWaitingMessage();
            }
          },



// ===重新处理变量模块结束===



// ===按钮可拖动功能模块开始===



          initDraggableButtons() {
              const characterBtn = document.getElementById('floating-character-btn');
              const interactionBtn = document.getElementById('floating-interaction-btn');

              if (characterBtn) {
                  this.makeDraggable(characterBtn, () => this.toggleCharacterPanel());
              }
              if (interactionBtn) {
                  this.makeDraggable(interactionBtn, () => this.toggleInteractionPanel());
              }
          },
          makeDraggable(element, clickCallback) {
              let isDragging = false;
              let startX, startY, startLeft, startTop;
              let hasMoved = false;


              element.addEventListener('mousedown', (e) => {
                  isDragging = true;
                  hasMoved = false;
                  startX = e.clientX;
                  startY = e.clientY;
                  startLeft = parseInt(window.getComputedStyle(element).left, 10);
                  startTop = parseInt(window.getComputedStyle(element).top, 10);
                  element.classList.add('dragging');
                  e.preventDefault();
              });

              document.addEventListener('mousemove', (e) => {
                  if (!isDragging) return;
                  
                  const deltaX = e.clientX - startX;
                  const deltaY = e.clientY - startY;
                  
                  if (Math.abs(deltaX) > 0 || Math.abs(deltaY) > 0) {
                      hasMoved = true;
                  }

                  const newLeft = startLeft + deltaX;
                  const newTop = startTop + deltaY;

                  const maxLeft = window.innerWidth - element.offsetWidth;
                  const maxTop = window.innerHeight - element.offsetHeight;

                  element.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                  element.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
              });

              document.addEventListener('mouseup', () => {
                  if (isDragging) {
                      isDragging = false;
                      element.classList.remove('dragging');
                      
                      if (!hasMoved) {
                          clickCallback();
                      }
                  }
              });

              element.addEventListener('touchstart', (e) => {
                  isDragging = true;
                  hasMoved = false;
                  const touch = e.touches[0];
                  startX = touch.clientX;
                  startY = touch.clientY;
                  startLeft = parseInt(window.getComputedStyle(element).left, 10);
                  startTop = parseInt(window.getComputedStyle(element).top, 10);
                  element.classList.add('dragging');
                  e.preventDefault();
              });

              element.addEventListener('touchmove', (e) => {
                  if (!isDragging) return;
                  
                  const touch = e.touches[0];
                  const deltaX = touch.clientX - startX;
                  const deltaY = touch.clientY - startY;
                  
                  if (Math.abs(deltaX) > 0 || Math.abs(deltaY) > 0) {
                      hasMoved = true;
                  }

                  const newLeft = startLeft + deltaX;
                  const newTop = startTop + deltaY;

                  const maxLeft = window.innerWidth - element.offsetWidth;
                  const maxTop = window.innerHeight - element.offsetHeight;

                  element.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                  element.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
                  e.preventDefault();
              });

              element.addEventListener('touchend', () => {
                  if (isDragging) {
                      isDragging = false;
                      element.classList.remove('dragging');
                      
                      if (!hasMoved) {
                          clickCallback();
                      }
                  }
              });
          },



// ===按钮可拖动功能模块开始===




// ===窗口大小自定义模块开始===



          // 主界面（一级窗口）大小自定义功能
          toggleWindowSizePanel() {
              const panel = document.getElementById('window-size-panel');
              if (panel) {
                  const isVisible = panel.style.display === 'block';
                  panel.style.display = isVisible ? 'none' : 'block';
                  if (!isVisible) {
                      this.loadCurrentWindowSize();
                  }
              }
          },

          hideWindowSizePanel() {
              const panel = document.getElementById('window-size-panel');
              if (panel) {
                  panel.style.display = 'none';
              }
          },
          
          loadCurrentWindowSize() {
              const container = document.querySelector('.guixu-root-container');
              const gameContainer = document.querySelector('.game-container');
              if (container && gameContainer) {
                  const currentWidth = parseInt(container.style.maxWidth) || 900;
                  const currentHeight = parseInt(gameContainer.style.height) || 600;
                  
                  const widthSlider = document.getElementById('width-slider');
                  const heightSlider = document.getElementById('height-slider');
                  const widthDisplay = document.getElementById('width-display');
                  const heightDisplay = document.getElementById('height-display');
                  
                  if (widthSlider) widthSlider.value = currentWidth;
                  if (heightSlider) heightSlider.value = currentHeight;
                  if (widthDisplay) widthDisplay.textContent = `${currentWidth}px`;
                  if (heightDisplay) heightDisplay.textContent = `${currentHeight}px`;
              }
              
              // 同时加载模态框当前大小
              this.loadCurrentModalSize();
          },

          loadCurrentModalSize() {
              // 从localStorage加载或使用默认值
              const savedState = localStorage.getItem('guixu_modal_size');
              let modalWidth = 800;
              let modalHeight = 600;
              
              if (savedState) {
                  try {
                      const { width, height } = JSON.parse(savedState);
                      modalWidth = width || 800;
                      modalHeight = height || 600;
                  } catch (e) {
                      console.error('解析模态框大小状态失败:', e);
                  }
              }
              
              const modalWidthSlider = document.getElementById('modal-width-slider');
              const modalHeightSlider = document.getElementById('modal-height-slider');
              const modalWidthDisplay = document.getElementById('modal-width-display');
              const modalHeightDisplay = document.getElementById('modal-height-display');
              
              if (modalWidthSlider) modalWidthSlider.value = modalWidth;
              if (modalHeightSlider) modalHeightSlider.value = modalHeight;
              if (modalWidthDisplay) modalWidthDisplay.textContent = `${modalWidth}px`;
              if (modalHeightDisplay) modalHeightDisplay.textContent = `${modalHeight}px`;
          },

          updateWidthDisplay(value) {
              const widthDisplay = document.getElementById('width-display');
              if (widthDisplay) {
                  widthDisplay.textContent = `${value}px`;
              }
              this.applyWindowSize(value, null);
          },

          updateHeightDisplay(value) {
              const heightDisplay = document.getElementById('height-display');
              if (heightDisplay) {
                  heightDisplay.textContent = `${value}px`;
              }
              this.applyWindowSize(null, value);
          },
          
          applyWindowSize(newWidth, newHeight) {
               const container = document.querySelector('.guixu-root-container');
               const gameContainer = document.querySelector('.game-container');

               if (container && gameContainer) {
                   if (newWidth !== null) {
                       container.style.maxWidth = `${newWidth}px`;
                   }
                   if (newHeight !== null) {
                       gameContainer.style.height = `${newHeight}px`;
                   }
               }
               // 实时保存，可能会有性能问题，但按指示忽略lodash
               this.saveWindowSizeState();
          },
          
          resetWindowSize() {
              const defaultWidth = 900;
              const defaultHeight = 600;
              
              const widthSlider = document.getElementById('width-slider');
              const heightSlider = document.getElementById('height-slider');
              
              if (widthSlider) widthSlider.value = defaultWidth;
              if (heightSlider) heightSlider.value = defaultHeight;

              this.updateWidthDisplay(defaultWidth);
              this.updateHeightDisplay(defaultHeight);

              this.showTemporaryMessage('已重置为默认大小');
          },

          saveWindowSizeState() {
              try {
                  const container = document.querySelector('.guixu-root-container');
                  const gameContainer = document.querySelector('.game-container');
                  
                  if (container && gameContainer) {
                      // 从实际的DOM样式中获取当前尺寸
                      const currentWidth = parseInt(container.style.maxWidth) || 900;
                      const currentHeight = parseInt(gameContainer.style.height) || 600;
                      
                      const sizeState = {
                          width: currentWidth,
                          height: currentHeight
                      };
                      
                      localStorage.setItem('guixu_window_size', JSON.stringify(sizeState));
                  }
              } catch (e) {
                  console.error('保存窗口大小状态失败:', e);
              }
          },
          
          loadWindowSizeState() {
              try {
                  const savedState = localStorage.getItem('guixu_window_size');
                  if (savedState) {
                      const { width, height } = JSON.parse(savedState);
                      if (width && height) {
                          // 直接应用到DOM，避免循环调用saveWindowSizeState
                          const container = document.querySelector('.guixu-root-container');
                          const gameContainer = document.querySelector('.game-container');
                          
                          if (container && gameContainer) {
                              container.style.maxWidth = `${width}px`;
                              gameContainer.style.height = `${height}px`;
                              
                              // 更新滑块显示值
                              const widthSlider = document.getElementById('width-slider');
                              const heightSlider = document.getElementById('height-slider');
                              const widthDisplay = document.getElementById('width-display');
                              const heightDisplay = document.getElementById('height-display');
                              
                              if (widthSlider) widthSlider.value = width;
                              if (heightSlider) heightSlider.value = height;
                              if (widthDisplay) widthDisplay.textContent = `${width}px`;
                              if (heightDisplay) heightDisplay.textContent = `${height}px`;
                              
                          }
                      }
                  }
              } catch (e) {
                  console.error('加载窗口大小状态失败:', e);
              }
          },

          // 模态框（二级窗口）大小自定义功能
          updateModalWidthDisplay(value) {
              const modalWidthDisplay = document.getElementById('modal-width-display');
              if (modalWidthDisplay) {
                  modalWidthDisplay.textContent = `${value}px`;
              }
              this.applyModalSize(value, null);
          },

          updateModalHeightDisplay(value) {
              const modalHeightDisplay = document.getElementById('modal-height-display');
              if (modalHeightDisplay) {
                  modalHeightDisplay.textContent = `${value}px`;
              }
              this.applyModalSize(null, value);
          },

          applyModalSize(newWidth, newHeight) {
              // 应用到所有模态框的 .modal-content
              const modalContents = document.querySelectorAll('.modal-content');
              modalContents.forEach(modalContent => {

                  // 豁免人物关系模态框、宗门模态框和归墟系统模态框，它们的尺寸由其内部CSS控制
                  if (modalContent.closest('#relationships-modal') || modalContent.closest('#sects-modal') || modalContent.closest('#guixu-system-modal')) {
                      return;
                  }
                  if (newWidth !== null) {
                      modalContent.style.maxWidth = `${newWidth}px`;
                      modalContent.style.width = `${Math.min(newWidth, window.innerWidth * 0.9)}px`;
                  }
                  if (newHeight !== null) {
                      modalContent.style.height = `${Math.min(newHeight, window.innerHeight * 0.9)}px`;
                      modalContent.style.maxHeight = `${Math.min(newHeight, window.innerHeight * 0.9)}px`;
                      // 确保内容区域也能正确显示
                      modalContent.style.overflow = 'auto';
                  }
              });
              
              // 实时保存模态框大小状态
              this.saveModalSizeState();
          },

          resetModalSize() {
              const defaultWidth = 800;
              const defaultHeight = 600;
              
              const modalWidthSlider = document.getElementById('modal-width-slider');
              const modalHeightSlider = document.getElementById('modal-height-slider');
              
              if (modalWidthSlider) modalWidthSlider.value = defaultWidth;
              if (modalHeightSlider) modalHeightSlider.value = defaultHeight;

              this.updateModalWidthDisplay(defaultWidth);
              this.updateModalHeightDisplay(defaultHeight);

              this.showTemporaryMessage('模态框大小已重置为默认');
          },

          resetPanelWidth() {
              const defaultLeftWidth = 20;
              const defaultRightWidth = 20;
              
              const leftSlider = document.getElementById('left-panel-width-slider');
              const rightSlider = document.getElementById('right-panel-width-slider');
              
              if (leftSlider) leftSlider.value = defaultLeftWidth;
              if (rightSlider) rightSlider.value = defaultRightWidth;

              // 更新显示值
              const leftValue = document.getElementById('left-panel-width-value');
              const rightValue = document.getElementById('right-panel-width-value');
              if (leftValue) leftValue.textContent = defaultLeftWidth + '%';
              if (rightValue) rightValue.textContent = defaultRightWidth + '%';

              // 应用实际样式
              const leftPanel = document.getElementById('left-panel');
              const rightPanel = document.getElementById('right-panel');
              if (leftPanel) leftPanel.style.flex = `0 0 ${defaultLeftWidth}%`;
              if (rightPanel) rightPanel.style.flex = `0 0 ${defaultRightWidth}%`;

              // 保存状态
              localStorage.setItem('guixu_left_panel_width', defaultLeftWidth);
              localStorage.setItem('guixu_right_panel_width', defaultRightWidth);

              this.showTemporaryMessage('面板宽度已重置为默认');
          },

          saveModalSizeState() {
              try {
                  const modalWidthSlider = document.getElementById('modal-width-slider');
                  const modalHeightSlider = document.getElementById('modal-height-slider');
                  
                  if (modalWidthSlider && modalHeightSlider) {
                      const currentWidth = parseInt(modalWidthSlider.value) || 800;
                      const currentHeight = parseInt(modalHeightSlider.value) || 600;
                      
                      const modalSizeState = {
                          width: currentWidth,
                          height: currentHeight
                      };
                      
                      localStorage.setItem('guixu_modal_size', JSON.stringify(modalSizeState));
                  }
              } catch (e) {
                  console.error('保存模态框大小状态失败:', e);
              }
          },

          loadModalSizeState() {
              try {
                  const savedState = localStorage.getItem('guixu_modal_size');
                  if (savedState) {
                      const { width, height } = JSON.parse(savedState);
                      if (width && height) {
                          // 更新滑块显示值
                          const modalWidthSlider = document.getElementById('modal-width-slider');
                          const modalHeightSlider = document.getElementById('modal-height-slider');
                          const modalWidthDisplay = document.getElementById('modal-width-display');
                          const modalHeightDisplay = document.getElementById('modal-height-display');
                          
                          if (modalWidthSlider) modalWidthSlider.value = width;
                          if (modalHeightSlider) modalHeightSlider.value = height;
                          if (modalWidthDisplay) modalWidthDisplay.textContent = `${width}px`;
                          if (modalHeightDisplay) modalHeightDisplay.textContent = `${height}px`;
                          
                          // 应用到现有的模态框
                          this.applyModalSize(width, height);
                          
                      }
                  }
              } catch (e) {
                  console.error('加载模态框大小状态失败:', e);
              }
          },



// ===窗口大小自定义模块结束===



// ===当前状态模块开始===



         toggleStatusPopup() {
           const popup = document.getElementById('status-effects-popup');
           if (popup) {
             const isVisible = popup.style.display === 'flex';
             popup.style.display = isVisible ? 'none' : 'flex';
           }
         },



// ===当前状态模块结束===




// ===核心mvu变量获取、读取、解析相关模块开始===

          SafeGetValue(obj, path, defaultValue = 'N/A') {
            let keys = Array.isArray(path) ? path : path.split('.');
            let current = obj;
            for (let i = 0; i < keys.length; i++) {
              if (
                current === undefined ||
                current === null ||
                typeof current !== 'object' ||
                !current.hasOwnProperty(keys[i])
              ) {
                return defaultValue;
              }
              current = current[keys[i]];
            }
            if (current === undefined || current === null) {
              return defaultValue;
            }
            // 如果是对象（但不是数组），直接返回
            if (typeof current === 'object' && !Array.isArray(current)) {
               return current;
           }
            if (Array.isArray(current)) {
              if (current.length > 0) {
                const actualValue = current[0];
                if (typeof actualValue === 'boolean') return actualValue;
                // 如果数组的第一个元素是对象，直接返回该对象
                if (typeof actualValue === 'object' && actualValue !== null) {
                   return actualValue;
                }
                return String(actualValue);
              } else {
                return defaultValue;
              }
            }
            if (typeof current === 'boolean') return current;
            return String(current);
          },

          // 安全设置值函数：对应 SafeGetValue 的设置版本
          SafeSetValue(obj, path, value) {
              if (!obj || typeof obj !== 'object') {
                  console.warn('[SafeSetValue] 目标对象无效:', obj);
                  return false;
              }

              const keys = Array.isArray(path) ? path : path.split('.');
              let current = obj;

              // 遍历到倒数第二层，确保路径上的所有对象都存在
              for (let i = 0; i < keys.length - 1; i++) {
                  const key = keys[i];
                  
                  if (!current.hasOwnProperty(key) ||
                      current[key] === null ||
                      current[key] === undefined ||
                      typeof current[key] !== 'object') {
                      // 创建新的对象
                      current[key] = {};
                  }
                  current = current[key];
              }

              // 设置最后一个键的值
              const lastKey = keys[keys.length - 1];
              current[lastKey] = value;
              
              console.log(`[SafeSetValue] 成功设置: ${path} = ${JSON.stringify(value)}`);
              return true;
          },

          // 改进的 SafeGetValue 函数
          SafeGetValue(obj, path, defaultValue = 'N/A') {
            let keys = Array.isArray(path) ? path : path.split('.');
            let current = obj;
            for (let i = 0; i < keys.length; i++) {
              if (
                current === undefined ||
                current === null ||
                typeof current !== 'object' ||
                !current.hasOwnProperty(keys[i])
              ) {
                return defaultValue;
              }
              current = current[keys[i]];
            }
            if (current === undefined || current === null) {
              return defaultValue;
            }
            // 如果是对象（但不是数组），直接返回
            if (typeof current === 'object' && !Array.isArray(current)) {
               return current;
           }
            if (Array.isArray(current)) {
              if (current.length > 0) {
                const actualValue = current[0];
                if (typeof actualValue === 'boolean') return actualValue;
                // 如果数组的第一个元素是对象，直接返回该对象
                if (typeof actualValue === 'object' && actualValue !== null) {
                   return actualValue;
                }
                return String(actualValue);
              } else {
                return defaultValue;
              }
            }
            if (typeof current === 'boolean') return current;
            return String(current);
          },

          
          async updateDynamicData() {
            try {
              // 加载核心mvu数据
              const messages = await getChatMessages(getCurrentMessageId());
              if (messages && messages.length > 0 && messages[0].data) {
                const rawData = messages[0].data;
                this.currentMvuState = this._safeLoadMvuData(rawData);
                this.renderUI(this.currentMvuState.stat_data);
              } else {
                console.warn('无法从当前消息中加载 mvu data。');
              }
              await this.loadAndDisplayCurrentScene();
            } catch (error) {
              console.error('更新归墟动态数据时出错:', error);
            }
          },

// ===统一的UI渲染函数（极为重要）===



          renderUI(data) {
            if (!data) {
              console.warn('RenderUI 调用失败：没有提供数据。');
              return;
            }
            const updateText = (id, value, style = '') => {
              const el = document.getElementById(id);
              if (el) {
                el.innerText = value;
                if (style) {
                  el.setAttribute('style', style);
                }
              }
            };
            const jingjieValue = this.SafeGetValue(data, '当前境界', '...');
            const match = jingjieValue.match(/^(\S{2})/);
            const jingjieTier = match ? match[1] : '';
            const jingjieStyle = this.getJingJieStyle(jingjieTier);
            updateText('val-jingjie', jingjieValue, jingjieStyle);
            updateText('val-jinian', this.SafeGetValue(data, '当前时间纪年'));
            const currentWorld = this.SafeGetValue(data, '当前第x世', '1');
            updateText('val-current-world', `第${currentWorld}世`);
            const charge = this.SafeGetValue(data, '归真数', '0');
            updateText('val-guixu-charge-text', `${charge}`);
            const chargeBar = document.getElementById('bar-guixu-charge');
            if (chargeBar) chargeBar.style.setProperty('--guixu-charge', `${charge}`);
            
            this.updateTalentAndLinggen(data);
            this.loadEquipmentFromMVU(data);
            this.updateDisplayedAttributes(data); // 核心渲染函数
            const summaryTextEl = document.getElementById('status-summary-text');
            const popupListEl = document.getElementById('status-effects-popup-list');
            if (summaryTextEl && popupListEl) {
              const statuses = this.SafeGetValue(data, '当前状态', {});
              const statusEntries = Object.entries(statuses).filter(([key]) => key !== '$meta');

              if (statusEntries.length > 0) {
                summaryTextEl.textContent = `当前有 ${statusEntries.length} 个状态效果`;
                
                popupListEl.innerHTML = statusEntries.map(([name, description]) => {
                  return `
                    <div class="status-effect-item">
                      <strong>${name}:</strong> ${description}
                    </div>
                  `;
                }).join('');
              } else {
                summaryTextEl.textContent = '当前无状态效果';
                popupListEl.innerHTML = '<div class="status-effect-item">暂无</div>';
              }
            }

            // 如果当前是任务Tab，刷新任务列表
            const activeTab = document.querySelector('.guixu-tab-btn.active');
            if (activeTab && activeTab.getAttribute('data-tab') === 'quest') {
                const activeStatus = document.querySelector('.quest-status-tabs .panel-tab-btn.active');
                const statusFilter = activeStatus ? activeStatus.getAttribute('data-status') : 'unfinished';
                this.renderQuestList(statusFilter);
            }
          },

// ===核心mvu变量获取、读取、解析相关模块结束===



// ===按钮统一监听绑定模块（极为重要）开始===
          bindStaticListeners() {
            if (this.listenersBound) return; // 如果已经绑定过，则直接返回

            // 为世界书高级设置中的位置选择框添加实时交互
            try {
                ['journey', 'past-lives', 'novel', 'segmented', 'large-summary', 'small-summary'].forEach(type => {
                    const positionSelect = document.getElementById(`${type}-position`);
                    const depthContainer = document.getElementById(`${type}-depth-container`);

                    if (positionSelect && depthContainer) {
                        positionSelect.addEventListener('change', (event) => {
                            depthContainer.style.display = event.target.value.startsWith('at_depth') ? 'contents' : 'none';
                            // 保存设置以持久化
                            this.saveWorldbookSettings();
                        });
                    }
                });
            } catch(e) {
                console.error("绑定世界书高级设置交互事件失败:", e);
            }

            // 为视图切换按钮绑定监听器
            document.getElementById('view-toggle-btn')?.addEventListener('click', () => this.toggleViewMode());
            document.getElementById('fullscreen-btn')?.addEventListener('click', () => this.toggleFullScreen());
            document.getElementById('exit-fullscreen-btn')?.addEventListener('click', () => this.exitFullScreen());

            // 为顶部全屏按钮绑定监听器
            document.getElementById('top-fullscreen-btn')?.addEventListener('click', () => this.toggleFullScreen());
            document.getElementById('top-exit-fullscreen-btn')?.addEventListener('click', () => this.exitFullScreen());

            // 为变量改变提醒绑定监听器
            document.getElementById('variable-changes-header')?.addEventListener('click', () => this.toggleVariableChanges());

            // 为面板折叠按钮绑定监听器
            document.getElementById('left-panel-toggle')?.addEventListener('click', () => this.toggleLeftPanel());
            document.getElementById('right-panel-toggle')?.addEventListener('click', () => this.toggleRightPanel());

            document.addEventListener('fullscreenchange', () => {
                // 右侧面板的全屏按钮
                const fullscreenBtn = document.getElementById('fullscreen-btn');
                const exitFullscreenBtn = document.getElementById('exit-fullscreen-btn');
                // 顶部状态栏的全屏按钮
                const topFullscreenBtn = document.getElementById('top-fullscreen-btn');
                const topExitFullscreenBtn = document.getElementById('top-exit-fullscreen-btn');
                
                if (document.fullscreenElement) {
                    // 进入全屏模式
                    if (fullscreenBtn) fullscreenBtn.style.display = 'none';
                    if (exitFullscreenBtn) exitFullscreenBtn.style.display = 'flex';
                    if (topFullscreenBtn) topFullscreenBtn.style.display = 'none';
                    if (topExitFullscreenBtn) topExitFullscreenBtn.style.display = 'flex';
                } else {
                    // 退出全屏模式
                    if (fullscreenBtn) fullscreenBtn.style.display = 'flex';
                    if (exitFullscreenBtn) exitFullscreenBtn.style.display = 'none';
                    if (topFullscreenBtn) topFullscreenBtn.style.display = 'flex';
                    if (topExitFullscreenBtn) topExitFullscreenBtn.style.display = 'none';
                }
            });
            // 浮动按钮事件监听器和拖动功能
            this.initDraggableButtons();
            
            // 为窗口大小调整滑动条绑定事件监听器（现在直接在设置面板中）
            document.getElementById('width-slider')?.addEventListener('input', (e) => this.updateWidthDisplay(e.target.value));
            document.getElementById('height-slider')?.addEventListener('input', (e) => this.updateHeightDisplay(e.target.value));
            document.getElementById('reset-size-btn')?.addEventListener('click', () => this.resetWindowSize());
            
            // 为二级窗口(模态框)大小调整绑定事件监听器
            document.getElementById('modal-width-slider')?.addEventListener('input', (e) => this.updateModalWidthDisplay(e.target.value));
            document.getElementById('modal-height-slider')?.addEventListener('input', (e) => this.updateModalHeightDisplay(e.target.value));
            document.getElementById('reset-modal-size-btn')?.addEventListener('click', () => this.resetModalSize());
            
            // 为面板宽度重置按钮绑定事件监听器
            document.getElementById('reset-panel-width-btn')?.addEventListener('click', () => this.resetPanelWidth());
            
            // 为状态效果弹出窗口绑定事件 ---
            document.getElementById('status-summary-button')?.addEventListener('click', () => this.toggleStatusPopup());
            document.getElementById('status-effects-popup-close')?.addEventListener('click', () => this.toggleStatusPopup());
            
            // 为世界书序号输入框绑定监听
            // 为统一的序号输入框绑定监听
            document.getElementById('unified-index-input')?.addEventListener('change', (e) => {
                const newIndex = parseInt(e.target.value, 10);
                if (!isNaN(newIndex) && newIndex > 0) {
                    this.unifiedIndex = newIndex;
                    this.saveUnifiedIndex();
                    this.showTemporaryMessage(`世界书读写序号已更新为 ${newIndex}`);
                    // 如果自动开关是开启的，立即更新启用的条目
                    if (this.isAutoToggleLorebookEnabled) {
                        this.startAutoTogglePolling();
                    }
                } else {
                    e.target.value = this.unifiedIndex; // 如果输入无效，则恢复
                }
            });

           // 小说模式序号输入框使用统一序号
           document.getElementById('novel-mode-index-input')?.addEventListener('change', (e) => {
               const newIndex = parseInt(e.target.value, 10);
               if (!isNaN(newIndex) && newIndex > 0) {
                   this.unifiedIndex = newIndex; // 使用统一序号
                   this.saveUnifiedIndex();
                   this.showTemporaryMessage(`世界书读写序号已更新为 ${newIndex}`);
                   // 立即刷新模态框内容
                   if (document.getElementById('novel-mode-modal').style.display === 'flex') {
                     this.showNovelMode();
                   }
                   // 如果自动开关是开启的，立即更新启用的条目
                   if (this.isAutoToggleLorebookEnabled) {
                       this.startAutoTogglePolling();
                   }
               } else {
                   e.target.value = this.unifiedIndex;
               }
           });

           // 辅助模型设置事件监听器
           document.getElementById('toggle-aux-model-enabled')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.isEnabled = e.target.checked;
               
               // 显示/隐藏配置区域
               const configSection = document.getElementById('aux-model-config-section');
               if (configSection) {
                   configSection.style.display = e.target.checked ? 'block' : 'none';
               }
               
               this.saveAuxModelSettings();
               this.showTemporaryMessage(`辅助模型已${e.target.checked ? '启用' : '禁用'}`);
           });

           document.getElementById('aux-model-source')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.source = e.target.value;
               this.saveAuxModelSettings();
           });

           document.getElementById('toggle-aux-model-use-preset')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.usePreset = e.target.checked;
               this.saveAuxModelSettings();
               this.showTemporaryMessage(`${e.target.checked ? '已启用' : '已禁用'}使用预设`);
           });

           document.getElementById('toggle-aux-model-streaming')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.isStreaming = e.target.checked;
               this.saveAuxModelSettings();
           });

           // 输入框实时保存
           document.getElementById('aux-model-api-url')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.apiUrl = e.target.value;
               this.saveAuxModelSettings();
           });

           document.getElementById('aux-model-api-key')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.apiKey = e.target.value;
               this.saveAuxModelSettings();
           });

           document.getElementById('aux-model-name')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.modelName = e.target.value;
               this.saveAuxModelSettings();
               console.log('[归墟] 已选择模型:', e.target.value);
           });

           // 连接按钮（获取模型列表）
           document.getElementById('btn-connect-aux-model')?.addEventListener('click', async () => {
               await this.connectAndFetchModels();
           });

           // 测试按钮
           document.getElementById('btn-test-aux-model')?.addEventListener('click', async () => {
               await this.testAuxModel();
           });

           // MVU更新方式切换事件监听器
           document.getElementById('mvu-mode-with-ai')?.addEventListener('change', (e) => {
               if (e.target.checked) {
                   this.mvuUpdateMode = '随AI输出';
                   this.generationMode = 'once'; // 同步更新生成模式
                   this.saveMvuUpdateMode();
                   this.showTemporaryMessage('已切换到：随AI输出模式');
                   // 隐藏分步变量更新配置
                   const configSection = document.getElementById('stepwise-config-section');
                   if (configSection) configSection.style.display = 'none';
               }
           });

           document.getElementById('mvu-mode-stepwise')?.addEventListener('change', (e) => {
               if (e.target.checked) {
                   this.mvuUpdateMode = '分步变量更新';
                   this.generationMode = 'stepwise'; // 同步更新生成模式
                   this.saveMvuUpdateMode();
                   this.showTemporaryMessage('已切换到：分步变量更新模式');
                   // 显示分步变量更新配置
                   const configSection = document.getElementById('stepwise-config-section');
                   if (configSection) configSection.style.display = 'block';
               }
           });

           document.getElementById('mvu-mode-with-ai')?.addEventListener('change', (e) => {
                if (e.target.checked) {
                    this.mvuUpdateMode = '随AI输出';
                    this.generationMode = 'once';
                    this.saveMvuUpdateMode();
                    this.showTemporaryMessage('已切换到：单次生成模式');
                    const configSection = document.getElementById('stepwise-config-section');
                    if (configSection) configSection.style.display = 'none';
                }
            });

            document.getElementById('mvu-mode-stepwise')?.addEventListener('change', (e) => {
                if (e.target.checked) {
                    this.mvuUpdateMode = '分步变量更新';
                    this.generationMode = 'stepwise';
                    this.saveMvuUpdateMode();
                    this.showTemporaryMessage('已切换到：分步变量更新模式');
                    const configSection = document.getElementById('stepwise-config-section');
                    if (configSection) configSection.style.display = 'block';
                }
            });

           // 分步变量更新配置事件监听器
           document.getElementById('stepwise-source-same')?.addEventListener('change', (e) => {
               if (e.target.checked) {
                   if (!this.stepwiseConfig) this.stepwiseConfig = {};
                   this.stepwiseConfig.modelSource = '与插头相同';
                   this.saveMvuUpdateMode();
                   this.showTemporaryMessage('变量生成将使用与插头相同的API');
               }
           });

           document.getElementById('stepwise-source-custom')?.addEventListener('change', (e) => {
               if (e.target.checked) {
                   if (!this.stepwiseConfig) this.stepwiseConfig = {};
                   this.stepwiseConfig.modelSource = '自定义';
                   this.saveMvuUpdateMode();
                   this.showTemporaryMessage('变量生成将使用第二API配置');
               }
           });

            // 为自动开关世界书复选框绑定监听
            document.getElementById('auto-toggle-lorebook-checkbox')?.addEventListener('change', (e) => {
                this.isAutoToggleLorebookEnabled = e.target.checked;
                this.saveAutoToggleState();
                this.showTemporaryMessage(`自动开关世界书已${this.isAutoToggleLorebookEnabled ? '开启' : '关闭'}`);
                if (this.isAutoToggleLorebookEnabled) {
                  this.startAutoTogglePolling();
                } else {
                  this.stopAutoTogglePolling();
                }
            });

            // 世界书高级设置相关事件
            document.getElementById('toggle-worldbook-advanced')?.addEventListener('click', (e) => {
                e.preventDefault();
                const advancedSection = document.getElementById('worldbook-advanced-settings');
                const arrow = document.getElementById('worldbook-advanced-arrow');
                
                if (advancedSection.style.display === 'none') {
                    advancedSection.style.display = 'block';
                    arrow.textContent = '▼';
                } else {
                    advancedSection.style.display = 'none';
                    arrow.textContent = '▶';
                }
            });

            // 位置选择改变时启用/禁用深度输入
            const positionSelects = ['journey-position', 'past-lives-position', 'novel-position'];
            positionSelects.forEach(id => {
                document.getElementById(id)?.addEventListener('change', (e) => {
                    const depthInput = document.getElementById(id.replace('-position', '-depth'));
                    if (depthInput) {
                        if (e.target.value.startsWith('at_depth')) {
                            depthInput.disabled = false;
                        } else {
                            depthInput.disabled = true;
                        }
                    }
                });
            });

            // 保存世界书设置
            document.getElementById('save-worldbook-settings')?.addEventListener('click', () => {
                this.saveWorldbookSettings();
                this.showTemporaryMessage('世界书设置已保存');
            });

            // 恢复默认设置
            document.getElementById('reset-worldbook-settings')?.addEventListener('click', () => {
                this.resetWorldbookSettings();
                this.loadWorldbookSettings(); // 重新加载UI
                this.showTemporaryMessage('已恢复默认世界书设置');
            });

            document.getElementById('btn-inventory')?.addEventListener('click', () => this.showInventory());
            document.getElementById('btn-relationships')?.addEventListener('click', () => this.showRelationships());
            document.getElementById('btn-sects')?.addEventListener('click', () => this.showSects());
            // document.getElementById('btn-world-events')?.addEventListener('click', () => this.showWorldEvents());
            // document.getElementById('btn-variable-editor')?.addEventListener('click', () => this.showVariableEditor());
            document.getElementById('btn-guixu-system')?.addEventListener('click', () => this.showGuixuSystem());
            document.getElementById('btn-guixu-space')?.addEventListener('click', () => this.showGuixuSpace());
            // 思维过程容器的点击事件
            document.getElementById('thinking-process-header')?.addEventListener('click', () => this.toggleThinkingDisplay());

            // 本世历程容器的点击事件
            document.getElementById('current-life-header')?.addEventListener('click', () => this.toggleCurrentLifeDisplay());

            // 往世涟漪容器的点击事件
            document.getElementById('past-lives-header')?.addEventListener('click', () => this.togglePastLivesDisplay());
            
            // 历史正文设置实时监听
            document.getElementById('historical-text-count')?.addEventListener('change', (e) => {
              const count = parseInt(e.target.value);
              if (!isNaN(count) && count >= -1) {
                this.historicalTextCount = count;
                this.saveHistoricalTextSettings();
                this.updateHistoricalText();
              }
            });

            // 滚动导航按钮事件
            const mainContent = document.getElementById('main-content');
            const toTopBtn = document.getElementById('scroll-to-top-btn');
            const toBottomBtn = document.getElementById('scroll-to-bottom-btn');
            const toRealBottomBtn = document.getElementById('scroll-to-real-bottom-btn');
            const prevChapterBtn = document.getElementById('prev-chapter-btn');
            const nextChapterBtn = document.getElementById('next-chapter-btn');
            const historicalTextContainer = document.getElementById('historical-text-container');
            const gameTextDisplay = document.getElementById('game-text-display');

            if (mainContent && toTopBtn && toBottomBtn && toRealBottomBtn && historicalTextContainer && gameTextDisplay) {
              let lastTopClickTime = 0;
              let lastScrollTop = 0;
              
              toTopBtn.addEventListener('click', () => {
                const now = Date.now();
                const currentScrollTop = mainContent.scrollTop;
                if (now - lastTopClickTime < 1000 && Math.abs(currentScrollTop - lastScrollTop) < 50) {
                  mainContent.scrollTo({ top: 0, behavior: 'smooth' });
                } else {
                  const rect = historicalTextContainer.getBoundingClientRect();
                  const containerRect = mainContent.getBoundingClientRect();
                  const targetPosition = mainContent.scrollTop + rect.top - containerRect.top;
                  mainContent.scrollTo({ top: targetPosition, behavior: 'smooth' });
                }
                
                lastTopClickTime = now;
                lastScrollTop = currentScrollTop;
              });

              toBottomBtn.addEventListener('click', () => {
                const titleContainer = document.getElementById('current-chapter-title');
                const thinkingContainer = document.getElementById('thinking-process-container');
                
                let targetElement = gameTextDisplay; // 默认目标
                if (titleContainer && titleContainer.style.display !== 'none') {
                  targetElement = titleContainer; // 优先滚动到标题
                } else if (thinkingContainer && thinkingContainer.style.display !== 'none') {
                  targetElement = thinkingContainer; // 其次滚动到思维链
                }
                
                const rect = targetElement.getBoundingClientRect();
                const containerRect = mainContent.getBoundingClientRect();
                const targetPosition = mainContent.scrollTop + rect.top - containerRect.top;
                mainContent.scrollTo({ top: targetPosition, behavior: 'smooth' });
              });

              toRealBottomBtn.addEventListener('click', () => {
                mainContent.scrollTo({ top: mainContent.scrollHeight, behavior: 'smooth' });
              });

              // 章节导航功能
              let currentChapterIndex = -1;
              let chapterElements = [];

              const updateChapterNavigation = () => {
                // 获取历史正文中的所有章节标题
                chapterElements = Array.from(historicalTextContainer.querySelectorAll('.novel-chapter-title'));
                
                if (chapterElements.length > 0) {
                  prevChapterBtn.style.display = 'block';
                  nextChapterBtn.style.display = 'block';
                } else {
                  prevChapterBtn.style.display = 'none';
                  nextChapterBtn.style.display = 'none';
                }
              };

              prevChapterBtn.addEventListener('click', () => {
                if (chapterElements.length === 0) return;
                
                const scrollTop = mainContent.scrollTop;
                const containerRect = mainContent.getBoundingClientRect();
                let targetIndex = -1;
                
                for (let i = chapterElements.length - 1; i >= 0; i--) {
                  const rect = chapterElements[i].getBoundingClientRect();
                  const relativeTop = mainContent.scrollTop + rect.top - containerRect.top;
                  if (relativeTop < scrollTop - 50) {
                    targetIndex = i;
                    break;
                  }
                }
                
                if (targetIndex > 0) {
                  const rect = chapterElements[targetIndex - 1].getBoundingClientRect();
                  const targetPosition = mainContent.scrollTop + rect.top - containerRect.top;
                  mainContent.scrollTo({ top: targetPosition, behavior: 'smooth' });
                } else if (targetIndex === 0 || targetIndex === -1) {
                  mainContent.scrollTo({ top: 0, behavior: 'smooth' });
                }
              });

              nextChapterBtn.addEventListener('click', () => {
                if (chapterElements.length === 0) return;
                
                const scrollTop = mainContent.scrollTop;
                const containerRect = mainContent.getBoundingClientRect();
                let targetIndex = -1;
                
                for (let i = 0; i < chapterElements.length; i++) {
                  const rect = chapterElements[i].getBoundingClientRect();
                  const relativeTop = mainContent.scrollTop + rect.top - containerRect.top;
                  if (relativeTop > scrollTop + 50) {
                    targetIndex = i;
                    break;
                  }
                }
                
                if (targetIndex !== -1) {
                  const rect = chapterElements[targetIndex].getBoundingClientRect();
                  const targetPosition = mainContent.scrollTop + rect.top - containerRect.top;
                  mainContent.scrollTo({ top: targetPosition, behavior: 'smooth' });
                } else {
                  const titleContainer = document.getElementById('current-chapter-title');
                  const thinkingContainer = document.getElementById('thinking-process-container');
                  
                  let targetElement = gameTextDisplay; // 默认目标
                  if (titleContainer && titleContainer.style.display !== 'none') {
                    targetElement = titleContainer; // 优先滚动到标题
                  } else if (thinkingContainer && thinkingContainer.style.display !== 'none') {
                    targetElement = thinkingContainer; // 其次滚动到思维链
                  }
                  
                  const rect = targetElement.getBoundingClientRect();
                  const targetPosition = mainContent.scrollTop + rect.top - containerRect.top;
                  mainContent.scrollTo({ top: targetPosition, behavior: 'smooth' });
                }
              });
              toTopBtn.style.display = 'block';
              toBottomBtn.style.display = 'block';

              // 暴露更新章节导航的方法供外部调用
              this.updateChapterNavigation = updateChapterNavigation;
            } 
            document.getElementById('btn-settings')?.addEventListener('click', () => this.showSettings());
            document.getElementById('btn-reprocess-variables')?.addEventListener('click', () => this.reprocessVariables());
      
            document.getElementById('btn-gacha-system')?.addEventListener('click', () => this.showGachaSystem());
  
            // 设置模态框内的按钮事件
            document.getElementById('btn-command-center-from-settings')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // 设置标志位
              this.showCommandCenter();
            });
            document.getElementById('btn-show-extracted-from-settings')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // 设置标志位
              this.showExtractedContent();
            });
            document.getElementById('btn-map-from-settings')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // 设置标志位
              this.showMap();
            });

            // 从设置中打开世界大事
            document.getElementById('world-events-btn-from-settings')?.addEventListener('click', () => {
                this.isFromSettingsModal = true;
                this.showWorldEvents();
            });
            // 从设置中打开变量编辑器
            document.getElementById('variable-editor-btn-from-settings')?.addEventListener('click', () => {
                this.isFromSettingsModal = true;
                this.showVariableEditor();
            });
            // 从设置中打开小说模式
            document.getElementById('novel-mode-btn-from-settings')?.addEventListener('click', () => {
                this.isFromSettingsModal = true;
                this.showNovelMode();
            });

            document.getElementById('background-settings-btn')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // 设置标志位
              this.showBackgroundSettings();
            });
            
            // 功能入口的世界书管理按钮事件监听器
            document.getElementById('btn-worldbook-manager-from-settings')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // 设置标志位
              this.showWorldbookManager();
            });

            // 分段记忆按钮事件
            document.getElementById('btn-segmented-memory-from-settings')?.addEventListener('click', () => {
                this.isFromSettingsModal = true; // 设置标志位
                this.showSegmentedMemoryModal();
            });

            // 预设管理按钮事件监听器
            document.getElementById('btn-presets-manager')?.addEventListener('click', () => {
              this.showWorldbookPresets();
            });

            // 为分段记忆预览的条目添加点击折叠/展开事件
            document.getElementById('segmented-memory-modal')?.addEventListener('click', (e) => {
                const header = e.target.closest('.summary-header');
                if (header) {
                    const details = header.nextElementSibling;
                    const arrow = header.querySelector('.summary-arrow');
                    if (details && details.classList.contains('summary-details')) {
                        if (details.style.display === 'none') {
                            details.style.display = 'block';
                            if(arrow) arrow.textContent = '▼';
                        } else {
                            details.style.display = 'none';
                            if(arrow) arrow.textContent = '▶';
                        }
                    }
                }
            });

            // 世界书管理界面的预设按钮事件监听器
            document.getElementById('worldbook-presets-btn')?.addEventListener('click', () => {
              this.isFromWorldbookManager = true; 
              this.showWorldbookPresets();
            });

            // 文字设置相关事件监听器
            // 文字颜色设置事件监听器
            document.getElementById('text-color-normal')?.addEventListener('change', (e) => {
              this.textSettings.colors.normal = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('text-color-dialogue')?.addEventListener('change', (e) => {
              this.textSettings.colors.dialogue = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('text-color-psychology')?.addEventListener('change', (e) => {
              this.textSettings.colors.psychology = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('text-color-scenery')?.addEventListener('change', (e) => {
              this.textSettings.colors.scenery = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('text-color-character')?.addEventListener('change', (e) => {
              this.textSettings.colors.character = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });

            // 单独字体大小设置事件监听器
            document.getElementById('font-size-normal')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.normal = parseInt(e.target.value);
              document.getElementById('font-size-normal-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('font-size-dialogue')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.dialogue = parseInt(e.target.value);
              document.getElementById('font-size-dialogue-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('font-size-psychology')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.psychology = parseInt(e.target.value);
              document.getElementById('font-size-psychology-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('font-size-scenery')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.scenery = parseInt(e.target.value);
              document.getElementById('font-size-scenery-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('font-size-character')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.character = parseInt(e.target.value);
              document.getElementById('font-size-character-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });

            // 全局字体大小设置事件监听器已移除
            document.getElementById('font-family-select')?.addEventListener('change', (e) => {
              if (e.target.value === 'upload_new') {
                // 触发文件选择
                document.getElementById('font-file-input').click();
                // 重置选择框到之前的值
                setTimeout(() => {
                  e.target.value = this.textSettings.fontFamily;
                }, 100);
              } else {
                // 应用选择的字体
                this.textSettings.fontFamily = e.target.value;
                // 确保自定义字体样式已加载
                this.ensureCustomFontLoaded(e.target.value).then(() => {
                  this.applyTextSettings();
                  this.saveTextSettings();
                });
                
                // 检查是否为自定义字体
                const isCustomFont = this.textSettings.customFonts.some(font => font.family === e.target.value);
                const fontName = isCustomFont ?
                  this.textSettings.customFonts.find(font => font.family === e.target.value).name :
                  e.target.options[e.target.selectedIndex].text;
                
                this.showTemporaryMessage(`已应用字体: ${fontName}`);
              }
            });
            document.getElementById('font-file-input')?.addEventListener('change', (e) => {
              this.handleFontUpload(e);
            });
            document.getElementById('reset-text-settings-btn')?.addEventListener('click', () => {
              this.resetTextSettings();
            });
            document.getElementById('preview-text-settings-btn')?.addEventListener('click', () => {
              this.previewTextSettings();
            });
            document.getElementById('font-compress-help-btn')?.addEventListener('click', () => {
              this.showFontCompressHelp();
            });
            // 主界面的世界线回顾按钮
            document.getElementById('btn-view-journey-main')?.addEventListener('click', () => this.showJourney());
            document.getElementById('btn-view-past-lives-main')?.addEventListener('click', () => this.showPastLives());
            document.getElementById('btn-save-load-manager')?.addEventListener('click', () => this.showNewSaveLoadManager());
            // document.getElementById('btn-novel-mode')?.addEventListener('click', () => this.showNovelMode());
            document.getElementById('btn-novel-mode-from-settings')?.addEventListener('click', () => this.showNovelMode());
            document.getElementById('btn-clear-all-saves')?.addEventListener('click', () => this.clearAllSaves());

            // 小说模式相关事件绑定
            // 背景设置按钮
            document.getElementById('novel-background-btn')?.addEventListener('click', () => this.showNovelBackgroundSettings());
            // 章节选择下拉框
            document.getElementById('chapter-select')?.addEventListener('change', (e) => {
              const chapterIndex = parseInt(e.target.value, 10);
              if (!isNaN(chapterIndex) && chapterIndex >= 0) {
                this.showNovelChapter(chapterIndex);
              }
            });
            // 上一章/下一章按钮
            document.getElementById('prev-chapter-btn')?.addEventListener('click', () => this.prevChapter());
            document.getElementById('next-chapter-btn')?.addEventListener('click', () => this.nextChapter());
            // 书签功能按钮
            document.getElementById('add-bookmark-btn')?.addEventListener('click', () => this.addNovelBookmark());
            document.getElementById('goto-bookmark-btn')?.addEventListener('click', () => this.gotoBookmark());
            document.getElementById('delete-bookmark-btn')?.addEventListener('click', () => this.deleteBookmark());

            // 显示模式切换事件监听器
            document.addEventListener('change', (e) => {
              if (e.target.name === 'novel-display-mode') {
                this.switchNovelDisplayMode(e.target.value);
              }
            });
            // 导入存档事件已在事件委托中处理，避免重复绑定
            document.getElementById('import-file-input')?.addEventListener('change', (e) => this.handleFileImport(e));

              // 为写入世界书按钮绑定监听器
             document
              .getElementById('btn-write-journey')
              ?.addEventListener('click', () => this.writeJourneyToLorebook());
            document
              .getElementById('btn-write-past-lives')
              ?.addEventListener('click', () => this.writePastLivesToLorebook());
            document
              .getElementById('btn-write-novel-mode')
              ?.addEventListener('click', () => this.writeNovelModeToLorebook());

            document
              .getElementById('btn-write-character-card')
              ?.addEventListener('click', () => this.writeCharacterCardToLorebook());
            // 为自动写入复选框绑定监听器，并增加状态保存
            const autoWriteCheckbox = document.getElementById('auto-write-checkbox');
            if (autoWriteCheckbox) {
              autoWriteCheckbox.addEventListener('change', e => {
                this.isAutoWriteEnabled = e.target.checked;
                this.saveAutoWriteState(this.isAutoWriteEnabled);
                this.showTemporaryMessage(`自动写入历程/涟漪已${this.isAutoWriteEnabled ? '开启' : '关闭'}`);
                if (this.isAutoWriteEnabled) {
                  this.startAutoWritePolling();
                } else {
                  this.stopAutoWritePolling();
                }
              });
            }


            // 指令中心按钮
            document
              .getElementById('btn-execute-commands')
              ?.addEventListener('click', () => this.executePendingActions());
            document.getElementById('btn-clear-commands')?.addEventListener('click', () => this.clearPendingActions());
            document.getElementById('btn-refresh-storage')?.addEventListener('click', () => this.refreshLocalStorage());
            document.getElementById('action-options-enabled-checkbox')?.addEventListener('change', (e) => {
                this.isActionOptionsEnabled = e.target.checked;
                this.saveActionOptionsState();
                this.showTemporaryMessage(`行动选项显示已${this.isActionOptionsEnabled ? '开启' : '关闭'}`);
                // 重新渲染行动选项以立即反映变化
                this.renderActionOptions(this._extractLastTagContent('行动选项', this.lastExtractedVariables || ''));
            });

            document.getElementById('auto-send-action-checkbox')?.addEventListener('change', (e) => {
               this.isActionAutoSend = e.target.checked;
               this.saveActionAutoSendState();
               this.showTemporaryMessage(`行动选项点击即发送已${this.isActionAutoSend ? '开启' : '关闭'}`);
            });

            document.getElementById('streaming-enabled-checkbox')?.addEventListener('change', (e) => {
                this.isStreamingEnabled = e.target.checked;
                this.saveStreamingState();
                this.showTemporaryMessage(`流式响应已${this.isStreamingEnabled ? '开启' : '关闭'}`);
            });

            document.getElementById('format-validation-enabled-checkbox')?.addEventListener('change', (e) => {
                this.isFormatValidationEnabled = e.target.checked;
                this.saveFormatValidationState();
                this.showTemporaryMessage(`格式审查已${this.isFormatValidationEnabled ? '开启' : '关闭'}`);
            });

            // 新增：为回车发送复选框绑定事件
            document.getElementById('enter-send-checkbox')?.addEventListener('change', (e) => {
                this.isEnterSendEnabled = e.target.checked;
                this.saveEnterSendState();
                this.showTemporaryMessage(`回车发送已${this.isEnterSendEnabled ? '开启' : '关闭'}`);
            });

            // 新增：为键盘快捷键复选框绑定事件
            document.getElementById('keyboard-shortcuts-checkbox')?.addEventListener('change', (e) => {
                this.isKeyboardShortcutsEnabled = e.target.checked;
                this.saveKeyboardShortcutsState();
                this.showTemporaryMessage(`键盘快捷键已${this.isKeyboardShortcutsEnabled ? '开启' : '关闭'}`);
            });

            // 新增：为手机输入框适配复选框绑定事件
            document.getElementById('mobile-input-adapt-checkbox')?.addEventListener('change', (e) => {
                this.isMobileInputAdaptEnabled = e.target.checked;
                this.saveMobileInputAdaptState();
                this.showTemporaryMessage(`手机输入框适配已${this.isMobileInputAdaptEnabled ? '开启' : '关闭'}`);
                
                // 如果关闭了适配，需要重置输入框位置
                if (!this.isMobileInputAdaptEnabled && this.floatingInputContainer) {
                    this.resetInputPosition();
                }
                
                // 重新初始化键盘处理逻辑
                this.reinitializeInputKeyboardHandling();
            });

            // 新增：为键盘快捷键三角按钮绑定点击事件
            document.getElementById('keyboard-shortcuts-toggle')?.addEventListener('click', () => {
                this.toggleKeyboardShortcutsDetails();
            });

            // 新增：为快速发送输入框绑定回车键事件
            document.getElementById('quick-send-input')?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey && this.isEnterSendEnabled) {
                    e.preventDefault(); // 阻止默认的换行行为
                    this.executeQuickSend();
                }
            });

             document
                .querySelectorAll('.modal-close-btn')
                .forEach(btn => btn.addEventListener('click', (e) => this.handleModalClose(e)));
  
              // 新增：为人物关系面板的自定义关闭按钮添加委托事件
              // 使用事件委托确保动态添加的按钮也能被监听到
              document.body.addEventListener('click', (e) => {
                if (e.target.matches('.relationships-close-btn') && e.target.closest('#relationships-modal')) {
                    window.GuixuManager.closeModal('relationships-modal');
                }
                
                if (e.target.matches('.sects-close-btn') && e.target.closest('#sects-modal')) {
                    window.GuixuManager.closeModal('sects-modal');
                }
                
                // 新增：处理正文中人物名称链接的点击事件
                if (e.target.matches('.character-link')) {
                    e.preventDefault();
                    const characterName = e.target.getAttribute('data-character');
                    if (characterName) {
                        // 打开人物关系界面
                        window.GuixuManager.showRelationships();
                        // 等待界面渲染完成后，跳转到对应人物
                        setTimeout(() => {
                            window.GuixuManager.renderCharacterDetails(characterName);
                        }, 100);
                    }
                }
              });

              // 新增：为输入缓存模态框的内容列表添加事件委托
              document.getElementById('input-cache-modal')?.addEventListener('click', e => {
                  if (e.target && e.target.closest('.input-cache-item')) {
                      const item = e.target.closest('.input-cache-item');
                      const content = item.dataset.content;
                      if (content) {
                          this.applyInputFromHistory(content);
                      }
                  }
              });
            document.querySelectorAll('.modal-overlay').forEach(overlay => {
              overlay.addEventListener('click', e => {
                if (e.target === overlay) this.handleModalClose(e);
              });
            });

            // 事件委托：背包内的点击事件
            const inventoryContentArea = document.querySelector('#inventory-modal .inventory-content-area');
            if (inventoryContentArea) {
              inventoryContentArea.addEventListener('click', e => {
                if (e.target.classList.contains('item-equip-btn')) {
                  const itemElement = e.target.closest('.inventory-item');
                  const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, "'") || '{}');
                  const category = itemElement.dataset.category;
                  // 处理功法装备按钮
                  if (e.target.dataset.equipType === 'zhuxiu') {
                    this.equipItem(itemData, category, e.target, 'zhuxiuGongfa');
                  } else if (e.target.dataset.equipType === 'fuxiu') {
                    this.equipItem(itemData, category, e.target, 'fuxiuXinfa');
                  } else {
                    this.equipItem(itemData, category, e.target);
                  }
                } else if (e.target.classList.contains('item-use-btn')) {
                  const itemElement = e.target.closest('.inventory-item');
                  const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, "'") || '{}');
                  this.useItem(itemData, e.target);
                } else if (e.target.classList.contains('item-unequip-btn')) {
                  const slotId = e.target.dataset.slotId;
                  const slotElement = document.getElementById(slotId);
                  if (slotElement) {
                    this.unequipItem(slotId, slotElement, true, true); // 从背包卸载，需要刷新背包UI
                  }
                } else if (e.target.classList.contains('item-discard-btn')) {
                  const itemElement = e.target.closest('.inventory-item');
                  const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, "'") || '{}');
                  const category = itemElement.dataset.category;
                  this.discardItem(itemData, category, itemElement);
                }
              });
            }

            // 事件委托：左侧装备面板的事件
            const characterPanel = document.querySelector('.character-panel');
            if (characterPanel) {
              // 悬浮显示Tooltip
              characterPanel.addEventListener('mouseover', e => {
                const slot = e.target.closest('.equipment-slot');
                if (slot && slot.classList.contains('equipped')) {
                  this.showEquipmentTooltip(slot, e);
                }
              });
              characterPanel.addEventListener('mouseout', e => {
                const slot = e.target.closest('.equipment-slot');
                if (slot) {
                  this.hideEquipmentTooltip();
                }
              });
              // 长按卸载，单击显示详情
              let longPressTimer = null;
              const longPressDuration = 1000; // 改为1秒

              const handlePressStart = (e, slot) => {
                if (!slot || !slot.classList.contains('equipped')) return;

                // 移除旧的指示器
                const oldIndicator = document.getElementById('long-press-indicator-instance');
                if (oldIndicator) oldIndicator.remove();
                const oldStyle = document.getElementById('long-press-style-instance');
                if (oldStyle) oldStyle.remove();

                const rect = slot.getBoundingClientRect();

                // 1. 创建动画样式
                const styleId = 'long-press-style-instance';
                const keyframes = `
                    @keyframes border-top-anim { to { width: 100%; } }
                    @keyframes border-right-anim { to { height: 100%; } }
                    @keyframes border-bottom-anim { to { width: 100%; } }
                    @keyframes border-left-anim { to { height: 100%; } }
                `;
                const styleSheet = document.createElement('style');
                styleSheet.id = styleId;
                styleSheet.textContent = keyframes;
                document.head.appendChild(styleSheet);

                // 2. 创建指示器容器
                const indicator = document.createElement('div');
                indicator.id = 'long-press-indicator-instance';
                Object.assign(indicator.style, {
                    position: 'fixed',
                    top: `${rect.top}px`,
                    left: `${rect.left}px`,
                    width: `${rect.width}px`,
                    height: `${rect.height}px`,
                    pointerEvents: 'none',
                    zIndex: '9999',
                    borderRadius: '5px',
                    overflow: 'hidden'
                });

                // 3. 创建四个边框段
                const borderTop = document.createElement('div');
                Object.assign(borderTop.style, { position: 'absolute', top: '0', left: '0', width: '0', height: '2px', backgroundColor: '#c9aa71', animation: `border-top-anim ${longPressDuration / 4000}s linear forwards` });
                
                const borderRight = document.createElement('div');
                Object.assign(borderRight.style, { position: 'absolute', top: '0', right: '0', width: '2px', height: '0', backgroundColor: '#c9aa71', animation: `border-right-anim ${longPressDuration / 4000}s linear forwards ${longPressDuration / 4000}s` });
                
                const borderBottom = document.createElement('div');
                Object.assign(borderBottom.style, { position: 'absolute', bottom: '0', right: '0', width: '0', height: '2px', backgroundColor: '#c9aa71', animation: `border-bottom-anim ${longPressDuration / 4000}s linear forwards ${longPressDuration / 2000}s` });

                const borderLeft = document.createElement('div');
                Object.assign(borderLeft.style, { position: 'absolute', bottom: '0', left: '0', width: '2px', height: '0', backgroundColor: '#c9aa71', animation: `border-left-anim ${longPressDuration / 4000}s linear forwards ${longPressDuration * 3 / 4000}s` });

                indicator.append(borderTop, borderRight, borderBottom, borderLeft);
                document.body.appendChild(indicator);
                
                longPressTimer = setTimeout(() => {
                  this.unequipItem(slot.id, slot, true, false);
                  longPressTimer = null;
                  const existingIndicator = document.getElementById('long-press-indicator-instance');
                  if (existingIndicator) existingIndicator.remove();
                  const existingStyle = document.getElementById(styleId);
                  if (existingStyle) existingStyle.remove();
                }, longPressDuration);
              };

              const removeIndicator = () => {
                  const existingIndicator = document.getElementById('long-press-indicator-instance');
                  if (existingIndicator) existingIndicator.remove();
                  const existingStyle = document.getElementById('long-press-style-instance');
                  if (existingStyle) existingStyle.remove();
              }

              const handlePressEnd = (e, slot) => {
                removeIndicator();
                if (longPressTimer) {
                  clearTimeout(longPressTimer);
                  longPressTimer = null;
                  if (slot && slot.classList.contains('equipped')) {
                    this.showEquipmentTooltip(slot, e); // 单击触发显示Tooltip
                  }
                }
              };
              
              const handlePressCancel = (e) => {
                  removeIndicator();
                  if (longPressTimer) {
                      clearTimeout(longPressTimer);
                      longPressTimer = null;
                  }
              };

              characterPanel.addEventListener('mousedown', e => {
                  const slot = e.target.closest('.equipment-slot');
                  handlePressStart(e, slot);
              });
              characterPanel.addEventListener('mouseup', e => {
                  const slot = e.target.closest('.equipment-slot');
                  handlePressEnd(e, slot);
              });
              characterPanel.addEventListener('mouseleave', handlePressCancel);
              
              characterPanel.addEventListener('touchstart', e => {
                  const slot = e.target.closest('.equipment-slot');
                  handlePressStart(e, slot);
              }, { passive: true });
              characterPanel.addEventListener('touchend', e => {
                  const slot = e.target.closest('.equipment-slot');
                  handlePressEnd(e, slot);
              });
              characterPanel.addEventListener('touchmove', handlePressCancel, { passive: true });
            }

            // 为快速发送按钮绑定事件
            document.getElementById('btn-quick-send')?.addEventListener('click', () => this.executeQuickSend());

            // --- 新增：为输入缓存绑定事件 ---
            document.getElementById('btn-show-cache')?.addEventListener('click', () => this.showInputCacheModal());

            // 新增：为行动选项容器绑定事件委托
            document.getElementById('action-options-container')?.addEventListener('click', (e) => {
                if (e.target && e.target.classList.contains('action-option-btn')) {
                    const actionText = e.target.dataset.actionText;
                    if (actionText) {
                        if (this.isActionAutoSend) {
                            // 开启时，直接点击发送
                            this.handleAction(actionText);
                        } else {
                            // 关闭时，加入输入框
                            const input = document.getElementById('quick-send-input');
                            if (input) {
                                input.value = actionText;
                            }
            if (document.getElementById('gacha-modal').style.display === 'flex') {
                this.renderSummonTab();
            }

                        }
                    }
                }
            });


            // 绑定新存档界面的事件
            const newSaveLoadContainer = document.getElementById('new-save-load-container');
            if (newSaveLoadContainer) {
              newSaveLoadContainer.addEventListener('click', (e) => {
                const header = e.target.closest('.accordion-header');
                if (header && !e.target.closest('.save-header-actions')) {
                  const item = header.parentElement;
                  const content = item.querySelector('.content-grid');
                  
                  // 手风琴效果：关闭其他所有已打开的
                  const allItems = newSaveLoadContainer.querySelectorAll('.accordion-item');
                  allItems.forEach(otherItem => {
                    if (otherItem !== item && otherItem.classList.contains('active')) {
                      otherItem.classList.remove('active');
                      otherItem.querySelector('.content-grid').style.display = 'none';
                    }
                  });

                  // 切换当前点击的
                  item.classList.toggle('active');
                  if (content) {
                    content.style.display = item.classList.contains('active') ? 'grid' : 'none';
                  }
                }
              });
            }
            
            // 自动存档复选框
            const autoSaveCheckbox = document.getElementById('auto-save-checkbox');
            if (autoSaveCheckbox) {
              autoSaveCheckbox.addEventListener('change', (e) => {
                  this.isAutoSaveEnabled = e.target.checked;
                  this.saveAutoSaveState();
                  this.showTemporaryMessage(`自动存档已${this.isAutoSaveEnabled ? '开启' : '关闭'}`);
              });
            }

            document.getElementById('btn-cancel-trim')?.addEventListener('click', () => {
                this.closeModal('trim-journey-modal');
            });


            // 绑定键盘快捷键
            this.bindKeyboardShortcuts();

            this.listenersBound = true; // 设置标志位，确保此代码块只运行一次


            // 为新的存档/读档模态框添加事件委托
            const saveLoadModal = document.getElementById('save-load-modal');
            if (saveLoadModal) {
                saveLoadModal.addEventListener('click', (e) => {
                    const target = e.target;
                    
                    // 手动存档按钮
                    if (target.id === 'btn-manual-save') {
                        this.saveGame(false);
                        return;
                    }

                    // 导入存档按钮
                    if (target.id === 'btn-import-save') {
                        document.getElementById('import-file-input').click();
                        return;
                    }

                    // 管理系列按钮
                    if (target.id === 'btn-manage-series') {
                        this.showSeriesManager();
                        return;
                    }

                    // 清除所有存档按钮
                    if (target.id === 'btn-clear-all-saves') {
                        this.showCustomConfirm('确定要删除所有存档吗？此操作不可恢复！', () => {
                            this.deleteAllSaves().then(() => this.showNewSaveLoadManager());
                        });
                        return;
                    }

                    const accordionItem = target.closest('.accordion-item');
                    if (!accordionItem) return;

                    const saveId = accordionItem.dataset.saveId;
                    if (!saveId) return;

                    if (target.classList.contains('btn-load-new')) {
                        this.loadGame(saveId);
                    } else if (target.classList.contains('btn-delete-new')) {
                        this.showCustomConfirm(`确定要删除存档“${accordionItem.querySelector('.save-name').textContent}”吗？`, () => {
                            this.deleteGameSave(saveId).then(() => this.showNewSaveLoadManager());
                        });
                    } else if (target.classList.contains('btn-rename-new')) {
                       e.stopPropagation(); // 阻止手风琴展开
                       this.renameSave(saveId);
                    } else if (target.classList.contains('btn-export-new')) {
                       e.stopPropagation(); // 阻止手风琴展开
                       this.exportSave(saveId);
                   }
                });
            }
 
            // 绑定背景图设置模态框中的静态事件
            this.bindBackgroundSettingsListeners();

            // 绑定世界大事导航按钮（使用事件委托，因为按钮是动态生成的）
            document.addEventListener('click', (e) => {
              const target = e.target.closest('#world-events-nav-prev, #world-events-nav-next');
              if (!target) return;
              
              e.preventDefault();
              e.stopPropagation();
              
              if (target.id === 'world-events-nav-prev') {
                this.navigateWorldEvent('prev');
              } else if (target.id === 'world-events-nav-next') {
                this.navigateWorldEvent('next');
              }
            });
          },
 
// ===按钮统一监听绑定模块（极为重要）结束===




// ===界面控制模块开始===



            showSettings() {
              this.isFromSettingsModal = false; // 确保从其他地方打开时重置状态
              this.openModal('settings-modal');
              // 初始化透明度滑块
              this.initOpacitySlider();
              this.initPanelWidthSliders(); // 新增：初始化面板宽度滑块
              // 初始化文字设置UI
              this.updateTextSettingsUI();
              this.updateCustomFontsList();
              // 确保当前字体样式立即生效
              this.applyTextSettings();
              // 初始化世界书控制状态
              this.initWorldbookControlsInSettings();
              
              // 新增：动态设置全屏尺寸
              const rootContainer = document.querySelector('.guixu-root-container');
              const modalContent = document.querySelector('#settings-modal .modal-content');
              if (rootContainer && modalContent) {
                  const rect = rootContainer.getBoundingClientRect();
                  modalContent.style.setProperty('width', `${rect.width}px`, 'important');
                  modalContent.style.setProperty('height', `${rect.height}px`, 'important');
                  modalContent.style.setProperty('top', `${rect.top}px`, 'important');
                  modalContent.style.setProperty('left', `${rect.left}px`, 'important');
                  modalContent.style.setProperty('max-width', 'none', 'important');
                  modalContent.style.setProperty('max-height', 'none', 'important');
              }
            },

           // 初始化透明度滑块
           initOpacitySlider() {
             const slider = document.getElementById('opacity-slider');
             const valueDisplay = document.getElementById('opacity-value');
             
             if (slider && valueDisplay) {
               // 设置当前值
               slider.value = this.mainOpacity;
               valueDisplay.textContent = `当前设置: ${this.mainOpacity}%`;
               
               // 绑定事件监听器
               slider.addEventListener('input', (e) => {
                 this.updateOpacity(parseInt(e.target.value));
               });
             }
           },

           // 更新透明度
           updateOpacity(value) {
             this.mainOpacity = value;
             const valueDisplay = document.getElementById('opacity-value');
             if (valueDisplay) {
               valueDisplay.textContent = `当前设置: ${value}%`;
             }
             
             // 应用透明度到主界面
             this.applyOpacityToMainInterface(value);
             
             // 保存设置
             this.saveOpacitySettings();
           },

           // 应用透明度到主界面
           applyOpacityToMainInterface(opacity) {
             // 将透明度值转换为0-1的范围
             const opacityValue = opacity / 100;
             
             // 通过动态创建CSS规则来控制伪元素的透明度
             let styleElement = document.getElementById('dynamic-overlay-style');
             if (!styleElement) {
               styleElement = document.createElement('style');
               styleElement.id = 'dynamic-overlay-style';
               document.head.appendChild(styleElement);
             }
             
             // 创建CSS规则来控制伪元素的透明度
             styleElement.textContent = `
               .guixu-root-container::before {
                 content: '';
                 position: absolute;
                 top: 0;
                 left: 0;
                 width: 100%;
                 height: 100%;
                 background: rgba(26, 26, 46, ${opacityValue}) !important;
                 pointer-events: none;
                 z-index: -1;
               }
             `;
           },

           // 新增：保存透明度设置
           saveOpacitySettings() {
             try {
               localStorage.setItem('guixu_main_opacity', this.mainOpacity.toString());
             } catch (e) {
               console.error('保存透明度设置失败:', e);
             }
           },

           // 新增：加载透明度设置
           loadOpacitySettings() {
             try {
               const saved = localStorage.getItem('guixu_main_opacity');
               if (saved) {
                 this.mainOpacity = parseInt(saved);
                 this.applyOpacityToMainInterface(this.mainOpacity);
               }
             } catch (e) {
               console.error('加载透明度设置失败:', e);
               this.mainOpacity = 100; // 默认值
             }
           },



// ===界面控制模块结束===



// ===文字、字体相关设置模块开始===
           // 应用文字设置到页面
           async applyTextSettings() {
             try {
               // 确保自定义字体的CSS样式存在
               await this.ensureCustomFontsLoaded();
               
               // 优化性能：查找现有样式标签，如果不存在则创建，否则直接更新内容
               let style = document.getElementById('guixu-text-settings-style');
               if (!style) {
                 style = document.createElement('style');
                 style.id = 'guixu-text-settings-style';
                 document.head.appendChild(style);
               }
               style.textContent = `
                 .game-text-container {
                   color: ${this.textSettings.colors.normal} !important;
                   font-size: ${this.textSettings.fontSizes?.normal}px !important;
                   font-family: ${this.textSettings.fontFamily} !important;
                 }
                 .text-language {
                   color: ${this.textSettings.colors.dialogue} !important;
                   font-size: ${this.textSettings.fontSizes?.dialogue}px !important;
                   font-style: italic;
                 }
                 .text-psychology {
                   color: ${this.textSettings.colors.psychology} !important;
                   font-size: ${this.textSettings.fontSizes?.psychology}px !important;
                   font-style: italic;
                   opacity: 0.8;
                 }
                 .text-scenery {
                   color: ${this.textSettings.colors.scenery} !important;
                   font-size: ${this.textSettings.fontSizes?.scenery}px !important;
                 }
                 .character-link {
                   color: ${this.textSettings.colors.character} !important;
                   font-size: ${this.textSettings.fontSizes?.character}px !important;
                 }
                  .game-text-container,
                  .game-text-container > *:not(.text-language):not(.text-psychology):not(.text-scenery):not(.character-link),
                  .game-text-container p,
                  .game-text-container div:not([class*="text-"]) {
                    font-size: ${this.textSettings.fontSizes?.normal}px !important;
                  }
               `;
               
               // 强制刷新页面上的文字显示
               this.refreshTextDisplay();
               
             } catch (e) {
               console.error('应用文字设置失败:', e);
             }
           },

           // 确保自定义字体已加载
           async ensureCustomFontsLoaded() {
             try {
               const loadPromises = this.textSettings.customFonts.map(async (font) => {
                 const existingStyle = document.getElementById(`font-style-${font.hash}`);
                 if (!existingStyle && font.cacheKey) {
                   try {
                     // 如果字体样式不存在，尝试从缓存重新加载
                     const cachedFont = await this.loadFontFromIndexedDB(font.cacheKey);
                     const style = document.createElement('style');
                     style.id = `font-style-${font.hash}`;
                     style.textContent = `
                       @font-face {
                         font-family: ${font.family};
                         src: url(${cachedFont.data});
                         font-display: swap;
                       }
                     `;
                     document.head.appendChild(style);
                     return true;
                   } catch (error) {
                     console.warn('[归墟文字设置] 无法重新加载字体:', font.name, error);
                     return false;
                   }
                 }
                 return true;
               });
               
               await Promise.all(loadPromises);
             } catch (e) {
               console.error('确保自定义字体加载失败:', e);
             }
           },

           // 强制刷新文字显示
           refreshTextDisplay() {
             try {
               // 找到所有文字容器并强制重新渲染
               const textContainers = document.querySelectorAll('.game-text-container');
               textContainers.forEach(container => {
                 // 触发重新渲染
                 const display = container.style.display;
                 container.style.display = 'none';
                 container.offsetHeight; // 强制重排
                 container.style.display = display;
               });

               // 刷新所有文字样式元素
               const textElements = document.querySelectorAll('.text-language, .text-psychology, .text-scenery');
               textElements.forEach(element => {
                 // 强制重新应用样式
                 const className = element.className;
                 element.className = '';
                 element.offsetHeight; // 强制重排
                 element.className = className;
               });
             } catch (e) {
               console.error('刷新文字显示失败:', e);
             }
           },

           // 保存文字设置
           saveTextSettings() {
             try {
               localStorage.setItem('guixu_text_settings', JSON.stringify(this.textSettings));
             } catch (e) {
               console.error('保存文字设置失败:', e);
             }
           },

           // 加载文字设置
           loadTextSettings() {
             try {
               const saved = localStorage.getItem('guixu_text_settings');
               if (saved) {
                 const settings = JSON.parse(saved);
                 this.textSettings = { ...this.textSettings, ...settings };

                 // 加载并应用自定义字体（从IndexedDB缓存）
                 if (this.textSettings.customFonts && this.textSettings.customFonts.length > 0) {
                   // 使用Promise.all确保所有字体都加载完成
                   const fontLoadPromises = this.textSettings.customFonts.map(async (font) => {
                     try {
                       if (font.cacheKey) {
                         // 从IndexedDB加载
                         const cachedFont = await this.loadFontFromIndexedDB(font.cacheKey);
                         if (!cachedFont) {
                            console.warn(`[归墟] 字体 "${font.name}" 从缓存加载失败，跳过。`);
                            return false; 
                         }
                         const oldStyle = document.getElementById(`font-style-${font.hash}`);
                         if (oldStyle) {
                           oldStyle.remove();
                         }
                         
                         const style = document.createElement('style');
                         style.id = `font-style-${font.hash}`;
                         style.textContent = `
                           @font-face {
                             font-family: "${font.family}";
                             src: url(${cachedFont.data});
                             font-display: swap;
                           }
                         `;
                         document.head.appendChild(style);
                         return true;
                       } else if (font.data) {
                         const style = document.createElement('style');
                         style.id = `font-style-${font.hash || 'legacy'}`;
                         style.textContent = `
                           @font-face {
                             font-family: ${font.family};
                             src: url(${font.data});
                             font-display: swap;
                           }
                         `;
                         document.head.appendChild(style);
                         return true;
                       }
                     } catch (error) {
                       console.warn(`[归墟文字设置] 无法加载字体 ${font.name}:`, error);
                       return false;
                     }
                   });

                   // 等待所有字体加载完成后再应用设置
                   Promise.all(fontLoadPromises).then((results) => {
                     this.textSettings.customFonts = this.textSettings.customFonts.filter((font, index) => results[index]);
                     
                     // 应用文字设置
                     this.updateTextSettingsUI();
                     this.applyTextSettings();
                   });
                 } else {
                   // 没有自定义字体，直接应用设置
                   this.updateTextSettingsUI();
                   this.applyTextSettings();
                 }
               } else {
                 // 没有保存的设置，使用默认设置
                 this.updateTextSettingsUI();
                 this.applyTextSettings();
               }
             } catch (e) {
               console.error('加载文字设置失败:', e);
               // 出错时也要应用默认设置
               this.updateTextSettingsUI();
               this.applyTextSettings();
             }
           },

           // 更新文字设置UI
           updateTextSettingsUI() {
             try {
               const normalInput = document.getElementById('text-color-normal');
               const dialogueInput = document.getElementById('text-color-dialogue');
               const psychologyInput = document.getElementById('text-color-psychology');
               const sceneryInput = document.getElementById('text-color-scenery');
               const characterInput = document.getElementById('text-color-character');
               const fontFamilySelect = document.getElementById('font-family-select');

               if (normalInput) normalInput.value = this.textSettings.colors.normal;
               if (dialogueInput) dialogueInput.value = this.textSettings.colors.dialogue;
               if (psychologyInput) psychologyInput.value = this.textSettings.colors.psychology;
               if (sceneryInput) sceneryInput.value = this.textSettings.colors.scenery;
               if (characterInput) characterInput.value = this.textSettings.colors.character;

               // 更新独立字体大小滑块的UI
               const fontSizes = this.textSettings.fontSizes;
               if (fontSizes) {
                   const normalSizeSlider = document.getElementById('font-size-normal');
                   const normalSizeValue = document.getElementById('font-size-normal-value');
                   if (normalSizeSlider && fontSizes.normal) {
                       normalSizeSlider.value = fontSizes.normal;
                       if (normalSizeValue) normalSizeValue.textContent = fontSizes.normal + 'px';
                   }

                   const dialogueSizeSlider = document.getElementById('font-size-dialogue');
                   const dialogueSizeValue = document.getElementById('font-size-dialogue-value');
                   if (dialogueSizeSlider && fontSizes.dialogue) {
                       dialogueSizeSlider.value = fontSizes.dialogue;
                       if (dialogueSizeValue) dialogueSizeValue.textContent = fontSizes.dialogue + 'px';
                   }

                   const psychologySizeSlider = document.getElementById('font-size-psychology');
                   const psychologySizeValue = document.getElementById('font-size-psychology-value');
                   if (psychologySizeSlider && fontSizes.psychology) {
                       psychologySizeSlider.value = fontSizes.psychology;
                       if (psychologySizeValue) psychologySizeValue.textContent = fontSizes.psychology + 'px';
                   }

                   const scenerySizeSlider = document.getElementById('font-size-scenery');
                   const scenerySizeValue = document.getElementById('font-size-scenery-value');
                   if (scenerySizeSlider && fontSizes.scenery) {
                     scenerySizeSlider.value = fontSizes.scenery;
                     scenerySizeValue.textContent = fontSizes.scenery + 'px';
                   }

                   const characterSizeSlider = document.getElementById('font-size-character');
                   const characterSizeValue = document.getElementById('font-size-character-value');
                   if (characterSizeSlider && fontSizes.character) {
                     characterSizeSlider.value = fontSizes.character;
                     characterSizeValue.textContent = fontSizes.character + 'px';
                   }
               }
               
               if (fontFamilySelect) {
                 this.updateFontFamilyOptions();
                 fontFamilySelect.value = this.textSettings.fontFamily;
               }
             } catch (e) {
               console.error('更新文字设置UI失败:', e);
             }
           },

           // --- 自动阅读 ---
           initAutoRead() {
             const autoReadCheckbox = document.getElementById('auto-read-checkbox');
             const autoReadSpeedSlider = document.getElementById('auto-read-speed');
             const autoReadSpeedValue = document.getElementById('auto-read-speed-value');
             const autoReadFloat = document.getElementById('auto-read-float');
             const autoReadFloatSpeedSlider = document.getElementById('auto-read-float-speed');
             const autoReadFloatSpeedValue = document.getElementById('auto-read-float-speed-value');
             const autoReadCloseBtn = document.getElementById('auto-read-close-btn');
             const autoReadToggleBtn = document.getElementById('auto-read-toggle-btn');
             const mainContent = document.getElementById('main-content');

             const updateSpeedDisplay = (speed) => {
               if (autoReadSpeedValue) autoReadSpeedValue.textContent = speed;
               if (autoReadFloatSpeedValue) autoReadFloatSpeedValue.textContent = speed;
               if (autoReadSpeedSlider) autoReadSpeedSlider.value = speed;
               if (autoReadFloatSpeedSlider) autoReadFloatSpeedSlider.value = speed;
             };

             this.loadAutoReadSettings();
             updateSpeedDisplay(this.autoReadSpeed);

             autoReadCheckbox.addEventListener('change', (e) => {
               this.isAutoReading = e.target.checked;
               
               // 确保悬浮窗元素存在
               let autoReadFloat = document.getElementById('auto-read-float');
               if (!autoReadFloat) {
                 console.error('[自动阅读] 悬浮窗元素丢失');
                 return;
               }
               
               // 确保悬浮窗在body中
               if (!document.body.contains(autoReadFloat)) {
                 document.body.appendChild(autoReadFloat);
               }
               
               if (this.isAutoReading) {
                 this.startAutoRead();
                 autoReadFloat.style.display = 'block';
               } else {
                 this.stopAutoRead();
                 autoReadFloat.style.display = 'none';
               }
               this.saveAutoReadSettings();
             });

             const handleSpeedChange = (e) => {
               this.autoReadSpeed = parseInt(e.target.value, 10);
               updateSpeedDisplay(this.autoReadSpeed);
               if (this.isAutoReading) {
                 this.stopAutoRead();
                 this.startAutoRead();
               }
               this.saveAutoReadSettings();
             };

             autoReadSpeedSlider.addEventListener('input', handleSpeedChange);
             autoReadFloatSpeedSlider.addEventListener('input', handleSpeedChange);

             autoReadCloseBtn.addEventListener('click', () => {
               this.isAutoReading = false;
               const autoReadCheckbox = document.getElementById('auto-read-checkbox');
               if (autoReadCheckbox) {
                 autoReadCheckbox.checked = false;
               }
               this.stopAutoRead();
               
               const autoReadFloat = document.getElementById('auto-read-float');
               if (autoReadFloat) {
                 autoReadFloat.style.display = 'none';
               }
               this.saveAutoReadSettings();
             });

             autoReadToggleBtn.addEventListener('click', () => {
               if (this.autoReadInterval) {
                 this.stopAutoRead();
                 autoReadToggleBtn.textContent = '开始';
                 autoReadToggleBtn.classList.add('paused');
               } else {
                 this.startAutoRead();
                 autoReadToggleBtn.textContent = '暂停';
                 autoReadToggleBtn.classList.remove('paused');
               }
             });
           },

           startAutoRead() {
             if (this.autoReadInterval) return;
             const mainContent = document.getElementById('main-content');
             let userInteracting = false;
             let interactionTimeout;
             let lastTimestamp = 0;
             let scrollAccumulator = 0;
             const TARGET_FPS = 60; // 目标帧率
             const FRAME_TIME = 1000 / TARGET_FPS; // 每帧时间(ms)

             const onUserScroll = () => {
               userInteracting = true;
               clearTimeout(interactionTimeout);
               interactionTimeout = setTimeout(() => userInteracting = false, 2000);
             };

             mainContent.addEventListener('wheel', onUserScroll, { passive: true });
             mainContent.addEventListener('touchmove', onUserScroll, { passive: true });

             const scrollStep = (timestamp) => {
               if (!lastTimestamp) lastTimestamp = timestamp;
               const deltaTime = timestamp - lastTimestamp;
               
               if (!userInteracting && this.isAutoReading) {
                 // 速度值 * 10 = 像素/秒
                 const pixelsPerSecond = this.autoReadSpeed * 10;
                 const scrollAmount = (pixelsPerSecond * deltaTime) / 1000;
                 scrollAccumulator += scrollAmount;
                 
                 // 每帧至少滚动0.5像素,避免累积过多造成卡顿
                 if (scrollAccumulator >= 0.5) {
                   // 使用scrollBy而非scrollTop,性能更好
                   mainContent.scrollBy(0, scrollAccumulator);
                   scrollAccumulator = 0;
                 }
               }
               
               lastTimestamp = timestamp;
               this.autoReadInterval = requestAnimationFrame(scrollStep);
             };
             this.autoReadInterval = requestAnimationFrame(scrollStep);
           },

           stopAutoRead() {
             if (this.autoReadInterval) {
               cancelAnimationFrame(this.autoReadInterval);
             }
             this.autoReadInterval = null;
           },

           saveAutoReadSettings() {
             try {
               const settings = {
                 isAutoReading: this.isAutoReading,
                 autoReadSpeed: this.autoReadSpeed
               };
               localStorage.setItem('guixu_auto_read_settings', JSON.stringify(settings));
             } catch (e) {
               console.error('Failed to save auto read settings', e);
             }
           },

           loadAutoReadSettings() {
             try {
               const saved = localStorage.getItem('guixu_auto_read_settings');
               if (saved) {
                 const settings = JSON.parse(saved);
                 this.isAutoReading = settings.isAutoReading || false;
                 this.autoReadSpeed = settings.autoReadSpeed || 3;
                 
                 const autoReadCheckbox = document.getElementById('auto-read-checkbox');
                 if (autoReadCheckbox) {
                   autoReadCheckbox.checked = this.isAutoReading;
                 }
                 
                 // 确保悬浮窗存在且在body中
                 let autoReadFloat = document.getElementById('auto-read-float');
                 if (!autoReadFloat) {
                   console.warn('[自动阅读] 悬浮窗元素未找到');
                   return;
                 }
                 
                 // 确保悬浮窗在body末尾(防止被其他DOM操作移除)
                 if (!document.body.contains(autoReadFloat)) {
                   console.warn('[自动阅读] 悬浮窗不在DOM中,重新添加到body');
                   document.body.appendChild(autoReadFloat);
                 }
                 
                 if (this.isAutoReading) {
                   autoReadFloat.style.display = 'block';
                   this.startAutoRead();
                 } else {
                   autoReadFloat.style.display = 'none';
                 }
               }
             } catch (e) {
               console.error('Failed to load auto read settings', e);
             }
           },

           // 新增：初始化设置界面中的世界书控制状态
           initWorldbookControlsInSettings() {
             try {
               // 初始化统一序号输入框
               const unifiedIndexInput = document.getElementById('unified-index-input');
               if (unifiedIndexInput) {
                 unifiedIndexInput.value = this.unifiedIndex;
               }

               // 初始化自动开关世界书复选框
               const autoToggleCheckbox = document.getElementById('auto-toggle-lorebook-checkbox');
               if (autoToggleCheckbox) {
                 autoToggleCheckbox.checked = this.isAutoToggleLorebookEnabled;
               }

               // 初始化预设显示
               this.updatePresetsInSettings();

               console.log('[归墟设置] 已初始化世界书控制状态');
             } catch (e) {
               console.error('初始化世界书控制状态失败:', e);
             }
           },

           // 更新字体选择下拉框选项
           updateFontFamilyOptions() {
             const fontFamilySelect = document.getElementById('font-family-select');
             if (!fontFamilySelect) return;

             // 保存当前选择的值
             const currentValue = fontFamilySelect.value;

             // 清空现有选项
             fontFamilySelect.innerHTML = '';

             // 添加预设字体选项
             const presetFonts = [
               { value: "'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif", text: "默认字体" },
               { value: "'Microsoft YaHei', sans-serif", text: "微软雅黑" },
               { value: "'SimSun', serif", text: "宋体" },
               { value: "'KaiTi', serif", text: "楷体" },
               { value: "'FangSong', serif", text: "仿宋" },
               { value: "'Arial', sans-serif", text: "Arial" },
               { value: "'Times New Roman', serif", text: "Times New Roman" }
             ];

             presetFonts.forEach(font => {
               const option = document.createElement('option');
               option.value = font.value;
               option.textContent = font.text;
               fontFamilySelect.appendChild(option);
             });

             // 添加分隔线（如果有自定义字体）
             if (this.textSettings.customFonts.length > 0) {
               const separator = document.createElement('option');
               separator.disabled = true;
               separator.textContent = '--- 自定义字体 ---';
               fontFamilySelect.appendChild(separator);

               // 添加自定义字体选项
               this.textSettings.customFonts.forEach(font => {
                 const option = document.createElement('option');
                 option.value = font.family;
                 option.textContent = font.name;
                 fontFamilySelect.appendChild(option);
               });
             }

             // 添加上传新字体选项
             const uploadOption = document.createElement('option');
             uploadOption.value = 'upload_new';
             uploadOption.textContent = '+ 上传新字体';
             fontFamilySelect.appendChild(uploadOption);

             // 恢复之前的选择
             if (currentValue && currentValue !== 'upload_new') {
               fontFamilySelect.value = currentValue;
             }
           },

           // 重置文字设置
           resetTextSettings() {
             this.textSettings = {
               colors: {
                 normal: '#e8dcc6',
                 dialogue: '#ff1493',
                 psychology: '#808080',
                 scenery: '#98fb98',
                 character: '#87CEFA'
               },
               fontSizes: {
                 normal: 14,
                 dialogue: 14,
                 psychology: 13,
                 scenery: 15,
                 character: 14
               },
               fontFamily: "'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif",
               customFonts: []
             };
             this.updateTextSettingsUI();
             this.applyTextSettings();
             this.saveTextSettings();
             this.showTemporaryMessage('文字设置已重置为默认值');
           },

           // 预览文字设置效果
           previewTextSettings() {
             const previewText = `
               <div style="padding: 15px; background: rgba(0,0,0,0.8); border: 1px solid #c9aa71; border-radius: 5px; margin: 10px 0;">
                 <div style="color: #c9aa71; font-size: 14px; margin-bottom: 10px;">文字效果预览：</div>
                 <div class="text-language">这是对话文字的效果预览</div>
                 <div class="text-psychology">这是心理活动文字的效果预览</div>
                 <div class="text-scenery">这是景物描写文字的效果预览</div>
                 <span class="character-link">这是人物名称文字的效果预览</span>
               </div>
             `;
             
             // 创建预览模态框
             const modal = document.createElement('div');
             modal.className = 'modal-overlay';
             modal.style.display = 'flex';
             modal.style.zIndex = '2002';
             modal.innerHTML = `
               <div class="modal-content" style="max-width: 500px;">
                 <div class="modal-header">
                   <h2 class="modal-title">文字效果预览</h2>
                   <button class="modal-close-btn">&times;</button>
                 </div>
                 <div class="modal-body">
                   ${previewText}
                   <div style="text-align: center; margin-top: 15px;">
                     <button class="interaction-btn" onclick="this.closest('.modal-overlay').remove()">关闭预览</button>
                   </div>
                 </div>
               </div>
             `;
             
             document.body.appendChild(modal);
             
             // 绑定关闭事件
             modal.querySelector('.modal-close-btn').addEventListener('click', () => {
               modal.remove();
             });
             modal.addEventListener('click', (e) => {
               if (e.target === modal) modal.remove();
             });
           },

           // 处理字体文件上传
           handleFontUpload(event) {
             const file = event.target.files[0];
             if (!file) return;

             // 重置文件输入框，允许重新选择相同文件
             event.target.value = '';

             const allowedTypes = ['font/ttf', 'font/otf', 'font/woff', 'font/woff2', 'application/font-woff', 'application/font-woff2'];
             const fileExtension = file.name.split('.').pop().toLowerCase();
             const allowedExtensions = ['ttf', 'otf', 'woff', 'woff2'];

             if (!allowedExtensions.includes(fileExtension)) {
               this.showTemporaryMessage('请选择有效的字体文件 (.ttf, .otf, .woff, .woff2)');
               return;
             }

             // 检查文件大小（限制为10MB，但给出警告）
             if (file.size > 10 * 1024 * 1024) {
               this.showTemporaryMessage('字体文件过大，请选择小于10MB的文件');
               return;
             }
             
             // 对于大于2MB的文件给出警告
             if (file.size > 2 * 1024 * 1024) {
               const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
               const shouldContinue = confirm(`字体文件较大 (${sizeMB}MB)，可能影响加载速度和存储空间。是否继续上传？`);
               if (!shouldContinue) {
                 this.showTemporaryMessage('上传已取消');
                 return;
               }
               this.showTemporaryMessage(`正在上传大字体文件 (${sizeMB}MB)，请稍候...`);
             }

             // 显示上传开始提示
             this.showTemporaryMessage(`正在处理字体文件: ${file.name}`);

             const reader = new FileReader();
             
             reader.onload = (e) => {
               try {
                 const fontData = e.target.result;
                 const fontName = file.name.replace(/\.[^/.]+$/, ""); // 移除扩展名
                 const fontFamily = `'${fontName}'`;
                 
                 // 检查是否已存在同名字体
                 const existingFont = this.textSettings.customFonts.find(f => f.name === fontName);
                 if (existingFont) {
                   const shouldReplace = confirm(`字体 "${fontName}" 已存在，是否替换？`);
                   if (!shouldReplace) {
                     this.showTemporaryMessage('上传已取消');
                     return;
                   }
                   // 移除旧字体
                   const index = this.textSettings.customFonts.indexOf(existingFont);
                   this.removeCustomFont(index);
                 }
                 
                 // 生成字体文件的哈希值作为缓存键
                 const fontHash = this.generateFontHash(fontName, file.size, file.lastModified);
                 const cacheKey = `guixu_font_${fontHash}`;

                 // 使用IndexedDB存储字体文件
                 this.storeFontInIndexedDB(cacheKey, fontData, fontName, fontFamily)
                   .then(() => {
                     // 创建字体样式
                     const style = document.createElement('style');
                     style.id = `font-style-${fontHash}`;
                     style.textContent = `
                       @font-face {
                         font-family: ${fontFamily};
                         src: url(${fontData});
                         font-display: swap;
                       }
                     `;
                     document.head.appendChild(style);

                     // 添加到自定义字体列表（只保存元数据，不保存文件数据）
                     const customFont = {
                       name: fontName,
                       family: fontFamily,
                       hash: fontHash,
                       cacheKey: cacheKey,
                       size: file.size,
                       lastModified: file.lastModified
                     };
                     
                     this.textSettings.customFonts.push(customFont);
                     this.updateCustomFontsList();
                     
                     // 更新字体选择下拉框
                     this.updateFontFamilyOptions();
                     
                     // 自动应用新上传的字体
                     this.textSettings.fontFamily = fontFamily;
                     const fontFamilySelect = document.getElementById('font-family-select');
                     if (fontFamilySelect) {
                       fontFamilySelect.value = fontFamily;
                     }
                     this.applyTextSettings();
                     this.saveTextSettings();
                     
                     const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
                     this.showTemporaryMessage(`字体 "${fontName}" (${sizeMB}MB) 上传成功并已应用`);
                   })
                   .catch(error => {
                     console.error('字体缓存失败:', error);
                     this.showTemporaryMessage(`字体缓存失败: ${error.message}`);
                     
                     // 即使缓存失败，也创建临时样式
                     const style = document.createElement('style');
                     style.textContent = `
                       @font-face {
                         font-family: ${fontFamily};
                         src: url(${fontData});
                         font-display: swap;
                       }
                     `;
                     document.head.appendChild(style);
                     
                     // 添加临时字体到列表（不保存到localStorage）
                     const tempFont = {
                       name: fontName + ' (临时)',
                       family: fontFamily,
                       hash: fontHash,
                       size: file.size,
                       temporary: true
                     };
                     this.textSettings.customFonts.push(tempFont);
                     this.updateCustomFontsList();
                   });
               } catch (error) {
                 console.error('字体处理失败:', error);
                 this.showTemporaryMessage(`字体处理失败: ${error.message}`);
               }
             };
             
             reader.onerror = (error) => {
               console.error('文件读取失败:', error);
               this.showTemporaryMessage('文件读取失败，请重试');
             };
             
             reader.readAsDataURL(file);
           },

           // 生成字体文件哈希值
           generateFontHash(name, size, lastModified) {
             const str = `${name}_${size}_${lastModified}`;
             let hash = 0;
             for (let i = 0; i < str.length; i++) {
               const char = str.charCodeAt(i);
               hash = ((hash << 5) - hash) + char;
               hash = hash & hash; // 转换为32位整数
             }
             return Math.abs(hash).toString(36);
           },

           // 使用IndexedDB存储字体文件
           // --- Dexie DB 统一管理 ---
           async initializeDatabase() {
               try {
                   // 检查环境支持
                   if (!window.indexedDB) {
                       console.warn('[归墟] IndexedDB不受支持，字体和头像缓存功能将被禁用');
                       this.dbAvailable = false;
                       return false;
                   }

                   // 检查Dexie库是否可用
                   if (typeof window.Dexie === 'undefined') {
                       console.warn('[归墟] Dexie库未加载，IndexedDB功能将被禁用');
                       this.dbAvailable = false;
                       return false;
                   }

                   // 初始化数据库
                   this.db = new window.Dexie('GuixuDB');
                   this.db.version(6).stores({
                       fonts: 'cacheKey, name, family', // 主键是 cacheKey
                       character_avatars: 'characterName', // 主键是 characterName，其他字段自动存储
                       game_saves: 'id, timestamp, auto_generated', // 游戏存档表
                       background_images: 'id, uploadTime, isPreset', // 新增：背景图存储表
                       key_value_store: 'key' // 新增：键值对存储，用于存储文件夹句柄等
                   });
                   
                   // 确保数据库打开
                   await this.db.open();
                   this.dbAvailable = true;
                   console.log('[归墟] Dexie 数据库初始化成功');

                   // 封装键值对存储方法
                   this.db.setItem = (key, value) => this.db.key_value_store.put({ key, value });
                   this.db.getItem = async (key) => {
                       const item = await this.db.key_value_store.get(key);
                       return item ? item.value : null;
                   };

                   return true;
               } catch (error) {
                   console.warn('[归墟] IndexedDB初始化失败，相关功能将被禁用:', error.message);
                   this.db = null;
                   this.dbAvailable = false;
                   return false;
               }
           },



// ===文字、字体相关设置模块结束===



// ===新版本indexedDB存档存储模块开始===
           

           async saveGameToStorage(saveData) {
               try {
                   // 优先使用IndexedDB
                   if (this.dbAvailable && this.db) {
                       await this.db.game_saves.put(saveData);
                       console.log('[归墟存档] IndexedDB存储成功:', saveData.name);
                       return true;
                   } else {
                       // 降级到localStorage
                       const allSaves = this.getLocalStorageGameSaves();
                       allSaves[saveData.id] = saveData;
                       localStorage.setItem('guixu_new_save_data', JSON.stringify(allSaves));
                       console.log('[归墟存档] localStorage降级存储成功:', saveData.name);
                       return true;
                   }
               } catch (error) {
                   console.error('[归墟存档] 存储失败:', error);
                   // 如果IndexedDB失败，尝试localStorage降级
                   try {
                       const allSaves = this.getLocalStorageGameSaves();
                       allSaves[saveData.id] = saveData;
                       localStorage.setItem('guixu_new_save_data', JSON.stringify(allSaves));
                       console.log('[归墟存档] localStorage降级存储成功:', saveData.name);
                       return true;
                   } catch (fallbackError) {
                       console.error('[归墟存档] 降级存储也失败:', fallbackError);
                       return false;
                   }
               }
           },

           // ===系列管理模块开始===
           // 系列数据结构: { seriesId: 'unique_id', name: '系列名', createTime: timestamp }
           
           // 加载所有系列
           loadSeriesList() {
               try {
                   const data = localStorage.getItem('guixu_series_list');
                   const series = data ? JSON.parse(data) : [];
                   return series;
               } catch (e) {
                   console.error('[系列管理] 加载系列列表失败:', e);
                   return [];
               }
           },
           
           // 保存系列列表
           saveSeriesList(series) {
               try {
                   localStorage.setItem('guixu_series_list', JSON.stringify(series));
                   return true;
               } catch (e) {
                   console.error('[系列管理] 保存系列列表失败:', e);
                   return false;
               }
           },
           
           // 添加新系列
           addSeries(seriesName) {
               if (!seriesName || seriesName.trim() === '') {
                   this.showTemporaryMessage('系列名称不能为空');
                   return null;
               }
               
               const series = this.loadSeriesList();
               
               // 检查重复
               if (series.some(s => s.name === seriesName)) {
                   this.showTemporaryMessage('该系列已存在');
                   return null;
               }
               
               const newSeries = {
                   seriesId: 'series_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                   name: seriesName,
                   createTime: new Date().toISOString()
               };
               
               series.push(newSeries);
               this.saveSeriesList(series);
               this.showTemporaryMessage(`系列"${seriesName}"已添加`);
               return newSeries;
           },
           
           // 删除系列(将该系列下的所有存档转为"无系列")
           async deleteSeries(seriesId) {
               const series = this.loadSeriesList();
               const seriesName = series.find(s => s.seriesId === seriesId)?.name || '未知系列';
               
               // 更新存档:将该系列的标记清空
               const allSaves = await this.getAllGameSaves();
               const savesToUpdate = allSaves.filter(save => save.series === seriesId);
               
               for (const save of savesToUpdate) {
                   save.series = '';
                   await this.saveGameToStorage(save);
               }
               
               // 删除系列
               const updatedSeries = series.filter(s => s.seriesId !== seriesId);
               this.saveSeriesList(updatedSeries);
               
               // 重置当前系列选择
               if (this.currentSeries === seriesId) {
                   this.currentSeries = '';
                   this.updateCurrentSeriesSelect();
               }
               
               this.showTemporaryMessage(`系列"${seriesName}"已删除`);
           },
           
           // 重命名系列
           renameSeries(seriesId, newName) {
               if (!newName || newName.trim() === '') {
                   this.showTemporaryMessage('系列名称不能为空');
                   return false;
               }
               
               const series = this.loadSeriesList();
               const seriesIndex = series.findIndex(s => s.seriesId === seriesId);
               
               if (seriesIndex === -1) {
                   this.showTemporaryMessage('系列不存在');
                   return false;
               }
               
               // 检查新名称是否已存在
               if (series.some((s, idx) => idx !== seriesIndex && s.name === newName)) {
                   this.showTemporaryMessage('该系列名称已存在');
                   return false;
               }
               
               series[seriesIndex].name = newName;
               this.saveSeriesList(series);
               this.showTemporaryMessage('系列已重命名');
               return true;
           },
           
           // 获取当前选中的系列
           getCurrentSeries() {
               return this.currentSeries || '';
           },
           
           // 设置当前系列
           setCurrentSeries(seriesId) {
               this.currentSeries = seriesId;
               localStorage.setItem('guixu_current_series', seriesId);
               this.updateCurrentSeriesSelect();
           },
           
           // 更新"当前系列"下拉框
           updateCurrentSeriesSelect() {
               const select = document.getElementById('current-series-select');
               if (!select) return;
               
               select.value = this.currentSeries || '';
           },
           
           // 初始化系列选择器
           initializeSeriesSelector() {
               const select = document.getElementById('current-series-select');
               if (!select) return;
               
               const series = this.loadSeriesList();
               
               // 清空选项
               select.innerHTML = '<option value="">无系列</option>';
               
               // 添加系列选项
               series.forEach(s => {
                   const option = document.createElement('option');
                   option.value = s.seriesId;
                   option.textContent = s.name;
                   select.appendChild(option);
               });
               
               // 恢复之前选择的系列
               this.currentSeries = localStorage.getItem('guixu_current_series') || '';
               select.value = this.currentSeries;
               
               // 绑定变化事件
               select.addEventListener('change', (e) => {
                   this.setCurrentSeries(e.target.value);
               });
           },
           
           // ===系列管理模块结束===

           // 从存储中获取所有存档
           async getAllGameSaves() {
               try {
                   if (this.dbAvailable && this.db) {
                       // 从IndexedDB获取
                       const saves = await this.db.game_saves.orderBy('timestamp').reverse().toArray();
                       console.log(`[归墟存档] 从IndexedDB读取到 ${saves.length} 个存档`);
                       return saves;
                   } else {
                       // 从localStorage获取
                       const saves = this.getLocalStorageGameSaves();
                       const saveArray = Object.values(saves).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                       console.log(`[归墟存档] 从localStorage读取到 ${saveArray.length} 个存档`);
                       return saveArray;
                   }
               } catch (error) {
                   console.error('[归墟存档] 读取存档失败:', error);
                   // 降级到localStorage
                   const saves = this.getLocalStorageGameSaves();
                   return Object.values(saves).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
               }
           },

           // 获取localStorage中的存档数据
           getLocalStorageGameSaves() {
               try {
                   const saves = localStorage.getItem('guixu_new_save_data');
                   return saves ? JSON.parse(saves) : {};
               } catch (e) {
                   console.error('[归墟存档] localStorage读取失败:', e);
                   return {};
               }
           },

           // 删除存档
           async deleteGameSave(saveId) {
               try {
                   if (this.dbAvailable && this.db) {
                       await this.db.game_saves.delete(saveId);
                       console.log('[归墟存档] IndexedDB删除成功:', saveId);
                   } else {
                       const allSaves = this.getLocalStorageGameSaves();
                       delete allSaves[saveId];
                       localStorage.setItem('guixu_new_save_data', JSON.stringify(allSaves));
                       console.log('[归墟存档] localStorage删除成功:', saveId);
                   }
                   return true;
               } catch (error) {
                   console.error('[归墟存档] 删除失败:', error);
                   return false;
               }
           },

           // 生成存档唯一ID
           generateSaveId() {
               const timestamp = Date.now();
               const random = Math.random().toString(36).substr(2, 9);
               return `save_${timestamp}_${random}`;
           },


           // 计算存档指纹用于去重
           calculateSaveFingerprint(saveData) {
               try {
                   // 只使用关键的游戏状态数据,排除可能变化的元数据
                   const statData = saveData.mvu_data?.stat_data || {};
                   
                   // 提取核心游戏状态用于指纹计算,排除时间戳等元数据
                   const coreGameState = {
                       // 玩家核心属性
                       当前境界: statData.当前境界,
                       当前时间纪年: statData.当前时间纪年
                   };
                   
                   // 世界书内容哈希
                   const worldbookHashes = {
                       journey: this.hashContent(saveData.worldbook_contents?.journey || ''),
                       novel_mode: this.hashContent(saveData.worldbook_contents?.novel_mode || ''),
                       past_lives: this.hashContent(saveData.worldbook_contents?.past_lives || '')
                   };
                   
                   // 使用排序后的JSON字符串确保一致性
                   const fingerprint = this.hashContent(
                       JSON.stringify(coreGameState, Object.keys(coreGameState).sort()) +
                       JSON.stringify(worldbookHashes, Object.keys(worldbookHashes).sort())
                   );
                   
                   console.log('[归墟存档] 计算指纹:', fingerprint, '核心状态:', coreGameState);
                   return fingerprint;
               } catch (error) {
                   console.warn('[归墟存档] 计算指纹失败:', error);
                   return Math.random().toString(36);
               }
           },

           // 简单哈希函数
           hashContent(content) {
               if (!content) return '0';
               let hash = 0;
               for (let i = 0; i < content.length; i++) {
                   const char = content.charCodeAt(i);
                   hash = ((hash << 5) - hash) + char;
                   hash = hash & hash; // 转换为32位整数
               }
               return Math.abs(hash).toString(36);
           },

           // 检查是否为重复存档
           async isDuplicateSave(newSaveData) {
               try {
                   const recentSaves = await this.getAllGameSaves();
                   const newFingerprint = this.calculateSaveFingerprint(newSaveData);
                   
                   // 只检查最近3个存档
                   const recentThree = recentSaves.slice(0, 3);
                   
                   for (const save of recentThree) {
                       const existingFingerprint = this.calculateSaveFingerprint(save);
                       if (newFingerprint === existingFingerprint) {
                           console.log('[归墟存档] 检测到重复存档，跳过保存');
                           return true;
                       }
                   }
                   
                   return false;
               } catch (error) {
                   console.warn('[归墟存档] 去重检查失败:', error);
                   return false; // 检查失败时允许保存
               }
           },



           
// ===新版本indexedDB存档存储模块结束===




// ===indexedDB字体相关设置模块开始===



           async storeFontInIndexedDB(cacheKey, fontData, fontName, fontFamily) {
               try {
                   // 检查数据库可用性
                   if (!this.dbAvailable) {
                       console.warn('[归墟] IndexedDB不可用，跳过字体缓存:', fontName);
                       return false;
                   }

                   // 确保数据库已初始化
                   if (!this.db) {
                       const initSuccess = await this.initializeDatabase();
                       if (!initSuccess) {
                           return false;
                       }
                   }
                   
                   const fontRecord = {
                       cacheKey: cacheKey,
                       name: fontName,
                       family: fontFamily,
                       data: fontData,
                       timestamp: Date.now()
                   };
                   await this.db.fonts.put(fontRecord);
                   console.log('[归墟] 字体缓存成功:', fontName);
                   return true;
               } catch (error) {
                   console.warn('[归墟] 字体缓存失败，跳过:', error.message);
                   return false;
               }
           },

           // 从IndexedDB加载字体文件
           async loadFontFromIndexedDB(cacheKey) {
               try {
                   // 检查数据库可用性
                   if (!this.dbAvailable) {
                       console.warn('[归墟] IndexedDB不可用，跳过字体加载:', cacheKey);
                       return null;
                   }

                   // 确保数据库已初始化
                   if (!this.db) {
                       const initSuccess = await this.initializeDatabase();
                       if (!initSuccess) {
                           return null;
                       }
                   }
                   
                   const fontRecord = await this.db.fonts.get(cacheKey);
                   if (fontRecord) {
                       console.log('[归墟] 字体缓存加载成功:', fontRecord.name);
                       return fontRecord;
                   } else {
                       console.warn('[归墟] 字体缓存未找到:', cacheKey);
                       return null;
                   }
               } catch (error) {
                   console.warn('[归墟] 字体缓存读取失败，跳过:', error.message);
                   return null;
               }
           },

           // 更新自定义字体列表显示
           updateCustomFontsList() {
             const container = document.getElementById('uploaded-fonts-list');
             if (!container) return;

             if (this.textSettings.customFonts.length === 0) {
               container.innerHTML = '<div style="color: #8b7355; font-size: 11px; text-align: center; padding: 10px;">暂无上传的字体</div>';
               return;
             }

             let html = '';
             this.textSettings.customFonts.forEach((font, index) => {
               html += `
                 <div style="display: flex; align-items: center; justify-content: space-between; padding: 5px; border: 1px solid #8b7355; border-radius: 3px; margin-bottom: 5px;">
                   <span style="font-size: 11px; color: #e0dcd1;">${font.name}</span>
                   <div>
                     <button class="interaction-btn font-use-btn" style="padding: 2px 6px; font-size: 10px; margin-right: 5px;" data-font-index="${index}">使用</button>
                     <button class="interaction-btn font-remove-btn" style="padding: 2px 6px; font-size: 10px; background: #8b0000; border-color: #ff6b6b;" data-font-index="${index}">删除</button>
                   </div>
                 </div>
               `;
             });
             
             container.innerHTML = html;

             // 绑定事件委托
             container.addEventListener('click', (e) => {
               const index = parseInt(e.target.dataset.fontIndex);
               if (isNaN(index)) return;

               if (e.target.classList.contains('font-use-btn')) {
                 this.useCustomFont(index);
               } else if (e.target.classList.contains('font-remove-btn')) {
                 this.removeCustomFont(index);
               }
             });
           },
            // 确保自定义字体已加载
            async ensureCustomFontLoaded(fontFamily) {
              // 检查是否是自定义字体
              const customFont = this.textSettings.customFonts.find(font => font.family === fontFamily);
              if (!customFont) {
                return; // 不是自定义字体，直接返回
              }

              // 检查字体样式是否已存在
              const existingStyle = document.getElementById(`font-style-${customFont.hash}`);
              if (existingStyle) {
                return; // 字体样式已存在，直接返回
              }

              // 字体样式不存在，需要重新加载
              if (customFont.cacheKey) {
                try {
                  const cachedFont = await this.loadFontFromIndexedDB(customFont.cacheKey);
                  const style = document.createElement('style');
                  style.id = `font-style-${customFont.hash}`;
                  style.textContent = `
                    @font-face {
                      font-family: '${cachedFont.name}';
                      src: url(data:font/truetype;base64,${cachedFont.data}) format('truetype');
                    }
                  `;
                  document.head.appendChild(style);
                  console.log('自定义字体重新加载成功:', cachedFont.name);
                } catch (error) {
                  console.error('自定义字体加载失败:', error);
                }
              }
            },


           // 使用自定义字体
           useCustomFont(index) {
             if (index >= 0 && index < this.textSettings.customFonts.length) {
               const font = this.textSettings.customFonts[index];
               this.textSettings.fontFamily = font.family;
               
               // 更新字体选择下拉框为对应的自定义字体
               const fontFamilySelect = document.getElementById('font-family-select');
               if (fontFamilySelect) {
                 fontFamilySelect.value = font.family;
               }
               if (customFontSection) {
                 customFontSection.style.display = 'block';
               }
               
               // 确保字体已加载后再应用
               this.ensureCustomFontLoaded(font.family).then(() => {
                 this.applyTextSettings();
                 this.saveTextSettings();
               });
               this.showTemporaryMessage(`已应用字体 "${font.name}"`);
             }
           },

           // 删除自定义字体
           removeCustomFont(index) {
             if (index >= 0 && index < this.textSettings.customFonts.length) {
               const font = this.textSettings.customFonts[index];
               this.showCustomConfirm(`确定要删除字体 "${font.name}" 吗？`, async () => {
                 try {
                   // 从IndexedDB中删除缓存的字体文件
                   if (font.cacheKey) {
                     await this.removeFontFromIndexedDB(font.cacheKey);
                   }
                   
                   // 移除页面中的字体样式
                   if (font.hash) {
                     const styleElement = document.getElementById(`font-style-${font.hash}`);
                     if (styleElement) {
                       styleElement.remove();
                     }
                   }
                   
                   // 检查当前是否正在使用被删除的字体
                   const isCurrentFont = this.textSettings.fontFamily === font.family;
                   
                   // 从设置中移除
                   this.textSettings.customFonts.splice(index, 1);
                   this.updateCustomFontsList();
                   
                   // 更新字体选择下拉框
                   this.updateFontFamilyOptions();
                   
                   // 如果删除的是当前使用的字体，切换到默认字体
                   if (isCurrentFont) {
                     this.textSettings.fontFamily = "'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif";
                     const fontFamilySelect = document.getElementById('font-family-select');
                     if (fontFamilySelect) {
                       fontFamilySelect.value = this.textSettings.fontFamily;
                     }
                     this.applyTextSettings();
                   }
                   
                   this.saveTextSettings();
                   this.showTemporaryMessage(`字体 "${font.name}" 已删除`);
                 } catch (error) {
                   console.error('删除字体缓存失败:', error);
                   // 即使缓存删除失败，也要从设置中移除
                   this.textSettings.customFonts.splice(index, 1);
                   this.updateCustomFontsList();
                   this.updateFontFamilyOptions();
                   this.saveTextSettings();
                   this.showTemporaryMessage(`字体 "${font.name}" 已删除（缓存清理可能失败）`);
                 }
               });
             }
           },

           // 从IndexedDB中删除字体文件
           async removeFontFromIndexedDB(cacheKey) {
               try {
                   // 检查数据库可用性
                   if (!this.dbAvailable) {
                       console.warn('[归墟] IndexedDB不可用，跳过字体删除:', cacheKey);
                       return false;
                   }

                   // 确保数据库已初始化
                   if (!this.db) {
                       const initSuccess = await this.initializeDatabase();
                       if (!initSuccess) {
                           return false;
                       }
                   }
                   
                   await this.db.fonts.delete(cacheKey);
                   console.log('[归墟] 字体缓存删除成功:', cacheKey);
                   return true;
               } catch (error) {
                   console.warn('[归墟] 字体缓存删除失败，跳过:', error.message);
                   return false;
               }
           },



// ===indexedDB字体相关设置模块结束===



// ===indexedDB人物关系/人物头像相关模块开始===



           async storeAvatarInDB(recordData) {
               try {
                   // 检查数据库可用性
                   if (!this.dbAvailable) {
                       console.warn('[归墟] IndexedDB不可用，跳过头像缓存:', recordData?.characterName);
                       return false;
                   }

                   // 确保数据库已初始化
                   if (!this.db) {
                       const initSuccess = await this.initializeDatabase();
                       if (!initSuccess) {
                           return false;
                       }
                   }
                   
                   // 获取角色名
                   const characterName = recordData.characterName;
                   if (!characterName) {
                       console.warn('[归墟] 角色名为空，跳过头像缓存');
                       return false;
                   }
                   
                   // 先获取现有记录
                   const existingRecord = await this.db.character_avatars.get(characterName);

                   // 合并新数据和现有数据
                   const avatarRecord = {
                       characterName: characterName,
                       avatarImage: recordData.avatarImage !== undefined ? recordData.avatarImage : existingRecord?.avatarImage,
                       backgroundImage: recordData.backgroundImage !== undefined ? recordData.backgroundImage : existingRecord?.backgroundImage,
                       backgroundOpacity: recordData.backgroundOpacity !== undefined ? recordData.backgroundOpacity : existingRecord?.backgroundOpacity ?? 0.5,
                       timestamp: Date.now()
                   };

                   await this.db.character_avatars.put(avatarRecord);
                   console.log(`[归墟] 角色头像 [${characterName}] 缓存成功`);
                   return true;
               } catch (error) {
                   console.warn(`[归墟] 角色头像 [${recordData?.characterName || 'unknown'}] 缓存失败，跳过:`, error.message);
                   return false;
               }
           },

           async getAvatarFromDB(characterName) {
               try {
                   // 检查数据库可用性
                   if (!this.dbAvailable) {
                       return null;
                   }

                   // 确保数据库已初始化
                   if (!this.db) {
                       const initSuccess = await this.initializeDatabase();
                       if (!initSuccess) {
                           return null;
                       }
                   }
                   
                   const result = await this.db.character_avatars.get(characterName);
                   return result || null; // 明确返回null
               } catch (error) {
                   // 如果数据库初始化失败等，直接返回null
                   console.warn('[归墟] IndexedDB (头像) 读取异常，跳过:', error.message);
                   return null;
               }
           },

           async removeAvatarFromDB(characterName) {
               try {
                   // 确保数据库已初始化
                   if (!this.db) {
                       await this.initializeDatabase();
                   }
                   
                   await this.db.character_avatars.delete(characterName);
                   console.log(`角色头像 [${characterName}] 删除成功`);
               } catch (error) {
                   console.error(`角色头像 [${characterName}] 删除失败:`, error);
                   throw error;
               }
           },

           // --- 头像上传与压缩 ---
           async compressImageForAvatar(file) {
               return new Promise((resolve, reject) => {
                   const MAX_WIDTH = 512;
                   const MAX_HEIGHT = 512;
                   const reader = new FileReader();
                   reader.readAsDataURL(file);
                   reader.onload = (e) => {
                       const img = new Image();
                       img.src = e.target.result;
                       img.onload = () => {
                           let width = img.width;
                           let height = img.height;

                           if (width > height) {
                               if (width > MAX_WIDTH) {
                                   height *= MAX_WIDTH / width;
                                   width = MAX_WIDTH;
                               }
                           } else {
                               if (height > MAX_HEIGHT) {
                                   width *= MAX_HEIGHT / height;
                                   height = MAX_HEIGHT;
                               }
                           }

                           const canvas = document.createElement('canvas');
                           canvas.width = width;
                           canvas.height = height;
                           const ctx = canvas.getContext('2d');
                           ctx.drawImage(img, 0, 0, width, height);
                           
                           // 使用JPEG格式以获得更好的压缩率
                           resolve(canvas.toDataURL('image/jpeg', 0.8));
                       };
                       img.onerror = (error) => reject(error);
                   };
                   reader.onerror = (error) => reject(error);
               });
           },

           async handleAvatarUpload(characterName, file) {
               if (!file.type.startsWith('image/')) {
                   this.showTemporaryMessage('请选择图片文件', 'error');
                   return;
               }
               this.showTemporaryMessage('正在处理图片...', 'info');
               try {
                   // 直接使用原始图片
                   const originalImage = await this.fileToDataUrl(file);
                   const avatarImage = originalImage;
                   const backgroundImage = originalImage;

                   // 智能处理透明度：先读取旧的，如果不存在则用默认值0.5
                   const existingRecord = await this.getAvatarFromDB(characterName);
                   const backgroundOpacity = existingRecord ? existingRecord.backgroundOpacity : 0.5;

                   const newRecord = {
                       characterName: characterName,
                       avatarImage: avatarImage,
                       backgroundImage: backgroundImage,
                       backgroundOpacity: backgroundOpacity
                   };

                   await this.storeAvatarInDB(newRecord);
                   
                   this.showTemporaryMessage('图片上传成功!', 'success');
                   
                   // 立即刷新UI
                   if (document.getElementById('relationships-modal').style.display === 'flex') {
                       this.renderCharacterDetails(characterName); // 刷新详情
                       this.renderCharacterList(); // 刷新列表
                   }
               } catch (error) {
                   console.error('头像上传失败:', error);
                   this.showTemporaryMessage('头像上传失败，请查看控制台', 'error');
               }
           },



           // 显示头像来源选择器
           showAvatarSourcePicker(characterName) {
               const menuId = 'avatar-source-picker-menu';
               const overlayId = 'avatar-source-picker-overlay';

               // 防止重复创建
               if (document.getElementById(menuId)) return;

               // 创建遮罩层
               const overlay = document.createElement('div');
               overlay.id = overlayId;
               overlay.style.cssText = `
                   position: absolute;
                   top: 0;
                   left: 0;
                   width: 100%;
                   height: 100%;
                   background: rgba(0, 0, 0, 0.8);
                   z-index: 10000;
                   display: flex;
                   justify-content: center;
                   align-items: center;
               `;

               // 创建选择菜单
               const menu = document.createElement('div');
               menu.id = menuId;
               menu.style.cssText = `
                   width: 320px;
                   padding: var(--spacing-lg, 20px);
                   border-radius: var(--border-radius-lg, 8px);
                   border: 1px solid var(--primary-gold, #c9aa71);
                   background: var(--bg-primary, rgba(26, 26, 46, 0.95));
                   box-shadow: var(--shadow-lg, 0 8px 25px rgba(0, 0, 0, 0.5));
                   animation: fadeIn 0.3s var(--easing-smooth, ease);
               `;
               
               menu.innerHTML = `
                   <div style="padding: 0 0 var(--spacing-md, 15px) 0; text-align: center;">
                       <h2 style="margin: 0; font-size: var(--font-size-h3, 1.3rem); color: var(--primary-gold, #c9aa71);">选择图片来源</h2>
                   </div>
                   <div style="display: flex; flex-direction: column; gap: var(--spacing-md, 15px);">
                       <button id="upload-local-btn" class="interaction-btn" style="width: 100%;">
                           <i class="fas fa-upload"></i> 上传本地图片
                       </button>
                       <button id="select-from-gallery-btn" class="interaction-btn" style="width: 100%;">
                           <i class="fas fa-images"></i> 从图库选择
                       </button>
                       <button id="cancel-picker-btn" class="interaction-btn" style="width: 100%; background: rgba(255, 107, 107, 0.1); border-color: var(--danger-color, #ff6b6b); color: var(--danger-color, #ff6b6b);">
                           <i class="fas fa-times"></i> 取消
                       </button>
                   </div>
               `;
               
               // 添加到页面
               overlay.appendChild(menu);
               const container = document.getElementById('guixu-root-container');
               if (container) {
                   container.appendChild(overlay);
               } else {
                   document.body.appendChild(overlay);
               }
               
               // 关闭菜单函数
               const closeMenu = () => {
                   overlay.remove();
               };
               
               // 绑定事件
               document.getElementById('upload-local-btn').onclick = () => {
                   closeMenu();
                   const input = document.createElement('input');
                   input.type = 'file';
                   input.accept = 'image/*';
                   input.onchange = (event) => {
                       const file = event.target.files[0];
                       if (file) this.handleAvatarUpload(characterName, file);
                   };
                   input.click();
               };
               
               document.getElementById('select-from-gallery-btn').onclick = () => {
                   closeMenu();
                   this.showAvatarGalleryPicker(characterName);
               };
               
               document.getElementById('cancel-picker-btn').onclick = closeMenu;
               overlay.addEventListener('click', (e) => {
                   if (e.target === overlay) {
                       closeMenu();
                   }
               });
           },

           // 显示头像图库选择器
           async showAvatarGalleryPicker(characterName) {
                console.log('[归墟头像] 打开头像图库选择器 - 使用通用图库组件');
                
                // 使用通用图库组件
                await this.showUnifiedGalleryPicker({
                    title: `为 ${characterName} 选择头像`,
                    mode: 'avatar',
                    enablePagination: true,
                    pageSize: 20,
                    enableSourceSwitch: true,
                    enableLazyLoad: true,
                    onSelect: async (imageData) => {
                        console.log('[归墟头像] 选择了头像:', imageData);
                        await this.handleAvatarSelectFromGallery(characterName, imageData.dataUrl);
                    },
                    onClose: () => {
                        console.log('[归墟头像] 关闭头像选择器');
                    }
                });
            },
           
           // 从图库选择头像
           async handleAvatarSelectFromGallery(characterName, imageUrl) {
               try {
                   this.showTemporaryMessage('正在设置头像...', 'info');
                   
                   // 获取现有记录以保留透明度设置
                   const existingRecord = await this.getAvatarFromDB(characterName);
                   const backgroundOpacity = existingRecord ? existingRecord.backgroundOpacity : 0.5;
                   
                   // 创建新记录
                   const newRecord = {
                       characterName: characterName,
                       avatarImage: imageUrl,
                       backgroundImage: imageUrl,
                       backgroundOpacity: backgroundOpacity
                   };
                   
                   // 保存到数据库
                   await this.storeAvatarInDB(newRecord);
                   
                   this.showTemporaryMessage('头像设置成功！', 'success');
                   
                   // 关闭图库选择模态框
                   this.closeModal('avatar-gallery-picker-modal');
                   
                   // 刷新人物关系界面
                   if (document.getElementById('relationships-modal').style.display === 'flex') {
                       this.renderCharacterDetails(characterName);
                       this.renderCharacterList();
                   }
               } catch (error) {
                   console.error('[归墟头像] 从图库选择头像失败:', error);
                   this.showTemporaryMessage('设置头像失败', 'error');
               }
           },

// ===indexedDB人物关系/人物头像相关模块结束===



// ===归墟空间模块开始===



           async showGuixuSystem() {
            this.openModal('guixu-system-modal');
            try {
              if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                await this.loadMvuData();
                if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                  this.showTemporaryMessage('无法加载玩家数据，请刷新页面');
                  return;
                }
              }
              await this.renderGuixuCharacterDetails();
              this.bindGuixuSystemTabEvents();
              this.bindGuixuReincarnateButton();
              
              // 新增：动态设置全屏尺寸
              const rootContainer = document.querySelector('.guixu-root-container');
              const modalContent = document.querySelector('#guixu-system-modal .modal-content');
              if (rootContainer && modalContent) {
                  const rect = rootContainer.getBoundingClientRect();
                  modalContent.style.setProperty('width', `${rect.width}px`, 'important');
                  modalContent.style.setProperty('height', `${rect.height}px`, 'important');
                  modalContent.style.setProperty('top', `${rect.top}px`, 'important');
                  modalContent.style.setProperty('left', `${rect.left}px`, 'important');
                  modalContent.style.setProperty('max-width', 'none', 'important');
                  modalContent.style.setProperty('max-height', 'none', 'important');
              }
              
            } catch (error) {
              console.error('加载归墟系统时出错:', error);
              this.showTemporaryMessage('加载归墟系统失败');
            }
          },

          // === 归墟系统新函数 ===
          
          // 渲染人物详情Tab内容
          async renderGuixuCharacterDetails() {
            const stat_data = this.currentMvuState.stat_data;
            if (!stat_data) return;

            // 核心属性数据
            const currentFali = this.SafeGetValue(stat_data, '当前法力', 0);
            const maxFali = this.SafeGetValue(stat_data, '法力', 0);
            const currentShenhai = this.SafeGetValue(stat_data, '当前神海', 0);
            const maxShenhai = this.SafeGetValue(stat_data, '神海', 0);
            const currentDaoxin = this.SafeGetValue(stat_data, '当前道心', 0);
            const maxDaoxin = this.SafeGetValue(stat_data, '道心', 0);
            const currentKongsu = this.SafeGetValue(stat_data, '当前空速', 0);
            const maxKongsu = this.SafeGetValue(stat_data, '空速', 0);
            const currentXueliang = this.SafeGetValue(stat_data, '当前血量', 0);
            const maxXueliang = this.SafeGetValue(stat_data, '血量', 0);
            
            // 辅助属性数据
            const qiyun = this.SafeGetValue(stat_data, '气运', 0);
            const meili = this.SafeGetValue(stat_data, '魅力', 0);
            const wuxing = this.SafeGetValue(stat_data, '悟性', 0);
            const xianling = this.SafeGetValue(stat_data, '仙灵之气', 0);
            const age = this.SafeGetValue(stat_data, '年龄', 18);
            const lifespan = this.SafeGetValue(stat_data, '寿元', 70);
            const mentalAge = this.SafeGetValue(stat_data, '心理年龄', 18);
            const mentalAgeMax = this.SafeGetValue(stat_data, '心理年龄上限', 200);
            
            // 境界与修炼进度
            const currentRealm = this.SafeGetValue(stat_data, '当前境界', '练气一层');
            const cultivationProgress = this.SafeGetValue(stat_data, '修为进度', 0);
            const cultivationBottleneck = this.SafeGetValue(stat_data, '修为瓶颈', '无');
            
            // 当前状态
            const currentStatus = this.SafeGetValue(stat_data, '当前状态', {});
            
            // 灵根与天赋
            const linggenList = this.SafeGetValue(stat_data, '灵根列表', {});
            const talentList = this.SafeGetValue(stat_data, '天赋列表', {});
            
            // 当前百分比加成
            const bonusData = this.SafeGetValue(stat_data, '当前百分比加成', {});
            const bonusFali = this.SafeGetValue(bonusData, '法力', '0%');
            const bonusShenhai = this.SafeGetValue(bonusData, '神海', '0%');
            const bonusDaoxin = this.SafeGetValue(bonusData, '道心', '0%');
            const bonusKongsu = this.SafeGetValue(bonusData, '空速', '0%');
            const bonusXiulian = this.SafeGetValue(bonusData, '修炼速度', '0%');
            
            // 归墟信息数据
            const currentWorld = this.SafeGetValue(stat_data, '当前第x世', '1');
            const currentTime = this.SafeGetValue(stat_data, '当前时间纪年', '玄昊历1年1月1日');
            const guizhen = this.SafeGetValue(stat_data, '归真数', 100);
            const guixuPoint = this.SafeGetValue(stat_data, '归墟点', '10');
            
            // 计算战力
            const combatPower = Math.floor(maxFali * 0.5 + maxShenhai * 1 + maxKongsu * 2 + maxDaoxin * 2);
            
            // 更新境界与修炼进度（添加染色）
            const realmMatch = currentRealm.match(/^(\S{2})/);
            const realmTier = realmMatch ? realmMatch[1] : '';
            const realmStyle = this.getJingJieStyle(realmTier);
            const realmElement = document.getElementById('guixu-char-realm');
            realmElement.textContent = currentRealm;
            realmElement.style.cssText = realmStyle;
            
            document.getElementById('guixu-char-cultivation-percent').textContent = `${cultivationProgress}%`;
            document.getElementById('guixu-char-cultivation-fill').style.width = `${cultivationProgress}%`;
            document.getElementById('guixu-char-bottleneck').textContent = cultivationBottleneck;
            
            // 更新灵根显示
            const linggenNames = Object.keys(linggenList);
            const linggenText = linggenNames.length > 0
              ? linggenNames.map(name => {
                  const tier = linggenList[name]?.tier || '';
                  return tier ? `${name}(${tier})` : name;
                }).join('、')
              : '无';
            document.getElementById('guixu-char-linggen').textContent = linggenText;
            
            // 更新天赋显示
            const talentNames = Object.keys(talentList);
            const talentText = talentNames.length > 0
              ? talentNames.map(name => {
                  const tier = talentList[name]?.tier || '';
                  return tier ? `${name}(${tier})` : name;
                }).join('、')
              : '无';
            document.getElementById('guixu-char-talents').textContent = talentText;
            
            // 更新百分比加成显示
            document.getElementById('guixu-char-bonus-fali').textContent = `+${bonusFali}`;
            document.getElementById('guixu-char-bonus-shenhai').textContent = `+${bonusShenhai}`;
            document.getElementById('guixu-char-bonus-daoxin').textContent = `+${bonusDaoxin}`;
            document.getElementById('guixu-char-bonus-kongsu').textContent = `+${bonusKongsu}`;
            document.getElementById('guixu-char-bonus-xiulian').textContent = `+${bonusXiulian}`;
            
            // 更新当前状态显示
            this.renderCurrentStatus(currentStatus);
            
            // 更新战力显示（纯数字，不带逗号）
            document.getElementById('guixu-char-combat-power').textContent = combatPower;
            
            // 更新辅助属性显示（使用染色系统）
            document.getElementById('guixu-char-qiyun').innerHTML = this.getQiyunDisplayHTML(qiyun);
            document.getElementById('guixu-char-meili').innerHTML = this.getCharmDisplayHTML(meili);
            document.getElementById('guixu-char-wuxing').innerHTML = this.getWuxingDisplayHTML(wuxing);
            document.getElementById('guixu-char-xianling').textContent = xianling;
            document.getElementById('guixu-char-age-physical').textContent = `${age} / ${lifespan}`;
            document.getElementById('guixu-char-age-mental').textContent = `${mentalAge} / ${mentalAgeMax}`;
            
            // 更新归墟信息显示
            document.getElementById('guixu-char-time').textContent = currentTime;
            document.getElementById('guixu-char-world').textContent = `第 ${currentWorld} 世`;
            document.getElementById('guixu-char-guizhen').textContent = guizhen;
            document.getElementById('guixu-char-guixu-point').textContent = guixuPoint;
            
            // 渲染核心属性进度条
            this.renderGuixuAttributes(currentFali, maxFali, currentShenhai, maxShenhai, currentDaoxin, maxDaoxin, currentKongsu, maxKongsu);
            this.renderGuixuHealth(currentXueliang, maxXueliang);
          },
          // 渲染当前状态
          renderCurrentStatus(statusData) {
            const container = document.getElementById('guixu-char-current-status');
            if (!container) return;
            
            if (!statusData || typeof statusData !== 'object' || Object.keys(statusData).length === 0) {
              container.innerHTML = '<div class="current-status-placeholder" style="color: #8b7355; font-size: 12px; padding: 8px;">暂无状态</div>';
              return;
            }
            
            let html = '';
            const entries = Object.entries(statusData).filter(([key]) => key !== '$meta');
            
            entries.forEach(([statusName, statusInfo], index) => {
              const description = (typeof statusInfo === 'object' && statusInfo?.description) ? statusInfo.description : (typeof statusInfo === 'string' ? statusInfo : '无描述');
              html += `<div class="current-status-item">
                <div class="current-status-name">${statusName}</div>
                <div class="current-status-desc">${description}</div>
              </div>`;
              
              // 添加分割线，最后一项不添加
              if (index < entries.length - 1) {
                html += '<div class="current-status-divider2"></div>';
              }
            });
            
            if (html === '') {
              container.innerHTML = '<div class="current-status-placeholder" style="color: #8b7355; font-size: 12px; padding: 8px;">暂无状态</div>';
            } else {
              container.innerHTML = html;
            }
          },


          bindGuixuSystemTabEvents() {
            const tabBtns = document.querySelectorAll('.guixu-tab-btn');
            const tabContents = document.querySelectorAll('.guixu-tab-content');
            
            tabBtns.forEach(btn => {
              btn.addEventListener('click', async () => {
                const tabName = btn.dataset.tab;
                tabBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                tabContents.forEach(content => content.classList.remove('active'));
                const targetContent = document.getElementById(`guixu-tab-${tabName}`);
                if (targetContent) {
                  targetContent.classList.add('active');
                  if (tabName === 'gacha') {
                    await this.loadGachaIntoGuixu();
                  } else if (tabName === 'shop') {
                    await this.loadShopIntoGuixu();
                  } else if (tabName === 'character') {
                    await this.renderGuixuCharacterDetails();
                  }
                }
              });
            });
          },

                    async loadGachaIntoGuixu() {
            const container = document.getElementById('gacha-embedded-container');
            if (!container) return;
            
            // 检查MVU数据是否已加载
            if (!this.currentMvuState || !this.currentMvuState.stat_data) {
              container.innerHTML = '<p style="text-align:center; color:#8b7355; padding: 50px;">无法加载角色数据，请先开始游戏或发送一条消息以初始化状态。</p>';
              return;
            }
            
            // 创建内嵌的衍梦尘界面结构
            const poolInfo = {
              character: { title: '镜花水月', bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
              item: { title: '万象奇珍', bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
              talent: { title: '天命灵根', bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
            };
            
            const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, '归墟点', 0);
            
            // 构建卡池切换按钮
            let switcherHtml = '';
            for (const [poolType, data] of Object.entries(poolInfo)) {
              switcherHtml += `<button class="pool-switch-btn-embedded ${poolType === 'character' ? 'active' : ''}" data-pool="${poolType}" data-title="${data.title}" style="background-image: url('${data.bg}');"></button>`;
            }
            
            container.innerHTML = `
              <div class="gacha-embedded-wrapper">
                <div id="gacha-pool-display-embedded" class="gacha-pool-display-embedded"></div>
                <div class="gacha-embedded-header">
                  <div class="gacha-pool-switcher-embedded">${switcherHtml}</div>
                </div>
                <div class="gacha-currency-top-right">归墟点: <strong>${guixuPoints}</strong></div>
                <div class="gacha-embedded-controls">
                  <button id="btn-gacha-settings-embedded" class="gacha-corner-btn-embedded" title="设置">⚙️</button>
                  <button id="btn-gacha-gallery-embedded" class="gacha-corner-btn-embedded" title="图鉴">🖼️</button>
                </div>
              </div>
            `;
            
            // 绑定卡池切换事件
            container.querySelectorAll('.pool-switch-btn-embedded').forEach(btn => {
              btn.addEventListener('click', () => {
                container.querySelectorAll('.pool-switch-btn-embedded').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this._renderGachaPoolEmbedded(btn.dataset.pool);
              });
            });
            
            // 绑定按钮事件
            document.getElementById('btn-gacha-settings-embedded')?.addEventListener('click', () => this.showGachaSettingsPopup());
            document.getElementById('btn-gacha-gallery-embedded')?.addEventListener('click', () => this.showGachaGalleryPopup(this.currentGachaPoolType || 'character'));
            
            // 渲染默认卡池
            this._renderGachaPoolEmbedded('character');
          },
          async loadShopIntoGuixu() {
            const container = document.getElementById('shop-embedded-container');
            if (!container) return;
            
            // 检查MVU数据
            if (!this.currentMvuState || !this.currentMvuState.stat_data) {
              container.innerHTML = '<p style="text-align:center; color:#8b7355; padding: 20px;">正在加载玩家数据...</p>';
              await this.loadMvuData();
              if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                container.innerHTML = '<p style="text-align:center; color:#8b7355; padding: 20px;">无法加载玩家数据，请刷新页面</p>';
                return;
              }
            }
            
            // 加载商品
            if (!this.guixuStoreItems || this.guixuStoreItems.length === 0) {
              container.innerHTML = '<p style="text-align:center; color:#8b7355; padding: 20px;">正在从世界书中加载商品...</p>';
              const allItems = await this.loadGuixuStoreItems();
              this.guixuStoreItems = allItems;
            }
            
            // 渲染归墟空间界面
            this._renderGuixuSpaceEmbedded(container);
          },

          // 内嵌版本的衍梦尘卡池渲染
          _renderGachaPoolEmbedded(poolType) {
            this.currentGachaPoolType = poolType;
            const displayContainer = document.getElementById('gacha-pool-display-embedded');
            if (!displayContainer) return;
            
            const poolData = {
              character: { title: '镜花水月 (角色池)', cost: 320, pitySSR: this.gachaState.pitySSR_char, pitySR: this.gachaState.pitySR_char, bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
              item: { title: '万象奇珍 (道具池)', cost: 160, pitySSR: this.gachaState.pitySSR_item, pitySR: this.gachaState.pitySR_item, bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
              talent: { title: '天命灵根 (天赋池)', cost: 160, pitySSR: this.gachaState.pitySSR_talent, pitySR: this.gachaState.pitySR_talent, bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
            };
            const currentPool = poolData[poolType];
            
            displayContainer.innerHTML = `
              <div class="summon-container-embedded" style="background-image: url('${currentPool.bg}');">
                <div class="summon-container-overlay"></div>
                <div class="summon-header-info-embedded"></div>
                <div class="summon-main-controls-embedded">
                  <h3 class="pool-title">${currentPool.title}</h3>
                  <p style="font-size:12px; color:#a09c91;">SSR保底: ${currentPool.pitySSR}/90 | SR保底: ${currentPool.pitySR}/10</p>
                  <div class="summon-buttons">
                    <button id="gacha-pull-1-embedded" class="interaction-btn">召唤1次 (${currentPool.cost} 梦尘)</button>
                    <button id="gacha-pull-10-embedded" class="interaction-btn primary-btn">召唤10次 (${currentPool.cost * 10} 梦尘)</button>
                  </div>
                </div>
              </div>
            `;
            
            document.getElementById('gacha-pull-1-embedded')?.addEventListener('click', () => this.handlePull(1, poolType));
            document.getElementById('gacha-pull-10-embedded')?.addEventListener('click', () => this.handlePull(10, poolType));
          },
          
          // 内嵌版本的归墟空间渲染
          _renderGuixuSpaceEmbedded(container) {
            const filterType = this.currentGuixuFilter || '全部';
            let filteredItems = filterType === '全部' ? this.guixuStoreItems : this.guixuStoreItems.filter(item => item.type === filterType);
            
            // 应用排序
            switch (this.currentGuixuSort) {
              case '品阶 (高到低)':
                filteredItems = this.sortByTier(filteredItems, item => item.tier);
                break;
              case '品阶 (低到高)':
                filteredItems = this.sortByTier(filteredItems, item => item.tier).reverse();
                break;
              case '点数 (高到低)':
                filteredItems.sort((a, b) => b.price - a.price);
                break;
              case '点数 (低到高)':
                filteredItems.sort((a, b) => a.price - b.price);
                break;
            }
            
            const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, '归墟点', 0);
            const filters = ['全部', '天赋', '背景'];
            const sorts = ['默认', '品阶 (高到低)', '品阶 (低到高)', '点数 (高到低)', '点数 (低到高)'];
            
            const headerHtml = `
              <div class="guixu-space-header-embedded">
                <div class="guixu-filter-tabs">
                  ${filters.map(f => `<button class="tab-btn ${filterType === f ? 'active' : ''}" data-filter="${f}">${f}</button>`).join('')}
                </div>
                <div class="guixu-controls">
                  <select class="guixu-sort-select">
                    ${sorts.map(s => `<option value="${s}" ${this.currentGuixuSort === s ? 'selected' : ''}>${s}</option>`).join('')}
                  </select>
                  <div class="points-display">
                    <span>归墟点: ${guixuPoints}</span>
                  </div>
                </div>
              </div>
            `;
            
            let itemsHtml = '';
            if (filteredItems && filteredItems.length > 0) {
              filteredItems.forEach((item, index) => {
                const tierStyle = this.getItemTierStyle(item.tier);
                const canAfford = guixuPoints >= item.price;
                itemsHtml += `
                  <div class="guixu-item-card" style="animation-delay: ${index * 0.05}s;">
                    <div class="item-content">
                      <h4 class="item-name" style="${tierStyle}">
                        ${item.name}
                        <span class="item-tier">${item.tier}</span>
                      </h4>
                      <p class="item-description">${item.description}</p>
                    </div>
                    <div class="item-footer">
                      <span class="item-price">${item.price} 点</span>
                      <button class="purchase-btn" data-item-id="${item.id}" ${!canAfford ? 'disabled' : ''}>购买</button>
                    </div>
                  </div>
                `;
              });
            } else {
              itemsHtml = '<p class="modal-placeholder">暂无此类商品</p>';
            }
            
            container.innerHTML = headerHtml + `<div class="guixu-item-grid-embedded">${itemsHtml}</div>`;
            
            // 绑定事件
            container.querySelectorAll('.tab-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                this.currentGuixuFilter = btn.dataset.filter;
                this._renderGuixuSpaceEmbedded(container);
              });
            });
            
            container.querySelector('.guixu-sort-select')?.addEventListener('change', (e) => {
              this.currentGuixuSort = e.target.value;
              this._renderGuixuSpaceEmbedded(container);
            });
            
            container.querySelectorAll('.purchase-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                if (!btn.disabled) {
                  this.handlePurchase(btn.dataset.itemId);
                } else {
                  this.showTemporaryMessage('归墟点不足');
                }
              });
            });
          },

          
          // 渲染天赋和灵根(带品阶染色)
          renderGuixuTalentAndLinggen(talentList, linggenList) {
            const container = document.getElementById('guixu-char-talent-container');
            if (!container) return;
            
            let html = '';
            
            const linggenEntries = Object.entries(linggenList).filter(([name]) => name !== '$meta');
            if (linggenEntries.length > 0) {
              const sortedLinggen = this.sortByTier(linggenEntries, ([, linggen]) => 
                this.SafeGetValue(linggen, 'tier', '凡品')
              );
              
              sortedLinggen.forEach(([name, linggen]) => {
                const tier = this.SafeGetValue(linggen, 'tier', '凡品');
                const description = this.SafeGetValue(linggen, 'description', '无描述');
                const tierStyle = this.getItemTierStyle(tier);
                
                html += `
                  <details class="details-container" style="margin-bottom: 8px;">
                    <summary style="cursor: pointer; padding: 8px; background: rgba(201, 170, 113, 0.1); border-radius: 4px;">
                      <span style="color: #c9aa71;">【灵根】</span>
                      <span style="${tierStyle}">【${tier}】${name}</span>
                    </summary>
                    <div style="padding: 10px; font-size: 13px; color: #e8dcc6; line-height: 1.6;">
                      ${description}
                    </div>
                  </details>
                `;
              });
            } else {
              html += `<div style="padding: 8px; color: #8b7355; font-size: 13px;">灵根: 未觉醒</div>`;
            }
            
            const tianfuEntries = Object.entries(talentList).filter(([name]) => name !== '$meta');
            if (tianfuEntries.length > 0) {
              const sortedTianfu = this.sortByTier(tianfuEntries, ([, tianfu]) =>
                this.SafeGetValue(tianfu, 'tier', '凡品')
              );
              
              sortedTianfu.forEach(([name, tianfu]) => {
                const tier = this.SafeGetValue(tianfu, 'tier', '凡品');
                const description = this.SafeGetValue(tianfu, 'description', '无描述');
                const tierStyle = this.getItemTierStyle(tier);
                
                html += `
                  <details class="details-container" style="margin-bottom: 8px;">
                    <summary style="cursor: pointer; padding: 8px; background: rgba(201, 170, 113, 0.1); border-radius: 4px;">
                      <span style="color: #c9aa71;">【天赋】</span>
                      <span style="${tierStyle}">【${tier}】${name}</span>
                    </summary>
                    <div style="padding: 10px; font-size: 13px; color: #e8dcc6; line-height: 1.6;">
                      ${description}
                    </div>
                  </details>
                `;
              });
            } else {
              html += `<div style="padding: 8px; color: #8b7355; font-size: 13px;">天赋: 未觉醒</div>`;
            }
            
            container.innerHTML = html;
          },
          
          // 渲染四维属性(带进度条)
          renderGuixuAttributes(currentFali, maxFali, currentShenhai, maxShenhai, currentDaoxin, maxDaoxin, currentKongsu, maxKongsu) {
            const container = document.getElementById('guixu-char-attributes-container');
            if (!container) return;
            
            let html = '';
            html += this.getAttributeProgressHTML(currentFali, maxFali, '法力');
            html += this.getAttributeProgressHTML(currentShenhai, maxShenhai, '神海');
            html += this.getAttributeProgressHTML(currentDaoxin, maxDaoxin, '道心');
            html += this.getAttributeProgressHTML(currentKongsu, maxKongsu, '空速');
            
            container.innerHTML = html;
          },
          
          // 渲染血量(带进度条)
          renderGuixuHealth(currentXueliang, maxXueliang) {
            const container = document.getElementById('guixu-char-health-container');
            if (!container) return;
            
            const html = this.getAttributeProgressHTML(currentXueliang, maxXueliang, '血量');
            container.innerHTML = html;
          },

          bindGuixuReincarnateButton() {
            const reincarnateBtn = document.getElementById('btn-guixu-reincarnate');
            if (!reincarnateBtn) return;
            const newBtn = reincarnateBtn.cloneNode(true);
            reincarnateBtn.parentNode.replaceChild(newBtn, reincarnateBtn);
            newBtn.addEventListener('click', async () => {
              const stat_data = this.currentMvuState.stat_data;
              const chargeTime = this.SafeGetValue(stat_data, '归真数', 0);
              if (chargeTime >= 1) {
                this.showCustomConfirm('你确定要归墟吗？', async () => {
                  try {
                    const command = '<user>选择归墟，世界将回到最初的锚点';
                    await this.handleAction(command);
                    this.showTemporaryMessage('轮回已开启...');
                    this.closeAllModals();
                  } catch (error) {
                    console.error('执行归墟指令时出错:', error);
                    this.showTemporaryMessage('执行归墟指令失败！');
                  }
                });
              } else {
                this.showTemporaryMessage('杂鱼！归真数不够了！');
              }
            });
          },

          YAMLParser: {
            parse: function (text) {
              if (!text || typeof text !== 'string') return {};
              const lines = text.split('\n');
              const result = {};
              const stack = [{ indent: -1, obj: result, lastKey: null }];

              for (const line of lines) {
                  const trimmed = line.trim();
                  if (!trimmed || trimmed.startsWith('#')) continue;

                  const indent = line.search(/\S/);

                  while (stack.length > 1 && indent <= stack[stack.length - 1].indent) {
                      stack.pop();
                  }
                  const parent = stack[stack.length - 1].obj;
                  let lastKeyInParent = stack[stack.length - 1].lastKey;

                  if (trimmed.startsWith('- ')) {
                      const value = trimmed.substring(2).trim();
                      if (lastKeyInParent && Array.isArray(parent[lastKeyInParent])) {
                          parent[lastKeyInParent].push(this._parseValue(value));
                      }
                  } else {
                      const colonIndex = trimmed.indexOf(':');
                      if (colonIndex > -1) {
                          const key = trimmed.substring(0, colonIndex).trim();
                          let value = trimmed.substring(colonIndex + 1).trim();
                          
                          stack[stack.length - 1].lastKey = key;

                          if (value === '|' || value === '>') {
                              let multiline = '';
                              const blockStartIndex = lines.indexOf(line) + 1;
                              for (let i = blockStartIndex; i < lines.length; i++) {
                                  const nextLine = lines[i];
                                  const nextIndent = nextLine.search(/\S/);
                                  if (nextLine.trim() === '' || nextIndent > indent) {
                                      multiline += nextLine.substring(indent + 2) + '\n';
                                  } else {
                                      break;
                                  }
                              }
                              parent[key] = multiline.trim();
                          } else if (value === '') {
                               const nextLine = lines[lines.indexOf(line) + 1] || '';
                               const nextTrimmed = nextLine.trim();
                               const nextIndent = nextLine.search(/\S/);
                               if (nextTrimmed.startsWith('- ') && nextIndent > indent) {
                                   const newArr = [];
                                   parent[key] = newArr;
                               } else if (nextIndent > indent) {
                                   const newObj = {};
                                   parent[key] = newObj;
                                   stack.push({ indent: indent, obj: newObj, lastKey: null });
                               } else {
                                   parent[key] = '';
                               }
                          } else {
                              parent[key] = this._parseValue(value);
                          }
                      }
                  }
              }
              return result;
            },
            _parseValue: function (val) {
              const numVal = Number(val);
              if (!isNaN(numVal) && val.trim() !== '') {
                return numVal;
              }
              if (val === 'true') return true;
              if (val === 'false') return false;
              return val;
            },
          },

// 【归墟空间：加载商品】
          async loadGuixuStoreItems() {
            try {
              if (typeof TavernHelper === 'undefined' || typeof TavernHelper.getGlobalWorldbookNames !== 'function' || typeof TavernHelper.getWorldbook !== 'function') {
                console.error('TavernHelper API not available.');
                this.showTemporaryMessage('错误：世界书API不可用');
                return [];
              }

              // 1. 获取所有启用的世界书名称
              const enabledBookNames = TavernHelper.getGlobalWorldbookNames();
              
              // 2. 筛选出目标世界书名称
              let targetBookNames = enabledBookNames.filter(name => name.startsWith('【归墟扩展】'));
              
              // 3. 添加 '1归墟' 并去重
              if (!targetBookNames.includes('1归墟')) {
                  targetBookNames.push('1归墟');
              }
              
              let allEntries = [];
              for (const bookName of targetBookNames) {
                  try {
                      const entries = await TavernHelper.getWorldbook(bookName);
                      allEntries.push(...entries);
                  } catch (e) {
                      console.warn(`无法加载世界书 "${bookName}" 的内容:`, e);
                  }
              }

              if (allEntries.length === 0) {
                console.warn('在目标世界书中未找到任何条目。');
                return [];
              }

              const validItemPrefixes = ['【天赋】', '【背景】'];
              const itemEntries = allEntries.filter(entry => {
                return validItemPrefixes.some(prefix => entry.name.startsWith(prefix));
              });

              if (itemEntries.length === 0) {
                  console.log('在目标世界书中未找到符合商品前缀的条目。');
                  return [];
              }
              
              const items = itemEntries.map(entry => {
                try {
                  const parsedContent = this.YAMLParser.parse(entry.content);
                  // 修复：兼容“价格”和“消耗点数”两种字段，并提供默认值
                  const priceValue = parsedContent.价格 ?? parsedContent.消耗点数 ?? 0;
                  const price = parseInt(priceValue, 10);

                  const itemId = `gs-item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                  return {
                    id: itemId,
                    name: parsedContent.名称 || entry.name.replace(/【.*?】/g, '').trim(),
                    price: price,
                    description: parsedContent.描述 || '暂无描述',
                    type: parsedContent.类型 || entry.name.match(/【(.*?)】/)?.[1] || '物品',
                    tier: parsedContent.品阶 || '凡品',
                    fullContent: entry.content,
                  };
                } catch (e) {
                  console.error(`解析世界书条目 "${entry.name}" 时出错:`, e);
                  return null;
                }
              }).filter(item => item !== null);

              return items;

            } catch (error) {
              console.error('加载归墟空间商品时出错:', error);
              this.showTemporaryMessage('加载商品失败');
              return [];
            }
          },

          currentGuixuSort: '默认',
          guixuItemDOMElements: {}, // 新增：用于缓存DOM元素
          // --- 归墟空间：主界面 ---
          async showGuixuSpace(filterType = '全部', isUpdate = false) {
            this.currentGuixuFilter = filterType;
            this.openModal('guixu-space-modal', true);
            const body = document.querySelector('#guixu-space-modal .modal-body');
            if (!body) return;

            // --- 性能优化：仅在首次加载时完全重绘 ---
            if (!isUpdate) {
               if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                   body.innerHTML = '<p class="modal-placeholder">正在加载玩家数据...</p>';
                   await this.loadMvuData();
                   if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                       this.showTemporaryMessage('无法加载玩家数据，请刷新页面');
                       return;
                   }
               }

               body.innerHTML = '<p class="modal-placeholder">正在从世界书中加载商品...</p>';
               const allItems = await this.loadGuixuStoreItems();
               this.guixuStoreItems = allItems;
               this.guixuItemDOMElements = {}; // 清空缓存
            }

            let filteredItems = filterType === '全部' ? this.guixuStoreItems : this.guixuStoreItems.filter(item => item.type === filterType);

            switch (this.currentGuixuSort) {
               case '品阶 (高到低)':
                   filteredItems = this.sortByTier(filteredItems, item => item.tier);
                   break;
               case '品阶 (低到高)':
                   filteredItems = this.sortByTier(filteredItems, item => item.tier).reverse();
                   break;
               case '点数 (高到低)':
                   filteredItems.sort((a, b) => b.price - a.price);
                   break;
               case '点数 (低到高)':
                   filteredItems.sort((a, b) => a.price - b.price);
                   break;
            }

            const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, '归墟点', 0);
            
//【性能优化：仅在首次加载时渲染Header和Grid容器】

            if (!isUpdate) {
               const filters = ['全部', '天赋', '背景'];
               const sorts = ['默认', '品阶 (高到低)', '品阶 (低到高)', '点数 (高到低)', '点数 (低到高)'];
               const headerHtml = `
                 <div class="guixu-space-header">
                   <div class="guixu-filter-tabs">
                     ${filters.map(f => `<button class="tab-btn ${filterType === f ? 'active' : ''}" data-filter="${f}">${f}</button>`).join('')}
                   </div>
                   <div class="guixu-controls">
                      <select class="guixu-sort-select">
                          ${sorts.map(s => `<option value="${s}" ${this.currentGuixuSort === s ? 'selected' : ''}>${s}</option>`).join('')}
                      </select>
                      <div class="points-display">
                        <span>归墟点: ${guixuPoints}</span>
                      </div>
                   </div>
                 </div>`;
               body.innerHTML = headerHtml + '<div class="guixu-item-grid"></div><p class="modal-placeholder" style="display:none;">暂无此类商品</p>';
               this.bindGuixuSpaceEvents(body);
            }
            
  // 【性能优化：DOM复用和局部更新】

            const grid = body.querySelector('.guixu-item-grid');
            const placeholder = body.querySelector('.modal-placeholder');
            if (!grid || !placeholder) return;

            // 更新UI状态
            body.querySelectorAll('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.filter === filterType));
            body.querySelector('.guixu-sort-select').value = this.currentGuixuSort;
            body.querySelector('.points-display span').textContent = `归墟点: ${guixuPoints}`;

            if (!filteredItems || filteredItems.length === 0) {
                grid.innerHTML = '';
                placeholder.style.display = 'block';
                return;
            }
            
            placeholder.style.display = 'none';

            const fragment = document.createDocumentFragment();
            
            // 创建或更新DOM元素
            filteredItems.forEach((item, index) => {
               let card = this.guixuItemDOMElements[item.id];
               if (!card) {
                   const tierStyle = this.getItemTierStyle(item.tier);
                   const cardHtml = `
                       <div class="item-content">
                         <h4 class="item-name" style="${tierStyle}">
                           ${item.name}
                           <span class="item-tier">${item.tier}</span>
                         </h4>
                         <p class="item-description">${item.description}</p>
                       </div>
                       <div class="item-footer">
                         <span class="item-price">${item.price} 点</span>
                         <button class="purchase-btn" data-item-id="${item.id}"></button>
                       </div>`;
                   card = document.createElement('div');
                   card.className = 'guixu-item-card';
                   card.innerHTML = cardHtml;
                   this.guixuItemDOMElements[item.id] = card;
               }
               
               // 更新动态内容
               card.style.animationDelay = `${index * 0.05}s`;
               const purchaseBtn = card.querySelector('.purchase-btn');
               purchaseBtn.disabled = guixuPoints < item.price;
               purchaseBtn.textContent = '购买';
               
               fragment.appendChild(card);
            });
          
            grid.innerHTML = ''; // 清空
            grid.appendChild(fragment); // 附加
          },

          bindGuixuSpaceEvents(container) {

// 【 分离click和change事件处理器，解决点击即刷新的bug】

              const clickHandler = (event) => {
                  const target = event.target;
                  if (target.classList.contains('purchase-btn')) {
                      if (target.disabled) {
                          this.showTemporaryMessage('归墟点不足');
                          return;
                      }
                      const itemId = target.dataset.itemId;
                      this.handlePurchase(itemId);
                  } else if (target.classList.contains('tab-btn')) {
                      const filter = target.dataset.filter;
                      this.showGuixuSpace(filter, true);
                  }
              };

              const changeHandler = (event) => {
                  const target = event.target;
                  if (target.classList.contains('guixu-sort-select')) {
                      this.currentGuixuSort = target.value;
                      this.showGuixuSpace(this.currentGuixuFilter, true);
                  }
              };

              if (!this.guixuEventHandlers) {
                  this.guixuEventHandlers = new WeakMap();
              }

              if (this.guixuEventHandlers.has(container)) {
                  const oldHandlers = this.guixuEventHandlers.get(container);
                  container.removeEventListener('click', oldHandlers.click);
                  container.removeEventListener('change', oldHandlers.change);
              }

              container.addEventListener('click', clickHandler);
              container.addEventListener('change', changeHandler);
              
              this.guixuEventHandlers.set(container, {
                  click: clickHandler,
                  change: changeHandler
              });
          },

          // 归墟空间UI静默刷新
          _silentUpdateGuixuSpaceUI() {
              const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, '归墟点', 0);
              const modalBody = document.querySelector('#guixu-space-modal .modal-body');
              if (!modalBody) return;

              // 1. 更新归墟点显示
              const pointsDisplay = modalBody.querySelector('.points-display span');
              if (pointsDisplay) {
                  pointsDisplay.textContent = `归墟点: ${guixuPoints}`;
              }

              // 2. 更新所有购买按钮的状态
              this.guixuStoreItems.forEach(item => {
                  const purchaseBtn = modalBody.querySelector(`button[data-item-id="${item.id}"]`);
                  if (purchaseBtn) {
                      purchaseBtn.disabled = guixuPoints < item.price;
                  }
              });
              console.log('[归墟空间] UI静默刷新完成');
          },


          // 归墟空间：处理购买
          async handlePurchase(itemId) {
              const item = this.guixuStoreItems.find(i => i.id === itemId);
              if (!item) {
                  console.error('找不到要购买的商品:', itemId);
                  return;
              }

              const currentPoints = parseInt(this.SafeGetValue(this.currentMvuState.stat_data, '归墟点', 0), 10);

              if (currentPoints < item.price) {
                  this.showTemporaryMessage('归墟点不足');
                  return;
              }

              const confirmMessage = `确定要花费 ${item.price} 归墟点购买【${item.name}】吗？`;

              this.showCustomConfirm(confirmMessage, async () => {
                  try {
                      // --- MVU API 重构开始 ---
                      // 1. 获取最新的“本地草稿”
                      const mvuData = this.currentMvuState;
                      if (!mvuData) {
                          this.showTemporaryMessage('发生内部错误，购买失败', 'error');
                          return;
                      }

                      // 2. 在“本地草稿”上进行原子化修改
                      const path = '归墟点';
                      const currentPoints = parseInt(Mvu.getMvuVariable(mvuData, path, { default_value: 0 }), 10);
                      await Mvu.setMvuVariable(mvuData, path, currentPoints - item.price, { reason: `购买 ${item.name}` });
                      console.log(`[归墟空间] 本地归墟点已更新为: ${Mvu.getMvuVariable(mvuData, path)}`); // 调试日志

                      // 3. 将修改后的“本地草稿”同步回“云端正本”
                      await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });
                      // 4. 构建后续指令并更新UI
                      const gainMessage = `<user>购买了${item.name}，详细信息：\n${item.fullContent}`;
                      this.addCommand(gainMessage);
                      this.savePendingActions();
                      
                      this.showTemporaryMessage(`购买【${item.name}】成功！！！好欸！！！`,`success`);
                      this._silentUpdateGuixuSpaceUI(); // 静默刷新UI,不跳转

                  } catch (error) {
                      console.error('购买过程中发生错误:', error);
                      this.showTemporaryMessage(`购买失败: ${error.message}`);
                  }
              }, null, true, { customClass: 'guixu-confirm-modal' });
          },



// ===归墟空间模块结束===



// ===模态框模块（极为重要）开始===




          openModal(modalId, keepOpen = false) {
            if (!keepOpen) {
                this.closeAllModals();
            }
            const modal = document.getElementById(modalId);
            if (modal) {
                const rootContainer = document.querySelector('.guixu-root-container');
                if (rootContainer && modal.parentNode !== rootContainer) {
                    // 如果是，则将其移动到根容器的末尾，以确保它在全屏时可见
                    rootContainer.appendChild(modal);
                }

                modal.style.display = 'flex';
                if (keepOpen) {
                    const highestZ = Array.from(document.querySelectorAll('.modal-overlay'))
                        .filter(el => el.style.display === 'flex' && el.id !== modalId)
                        .reduce((maxZ, el) => Math.max(maxZ, parseInt(window.getComputedStyle(el).zIndex, 10) || 1000), 1000);
                    modal.style.zIndex = highestZ + 1;
                } else {
                    modal.style.zIndex = ''; 
                }
              
                this.applyModalSizeToModal(modal);

            }
          },

          // 新增：为特定模态框应用大小设置
          applyModalSizeToModal(modal) {
              try {
                  // 核心：如果模态框是定制化确认框，则跳过全局大小调整
                  if (modal.classList.contains('guixu-confirm-modal')) {
                      return;
                  }
                  const savedState = localStorage.getItem('guixu_modal_size');
                  // 豁免人物关系模态框、归墟系统模态框、设置模态框、世界大事模态框和背包模态框，它们的尺寸由其内部CSS控制
                  if (savedState && modal.id !== 'relationships-modal' && modal.id !== 'guixu-system-modal' && modal.id !== 'settings-modal' && modal.id !== 'world-events-modal' && modal.id !== 'inventory-modal') {
                      const { width, height } = JSON.parse(savedState);
                      if (width && height) {
                          const modalContent = modal.querySelector('.modal-content');
                          if (modalContent) {
                              modalContent.style.maxWidth = `${width}px`;
                              modalContent.style.width = `${Math.min(width, window.innerWidth * 0.9)}px`;
                              modalContent.style.height = `${Math.min(height, window.innerHeight * 0.9)}px`;
                              modalContent.style.maxHeight = `${Math.min(height, window.innerHeight * 0.9)}px`;
                              modalContent.style.overflow = 'auto';
                          }
                      }
                  }
              } catch (e) {
                  console.error('应用模态框大小设置失败:', e);
              }
          },

          closeModal(modalId) {
              const modal = document.getElementById(modalId);
              if (modal) {
                  modal.style.display = 'none';
                  modal.style.zIndex = ''; // Reset z-index

              }
          },

          // 【重要：处理模态框关闭的统一方法】
           handleModalClose(event) {
            const modalOverlay = event.target.closest('.modal-overlay');

           if (modalOverlay && modalOverlay.id === 'guixu-space-modal') {
               this.closeModal('guixu-space-modal');
               this.openModal('guixu-system-modal');
               return;
           }

            // 衍梦尘子窗口关闭逻辑修改
            if (modalOverlay && (modalOverlay.id === 'gacha-results-modal' || modalOverlay.id === 'gacha-history-modal' || modalOverlay.id === 'gacha-details-modal' || modalOverlay.id === 'gacha-gallery-popup' || modalOverlay.id === 'gacha-settings-popup')) {
        this.closeModal(modalOverlay.id); // 只关闭当前子窗口
                 // 核心修复：如果关闭的是召唤结果窗口，则刷新召唤主界面
                if (modalOverlay.id === 'gacha-results-modal') {
                    this.renderSummonTab(this.currentGachaPoolType);
                }
                return;
            }

            // 新增：人物关系界面关闭逻辑 - 检查是否有其他模态框打开
            if (modalOverlay && modalOverlay.id === 'relationships-modal') {
                // 检查是否有其他模态框在下层（如宗门界面）
                const otherModals = Array.from(document.querySelectorAll('.modal-overlay'))
                    .filter(el => el.style.display === 'flex' && el.id !== 'relationships-modal');
                
                if (otherModals.length > 0) {
                    // 有其他模态框打开，只关闭人物关系界面
                    this.closeModal('relationships-modal');
                    return;
                }
                // 没有其他模态框，执行默认关闭逻辑（关闭所有）
            }

            // 衍梦尘主窗口关闭逻辑
            if (modalOverlay && modalOverlay.id === 'gacha-modal') {
                // 检查是否从归墟系统进入
                if (this.isFromGuixuSystem) {
                    this.closeModal(modalOverlay.id); // 关闭gacha主窗口
                    this.showGuixuSystem(); // 返回归墟系统界面
                    this.isFromGuixuSystem = false; // 重置标志
                    return; // 结束处理
                }
                // 如果不是从归墟系统进入，则会执行下面的默认关闭逻辑
            }

            // 新增：处理从设置界面打开的窗口的返回逻辑
            if (this.isFromSettingsModal) {
                this.closeModal(modalOverlay.id);
                this.showSettings();
                this.isFromSettingsModal = false; // 重置标志
                return;
            }

            if (!modalOverlay) {
              this.closeAllModals();
              return;
            }

            const modalId = modalOverlay.id;
            
            // 特殊处理格式验证模态框关闭
            if (modalId === 'format-validation-modal') {
              // 关闭等待消息
              this.hideWaitingMessage();
              // 填充原始内容而不是清空
              const gameTextDisplay = document.getElementById('game-text-display');
              if (gameTextDisplay && this.lastValidGametxtHTML) {
                gameTextDisplay.innerHTML = this.lastValidGametxtHTML;
                this.updateLiveWordCount(); // 新增：调用字数统计函数
              }
              this.closeModal(modalId);
              this.showTemporaryMessage('已取消格式验证，内容已恢复。');
              return;
            }
            
            // 特殊处理：系列管理模态框关闭后返回存档界面
            if (modalId === 'series-manager-modal') {
              this.closeModal(modalId);
              this.showNewSaveLoadManager(); // 返回存档界面
              return;
            }

            // 检查是否是从设置界面进入的子窗口
            if (this.isFromSettingsModal &&
                (modalId === 'command-center-modal' ||
                 modalId === 'extracted-content-modal' ||
                 modalId === 'map-modal' ||
                 modalId === 'background-settings-modal' ||
                 modalId === 'worldbook-manager-modal' ||
                 modalId === 'segmented-memory-modal')) { // 新增对分段记忆模态框的判断
              // 关闭当前子窗口并返回设置界面
              this.closeModal(modalId);
              this.isFromSettingsModal = false; // 重置状态
              this.showSettings();
            } else {
              // 正常关闭所有模态框
              this.closeAllModals();
            }
          },

          closeAllModals() {
            document.querySelectorAll('.modal-overlay').forEach(modal => {
              modal.style.display = 'none';
            });
           this.hideWindowSizePanel();
          },

          showCustomConfirm(message, onConfirm, onCancel = null, keepCurrentModal = false, options = {}) {
            const modal = document.getElementById('custom-confirm-modal');
            const messageEl = document.getElementById('custom-confirm-message');
            const okBtn = document.getElementById('custom-confirm-btn-ok');
            const cancelBtn = document.getElementById('custom-confirm-btn-cancel');
            const closeBtn = modal?.querySelector('.modal-close-btn');

            if (!modal || !messageEl || !okBtn || !cancelBtn) return;

            // --- 新增：处理自定义样式类 ---
            if (options.customClass) {
                modal.classList.add(options.customClass);
            }

            messageEl.textContent = message;
            const newOkBtn = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);

            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            const closeAction = () => {
                // --- 新增：清理自定义样式类 ---
                if (options.customClass) {
                    modal.classList.remove(options.customClass);
                }
                if (keepCurrentModal) {
                    this.closeModal('custom-confirm-modal');
                    // 如果是从预设管理界面进入的，返回预设管理界面
                    if (this.isFromWorldbookManager) {
                        this.showWorldbookPresets();
                    }
                } else {
                    this.closeAllModals();
                }
            };

            newOkBtn.addEventListener('click', () => {
              closeAction();
              if (typeof onConfirm === 'function') {
                onConfirm();
              }
            });

            newCancelBtn.addEventListener('click', () => {
              closeAction();
              if (typeof onCancel === 'function') {
                onCancel();
              }
            });

            // 处理关闭按钮（×）
            if (closeBtn) {
              closeBtn.onclick = () => {
                closeAction();
                if (typeof onCancel === 'function') {
                  onCancel();
                }
              };
            }

            this.openModal('custom-confirm-modal', keepCurrentModal);
          },


// ===模态框模块（极为重要）结束===



// ===任务系统模块开始===



          // 任务系统：初始化
          initQuestSystem() {
              // 绑定状态筛选按钮事件
              const statusTabs = document.querySelectorAll('.quest-status-tabs .panel-tab-btn');
              statusTabs.forEach(btn => {
                  btn.addEventListener('click', (e) => {
                      statusTabs.forEach(b => b.classList.remove('active'));
                      e.target.classList.add('active');
                      const status = e.target.getAttribute('data-status');
                      this.renderQuestList(status);
                  });
              });

              // 初始渲染
              const activeStatus = document.querySelector('.quest-status-tabs .panel-tab-btn.active');
              const initialStatus = activeStatus ? activeStatus.getAttribute('data-status') : 'unfinished';
              this.renderQuestList(initialStatus);
          },

          // 任务系统：渲染任务列表
          renderQuestList(statusFilter = 'unfinished') {
              const container = document.getElementById('quest-list-container');
              if (!container) return;

              const mvuData = this.currentMvuState;
              if (!mvuData || !mvuData.stat_data) {
                  container.innerHTML = `
                      <div class="quest-placeholder">
                          <div class="placeholder-icon">📜</div>
                          <div class="placeholder-text">暂无任务</div>
                          <div class="placeholder-desc">完成主线剧情可获得任务</div>
                      </div>
                  `;
                  this.updateQuestBadges({});
                  return;
              }

              const questList = this.SafeGetValue(mvuData.stat_data, '任务列表', {});
              const quests = Object.entries(questList).filter(([key]) => key !== '$meta');

              if (quests.length === 0) {
                  container.innerHTML = `
                      <div class="quest-placeholder">
                          <div class="placeholder-icon">📜</div>
                          <div class="placeholder-text">暂无任务</div>
                          <div class="placeholder-desc">完成主线剧情可获得任务</div>
                      </div>
                  `;
                  this.updateQuestBadges({});
                  return;
              }

              // 筛选任务
              const filteredQuests = quests.filter(([_, quest]) => {
                  const status = quest['任务状态'] || '未接取';
                  if (statusFilter === 'unclaimed') {
                      return status === '未接取';
                  } else if (statusFilter === 'unfinished') {
                      return ['进行中', '失败'].includes(status);
                  } else {
                      return status === '完成';
                  }
              });

              // 更新徽章
              this.updateQuestBadges(questList);

              if (filteredQuests.length === 0) {
                  const statusName = statusFilter === 'unclaimed' ? '待接取' : (statusFilter === 'unfinished' ? '未完成' : '已完成');
                  container.innerHTML = `
                      <div class="quest-placeholder">
                          <div class="placeholder-icon">📜</div>
                          <div class="placeholder-text">暂无${statusName}任务</div>
                      </div>
                  `;
                  return;
              }

              // 渲染任务卡片
              const questCardsHtml = filteredQuests.map(([questName, quest]) => {
                  return this.renderQuestCard(questName, quest);
              }).join('');

              container.innerHTML = questCardsHtml;

              // 绑定展开/折叠事件
              this.bindQuestCardEvents();
          },

          // 任务系统：渲染单个任务卡片
          renderQuestCard(questName, quest) {
              const tier = quest['任务品阶'] || 1;
              const description = quest['任务描述'] || '';
              const category = quest['任务类别'] || '主线';
              const status = quest['任务状态'] || '未接取';
              const deadline = quest['完成时间期限'] || '';
              const completeTime = quest['任务完成时间'] || '';
              const rewards = quest['任务奖励'] || {};
              const penalty = quest['任务惩罚'] || {};

              // 品阶染色 - 注意品阶是数字，需要加"阶"后缀
              const tierText = `${tier}阶`;
              const tierStyle = this.getItemTierStyle(tierText);
              const statusClass = `status-${status}`;

              // 渲染奖励部分
              const rewardsHtml = this.renderQuestRewards(rewards);
              
              // 渲染惩罚部分
              const penaltyHtml = penalty && penalty['描述'] ? `
                  <div class="quest-penalty-section">
                      <div class="quest-penalty-text">${penalty['描述']}</div>
                  </div>
              ` : '';

              return `
                  <div class="quest-card" data-quest-name="${questName}">
                      <div class="quest-card-header">
                          <div class="quest-card-title-section">
                              <div class="quest-card-title" style="${tierStyle}">${questName}</div>
                              <span class="quest-tier-badge" style="${tierStyle}">${tier}</span>
                          </div>
                          <div class="quest-card-meta">
                              <span class="quest-status-badge ${statusClass}">${status}</span>
                              <span class="quest-category-badge">${category}</span>
                              <span class="quest-expand-icon">▼</span>
                          </div>
                      </div>
                      <div class="quest-card-content">
                          <div class="quest-card-body">
                              <div class="quest-description">${description}</div>
                              <div class="quest-time-info">
                                  <span><span class="quest-time-label">时间期限:</span> ${deadline || '无限制'}</span>
                                  ${completeTime ? `<span><span class="quest-time-label">完成时间:</span> ${completeTime}</span>` : ''}
                              </div>
                              ${rewardsHtml}
                              ${penaltyHtml}
                          </div>
                      </div>
                  </div>
              `;
          },

          // 任务系统：渲染任务奖励
          renderQuestRewards(rewards) {
              if (!rewards || Object.keys(rewards).length === 0) return '';

              let html = '<div class="quest-rewards-section">';
              html += '<div class="quest-section-title">任务奖励</div>';

              // 基础奖励（修为、归墟点、灵石）
              const basicRewards = [];
              if (rewards['修为进度'] && rewards['修为进度'] > 0) {
                  basicRewards.push({name: '修为进度', value: rewards['修为进度']});
              }
              if (rewards['归墟点'] && rewards['归墟点'] > 0) {
                  basicRewards.push({name: '归墟点', value: rewards['归墟点']});
              }
              if (rewards['灵石'] && rewards['灵石'] > 0) {
                  basicRewards.push({name: '灵石', value: rewards['灵石']});
              }

              if (basicRewards.length > 0) {
                  html += '<div class="quest-rewards-grid">';
                  basicRewards.forEach(reward => {
                      html += `
                          <div class="quest-reward-item">
                              <span class="reward-name">${reward.name}</span>
                              <span>${reward.value}</span>
                          </div>
                      `;
                  });
                  html += '</div>';
              }

              // 物品奖励
              if (rewards['物品奖励']) {
                  html += this.renderItemRewards(rewards['物品奖励'], '物品奖励');
              }

              // 其他奖励
              if (rewards['其他奖励']) {
                  html += this.renderItemRewards(rewards['其他奖励'], '其他奖励');
              }

              html += '</div>';
              return html;
          },

          // 任务系统：渲染物品奖励（物品奖励和其他奖励）
          renderItemRewards(itemRewards, title) {
              if (!itemRewards || Object.keys(itemRewards).length === 0) return '';

              let html = `<div class="quest-section-title" style="margin-top: 10px;">${title}</div>`;
              html += '<div class="quest-item-rewards">';

              Object.entries(itemRewards).forEach(([itemName, itemData]) => {
                  if (itemName === '$meta') return;

                  const tier = itemData.tier || itemData['品阶'] || '';
                  const quantity = itemData.quantity || 1;
                  const description = itemData.description || itemData['描述'] || '';
                  const specialEffects = itemData.special_effects || itemData['词条'] || {};
                  
                  // 品阶染色
                  const tierStyle = tier ? this.getItemTierStyle(tier) : '';

                  // 生成唯一ID
                  const itemId = `quest-item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

                  html += `
                      <div class="quest-item-reward" data-item-id="${itemId}">
                          <div class="quest-item-reward-header">
                              <span style="${tierStyle}">${itemName} x${quantity}</span>
                              <span>▼</span>
                          </div>
                          <div class="quest-item-reward-details">
                              <div class="quest-item-detail-content">
                                  ${description ? `<div><strong>描述:</strong> ${description}</div>` : ''}
                                  ${Object.keys(specialEffects).filter(k => k !== '$meta').length > 0 ? `
                                      <div><strong>词条:</strong></div>
                                      <ul style="margin: 5px 0; padding-left: 20px;">
                                          ${Object.entries(specialEffects).filter(([k]) => k !== '$meta').map(([k, v]) => `<li>${k}: ${v}</li>`).join('')}
                                      </ul>
                                  ` : ''}
                              </div>
                          </div>
                      </div>
                  `;
              });

              html += '</div>';
              return html;
          },

          // 任务系统：更新徽章
          updateQuestBadges(questList) {
              const quests = Object.entries(questList).filter(([key]) => key !== '$meta');
              
              // 计算各状态任务数量
              const counts = {
                  unclaimed: 0,
                  unfinished: 0,
                  completed: 0
              };

              quests.forEach(([_, quest]) => {
                  const status = quest['任务状态'] || '未接取';
                  if (status === '未接取') {
                      counts.unclaimed++;
                  } else if (['进行中', '失败'].includes(status)) {
                      counts.unfinished++;
                  } else if (status === '完成') {
                      counts.completed++;
                  }
              });

              // 更新各tab的徽章
              const tabs = {
                  unclaimed: document.querySelector('.quest-status-tabs .panel-tab-btn[data-status="unclaimed"]'),
                  unfinished: document.querySelector('.quest-status-tabs .panel-tab-btn[data-status="unfinished"]'),
                  completed: document.querySelector('.quest-status-tabs .panel-tab-btn[data-status="completed"]')
              };

              Object.entries(tabs).forEach(([status, tabElement]) => {
                  if (tabElement) {
                      let badge = tabElement.querySelector('.inventory-tab-badge');
                      if (!badge) {
                          badge = document.createElement('span');
                          badge.className = 'inventory-tab-badge';
                          // 将徽章添加到按钮的第一个span子元素之后
                          const textSpan = tabElement.querySelector('span');
                          if(textSpan) {
                            textSpan.insertAdjacentElement('afterend', badge);
                          } else {
                            tabElement.appendChild(badge);
                          }
                      }
                      
                      const count = counts[status];
                      if (count > 0) {
                          badge.textContent = count;
                          badge.style.display = 'inline-block';
                      } else {
                          badge.style.display = 'none';
                      }
                  }
              });
          },

          // 任务系统：绑定卡片事件
          bindQuestCardEvents() {
              // 绑定卡片头部点击事件（展开/折叠）
              const headers = document.querySelectorAll('.quest-card-header');
              headers.forEach(header => {
                  header.addEventListener('click', (e) => {
                      // 防止点击子元素时触发
                      if (e.target.closest('.quest-card-header') !== header) return;

                      const card = header.closest('.quest-card');
                      const content = card.querySelector('.quest-card-content');
                      const icon = header.querySelector('.quest-expand-icon');

                      // 切换展开状态
                      content.classList.toggle('expanded');
                      header.classList.toggle('expanded');
                      icon.classList.toggle('expanded');
                  });
              });

              // 绑定物品奖励展开事件
              const itemRewards = document.querySelectorAll('.quest-item-reward');
              itemRewards.forEach(item => {
                  item.addEventListener('click', (e) => {
                      // 防止冒泡到卡片头部
                      e.stopPropagation();
                      
                      const details = item.querySelector('.quest-item-reward-details');
                      details.classList.toggle('expanded');
                  });
              });
          },

// ===任务系统模块结束===



// ===背包模块开始===



          async showInventory(useLocalState = false) {
            this.openModal('inventory-modal');

            // 动态设置全屏尺寸
            const rootContainer = document.querySelector('.guixu-root-container');
            const modalContent = document.querySelector('#inventory-modal .modal-content');
            if (rootContainer && modalContent) {
              const rect = rootContainer.getBoundingClientRect();
              modalContent.style.setProperty('width', `${rect.width}px`, 'important');
              modalContent.style.setProperty('height', `${rect.height}px`, 'important');
              modalContent.style.setProperty('top', `${rect.top}px`, 'important');
              modalContent.style.setProperty('left', `${rect.left}px`, 'important');
              modalContent.style.setProperty('max-width', 'none', 'important');
              modalContent.style.setProperty('max-height', 'none', 'important');
            }

            const tabsContainer = document.querySelector('#inventory-modal .inventory-tabs');
            const contentArea = document.querySelector('#inventory-modal .inventory-content-area');
            if (!tabsContainer || !contentArea) return;

            contentArea.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">正在清点行囊...</p>';

            try {
              let stat_data;
              // 修复：如果是在装备/卸下操作中，直接使用内存中的最新状态进行渲染，避免因后端同步延迟导致的UI不刷新
              if (useLocalState && this.currentMvuState?.stat_data) {
                stat_data = this.currentMvuState.stat_data;
              } else {
                const messages = await getChatMessages(getCurrentMessageId());
                if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
                  contentArea.innerHTML =
                    '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">无法获取背包数据。</p>';
                  console.warn('无法从当前消息中加载 stat_data 用于背包。');
                  return;
                }
                stat_data = messages[0].data.stat_data;
              }

              this.renderInventoryWithTabs(stat_data || {});
            } catch (error) {
              console.error('加载背包时出错:', error);
              contentArea.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">加载背包时出错: ${error.message}</p>`;
            }
          },



// ===背包模块结束===



// ===世界大事模块开始===



          async showWorldEvents() {
            if (this.isFromSettingsModal) {
                this.closeModal('settings-modal');
            }
            this.openModal('world-events-modal');
            
            // 初始化状态
            if (!this.worldEventsState) {
              this.worldEventsState = {
                isEditMode: false,
                isVerticalLayout: false,
                isTabsCollapsed: false,
                searchQuery: '',
                selectedEventId: null,
                filterCategory: 'all', // 'all', 'ongoing', 'ended'
                collapsedCategories: {} // 记录折叠状态
              };
            }

            const container = document.querySelector('#world-events-container');
            if (!container) return;

            container.innerHTML = '<p style="text-align:center; color:#ba8bff; padding:40px;">正在加载世界大事...</p>';

            try {
              const messages = await getChatMessages(getCurrentMessageId());
              if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
                container.innerHTML = '<div class="world-events-empty"><div class="world-events-empty-icon">🌍</div><div class="world-events-empty-title">暂无世界大事</div><div class="world-events-empty-description">当前没有可显示的世界大事记录</div></div>';
                console.warn('无法从当前消息中加载 stat_data 用于世界大事。');
                return;
              }
              
              const stat_data = messages[0].data.stat_data;
              this.currentWorldEventsData = stat_data;
              
              // 先渲染UI
              this.renderWorldEventsUI(stat_data);

              // 绑定搜索事件
              const searchInput = document.getElementById('world-events-search');
              if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                  this.worldEventsState.searchQuery = e.target.value;
                  this.renderWorldEventsUI(stat_data);
                });
              }

              // 动态设置全屏尺寸
              const rootContainer = document.querySelector('.guixu-root-container');
              const modalContent = document.querySelector('#world-events-modal .modal-content');
              if (rootContainer && modalContent) {
                  const rect = rootContainer.getBoundingClientRect();
                  modalContent.style.setProperty('width', `${rect.width}px`, 'important');
                  modalContent.style.setProperty('height', `${rect.height}px`, 'important');
                  modalContent.style.setProperty('top', `${rect.top}px`, 'important');
                  modalContent.style.setProperty('left', `${rect.left}px`, 'important');
                  modalContent.style.setProperty('max-width', 'none', 'important');
                  modalContent.style.setProperty('max-height', 'none', 'important');
              }

              // 自动跳转到最新事件
              requestAnimationFrame(() => {
                setTimeout(() => {
                  const firstTab = document.querySelector('.world-events-tab-item');
                  if (firstTab) {
                    const latestEventId = firstTab.getAttribute('data-event-id');
                    this.selectWorldEvent(latestEventId);
                  }
                }, 300);
              });

            } catch (error) {
              console.error('加载世界大事时出错:', error);
              container.innerHTML = `<div class="world-events-empty"><div class="world-events-empty-icon">❌</div><div class="world-events-empty-title">加载失败</div><div class="world-events-empty-description">加载世界大事时出错: ${error.message}</div></div>`;
            }
          },

          // 渲染世界大事UI
          renderWorldEventsUI(stat_data) {
            const worldEvents = stat_data.世界大事 || stat_data.world_events || {};
            const eventsArray = Object.entries(worldEvents)
              .filter(([key, event]) => key !== '$meta' && typeof event === 'object' && event !== null)
              .map(([key, event]) => ({ id: key, ...event }));

            // 应用搜索过滤
            const filteredEvents = eventsArray.filter(event => {
              if (!this.worldEventsState.searchQuery) return true;
              const query = this.worldEventsState.searchQuery.toLowerCase();
              const title = (event.标题 || event.title || '').toLowerCase();
              const category = (event.分类 || event.category || '').toLowerCase();
              const participants = (event.参与者 || event.participants || []).join(' ').toLowerCase();
              return title.includes(query) || category.includes(query) || participants.includes(query);
            });

            if (filteredEvents.length === 0) {
              document.getElementById('world-events-container').innerHTML =
                '<div class="world-events-empty"><div class="world-events-empty-icon">🔍</div><div class="world-events-empty-title">未找到匹配的事件</div><div class="world-events-empty-description">请尝试其他搜索关键词</div></div>';
              return;
            }

            // 按状态分类事件
            const ongoingEvents = filteredEvents.filter(event => {
              const status = (event.状态 || event.status || '').toLowerCase();
              return status.includes('进行') || status.includes('ongoing');
            });
            const endedEvents = filteredEvents.filter(event => {
              const status = (event.状态 || event.status || '').toLowerCase();
              return status.includes('结束') || status.includes('ended') || status.includes('完成');
            });

            // 计算总token
            const totalTokens = filteredEvents.reduce((sum, event) => sum + this.calculateEventTokenCount(event), 0);

            // 渲染Tab列表头部统计
            const tabsHeaderHtml = `
              <div class="world-events-tabs-header">
                <div class="tabs-stat-item">
                  <span class="tabs-stat-label">事件总数</span>
                  <span class="tabs-stat-value">${filteredEvents.length}</span>
                </div>
                <div class="tabs-stat-item">
                  <span class="tabs-stat-label">Token总数</span>
                  <span class="tabs-stat-value">${totalTokens}</span>
                </div>
              </div>
            `;

            // 渲染单个事件tab项
            const renderEventTab = (event) => {
              const title = event.标题 || event.title || '未知事件';
              let timeString = '';
              if (event.时间 || event.time) {
                const timeData = event.时间 || event.time;
                const shi = timeData.第几世 ? `第${timeData.第几世}世 ` : '';
                const date = timeData.日期 || '';
                timeString = `${shi}${date}`;
              }
              const tokenCount = this.calculateEventTokenCount(event);
              const isActive = this.worldEventsState.selectedEventId === event.id;

              return `
                <div class="world-events-tab-item ${isActive ? 'active' : ''}" data-event-id="${event.id}" onclick="GuixuManager.selectWorldEvent('${event.id}')">
                  <div class="world-events-tab-title">${this.escapeHtml(title)}</div>
                  <div class="world-events-tab-time">${this.escapeHtml(timeString)}</div>
                  <div class="world-events-tab-meta">
                    <span class="world-events-tab-token">${tokenCount}</span>
                    <button class="world-events-tab-delete" onclick="event.stopPropagation(); GuixuManager.deleteWorldEvent('${event.id}')">删除</button>
                  </div>
                </div>
              `;
            };

            // 渲染筛选分类
            const renderFilterCategory = (categoryKey, categoryTitle, events) => {
              const isCollapsed = this.worldEventsState.collapsedCategories[categoryKey] || false;
              const collapsedClass = isCollapsed ? 'collapsed' : '';
              // 倒序显示事件
              const reversedEvents = [...events].reverse();
              const eventsHtml = reversedEvents.map(event => renderEventTab(event)).join('');
              
              return `
                <div class="world-events-filter-category ${collapsedClass}" data-category="${categoryKey}">
                  <div class="world-events-filter-header" onclick="GuixuManager.toggleFilterCategory('${categoryKey}')">
                    <div class="world-events-filter-title">
                      <span>${categoryTitle}</span>
                      <span class="world-events-filter-count">${events.length}</span>
                    </div>
                    <span class="world-events-filter-arrow">▼</span>
                  </div>
                  <div class="world-events-filter-content">
                    ${eventsHtml}
                  </div>
                </div>
              `;
            };

            // 设置默认折叠状态（首次加载时）- 确保全部分类始终展开
            if (!this.worldEventsState.collapsedCategories.hasOwnProperty('all')) {
              this.worldEventsState.collapsedCategories.all = false; // 全部默认展开
              this.worldEventsState.collapsedCategories.ongoing = true; // 进行中默认折叠
              this.worldEventsState.collapsedCategories.ended = true; // 已结束默认折叠
            } else {
              // 确保全部分类始终展开
              this.worldEventsState.collapsedCategories.all = false;
            }

            // 构建分类HTML
            const allCategoryHtml = renderFilterCategory('all', '全部', filteredEvents);
            const ongoingCategoryHtml = renderFilterCategory('ongoing', '进行中', ongoingEvents);
            const endedCategoryHtml = renderFilterCategory('ended', '已结束', endedEvents);

            // 渲染时间轴
            const timelineHtml = filteredEvents.map(event => this.renderWorldEventCard(event)).join('');

            const editModeClass = this.worldEventsState.isEditMode ? 'edit-mode' : '';
            const layoutClass = this.worldEventsState.isVerticalLayout ? 'vertical-layout' : '';

            document.getElementById('world-events-container').innerHTML = `
              <div class="world-events-tabs ${editModeClass}">
                ${tabsHeaderHtml}
                ${allCategoryHtml}
                ${ongoingCategoryHtml}
                ${endedCategoryHtml}
              </div>
              <div class="world-events-content">
                <div class="world-events-timeline ${layoutClass}">
                  <div class="timeline-container">
                    ${timelineHtml}
                  </div>
                </div>
                <button id="world-events-nav-prev" class="world-events-nav-btn world-events-nav-prev" title="上一个事件">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="15 18 9 12 15 6"></polyline>
                  </svg>
                </button>
                <button id="world-events-nav-next" class="world-events-nav-btn world-events-nav-next" title="下一个事件">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="9 18 15 12 9 6"></polyline>
                  </svg>
                </button>
              </div>
            `;
          },

          // 切换筛选分类的折叠状态
          toggleFilterCategory(categoryKey) {
            this.worldEventsState.collapsedCategories[categoryKey] = !this.worldEventsState.collapsedCategories[categoryKey];
            const categoryElement = document.querySelector(`.world-events-filter-category[data-category="${categoryKey}"]`);
            if (categoryElement) {
              if (this.worldEventsState.collapsedCategories[categoryKey]) {
                categoryElement.classList.add('collapsed');
              } else {
                categoryElement.classList.remove('collapsed');
              }
            }
          },

          // 事件卡片展开/折叠功能，确保动画流畅
          toggleEventExpand(cardElement) {
            return new Promise(resolve => {
              const isExpanded = cardElement.classList.contains('fully-expanded');
              cardElement.setAttribute('data-expand-level', isExpanded ? '0' : '1');
              requestAnimationFrame(() => {
                if (isExpanded) {
                  cardElement.classList.remove('fully-expanded');
                } else {
                  cardElement.classList.add('fully-expanded');
                }
                const onTransitionEnd = () => {
                  cardElement.removeEventListener('transitionend', onTransitionEnd);
                  resolve();
                };
                cardElement.addEventListener('transitionend', onTransitionEnd);
              });
            });
          },
          renderWorldEvents(stat_data) {
            const worldEvents = stat_data.世界大事 || stat_data.world_events || {};
            
            if (!worldEvents || Object.keys(worldEvents).length === 0) {
              return `
                <div class="world-events-empty">
                  <div class="world-events-empty-icon">🌍</div>
                  <div class="world-events-empty-title">暂无世界大事</div>
                  <div class="world-events-empty-description">当前世界还没有发生重大事件</div>
                </div>
              `;
            }

            // 将世界大事转换为数组，按变量结构原始顺序保留（不排序）
            const eventsArray = Object.entries(worldEvents)
              .filter(([key, event]) => key !== '$meta' && typeof event === 'object' && event !== null)
              .map(([key, event]) => ({ id: key, ...event }));

            if (this.worldEventsViewMode === 'list') {
              let html = '<div class="world-events-list">';
              eventsArray.forEach(event => {
                const title = event.title || event.标题 || '未知事件';
                let timeString = '';
                 if (event.time || event.时间) {
                    const timeData = event.time || event.时间;
                    const shi = timeData.第几世 ? `第${timeData.第几世}世 ` : '';
                    const date = timeData.日期 || '';
                    timeString = `${shi}${date}`;
                }
                html += `
                  <div class="world-events-list-item">
                    <span class="world-events-list-time">${this.escapeHtml(timeString)}</span>
                    <span class="world-events-list-title">${this.escapeHtml(title)}</span>
                  </div>
                `;
              });
              html += '</div>';
              return html;
            } else {
              // 默认时间轴模式
              let html = '<div class="world-events-timeline"><div class="timeline-container">';
              eventsArray.forEach(event => {
                html += this.renderWorldEventItem(event);
              });
              html += '</div></div>';
              return html;
            }
          },

          // 渲染单个世界大事卡片 - 新布局
          renderWorldEventCard(event) {
            const title = event.标题 || event.title || '未知事件';
            const description = event.描述 || event.description || '';
            const category = event.分类 || event.category || '';
            const scope = event.影响范围 || event.scope || '';
            const location = event.地点 || event.location || '';
            const status = event.状态 || event.status || '';
            const participants = event.参与者 || event.participants || [];

            // 处理时间对象
            let timeString = '';
            if (event.时间 || event.time) {
              const timeData = event.时间 || event.time;
              const shi = timeData.第几世 ? `第${timeData.第几世}世 ` : '';
              const date = timeData.日期 || '';
              timeString = `${shi}${date}`;
            }

            // 时间+地点+影响范围（合并显示）
            const metaInfo = [timeString, location, scope].filter(Boolean).join(' · ');

            // 处理结果
            let resultHtml = '';
            if(event.结果 || event.result) {
                const resultData = event.结果 || event.result;
                const overview = resultData.概述 || resultData.overview || '';
                if(overview) {
                    resultHtml = `
                      <div class="event-section">
                        <div class="event-section-title">最终结果</div>
                        <div class="event-section-content">${this.escapeHtml(overview)}</div>
                      </div>
                    `;
                }
            }

            // 处理影响
            let impactHtml = '';
            if (event.影响 || event.impact) {
              const impactData = event.影响 || event.impact;
              const shortTerm = impactData.短期影响 || impactData.short_term_impact || '';
              const longTerm = impactData.长期影响 || impactData.long_term_impact || '';
              if (shortTerm || longTerm) {
                impactHtml = `
                  <div class="event-section">
                    <div class="event-section-title">影响与后果</div>
                    <div class="event-section-content">
                      ${shortTerm ? `<div class="event-impact-item"><span class="event-impact-label">短期：</span>${this.escapeHtml(shortTerm)}</div>` : ''}
                      ${longTerm ? `<div class="event-impact-item"><span class="event-impact-label">长期：</span>${this.escapeHtml(longTerm)}</div>` : ''}
                    </div>
                  </div>
                `;
              }
            }

            // 判断是否有可折叠内容
            const hasCollapsibleContent = resultHtml || impactHtml;

            return `
              <div class="world-event-card ${hasCollapsibleContent ? 'has-collapsible' : ''}" data-event-id="${event.id}" id="event-${event.id}" data-expanded="false" onclick="GuixuManager.toggleEventCardExpand(this, event)">
                <div class="world-event-header">
                  <div class="event-title-row">
                    <div class="event-title">${this.escapeHtml(title)}</div>
                    ${status ? `<div class="event-status-badge status-${status}">${this.escapeHtml(status)}</div>` : ''}
                  </div>
                  <div class="event-tags-row">
                    ${category ? `<span class="event-category">${this.escapeHtml(category)}</span>` : ''}
                    ${participants.map(p => `<span class="event-participant-tag">${this.escapeHtml(p)}</span>`).join('')}
                  </div>
                  ${metaInfo ? `<div class="event-time-location">${this.escapeHtml(metaInfo)}</div>` : ''}
                </div>
                <div class="world-event-content">
                  ${description ? `<div class="event-description">${this.escapeHtml(description)}</div>` : ''}
                  ${hasCollapsibleContent ? `
                    <div class="event-collapsible-content">
                      ${resultHtml}
                      ${impactHtml}
                    </div>
                  ` : ''}
                </div>
              </div>
            `;
          },

          // 选择世界大事（tab点击）
          selectWorldEvent(eventId) {
            console.log('[selectWorldEvent] 被调用，eventId:', eventId);
            this.worldEventsState.selectedEventId = eventId;
            
            // 更新tab激活状态
            const allTabs = document.querySelectorAll('.world-events-tab-item');
            console.log('[selectWorldEvent] 找到tab数量:', allTabs.length);
            
            let foundTab = false;
            allTabs.forEach(tab => {
              const tabEventId = tab.getAttribute('data-event-id');
              if (tabEventId === eventId) {
                tab.classList.add('active');
                foundTab = true;
                console.log('[selectWorldEvent] 找到并激活tab');
                // 不滚动tab列表，因为事件已经是倒序排列（最新的在最上面）
              } else {
                tab.classList.remove('active');
              }
            });
            
            if (!foundTab) {
              console.warn('[selectWorldEvent] 未找到匹配的tab，eventId:', eventId);
            }
            
            // 滚动到对应事件卡片
            this.scrollToWorldEvent(eventId);
            
            // 更新导航按钮状态
            this.updateWorldEventNavButtons();
          },

          // 导航到上一个或下一个事件
          navigateWorldEvent(direction) {
            const allTabs = Array.from(document.querySelectorAll('.world-events-tab-item'));
            if (allTabs.length === 0) return;
            
            const currentIndex = allTabs.findIndex(tab =>
              tab.getAttribute('data-event-id') === this.worldEventsState.selectedEventId
            );
            
            let targetIndex;
            if (direction === 'prev') {
              // 上一个：索引减1（因为是倒序，上一个是更旧的事件）
              targetIndex = currentIndex + 1;
            } else {
              // 下一个：索引加1（因为是倒序，下一个是更新的事件）
              targetIndex = currentIndex - 1;
            }
            
            // 边界检查
            if (targetIndex >= 0 && targetIndex < allTabs.length) {
              const targetEventId = allTabs[targetIndex].getAttribute('data-event-id');
              this.selectWorldEvent(targetEventId);
            }
          },

          // 更新导航按钮的启用/禁用状态
          updateWorldEventNavButtons() {
            const allTabs = Array.from(document.querySelectorAll('.world-events-tab-item'));
            const prevBtn = document.getElementById('world-events-nav-prev');
            const nextBtn = document.getElementById('world-events-nav-next');
            
            if (!prevBtn || !nextBtn || allTabs.length === 0) return;
            
            const currentIndex = allTabs.findIndex(tab =>
              tab.getAttribute('data-event-id') === this.worldEventsState.selectedEventId
            );
            
            // 上一个按钮：当前是最后一个（最旧的）时禁用
            if (currentIndex >= allTabs.length - 1) {
              prevBtn.classList.add('disabled');
              prevBtn.disabled = true;
            } else {
              prevBtn.classList.remove('disabled');
              prevBtn.disabled = false;
            }
            
            // 下一个按钮：当前是第一个（最新的）时禁用
            if (currentIndex <= 0) {
              nextBtn.classList.add('disabled');
              nextBtn.disabled = true;
            } else {
              nextBtn.classList.remove('disabled');
              nextBtn.disabled = false;
            }
          },

          // 滚动到指定事件
          scrollToWorldEvent(eventId) {
            console.log('[scrollToWorldEvent] 被调用，eventId:', eventId);
            const eventCard = document.getElementById(`event-${eventId}`);
            console.log('[scrollToWorldEvent] 找到的卡片元素:', eventCard);
            
            // 调试：打印所有卡片的ID
            const allCards = document.querySelectorAll('.world-event-card');
            console.log('[scrollToWorldEvent] 所有卡片数量:', allCards.length);
            if (allCards.length > 0) {
              console.log('[scrollToWorldEvent] 前3个卡片ID:',
                Array.from(allCards).slice(0, 3).map(c => c.id));
              console.log('[scrollToWorldEvent] 最后一个卡片ID:',
                allCards[allCards.length - 1].id);
            }
            
            if (eventCard) {
              console.log('[scrollToWorldEvent] 开始滚动');
              // 获取时间轴容器
              const timeline = document.querySelector('.world-events-timeline');
              if (timeline) {
                // 计算卡片相对于时间轴容器的位置
                const cardRect = eventCard.getBoundingClientRect();
                const timelineRect = timeline.getBoundingClientRect();
                const scrollLeft = timeline.scrollLeft + (cardRect.left - timelineRect.left) - (timelineRect.width / 2) + (cardRect.width / 2);
                
                // 平滑滚动到目标位置
                timeline.scrollTo({
                  left: scrollLeft,
                  behavior: 'smooth'
                });
              }
              
              // 添加高亮效果
              eventCard.style.boxShadow = '0 0 20px rgba(201, 170, 113, 0.6)';
              setTimeout(() => {
                eventCard.style.boxShadow = '';
              }, 2000);
            } else {
              console.warn('[scrollToWorldEvent] 未找到事件卡片元素，ID:', `event-${eventId}`);
            }
          },

          // 切换编辑模式
          toggleWorldEventsEditMode() {
            this.worldEventsState.isEditMode = !this.worldEventsState.isEditMode;
            const editBtn = document.getElementById('world-events-edit-btn');
            const tabsContainer = document.querySelector('.world-events-tabs');
            
            if (this.worldEventsState.isEditMode) {
              editBtn.classList.add('active');
              editBtn.textContent = '编辑ing';
              tabsContainer.classList.add('edit-mode');
            } else {
              editBtn.classList.remove('active');
              editBtn.textContent = '编辑';
              tabsContainer.classList.remove('edit-mode');
            }
          },

          // 切换布局方向
          toggleWorldEventsLayout() {
            this.worldEventsState.isVerticalLayout = !this.worldEventsState.isVerticalLayout;
            const timeline = document.querySelector('.world-events-timeline');
            
            if (this.worldEventsState.isVerticalLayout) {
              timeline.classList.add('vertical-layout');
            } else {
              timeline.classList.remove('vertical-layout');
            }
          },

          // 切换Tab侧边栏展开/折叠
          toggleWorldEventsTabs() {
            this.worldEventsState.isTabsCollapsed = !this.worldEventsState.isTabsCollapsed;
            const tabsContainer = document.querySelector('.world-events-tabs');
            const toggleIcon = document.getElementById('world-events-tabs-toggle-icon');
            
            if (this.worldEventsState.isTabsCollapsed) {
              tabsContainer.classList.add('collapsed');
              if (toggleIcon) toggleIcon.textContent = '▶';
            } else {
              tabsContainer.classList.remove('collapsed');
              if (toggleIcon) toggleIcon.textContent = '◀';
            }
          },

          // 切换事件卡片展开/折叠
          toggleEventCardExpand(cardElement, evt) {
            if (evt) evt.stopPropagation();
            const isExpanded = cardElement.dataset.expanded === 'true';
            cardElement.dataset.expanded = isExpanded ? 'false' : 'true';
          },



// ===世界大事模块结束===



// ===变量编辑器模块（极为重要）开始===



          async showVariableEditor() {
            if (this.isFromSettingsModal) {
                this.closeModal('settings-modal');
            }
            this.openModal('variable-editor-modal');
            this.initVariableEditor();
          },

          _handleVariableEditorTabClick(event) {
              const tab = event.currentTarget;
              const tabs = document.querySelectorAll('#variable-editor-modal .tab-btn');
              tabs.forEach(t => t.classList.remove('active'));
              tab.classList.add('active');
              this.activeEditorCategory = tab.dataset.category;
              this.renderVariables(this.activeEditorCategory, this.editorSearchTerm);
          },

          _handleVariableEditorSearch() {
              const searchInput = document.getElementById('variable-search-input');
              this.editorSearchTerm = searchInput.value;
              this.renderVariables(this.activeEditorCategory, this.editorSearchTerm);
          },

          initVariableEditor() {
              if (this.isVariableEditorInitialized) {
                  // 如果已经初始化过，只同步UI状态并重新渲染
                  this.editorSearchTerm = ''; // 每次打开重置搜索词
                  document.getElementById('variable-search-input').value = '';
                  
                  const tabs = document.querySelectorAll('#variable-editor-modal .tab-btn');
                  tabs.forEach(t => t.classList.remove('active'));
                  // 使用持久化的 activeEditorCategory 来设置正确的激活Tab
                  const activeTab = document.querySelector(`#variable-editor-modal .tab-btn[data-category="${this.activeEditorCategory || 'system'}"]`);
                  if (activeTab) activeTab.classList.add('active');
                  
                  this.renderVariables(this.activeEditorCategory || 'system', this.editorSearchTerm);
                  return;
              }

              // 首次初始化时设置默认值
              this.activeEditorCategory = 'system';
              this.editorSearchTerm = '';

              const tabs = document.querySelectorAll('#variable-editor-modal .tab-btn');
              const searchInput = document.getElementById('variable-search-input');
              const saveButton = document.getElementById('save-variable-changes-btn');
              const addNewVariableBtn = document.getElementById('add-new-variable-btn');

              tabs.forEach(tab => {
                  tab.addEventListener('click', this._handleVariableEditorTabClick.bind(this));
              });

              searchInput.addEventListener('input', this._handleVariableEditorSearch.bind(this));
              saveButton.addEventListener('click', this.saveVariableChanges.bind(this));
              addNewVariableBtn.addEventListener('click', this.addNewVariable.bind(this));
              
              // 同步初始UI状态
              const defaultTab = document.querySelector('#variable-editor-modal .tab-btn[data-category="system"]');
              if (defaultTab) defaultTab.classList.add('active');

              this.renderVariables(this.activeEditorCategory, this.editorSearchTerm);
              this.isVariableEditorInitialized = true;
          },

          // 渲染变量 (已重构: 使用 Mvu API)
          renderVariables(category, searchTerm) {
              const displayArea = document.getElementById('variable-display-area');
              if (!displayArea) return;

              displayArea.innerHTML = '<div class="placeholder">加载中...</div>';

              // 使用 Mvu API 获取数据，增强兼容性和未来扩展性
              let mvu_data;
              try {
                  mvu_data = Mvu.getMvuData({ type: 'message', message_id: 'latest' });
              } catch (error) {
                  console.warn('[变量编辑器] Mvu API 不可用，回退到旧方式:', error);
                  mvu_data = this.currentMvuState;
              }

              const stat_data = mvu_data?.stat_data;
              if (!stat_data) {
                  displayArea.innerHTML = '<div class="placeholder">变量数据不可用。</div>';
                  return;
              }

              let html = '';
              const systemVars = ['当前第x世', '当前时间纪年', '归墟空间', '本世归墟选择', '归真数', '归墟点', '世界大事','宗门列表' ];
              
              let variablesToRender = {};

              if (category === 'system') {
                  systemVars.forEach(key => {
                      if (stat_data.hasOwnProperty(key)) {
                          variablesToRender[key] = stat_data[key];
                      }
                  });
              } else if (category === 'player') {
                  Object.keys(stat_data).forEach(key => {
                      if (!systemVars.includes(key) && key !== '人物关系列表' && key !== '$meta') {
                          variablesToRender[key] = stat_data[key];
                      }
                  });
              } else if (category === 'npc') {
                  variablesToRender = stat_data['人物关系列表'] || {};
              }

              // 过滤
              if (searchTerm) {
                  const lowerCaseSearchTerm = searchTerm.toLowerCase();
                  variablesToRender = Object.keys(variablesToRender)
                      .filter(key => key.toLowerCase().includes(lowerCaseSearchTerm))
                      .reduce((obj, key) => {
                          obj[key] = variablesToRender[key];
                          return obj;
                      }, {});
              }

              if (Object.keys(variablesToRender).length === 0) {
                  displayArea.innerHTML = '<div class="placeholder">没有匹配的变量。</div>';
                  return;
              }

              // 生成HTML
              if (category === 'npc') {
                  html = this.buildReadableHtml(variablesToRender, 0, '人物关系列表');
              } else {
                  html = this.buildReadableHtml(variablesToRender);
              }
              displayArea.innerHTML = html;
          },

          // 构建人类可读的HTML (深度模板化)
          buildReadableHtml(obj, level = 0, parentPath = '') {
              let html = '';
              const processedKeys = new Set();
              
              const bonusTemplates = {
                  'attributes_bonus': ['法力', '神海', '道心', '空速', '气运', '悟性', '魅力'],
                  '百分比加成': ['法力', '神海', '道心', '空速', '修炼速度']
              };

              // 1. 渲染已存在的键
              for (const key in obj) {
                  if (key === '$meta') continue;
                  processedKeys.add(key);

                  const value = obj[key];
                  const isObject = typeof value === 'object' && value !== null;
                  const currentPath = parentPath ? `${parentPath}.${key}` : key;

                  html += `<div class="readable-variable-item" style="margin-left: ${level * 20}px;">`;
                  html += `<div class="variable-title">${key}</div>`;
                  
                  if (isObject) {
                      html += `<div class="nested-item">${this.buildReadableHtml(value, level + 1, currentPath)}</div>`;
                  } else {
                      const displayValue = (value === null) ? 'null' : (value === undefined) ? 'undefined' : value;
                      html += `<div class="variable-value"><textarea rows="1" data-path="${currentPath}" oninput="this.classList.add('is-dirty')">${displayValue}</textarea></div>`;
                  }
                  html += `</div>`;
              }

              // 2. 为父级对象（如物品、NPC）添加缺失的模板父键
              const isItemOrNpc = parentPath.includes('物品列表') || parentPath.includes('装备栏') || parentPath.includes('人物关系列表');
              if (isItemOrNpc) {
                  Object.keys(bonusTemplates).forEach(templateKey => {
                      if (!processedKeys.has(templateKey)) {
                          html += `<div class="readable-variable-item" style="margin-left: ${level * 20}px;">`;
                          html += `<div class="variable-title">${templateKey}</div>`;
                          html += `<div class="nested-item"></div>`;
                          html += `</div>`;
                      }
                  });
              }
              
              // 3. 为attributes_bonus和百分比加成对象本身，补充缺失的子键
              const currentKey = parentPath.split('.').pop();
              if (bonusTemplates[currentKey]) {
                  bonusTemplates[currentKey].forEach(subKey => {
                      if (!processedKeys.has(subKey)) {
                          const subPath = `${parentPath}.${subKey}`;
                          html += `<div class="readable-variable-item template-item" style="margin-left: ${(level) * 20}px;">`;
                          html += `<div class="variable-title template-title">${subKey}</div>`;
                          html += `<div class="variable-value"><textarea rows="1" data-path="${subPath}" placeholder="输入数值..."></textarea></div>`;
                          html += `</div>`;
                      }
                  });
              }

              return html;
          },

          // 保存变量更改 (已重构: 使用 Mvu API)
          async saveVariableChanges() {
              const displayArea = document.getElementById('variable-display-area');
              // 核心修复：只选择被用户实际修改过的输入框
              const textareas = displayArea.querySelectorAll('textarea[data-path].is-dirty');
              
              // 获取当前的 mvu_data
              let mvu_data;
              try {
                  mvu_data = Mvu.getMvuData({ type: 'message', message_id: 'latest' });
              } catch (error) {
                  console.warn('[变量编辑器] Mvu API 不可用，回退到旧方式:', error);
                  mvu_data = this.currentMvuState;
              }

              if (!mvu_data || !mvu_data.stat_data) {
                  this.showTemporaryMessage('无法获取变量数据，保存失败。', 'error');
                  return;
              }

              const originalState = mvu_data.stat_data;
              const changedVariables = [];

              // 收集所有变更
              textareas.forEach(textarea => {
                  const path = textarea.dataset.path;
                  const newValueStr = textarea.value;
                  const isNew = textarea.dataset.isNew === 'true';

                  // 如果输入框是模板生成的（有placeholder）且内容为空，则忽略它
                  if (textarea.hasAttribute('placeholder') && newValueStr.trim() === '') {
                      return;
                  }
                  // 对于非模板生成的输入框，如果内容为空，也跳过（除非它是新添加的变量，允许设置为空字符串）
                  if (!isNew && !textarea.hasAttribute('placeholder') && newValueStr.trim() === '') {
                      // 逻辑上可以允许将现有值清空，所以这里暂时不return，但需注意后续处理
                  }
                  
                  let newValue;
                  try {
                      // 尝试解析为JSON，如果失败则作为字符串
                      newValue = JSON.parse(newValueStr);
                  } catch (e) {
                      newValue = newValueStr;
                  }

                  if (isNew) {
                      // 对于新变量，直接添加到变更列表
                      changedVariables.push({ path, newValue, reason: '变量编辑器添加' });
                  } else {
                      // 对于现有变量，比较值是否真的改变了
                      const originalValue = this.SafeGetValue(originalState, path);
                      if (!_.isEqual(originalValue, newValue)) {
                          changedVariables.push({ path, newValue, reason: '变量编辑器修改' });
                      }
                  }
              });
              
              if (changedVariables.length > 0) {
                  this.showTemporaryMessage(`正在保存 ${changedVariables.length} 个变量的修改...`);

                  try {
                      let hasAnySuccess = false;

                      // 使用 Mvu.setMvuVariable 实现增量更新
                      for (const { path, newValue, reason } of changedVariables) {
                          try {
                              // 直接在当前的前端状态上调用 setMvuVariable
                              // 这个API会同时更新JS对象和display_data等元数据
                              const success = await Mvu.setMvuVariable(this.currentMvuState, path, newValue, { reason });

                              if (success) {
                                  hasAnySuccess = true;
                              }
                          } catch (error) {
                              // 保留错误处理，但移除具体的日志输出
                          }
                      }

                      if (hasAnySuccess) {
                          // 增量更新后，只需用最新的前端状态全局覆写一次后端即可
                          await Mvu.replaceMvuData(this.currentMvuState, { type: 'message', message_id: 'latest' });

                          // 更新UI
                          this.renderUI(this.currentMvuState.stat_data);
                          
                          // 重新渲染变量编辑器本身以反映最新状态，并停留在当前Tab
                          const searchTerm = document.getElementById('variable-search-input').value;
                          this.renderVariables(this.activeEditorCategory, searchTerm);

                          this.showTemporaryMessage(`成功增量更新 ${changedVariables.length} 个变量！`, 'success');
                      } else {
                          this.showTemporaryMessage('所有变量更新都失败了。', 'error');
                      }

                  } catch (error) {
                      console.error('[变量编辑器] 保存变量失败:', error);
                      this.showTemporaryMessage(`保存失败: ${error.message}`, 'error');
                  }
              } else {
                  this.showTemporaryMessage('没有检测到任何更改。');
              }
          },

          // 添加新变量
          addNewVariable() {
              const path = prompt("请输入新变量的完整路径 (例如: '人物关系列表.新角色'):【功能待完善】");
              if (!path) return;

              const value = prompt(`请输入 '${path}' 的初始值:`, '""');
              if (value === null) return;

              // 动态创建一个新的可编辑项并添加到显示区域
              const displayArea = document.getElementById('variable-display-area');
              const newItemHtml = `
                  <div class="readable-variable-item" style="margin-left: 0px; border: 2px dashed #c9aa71; padding: 10px; border-radius: 5px;">
                      <div class="variable-title">${path}</div>
                      <div class="variable-value">
                          <textarea rows="1" data-path="${path}" data-is-new="true">${value}</textarea>
                      </div>
                  </div>
              `;
              displayArea.insertAdjacentHTML('afterbegin', newItemHtml);
          },


          // === 数据收集和解析 ===
          collectVisualEditorData() {
            // 直接返回当前的变量值，因为我们已经实时更新了
            return this.currentVariableValue;
          },

          parseVisualValue(value) {
            if (value === '' || value === 'null') return null;
            if (value === 'true') return true;
            if (value === 'false') return false;
            if (!isNaN(value) && !isNaN(parseFloat(value))) return parseFloat(value);
            return value;
          },

          // === 简单对象和数组渲染器 ===
          renderSimpleObject(obj, path) {
            let html = `<div class="smart-form-group" data-path="${path}">
              <label class="smart-form-label">${path.split('.').pop() || '对象'}</label>`;
            
            Object.entries(obj).forEach(([key, value]) => {
              const fieldPath = `${path}.${key}`;
              html += `<div class="attribute-item">
                <label class="attribute-label">${key}</label>
                <input type="text" class="attribute-input"
                       value="${value}" data-path="${fieldPath}">
              </div>`;
            });
            
            html += `</div>`;
            return html;
          },

          renderSmartArray(arr, path) {
            let html = `<div class="relationships-container" data-path="${path}">
              <div class="details-toggle" onclick="this.nextElementSibling.classList.toggle('hidden')">
                <span>${path.split('.').pop() || '数组'} (${arr.length}项)</span>
                <span>▼</span>
              </div>
              <div class="details-content">
                <ul class="sortable-list" data-path="${path}">`;

            arr.forEach((item, index) => {
              const itemPath = `${path}[${index}]`;
              html += `<li class="sortable-item" data-index="${index}">
                <span class="drag-handle">⋮⋮</span>
                <div style="flex: 1;">`;
              
              if (typeof item === 'object' && item !== null) {
                html += `<textarea class="rich-text-editor" data-path="${itemPath}" rows="2">${JSON.stringify(item, null, 2)}</textarea>`;
              } else {
                html += `<input type="text" class="attribute-input" value="${item}" data-path="${itemPath}">`;
              }
              
              html += `</div>
                <button class="action-btn secondary" onclick="guixuApp.removeArrayItem('${path}', ${index})">删除</button>
              </li>`;
            });

            html += `</ul>
              <div class="action-buttons">
                <button class="action-btn" onclick="guixuApp.addArrayItem('${path}')">添加项目</button>
              </div>
            </div></div>`;

            return html;
          },

          renderPrimitiveValue(value, path) {
            const type = typeof value;
            let inputType = 'text';
            let inputClass = 'attribute-input';
            
            if (type === 'number') {
              inputType = 'number';
            } else if (type === 'boolean') {
              return `<div class="smart-form-group">
                <label class="smart-form-label">${path.split('.').pop() || '值'}</label>
                <select class="smart-select" data-path="${path}">
                  <option value="true" ${value ? 'selected' : ''}>是</option>
                  <option value="false" ${!value ? 'selected' : ''}>否</option>
                </select>
              </div>`;
            }

            return `<div class="smart-form-group">
              <label class="smart-form-label">${path.split('.').pop() || '值'}</label>
              <input type="${inputType}" class="${inputClass}"
                     value="${value}" data-path="${path}">
            </div>`;
          },

          renderGenericObject(obj, path) {
            let html = `<div class="details-section" data-path="${path}">
              <div class="details-toggle" onclick="this.nextElementSibling.classList.toggle('hidden')">
                <span>${path.split('.').pop() || '对象'} (${Object.keys(obj).length}个属性)</span>
                <span>▼</span>
              </div>
              <div class="details-content">`;

            Object.entries(obj).forEach(([key, value]) => {
              const fieldPath = `${path}.${key}`;
              html += this.renderGenericField(key, value, fieldPath);
            });

            html += `</div></div>`;
            return html;
          },
          // 新增：根据路径设置值
          setValueByPath(obj, path, value) {
            const keys = path.split(/[\.\[\]]/).filter(key => key !== '');
            let current = obj;
            
            for (let i = 0; i < keys.length - 1; i++) {
              const key = keys[i];
              if (!(key in current)) {
                current[key] = isNaN(keys[i + 1]) ? {} : [];
              }
              current = current[key];
            }
            
            const lastKey = keys[keys.length - 1];
            current[lastKey] = value;
          },



// ===变量编辑器模块（极为重要）结束===



// ===人物关系模块（极为重要）开始===



          async showRelationships() {
              this.loadRelationshipSortSettings(); // 加载排序设置
              this.openModal('relationships-modal');
              
              const container = document.querySelector('#relationships-modal .relationships-container');
              if (!container) return;

              const listPanel = container.querySelector('.character-list-panel .character-list');
              const detailsPanel = container.querySelector('.character-details-panel');
              if (!listPanel || !detailsPanel) {
                return;
              }

              listPanel.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">正在梳理人脉...</p>';
              detailsPanel.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">请先在左侧选择人物</p>';

              try {
                  if (!this.currentMvuState) {
                      listPanel.innerHTML = '<p class="modal-placeholder">无法获取人物关系数据（状态未初始化）。</p>';
                      return;
                  }
                  const relationships = this.SafeGetValue(this.currentMvuState.stat_data, '人物关系列表', {});
                  this.currentRelationshipData = relationships; // 缓存数据
                  
                  this.renderCharacterList();
                  
                  // 从localStorage恢复上次选择的人物，如果没有则选择第一个
                  const savedCharacter = localStorage.getItem('guixu_last_selected_character');
                  let targetCharacterName = null;
                  
                  // 优先使用保存的人物名，但要确保该人物仍然存在
                  if (savedCharacter && relationships[savedCharacter]) {
                      targetCharacterName = savedCharacter;
                  } else {
                      // 如果保存的人物不存在，选择第一个
                      targetCharacterName = listPanel.querySelector('.character-card')?.dataset.characterName;
                  }
                  
                  if (targetCharacterName) {
                      // 给对应的卡片添加active状态
                      const targetCard = listPanel.querySelector(`.character-card[data-character-name="${targetCharacterName}"]`);
                      if (targetCard) {
                          targetCard.classList.add('active');
                      }
                      // 显示详情
                      this.renderCharacterDetails(targetCharacterName);
                      // 记录当前选择
                      this.lastSelectedCharacter = targetCharacterName;
                  } else {
                      detailsPanel.innerHTML = '<p class="modal-placeholder">暂无人物详情。</p>';
                  }
                  
                  this.adjustRelationshipPanelWidth();
                  const rootContainer = document.querySelector('.guixu-root-container');
                  const modalContent = document.querySelector('#relationships-modal .modal-content');
                  if (rootContainer && modalContent) {
                      const rect = rootContainer.getBoundingClientRect();
                      modalContent.style.setProperty('width', `${rect.width}px`, 'important');
                      modalContent.style.setProperty('height', `${rect.height}px`, 'important');
                      modalContent.style.setProperty('top', `${rect.top}px`, 'important');
                      modalContent.style.setProperty('left', `${rect.left}px`, 'important');
                      modalContent.style.setProperty('max-width', 'none', 'important');
                      modalContent.style.setProperty('max-height', 'none', 'important');
                  }

              } catch (error) {
                  console.error('加载人物关系时出错:', error);
                  listPanel.innerHTML = `<p class="modal-placeholder">加载人物关系时出错: ${error.message}</p>`;
              }
          },

          renderCharacterList() {
              const listPanel = document.querySelector('#relationships-modal .character-list');
              const listHeader = document.querySelector('#relationships-modal .character-list-header');
              if (!listPanel || !this.currentRelationshipData || !listHeader) return;

              const relationships = this.currentRelationshipData;
              let allRelationshipEntries = Object.entries(relationships).filter(([name, rel]) => {
                  return name && name !== '$meta' && rel && typeof rel === 'object';
              });

              // 搜索过滤
              const searchTerm = listHeader.querySelector('.character-search-input')?.value || '';
              if (searchTerm) {
                  allRelationshipEntries = allRelationshipEntries.filter(([name, rel]) => {
                      return name.toLowerCase().includes(searchTerm.toLowerCase());
                  });
              }

              // 更新角色计数
              const subtitleElement = document.querySelector('#relationships-modal .character-list-header .subtitle');
              if (subtitleElement) {
                  subtitleElement.textContent = `共 ${allRelationshipEntries.length} 个角色`;
              }

              const sortedEntries = this.sortRelationshipEntries(allRelationshipEntries);

              if (sortedEntries.length === 0) {
                  listPanel.innerHTML = '<p class="modal-placeholder">暂无人物关系。</p>';
                  return;
              }

              try {
                  listPanel.innerHTML = sortedEntries.map(([name, rel]) => {
                      const cultivation = this.SafeGetValue(rel, '当前修为', '凡人');
                      const tierMatch = cultivation.match(/^(练气|筑基|洞玄|合道|飞升|神桥|凡人)/);
                      const tier = tierMatch ? tierMatch[0] : '凡人';
                      const style = this.getJingJieStyle(tier);
                      const favorability = this.SafeGetValue(rel, '好感度', 0);
                      const favorPercentage = Math.min(Math.abs(favorability) / 200 * 100, 100);
                      const favorClass = favorability >= 0 ? 'positive' : 'negative';

                      // 为卡片背景预留一个style属性
                      return `
                          <div class="character-card" id="card-${name}" data-character-name="${name}" style="">
                              <div class="card-background-overlay"></div>
                              <div class="avatar" id="avatar-${name}">${name.charAt(0)}</div>
                              <div class="info">
                                  <div class="name" style="${style}">${name}</div>
                                  <div class="favor-bar-container">
                                      <div class="favor-bar-bg">
                                          <div class="favor-bar ${favorClass}" style="width: ${favorPercentage}%;"></div>
                                      </div>
                                      <div class="favor-value">${favorability}</div>
                                  </div>
                              </div>
                          </div>
                      `;
                  }).join('');

                  // --- 异步加载所有列表头像和背景 ---
                  sortedEntries.forEach(([name, rel]) => {
                      this.getAvatarFromDB(name).then(avatarRecord => {
                          const avatarEl = document.getElementById(`avatar-${name}`);
                          if (avatarEl && avatarRecord && avatarRecord.avatarImage) {
                              avatarEl.style.backgroundImage = `url(${avatarRecord.avatarImage})`;
                              avatarEl.style.backgroundSize = 'cover';
                              avatarEl.style.backgroundPosition = 'center';
                              avatarEl.textContent = ''; // 清空文字
                          }

                          const cardEl = document.getElementById(`card-${name}`);
                          if (cardEl && avatarRecord && avatarRecord.backgroundImage) {
                              cardEl.style.backgroundImage = `url(${avatarRecord.backgroundImage})`;
                              cardEl.style.backgroundSize = 'cover';
                              cardEl.style.backgroundPosition = 'center';
                          }
                      });
                  });

              } catch (error) {
                  console.error('渲染人物列表时出错:', error);
                  listPanel.innerHTML = '<p class="modal-placeholder">渲染人物列表时出错。</p>';
              }
          },

           async renderCharacterDetails(characterName) {
               const detailsPanel = document.querySelector('#relationships-modal .character-details-panel');
               if (!detailsPanel || !this.currentRelationshipData) return;

               const characterData = this.currentRelationshipData[characterName];
               if (!characterData) {
                   detailsPanel.innerHTML = `<p class="modal-placeholder">无法找到 ${characterName} 的信息。</p>`;
                   return;
               }

               // 1. 异步获取图片和透明度数据
               const avatarRecord = await this.getAvatarFromDB(characterName);
               const avatarImage = avatarRecord ? avatarRecord.avatarImage : '';
               const backgroundImage = avatarRecord ? avatarRecord.backgroundImage : '';
               const backgroundOpacity = avatarRecord ? avatarRecord.backgroundOpacity : 0.5;

               const name = characterName;
               const cultivation = this.SafeGetValue(characterData, '当前修为', '凡人');
               const tierMatch = cultivation.match(/^(练气|筑基|洞玄|合道|飞升|神桥|凡人)/);
               const tier = tierMatch ? tierMatch[0] : '凡人';
               const age = this.SafeGetValue(characterData, '年龄', '??');
               const appearance = this.SafeGetValue(characterData, '外貌', '暂无');
               const personality = this.SafeGetValue(characterData, '性格', '暂无');
               const origin = this.SafeGetValue(characterData, '出身', '暂无');
               const lifespan = this.SafeGetValue(characterData, '寿元', '??');
               const location = this.SafeGetValue(characterData, '所处地点', '未知');
               const cultivationProgress = this.SafeGetValue(characterData, '修炼进度', 0);

               const style = this.getJingJieStyle(tier);
               
               // 2. 更新HTML模板
               const avatarStyle = avatarImage ? `background-image: url(${avatarImage}); background-size: cover; background-position: center;` : '';
               this.updateCharacterDetailsBackground(backgroundImage, backgroundOpacity);

               let html = `
                   <div class="details-header">
                       <div class="avatar-container">
                           <div class="large-avatar" id="large-avatar-${name}" style="${avatarStyle}">${avatarImage ? '' : name.charAt(0)}</div>
                           <div class="custom-image-prompt">
                               <i class="fas fa-camera"></i>
                               <span>点击上传图片</span>
                           </div>
                       </div>
                       <div class="main-info">
                           <div class="name" style="${style}">${name}</div>
                           <div style="display: flex; align-items: center; justify-content: space-between; gap: 15px; margin-top: 5px;">
                             <div style="display: flex; align-items: center; gap: 15px;">
                               <div class="title">${cultivation} · ${age}/${lifespan}</div>
                               <div class="location-tag"><i class="fas fa-map-marker-alt"></i> ${location}</div>
                             </div>
                             <div style="display: flex; align-items: center; min-width: 280px;">
                                 <strong style="white-space: nowrap; color: #c9aa71; font-size: 13px; margin-right: 10px;">修炼进度:</strong>
                                 <div class="progress-bar-container" style="width: 150px; display: flex; align-items: center;">
                                     <div class="progress-bar-bg" style="flex-grow: 1;">
                                         <div class="progress-bar-fill" style="width: ${cultivationProgress}%;"></div>
                                     </div>
                                     <span style="margin-left: 10px; color: #e8dcc6; font-size: 13px; white-space: nowrap;">${cultivationProgress}%</span>
                                 </div>
                             </div>
                           </div>
                       </div>
                   </div>
                   <div class="details-tabs">
                       <button class="tab-button active" data-tab="attributes">详情</button>
                       <button class="tab-button" data-tab="journey">道途</button>
                       <button class="tab-button" data-tab="skills">功法</button>
                       <button class="tab-button" data-tab="equipment">装备</button>
                       <button class="tab-button" data-tab="inventory">储物袋</button>
                       <button class="tab-button" data-tab="social">社交</button>
                       <button class="tab-button" data-tab="memory">记忆</button>
                       <button class="tab-button" data-tab="advanced">高级</button>
                   </div>
                   <div class="details-content" style="display: flex; flex-direction: column; flex-grow: 1; min-height: 0;">
                       <div class="tab-pane active" id="tab-attributes">
                           <div class="info-section">
                               <h4>基本信息</h4>
                               <div class="info-grid">
                                   <div class="info-item full-width"><strong style="color: #c9aa71;">身份背景:</strong> ${this.SafeGetValue(characterData, '身份背景', '暂无')}</div>
                                   <div class="info-item full-width"><strong style="color: #c9aa71;">性格:</strong> ${personality}</div>
                                   <div class="info-item full-width"><strong style="color: #c9aa71;">外貌:</strong> ${appearance}</div>
                                   <div class="info-item full-width"><strong style="color: #c9aa71;">穿着:</strong> ${this.SafeGetValue(characterData, '穿着', '暂无')}</div>
                                   <div class="info-item"><strong style="color: #c9aa71;">魅力:</strong> ${this.getCharmDisplayHTML(this.SafeGetValue(characterData, '魅力', 0))}</div>
                                   <div class="info-item"><strong style="color: #c9aa71;">关系:</strong> ${this.SafeGetValue(characterData, '关系', '未知')}</div>
                               </div>
                               <div style="display: flex; gap: 15px; padding: 6px 0; border-top: 1px solid rgba(201, 170, 113, 0.15); border-bottom: 1px solid rgba(201, 170, 113, 0.15); flex-wrap: nowrap; margin-top: 0;">
                                    <div style="flex: 1; min-width: 0; font-size: 14px;"><strong style="color: #c9aa71;">气运:</strong> ${this.getQiyunDisplayHTML(this.SafeGetValue(characterData, '气运', 0))}</div>
                                    <div style="flex: 1; min-width: 0; font-size: 14px;"><strong style="color: #c9aa71;">悟性:</strong> ${this.getWuxingDisplayHTML(this.SafeGetValue(characterData, '悟性', 0))}</div>
                               </div>
                               <div class="info-grid" style="margin-top: 8px; gap: 4px;">
                                    ${this.getAttributeProgressHTML(this.SafeGetValue(characterData, '当前血量', 0), this.SafeGetValue(characterData, '血量', 0), '血量')}
                                    ${this.getAttributeProgressHTML(this.SafeGetValue(characterData, '当前神海', 0), this.SafeGetValue(characterData, '神海', 0), '神海')}
                                    ${this.getAttributeProgressHTML(this.SafeGetValue(characterData, '当前法力', 0), this.SafeGetValue(characterData, '法力', 0), '法力')}
                                    ${this.getAttributeProgressHTML(this.SafeGetValue(characterData, '当前道心', 0), this.SafeGetValue(characterData, '道心', 0), '道心')}
                                    ${this.getAttributeProgressHTML(this.SafeGetValue(characterData, '当前空速', 0), this.SafeGetValue(characterData, '空速', 0), '空速')}
                               </div>
                               <div class="info-grid" style="margin-top: 12px;">
                                   <input type="checkbox" id="toggle-mind" class="hidden-toggle">
                                   <label for="toggle-mind" class="info-item full-width separator-line">—— 内心 ——</label>
                                   <div class="collapsible-content">
                                       <div class="info-item full-width"><strong style="color: #c9aa71;">当前内心想法:</strong> ${this.SafeGetValue(characterData, '当前内心想法', '暂无')}</div>
                                       <div class="info-item full-width"><strong style="color: #c9aa71;">短期目标:</strong> ${this.SafeGetValue(characterData, '短期目标', '暂无')}</div>
                                       <div class="info-item full-width"><strong style="color: #c9aa71;">长期目标:</strong> ${this.SafeGetValue(characterData, '长期目标', '暂无')}</div>
                                   </div>
                               </div>
                           </div>
                       </div>
                       <div class="tab-pane" id="tab-journey">${this._renderDaotuContent(characterData)}</div>
                       <div class="tab-pane" id="tab-skills">${this._renderGongfaSection(characterData)}</div>
                       <div class="tab-pane" id="tab-equipment">${this._renderEquipmentSection(characterData)}</div>
                       <div class="tab-pane" id="tab-inventory">${this._renderInventorySection(characterData)}</div>
                       <div class="tab-pane" id="tab-social">${this._renderSocialSection(characterData)}</div>
                       <div class="tab-pane" id="tab-memory">${this._renderMemorySection(characterData)}</div>
                       <div class="tab-pane" id="tab-advanced">
                            <div class="info-section">
                                <h4>背景设置</h4>
                                <div style="padding: 15px 0;">
                                    <div style="display: flex; align-items: center; margin-bottom: 15px;">
                                        <i class="fas fa-eye" style="color: #c9aa71; margin-right: 8px;"></i>
                                        <span style="color: #c9aa71; font-size: 14px; margin-right: 15px;">背景透明度:</span>
                                        <input type="range" id="avatar-opacity-slider" min="0" max="1" step="0.05" value="${backgroundOpacity}" style="flex: 1; max-width: 200px;" title="调整背景透明度">
                                        <span id="avatar-opacity-value" style="margin-left: 10px; color: #e8dcc6; font-size: 14px; min-width: 40px;">${Math.round(backgroundOpacity * 100)}%</span>
                                    </div>
                                </div>
                            </div>
                            <div class="info-section" style="margin-top: 15px;">
                                <h4>数据统计</h4>
                                <div style="padding: 15px 0;">
                                    <div style="display: flex; align-items: center; color: #e8dcc6; font-size: 14px;">
                                        <i class="fas fa-database" style="color: #c9aa71; margin-right: 8px;"></i>
                                        <span style="color: #c9aa71; margin-right: 8px;">占用Token:</span>
                                        <span id="character-token-count" style="color: #daa520; font-weight: bold;">计算中...</span>
                                    </div>
                                </div>
                            </div>
                            <div class="info-section" style="margin-top: 15px;">
                                 <h4>高级指令</h4>
                                 <div class="action-buttons" style="padding-top: 15px; display: flex; flex-direction: column; gap: 10px; align-items: stretch;">
                                     <button class="interaction-btn" id="btn-enhance-character" style="width: 100%;">完善人设</button>
                                     <button class="interaction-btn" id="btn-delete-character" style="width: 100%; background: linear-gradient(45deg, #8b2e2e, #cd5c5c); border-color: #cd5c5c;">删除人物</button>
                                 </div>
                             </div>
                        </div>
                   </div>
               `;
               detailsPanel.innerHTML = html;

               // 3. 更新事件绑定
               const avatarContainer = detailsPanel.querySelector('.avatar-container');
               const opacitySlider = detailsPanel.querySelector('#avatar-opacity-slider');
               const opacityValueEl = detailsPanel.querySelector('#avatar-opacity-value');
               let debounceTimer;

               // 绑定头像上传事件（新增：支持从图库选择）
               if (avatarContainer) {
                   avatarContainer.onclick = (e) => {
                       if (e.target.closest('.large-avatar') || e.target.closest('.custom-image-prompt')) {
                           this.showAvatarSourcePicker(characterName);
                       }
                   };
               }

               // 绑定背景透明度滑块事件
               if (opacitySlider) {
                   let animationFrameId = null;
                   opacitySlider.addEventListener('input', () => {
                       const newOpacity = opacitySlider.value;

                       // 使用requestAnimationFrame优化UI更新
                       if (animationFrameId) {
                           cancelAnimationFrame(animationFrameId);
                       }
                       animationFrameId = requestAnimationFrame(() => {
                           this.updateCharacterDetailsBackground(backgroundImage, newOpacity); // 更新伪元素样式
                           if (opacityValueEl) opacityValueEl.textContent = `${Math.round(newOpacity * 100)}%`;
                       });
                       
                       // 使用防抖优化数据库写入
                       clearTimeout(debounceTimer);
                       debounceTimer = setTimeout(() => {
                           this.storeAvatarInDB({
                               characterName: characterName,
                               backgroundOpacity: parseFloat(newOpacity)
                           });
                       }, 500);
                   });
               }

               // Re-bind tab events - 更新为支持tab记忆
               const tabs = detailsPanel.querySelectorAll('.tab-button');
               const panes = detailsPanel.querySelectorAll('.tab-pane');
               
               // 从localStorage恢复上次激活的tab
               const savedTab = localStorage.getItem('guixu_relationship_tab');
               const currentTab = savedTab || this.currentRelationshipTab || 'attributes';
               this.currentRelationshipTab = currentTab;
               
               tabs.forEach(t => t.classList.remove('active'));
               panes.forEach(p => p.classList.remove('active'));
               
               const activeTab = detailsPanel.querySelector(`[data-tab="${currentTab}"]`);
               const activePane = detailsPanel.querySelector(`#tab-${currentTab}`);
               if (activeTab && activePane) {
                   activeTab.classList.add('active');
                   activePane.classList.add('active');
               } else {
                   // 如果找不到上次的tab，回退到第一个
                   tabs[0]?.classList.add('active');
                   panes[0]?.classList.add('active');
               }
               
               // 绑定点击事件，并记录tab状态
               tabs.forEach(tab => {
                   tab.addEventListener('click', () => {
                       tabs.forEach(t => t.classList.remove('active'));
                       tab.classList.add('active');
                       panes.forEach(p => p.classList.remove('active'));
                       const targetPane = detailsPanel.querySelector(`#tab-${tab.dataset.tab}`);
                       if(targetPane) {
                           targetPane.classList.add('active');
                           // 记录当前激活的tab并保存到localStorage
                           this.currentRelationshipTab = tab.dataset.tab;
                           localStorage.setItem('guixu_relationship_tab', tab.dataset.tab);
                       }
                   });
               });

               // 计算并显示token数量
                const tokenCountEl = detailsPanel.querySelector('#character-token-count');
                if (tokenCountEl) {
                    const tokenCount = this.calculateCharacterTokenCount(characterData);
                    tokenCountEl.textContent = `约 ${tokenCount} 字符`;
                }

                // 绑定高级操作按钮事件
                const enhanceBtn = detailsPanel.querySelector('#btn-enhance-character');
                if (enhanceBtn) {
                    enhanceBtn.addEventListener('click', () => {
                        // 直接使用 characterData 对象，即角色的 stat_data
                        const statData = characterData;

                        // 将 stat_data 格式化为详细的指令文本
                        const detailedText = `[最高指令] 根据以下角色的stat_data，进行深度完善和扩展：\n\`\`\`json\n${JSON.stringify(statData, null, 2)}\n\`\`\`\n请严格遵循<人物关系列表修改准则>，从武器、装备、饰品、防具、主修功法、辅修功法、真气、筑基奇物、洞天、神妙、本命神妙、仙灵之气、储物袋（至少5件物品）、人物关系网络、重要事件等方面，分步使用变量指令对 ${characterName} 的变量结构进行完善。`;

                        // 使用简化的指令中心接口
                        this.addCommand(detailedText);
                        this.showTemporaryMessage(`已添加详细指令：完善 ${characterName} 的变量`);
                    });
                }

                // 绑定删除按钮事件
                const deleteBtn = detailsPanel.querySelector('#btn-delete-character');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', () => {
                        this.deleteCharacterFromRelationships(characterName);
                    });
                }
                 // 重新绑定事件以处理新渲染的内容
                this.bindRelationshipEvents();
           },
           

          _renderSocialSection(characterData) {
              const socialNetwork = this.SafeGetValue(characterData, '人物关系网', {});
              const entries = Object.entries(socialNetwork).filter(([name]) => name !== '$meta');
              if (entries.length === 0) {
                  return '<p>此人独来独往，尚未建立起自己的人脉。</p>';
              }
              let html = '<div class="social-network-grid">';
              entries.forEach(([name, details]) => {
                  html += `
                      <div class="social-card">
                          <div class="social-card-name">${name}</div>
                          <div class="social-card-relationship">${this.SafeGetValue(details, 'relationship', '未知关系')}</div>
                          <div class="social-card-intimacy">亲密度: ${this.SafeGetValue(details, 'intimacy', '??')}</div>
                          <div class="social-card-description">${this.SafeGetValue(details, 'description', '暂无描述')}</div>
                      </div>
                  `;
              });
              html += '</div>';
              return html;
          },

          // 计算人物数据占用的字符数（Token估算）
          calculateCharacterTokenCount(characterData) {
              try {
                  const jsonString = JSON.stringify(characterData, null, 2);
                  return jsonString.length;
              } catch (error) {
                  console.error('计算Token数量失败:', error);
                  return 0;
              }
          },

          // 计算世界大事占用的字符数（Token估算）
          calculateEventTokenCount(eventData) {
              try {
                  const jsonString = JSON.stringify(eventData, null, 2);
                  return jsonString.length;
              } catch (error) {
                  console.error('计算事件Token数量失败:', error);
                  return 0;
              }
          },

          // 删除世界大事（通用组件）
          async deleteWorldEvent(eventId) {
              if (!eventId) {
                  this.showTemporaryMessage('事件ID无效', 'error');
                  return;
              }

              // 显示确认对话框
              this.showCustomConfirm(
                  `确定要删除事件 "${eventId}" 吗？\n\n此操作将从世界大事列表中移除该事件，且无法撤销。`,
                  async () => {
                      try {
                          // 第一步：获取最新的"本地草稿"
                          const mvuData = this.currentMvuState;
                          if (!mvuData) {
                              this.showTemporaryMessage('无法获取MVU状态！', 'error');
                              return;
                          }

                          // 第二步：在"本地草稿"上进行删除操作
                          const worldEvents = Mvu.getMvuVariable(mvuData, '世界大事', { default_value: {} });
                          
                          // 检查事件是否存在
                          if (!worldEvents[eventId]) {
                              this.showTemporaryMessage(`事件 "${eventId}" 不存在`, 'warning');
                              return;
                          }

                          // 执行删除
                          await Mvu.setMvuVariable(
                              mvuData,
                              `世界大事.${eventId}`,
                              undefined,
                              { reason: `删除世界大事：${eventId}` }
                          );

                          // 第三步：将修改后的"本地草稿"同步回"云端正本"
                          await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                          // 第四步：刷新UI并给予反馈
                          this.showTemporaryMessage(`已成功删除事件 "${eventId}"`, 'success');
                          
                          // 更新当前数据并重新渲染，不关闭模态框
                          this.currentWorldEventsData = mvuData.stat_data;
                          this.renderWorldEventsUI(mvuData.stat_data);

                      } catch (error) {
                          console.error('删除事件失败:', error);
                          this.showTemporaryMessage(`删除失败: ${error.message}`, 'error');
                      }
                  },
                  () => {
                      this.showTemporaryMessage('已取消删除');
                  },
                  true // keepCurrentModal = true，保持当前模态框
              );
          },

          // 删除人物关系（通用组件）
          async deleteCharacterFromRelationships(characterName) {
              if (!characterName) {
                  this.showTemporaryMessage('人物名称无效', 'error');
                  return;
              }

              // 显示确认对话框
              this.showCustomConfirm(
                  `确定要删除 "${characterName}" 吗？\n\n此操作将从人物关系列表中移除该人物，且无法撤销。`,
                  async () => {
                      try {
                          // 第一步：获取最新的"本地草稿"
                          const mvuData = this.currentMvuState;
                          if (!mvuData) {
                              this.showTemporaryMessage('无法获取MVU状态！', 'error');
                              return;
                          }

                          // 第二步：在"本地草稿"上进行删除操作
                          const relationships = Mvu.getMvuVariable(mvuData, '人物关系列表', { default_value: {} });
                          
                          // 检查人物是否存在
                          if (!relationships[characterName]) {
                              this.showTemporaryMessage(`人物 "${characterName}" 不存在`, 'warning');
                              return;
                          }

                          // 执行删除
                          await Mvu.setMvuVariable(
                              mvuData,
                              `人物关系列表.${characterName}`,
                              undefined,
                              { reason: `删除人物：${characterName}` }
                          );

                          // 第三步：将修改后的"本地草稿"同步回"云端正本"
                          await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                          // 第四步：刷新UI并给予反馈
                          this.showTemporaryMessage(`已成功删除 "${characterName}"`, 'success');
                          
                          // 关闭详情面板，刷新列表
                          this.closeModal('relationships-modal');
                          setTimeout(() => {
                              this.showRelationships();
                          }, 300);

                      } catch (error) {
                          console.error('删除人物失败:', error);
                          this.showTemporaryMessage(`删除失败: ${error.message}`, 'error');
                      }
                  },
                  () => {
                      this.showTemporaryMessage('已取消删除');
                  },
                  true // keepCurrentModal = true，保持当前模态框
              );
          },

          _renderMemorySection(characterData) {
              const memory = this.SafeGetValue(characterData, '重要事件记录', {});
              const entries = Object.entries(memory).filter(([name]) => name !== '$meta');
              if (entries.length === 0) {
                  return '<p class="modal-placeholder">往事如烟，此人心中未留下深刻的记忆。</p>';
              }
              try {
                entries.sort((a, b) => {
                    const dateA = new Date(a[0].substring(a[0].indexOf('-') + 1));
                    const dateB = new Date(b[0].substring(b[0].indexOf('-') + 1));
                    return dateB - dateA;
                });
              } catch (e) {
                console.error("解析记忆事件时间失败:", e);
              }

              let html = '<div class="memory-list-new">';
              entries.forEach(([time, details]) => {
                  const type = this.SafeGetValue(details, 'type', '事件');
                  const description = this.SafeGetValue(details, 'description', '...');
                  html += `
                      <div class="memory-event-new" data-memory-key="${time}">
                          <div class="event-dot"></div>
                          <div class="event-main-content">
                              <span class="event-time">${time}</span>
                              <span class="event-description">${description}</span>
                          </div>
                          <div class="event-type-tag">${type}</div>
                      </div>
                  `;
              });
              html += '</div>';
              return html;
          },

          _renderDaotuContent(characterData) {
              const daotuOrder = ['真气', '筑基奇物', '洞天', '神妙', '本命神妙', '仙灵之气'];
              let html = '';
              let hasContent = false;

              daotuOrder.forEach(key => {
                  const data = this.SafeGetValue(characterData, key, null);
                  if (data && (typeof data !== 'object' || Object.keys(data).filter(k => k !== '$meta').length > 0)) {
                      hasContent = true;
                      switch (key) {
                          case '真气':
                              html += this._renderZhenqiSection(data);
                              break;
                          case '筑基奇物':
                              html += this._renderZhujiSection(data);
                              break;
                          case '洞天':
                              html += this._renderDongtianSection(data);
                              break;
                          case '本命神妙':
                              html += this._renderBenmingSection(data);
                              break;
                          case '神妙':
                              html += this._renderShenmiaoSection(data);
                              break;
                          case '仙灵之气':
                              html += this._renderXianlingqiSection(data);
                              break;
                      }
                  }
              });

              return hasContent ? html : '<p>道途漫漫，此人尚未留下独特的足迹。</p>';
          },

          _renderZhenqiSection(data) {
              if (!data) return '';
              const title = '真气';
              const name = Object.keys(data).find(k => k !== '$meta');
              if (!name) return '';
              const item = data[name];
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.品阶 || '凡品';
              const style = this.getItemTierStyle(tier);

              let descriptiveFieldsHtml = '';
              const time = item.获取时间 || item.炼就时间 || item.开辟时间 || item.凝练时间;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>获得于:</strong> ${time}</div>`;
              if (item.经历) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>经历:</strong> ${item.经历}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.百分比加成) {
                  attributesHtml += Object.entries(item.百分比加成).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }

              let termsHtml = '';
              const effects = item.special_effects || item.词条;
              if (effects && typeof effects === 'object') {
                  const termEntries = Object.entries(effects).filter(([key]) => key !== '$meta');
                  if (termEntries.length > 0) {
                      termsHtml += termEntries.map(([key, value]) => `<div class="info-item full-width"><strong>${key}:</strong> ${value.描述 || value}</div>`).join('');
                  }
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.描述 || ''}</div>
                  ${descriptiveFieldsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">来历</h4></div><div class="info-grid">${descriptiveFieldsHtml}</div>` : ''}
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">属性加成</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${termsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">词条</h4></div><div class="info-grid">${termsHtml}</div>` : ''}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">【${tier}】 ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderBenmingSection(data) {
              if (!data) return '';
              const title = '本命神妙';
              const name = Object.keys(data).find(k => k !== '$meta');
              if (!name) return '';
              const item = data[name];
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.品阶 || '凡品';
              const style = this.getItemTierStyle(tier);
              
              let descriptiveFieldsHtml = '';
              const time = item.获取时间 || item.炼就时间 || item.开辟时间 || item.凝练时间;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>获得于:</strong> ${time}</div>`;
              if (item.经历) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>经历:</strong> ${item.经历}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.百分比加成) {
                  attributesHtml += Object.entries(item.百分比加成).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }

              let termsHtml = '';
              if (item.词条 && typeof item.词条 === 'object') {
                  const termEntries = Object.entries(item.词条).filter(([key]) => key !== '$meta');
                  if (termEntries.length > 0) {
                      termsHtml += termEntries.map(([key, value]) => `<div class="info-item full-width"><strong>${key}:</strong> ${value.描述 || value}</div>`).join('');
                  }
              }

              let fusedShenmiaoHtml = '';
              if (item.融合神妙 && typeof item.融合神妙 === 'object') {
                  const fusedEntries = Object.entries(item.融合神妙).filter(([key]) => key !== '$meta');
                  if (fusedEntries.length > 0) {
                      fusedShenmiaoHtml += `<div class="content-divider"><h4 class="daotu-subtitle">融合神妙</h4></div>`;
                      fusedEntries.forEach(([fusedName, fusedData]) => {
                          const fusedTier = fusedData.品阶 || '';
                          const fusedDesc = fusedData.描述 || '暂无描述';
                          fusedShenmiaoHtml += `<div class="info-item full-width"><strong>${fusedName}</strong> ${fusedTier ? `【${fusedTier}】` : ''}: ${fusedDesc}</div>`;
                      });
                  }
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.描述 || ''}</div>
                  ${descriptiveFieldsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">来历</h4></div><div class="info-grid">${descriptiveFieldsHtml}</div>` : ''}
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">属性加成</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${termsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">词条</h4></div><div class="info-grid">${termsHtml}</div>` : ''}
                  ${fusedShenmiaoHtml}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">【${tier}】 ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderZhujiSection(data) {
              if (!data) return '';
              const title = '筑基奇物';
              const name = Object.keys(data).find(k => k !== '$meta');
              if (!name) return '';
              const item = data[name];
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.品阶 || '凡品';
              const style = this.getItemTierStyle(tier);

              let descriptiveFieldsHtml = '';
              const time = item.获取时间 || item.炼就时间 || item.开辟时间 || item.凝练时间;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>获得于:</strong> ${time}</div>`;
              if (item.契合度) descriptiveFieldsHtml += `<div class="info-item"><strong>契合度:</strong> ${item.契合度}</div>`;
              if (item.经历) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>经历:</strong> ${item.经历}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.百分比加成) {
                  attributesHtml += Object.entries(item.百分比加成).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }

              let specialEffectsHtml = '';
              if (item.词条 && Object.keys(item.词条).filter(k => k !== '$meta').length > 0) {
                  specialEffectsHtml = `<div class="content-divider"><h4 class="daotu-subtitle">词条</h4></div>` + Object.entries(item.词条)
                      .filter(([key]) => key !== '$meta')
                      .map(([key, value]) => `<div class="info-item"><strong>${key}:</strong> ${value}</div>`)
                      .join('');
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.描述 || ''}</div>
                  <div class="info-grid">${descriptiveFieldsHtml}</div>
                  <div class="info-grid">${specialEffectsHtml}</div>
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">属性加成</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">【${tier}】 ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderDongtianSection(data) {
              if (!data) return '';
              const title = '洞天';
              const name = Object.keys(data).find(k => k !== '$meta');
              if (!name) return '';
              const item = data[name];
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.品阶 || '凡品';
              const style = this.getItemTierStyle(tier);

              let descriptiveFieldsHtml = '';
              const time = item.获取时间 || item.炼就时间 || item.开辟时间 || item.凝练时间;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>获得于:</strong> ${time}</div>`;
              if (item.经历) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>经历:</strong> ${item.经历}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.百分比加成) {
                  attributesHtml += Object.entries(item.百分比加成).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }

              let daohanHtml = '';
              if (item.道痕 && typeof item.道痕 === 'object') {
                  const daohanEntries = Object.entries(item.道痕).filter(([key]) => key !== '$meta');
                  if (daohanEntries.length > 0) {
                      daohanHtml += `<div class="content-divider" style="margin-top:10px; padding-top:10px;"><h4 class="daotu-subtitle">道痕</h4></div>`;
                      daohanEntries.forEach(([daohanName, daohanData]) => {
                          const daohanTier = daohanData.品阶 || '';
                          const daohanDesc = daohanData.描述 || '暂无描述';
                          daohanHtml += `<div class="info-item full-width"><strong>${daohanName}</strong> ${daohanTier ? `【${daohanTier}】` : ''}: ${daohanDesc}`;
                          
                          // 新增：渲染道痕词条
                          if (daohanData.道痕词条 && typeof daohanData.道痕词条 === 'object') {
                              const termsEntries = Object.entries(daohanData.道痕词条).filter(([key]) => key !== '$meta');
                              if (termsEntries.length > 0) {
                                  daohanHtml += `<div class="daotu-terms">`;
                                  termsEntries.forEach(([termName, termData]) => {
                                      daohanHtml += `<div class="term-item"><strong>${termName}:</strong> ${termData.描述 || termData}</div>`;
                                  });
                                  daohanHtml += `</div>`;
                              }
                          }
                          daohanHtml += `</div>`;
                      });
                  }
              }
              
              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.描述 || ''}</div>
                  ${descriptiveFieldsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">来历</h4></div><div class="info-grid">${descriptiveFieldsHtml}</div>` : ''}
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">属性加成</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${daohanHtml}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">【${tier}】 ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderShenmiaoSection(data) {
              if (!data || typeof data !== 'object') return '';
              const title = '神妙';
              let html = '';
              const shenmiaoEntries = Object.entries(data).filter(([key]) => key !== '$meta');
              if (shenmiaoEntries.length === 0) return '';
              
              shenmiaoEntries.forEach(([name, item]) => {
                  html += this._renderSingleShenmiao(title, name, item);
              });
              return html;
          },

          _renderSingleShenmiao(title, name, item) {
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.品阶 || '凡品';
              const style = this.getItemTierStyle(tier);

              let descriptiveFieldsHtml = '';
              const time = item.获取时间 || item.炼就时间 || item.开辟时间 || item.凝练时间;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>获得于:</strong> ${time}</div>`;
              if (item.经历) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>经历:</strong> ${item.经历}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.百分比加成) {
                  attributesHtml += Object.entries(item.百分比加成).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }

              let termsHtml = '';
              if (item.词条 && typeof item.词条 === 'object') {
                  const termEntries = Object.entries(item.词条).filter(([key]) => key !== '$meta');
                  if (termEntries.length > 0) {
                      termsHtml += termEntries.map(([key, value]) => `<div class="info-item full-width"><strong>${key}:</strong> ${value.描述 || value}</div>`).join('');
                  }
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.描述 || ''}</div>
                  ${descriptiveFieldsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">来历</h4></div><div class="info-grid">${descriptiveFieldsHtml}</div>` : ''}
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">属性加成</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${termsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">词条</h4></div><div class="info-grid">${termsHtml}</div>` : ''}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">【${tier}】 ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderGongfaSection(characterData) {
              const mainGongfaData = this.SafeGetValue(characterData, '主修功法', null);
              const subGongfaData = this.SafeGetValue(characterData, '辅修功法', null);

              let html = '';
              let hasGongfa = false;

              if (mainGongfaData && typeof mainGongfaData === 'object') {
                  const mainEntries = Object.entries(mainGongfaData).filter(([key]) => key !== '$meta');
                  if (mainEntries.length > 0) {
                      const [name, item] = mainEntries[0];
                      html += this._renderSingleGongfa('主修功法', name, item);
                      hasGongfa = true;
                  }
              }

              if (subGongfaData && typeof subGongfaData === 'object') {
                  const subEntries = Object.entries(subGongfaData).filter(([key]) => key !== '$meta');
                  if (subEntries.length > 0) {
                      const [name, item] = subEntries[0];
                      html += this._renderSingleGongfa('辅修功法', name, item);
                      hasGongfa = true;
                  }
              }

              return hasGongfa ? html : '<p>此人尚未修行任何功法。</p>';
          },

          _renderSingleGongfa(title, name, item) {
              if (!item || typeof item !== 'object' || Object.keys(item).length === 0) return '';
              const uniqueId = `toggle-gongfa-${title}-${name.replace(/\s/g, '-')}`;
              const tier = item.tier || item.品阶 || '凡品';
              const style = this.getItemTierStyle(tier);

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.百分比加成) {
                  attributesHtml += Object.entries(item.百分比加成).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }

              let proficiencyHtml = '';
              const proficiency = item.proficiency;
              if (proficiency && typeof proficiency === 'object') {
                  const current = proficiency.current || 0;
                  const max = proficiency.max || 100;
                  const percentage = max > 0 ? Math.round((current / max) * 100) : 0;
                  proficiencyHtml += `<div class="info-item full-width"><strong>熟练度:</strong> ${current} / ${max} (${percentage}%)</div>`;
              }

              let skillEffectsHtml = '';
              const skillEffects = item.skill_effects;
              if (skillEffects && typeof skillEffects === 'object') {
                  const effectEntries = Object.entries(skillEffects).filter(([key]) => key !== '$meta');
                  if (effectEntries.length > 0) {
                      skillEffectsHtml += effectEntries.map(([key, effect]) => {
                          if (typeof effect === 'object' && effect !== null) {
                              const effectName = effect.name || key;
                              const description = effect.description || '';
                              return `<div class="info-item full-width">- <strong>${effectName}:</strong> ${description}</div>`;
                          } else {
                              return `<div class="info-item full-width">- <strong>${key}:</strong> ${effect}</div>`;
                          }
                      }).join('');
                  }
              }

              let skillMovesHtml = '';
              const skillMoves = item.skill_moves;
              if (skillMoves && typeof skillMoves === 'object') {
                  const moveEntries = Object.entries(skillMoves).filter(([key]) => key !== '$meta');
                  if (moveEntries.length > 0) {
                      skillMovesHtml += moveEntries.map(([key, move]) => {
                          if (typeof move === 'object' && move !== null) {
                              const moveName = move.name || key;
                              const description = move.description || '';
                              return `<div class="info-item full-width">- <strong>${moveName}:</strong> ${description}</div>`;
                          } else {
                              return `<div class="info-item full-width">- <strong>${key}:</strong> ${move}</div>`;
                          }
                      }).join('');
                  }
              }

              let termsHtml = '';
              const effects = item.special_effects || item.词条;
              if (effects && typeof effects === 'object') {
                  const termEntries = Object.entries(effects).filter(([key]) => key !== '$meta');
                  if (termEntries.length > 0) {
                      termsHtml += termEntries.map(([key, value]) => {
                          // 兼容嵌套格式
                          if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                              let nestedHtml = `<div class="info-item full-width">- <strong>${key}:</strong></div>`;
                              const nestedEntries = Object.entries(value).filter(([k]) => k !== '$meta');
                              nestedEntries.forEach(([subKey, subValue]) => {
                                  nestedHtml += `<div class="info-item full-width" style="margin-left: 20px;">- <strong>${subKey}:</strong> ${subValue}</div>`;
                              });
                              return nestedHtml;
                          } else {
                              return `<div class="info-item full-width">- <strong>${key}:</strong> ${value.描述 || value}</div>`;
                          }
                      }).join('');
                  }
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.描述 || ''}</div>
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">属性加成</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${proficiencyHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">熟练度</h4></div><div class="info-grid">${proficiencyHtml}</div>` : ''}
                  ${skillEffectsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">功法效果</h4></div><div class="info-grid">${skillEffectsHtml}</div>` : ''}
                  ${skillMovesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">功法招式</h4></div><div class="info-grid">${skillMovesHtml}</div>` : ''}
                  ${termsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">特殊词条</h4></div><div class="info-grid">${termsHtml}</div>` : ''}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">【${tier}】 ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderEquipmentSection(characterData) {
              const equipmentKeys = ['武器', '防具', '饰品', '法宝'];
              let html = '';
              let hasEquipment = false;

              equipmentKeys.forEach(key => {
                  const equipmentData = this.SafeGetValue(characterData, key, null);
                  if (equipmentData && typeof equipmentData === 'object') {
                      const entries = Object.entries(equipmentData).filter(([k]) => k !== '$meta');
                      if (entries.length > 0) {
                          const [name, item] = entries[0];
                          html += this._renderSingleGongfa(key, name, item); // 复用功法的渲染逻辑
                          hasEquipment = true;
                      }
                  }
              });

              return hasEquipment ? html : '<p>此人未着寸缕，亦无法宝傍身。</p>';
          },

          _renderInventorySection(characterData) {
              const inventoryData = this.SafeGetValue(characterData, '储物袋', null);
              if (!inventoryData || typeof inventoryData !== 'object') {
                  return '<p class="modal-placeholder" style="text-align:center;">此人身无长物，储物袋空空如也。</p>';
              }

              const itemEntries = Object.entries(inventoryData).filter(([key]) => key !== '$meta');

              if (itemEntries.length === 0) {
                  return '<p class="modal-placeholder" style="text-align:center;">此人身无长物，储物袋空空如也。</p>';
              }

              let html = '<div class="inventory-item-list">';
              const sortedItems = this.sortByTier(itemEntries, ([, item]) => this.SafeGetValue(item, 'tier', '凡品'));
              
              sortedItems.forEach(([name, item]) => {
                  html += this._renderInventoryItem(name, item);
              });
              html += '</div>';

              return html;
          },

          _renderInventoryItem(name, item) {
              if (!item || typeof item !== 'object') return '';

              const tier = this.SafeGetValue(item, 'tier', '凡品');
              const tierStyle = this.getItemTierStyle(tier);
              const quantity = this.SafeGetValue(item, 'quantity', 1);
              const quantityDisplay = quantity > 1 ? `<span class="item-quantity">x${quantity}</span>` : '';
              const description = this.SafeGetValue(item, 'description', this.SafeGetValue(item, 'effect', '无描述'));
              
              const tierDisplay = tier !== '无' ? `<span style="${tierStyle}">品阶: ${tier}</span>` : '';

              let detailsHtml = '';
              const attributes = this.SafeGetValue(item, 'attributes_bonus', null);
              const percentage = this.SafeGetValue(item, '百分比加成', null);
              
              if (attributes) {
                  detailsHtml += Object.entries(attributes).map(([key, value]) => `<div>${key}: +${value}</div>`).join('');
              }
              if (percentage) {
                  detailsHtml += Object.entries(percentage).map(([key, value]) => `<div>${key}: +${value}</div>`).join('');
              }

              const proficiency = item.proficiency;
              if (proficiency && typeof proficiency === 'object') {
                  const current = proficiency.current || 0;
                  const max = proficiency.max || 100;
                  const percentageVal = max > 0 ? Math.round((current / max) * 100) : 0;
                  detailsHtml += `<div><strong>熟练度:</strong> ${current} / ${max} (${percentageVal}%)</div>`;
              }

              const skillEffects = item.skill_effects;
              if (skillEffects && typeof skillEffects === 'object') {
                  const effectEntries = Object.entries(skillEffects).filter(([key]) => key !== '$meta');
                  if (effectEntries.length > 0) {
                      detailsHtml += '<div style="margin-top: 8px;"><strong>功法效果:</strong></div>';
                      effectEntries.forEach(([key, effect]) => {
                          if (typeof effect === 'object' && effect !== null) {
                              const effectName = effect.name || key;
                              const effectDesc = effect.description || '';
                              detailsHtml += `<div style="margin-left: 15px;">- <strong>${effectName}:</strong> ${effectDesc}</div>`;
                          } else {
                              detailsHtml += `<div style="margin-left: 15px;">- <strong>${key}:</strong> ${effect}</div>`;
                          }
                      });
                  }
              }

              const skillMoves = item.skill_moves;
              if (skillMoves && typeof skillMoves === 'object') {
                  const moveEntries = Object.entries(skillMoves).filter(([key]) => key !== '$meta');
                  if (moveEntries.length > 0) {
                      detailsHtml += '<div style="margin-top: 8px;"><strong>功法招式:</strong></div>';
                      moveEntries.forEach(([key, move]) => {
                          if (typeof move === 'object' && move !== null) {
                              const moveName = move.name || key;
                              const moveDesc = move.description || '';
                              detailsHtml += `<div style="margin-left: 15px;">- <strong>${moveName}:</strong> ${moveDesc}</div>`;
                          } else {
                              detailsHtml += `<div style="margin-left: 15px;">- <strong>${key}:</strong> ${move}</div>`;
                          }
                      });
                  }
              }

              const effects = item.special_effects || item.词条;
              if (effects && typeof effects === 'object') {
                  detailsHtml += Object.entries(effects).filter(([key]) => key !== '$meta').map(([key, value]) => {
                      // 兼容嵌套格式
                      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                          let nestedHtml = `<div>- <strong>${key}:</strong></div>`;
                          const nestedEntries = Object.entries(value).filter(([k]) => k !== '$meta');
                          nestedEntries.forEach(([subKey, subValue]) => {
                              nestedHtml += `<div style="margin-left: 15px;">- <strong>${subKey}:</strong> ${subValue}</div>`;
                          });
                          return nestedHtml;
                      } else {
                          return `<div>- <strong>${key}:</strong> ${value.描述 || value}</div>`;
                      }
                  }).join('');
              }

              return `
                  <div class="inventory-item" data-item-name="${name}">
                      <div class="inventory-item-actions">
                          <button class="inventory-action-btn" data-action="request" data-item-name="${name}">请求赠予</button>
                          <button class="inventory-action-btn" data-action="trade" data-item-name="${name}">交易</button>
                          <button class="inventory-action-btn" data-action="ask" data-item-name="${name}">询问</button>
                          <button class="inventory-action-btn" data-action="steal" data-item-name="${name}">盗取</button>
                      </div>
                      <div class="item-header">
                          <div class="item-name" style="${tierStyle}">${name}</div>
                          <div class="item-meta">
                              ${tierDisplay}
                              ${quantityDisplay}
                          </div>
                      </div>
                      <div class="item-description">${description}</div>
                      ${detailsHtml ? `<div class="item-details">${detailsHtml}</div>` : ''}
                  </div>
              `;
          },

          _renderXianlingqiSection(data) {
             if (!data || data <= 0) return '';
             return `<div class="info-section"><h4>仙灵之气</h4><div class="info-grid"><div class="info-item">${data}</div></div></div>`;
          },

           updateCharacterDetailsBackground(imageUrl, opacity) {
               const styleId = 'character-details-bg-style';
               let styleElement = document.getElementById(styleId);
               if (!styleElement) {
                   styleElement = document.createElement('style');
                   styleElement.id = styleId;
                   document.head.appendChild(styleElement);
               }
               
               let styleContent = '';
               if (imageUrl) {
                   styleContent = `
                       .character-details-panel::before {
                           background-image: url(${imageUrl});
                           opacity: ${opacity};
                       }
                   `;
               } else {
                   styleContent = `
                       .character-details-panel::before {
                           background-image: none;
                       }
                   `;
               }
               styleElement.textContent = styleContent;
           },

          bindRelationshipEvents() {
              const searchIcon = document.querySelector('#relationships-modal .header-icon[title="搜索"]');
              const searchInput = document.querySelector('#relationships-modal .character-search-input');
              const listHeader = document.querySelector('#relationships-modal .character-list-header');

              if (searchIcon && searchInput && listHeader) {
                  // 防止重复绑定
                  if (!searchIcon.dataset.listenerAttached) {
                      searchIcon.addEventListener('click', () => {
                          listHeader.classList.toggle('is-searching');
                          if (listHeader.classList.contains('is-searching')) {
                              searchInput.focus();
                          }
                      });
                      searchInput.addEventListener('input', () => {
                          this.renderCharacterList();
                      });
                      searchIcon.dataset.listenerAttached = 'true';
                  }
              }

              const listPanel = document.querySelector('#relationships-modal .character-list');
              if(listPanel) {
                  listPanel.addEventListener('click', (e) => {
                      const card = e.target.closest('.character-card');
                      if (card && card.dataset.characterName) {
                          // 移除其他卡片的active状态
                          listPanel.querySelectorAll('.character-card').forEach(c => c.classList.remove('active'));
                          // 给当前卡片添加active状态
                          card.classList.add('active');
                          // 保存选择到localStorage
                          const characterName = card.dataset.characterName;
                          this.lastSelectedCharacter = characterName;
                          localStorage.setItem('guixu_last_selected_character', characterName);
                          // 显示详情
                          this.renderCharacterDetails(characterName);
                      }
                  });
              }

              // “添加”按钮事件绑定
              const addIcon = document.querySelector('#relationships-modal .header-icon[title="添加"]');
              if (addIcon && !addIcon.dataset.listenerAttached) {
                  addIcon.addEventListener('click', () => {
                      this.showRelationshipEditor();
                  });
                  addIcon.dataset.listenerAttached = 'true';
              }

              // 排序下拉菜单事件绑定
              const sortDropdown = document.querySelector('#relationships-modal .sort-dropdown');
              if (sortDropdown && !sortDropdown.dataset.listenerAttached) {
                  const sortIcon = sortDropdown.querySelector('.header-icon');
                  const sortMenu = sortDropdown.querySelector('.sort-menu');

                  sortIcon.addEventListener('click', (e) => {
                      e.stopPropagation();
                      sortMenu.classList.toggle('active');
                  });

                  sortMenu.addEventListener('click', (e) => {
                      const option = e.target.closest('.sort-option');
                      if (option && option.dataset.sort) {
                          this.relationshipSortType = option.dataset.sort;
                          this.saveRelationshipSortSettings();
                          this.renderCharacterList();
                          
                          // 更新选中状态
                          sortMenu.querySelectorAll('.sort-option').forEach(opt => opt.classList.remove('selected'));
                          option.classList.add('selected');

                          sortMenu.classList.remove('active');
                      }
                  });

                  // 点击其他地方关闭菜单
                  document.addEventListener('click', (e) => {
                      if (!sortDropdown.contains(e.target)) {
                          sortMenu.classList.remove('active');
                      }
                  });

                  sortDropdown.dataset.listenerAttached = 'true';
              }

              const detailsPanel = document.querySelector('#relationships-modal .character-details-panel');
              if(detailsPanel) {
                  // 移除旧的点击事件监听器（如果存在）
                  if (detailsPanel._clickHandler) {
                      detailsPanel.removeEventListener('click', detailsPanel._clickHandler);
                  }
                  
                  // 创建新的事件处理器
                  detailsPanel._clickHandler = (e) => {
                      const tab = e.target.closest('.tab-button');
                      if (tab && tab.dataset.tab) {
                          detailsPanel.querySelectorAll('.tab-button').forEach(t => t.classList.remove('active'));
                          tab.classList.add('active');

                          detailsPanel.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
                          const targetPane = detailsPanel.querySelector(`#tab-${tab.dataset.tab}`);
                          if (targetPane) {
                              targetPane.classList.add('active');
                              // 记录当前激活的tab并保存到localStorage
                              this.currentRelationshipTab = tab.dataset.tab;
                              localStorage.setItem('guixu_relationship_tab', tab.dataset.tab);
                          }
                      }

                      // 储物袋操作按钮点击事件
                      const actionBtn = e.target.closest('.inventory-action-btn');
                      if (actionBtn) {
                          e.stopPropagation();
                          const action = actionBtn.dataset.action;
                          const itemName = actionBtn.dataset.itemName;
                          const characterName = document.querySelector('#relationships-modal .character-card.active')?.dataset.characterName;
                          
                          if (characterName && itemName) {
                              this.handleInventoryAction(action, itemName, characterName);
                          }
                      }
                  };
                  
                  // 绑定新的事件处理器
                  detailsPanel.addEventListener('click', detailsPanel._clickHandler);

                  // 储物袋物品长按删除事件 - 使用边框动画
                  let inventoryLongPressTimer = null;
                  const inventoryLongPressDuration = 3000;

                  const handleInventoryPressStart = (e, item) => {
                      if (!item || e.target.closest('.inventory-action-btn')) return;

                      const oldIndicator = document.getElementById('inventory-long-press-indicator');
                      if (oldIndicator) oldIndicator.remove();

                      const rect = item.getBoundingClientRect();
                      const indicator = document.createElement('div');
                      indicator.id = 'inventory-long-press-indicator';
                      Object.assign(indicator.style, {
                          position: 'fixed',
                          top: `${rect.top}px`,
                          left: `${rect.left}px`,
                          width: `${rect.width}px`,
                          height: `${rect.height}px`,
                          pointerEvents: 'none',
                          zIndex: '9999',
                          borderRadius: '4px'
                      });

                      const borderTop = document.createElement('div');
                      Object.assign(borderTop.style, { position: 'absolute', top: '0', left: '0', width: '0', height: '2px', backgroundColor: '#ff6b6b', animation: `border-top-anim ${inventoryLongPressDuration / 4000}s linear forwards` });
                      
                      const borderRight = document.createElement('div');
                      Object.assign(borderRight.style, { position: 'absolute', top: '0', right: '0', width: '2px', height: '0', backgroundColor: '#ff6b6b', animation: `border-right-anim ${inventoryLongPressDuration / 4000}s linear forwards ${inventoryLongPressDuration / 4000}s` });
                      
                      const borderBottom = document.createElement('div');
                      Object.assign(borderBottom.style, { position: 'absolute', bottom: '0', right: '0', width: '0', height: '2px', backgroundColor: '#ff6b6b', animation: `border-bottom-anim ${inventoryLongPressDuration / 4000}s linear forwards ${inventoryLongPressDuration / 2000}s` });

                      const borderLeft = document.createElement('div');
                      Object.assign(borderLeft.style, { position: 'absolute', bottom: '0', left: '0', width: '2px', height: '0', backgroundColor: '#ff6b6b', animation: `border-left-anim ${inventoryLongPressDuration / 4000}s linear forwards ${inventoryLongPressDuration * 3 / 4000}s` });

                      indicator.append(borderTop, borderRight, borderBottom, borderLeft);
                      document.body.appendChild(indicator);
                      
                      inventoryLongPressTimer = setTimeout(() => {
                          const itemName = item.dataset.itemName;
                          const characterName = document.querySelector('#relationships-modal .character-card.active')?.dataset.characterName;
                          if (itemName && characterName) {
                              this.deleteInventoryItem(characterName, itemName);
                          }
                          inventoryLongPressTimer = null;
                          const existingIndicator = document.getElementById('inventory-long-press-indicator');
                          if (existingIndicator) existingIndicator.remove();
                      }, inventoryLongPressDuration);
                  };

                  const removeInventoryIndicator = () => {
                      const existingIndicator = document.getElementById('inventory-long-press-indicator');
                      if (existingIndicator) existingIndicator.remove();
                  };

                  const handleInventoryPressEnd = () => {
                      removeInventoryIndicator();
                      if (inventoryLongPressTimer) {
                          clearTimeout(inventoryLongPressTimer);
                          inventoryLongPressTimer = null;
                      }
                  };

                  // 记忆事件长按删除事件 - 使用边框动画
                  let memoryLongPressTimer = null;
                  const memoryLongPressDuration = 3000;

                  const handleMemoryPressStart = (e, memoryEvent) => {
                      if (!memoryEvent) return;

                      const oldIndicator = document.getElementById('memory-long-press-indicator');
                      if (oldIndicator) oldIndicator.remove();

                      const rect = memoryEvent.getBoundingClientRect();
                      const indicator = document.createElement('div');
                      indicator.id = 'memory-long-press-indicator';
                      Object.assign(indicator.style, {
                          position: 'fixed',
                          top: `${rect.top}px`,
                          left: `${rect.left}px`,
                          width: `${rect.width}px`,
                          height: `${rect.height}px`,
                          pointerEvents: 'none',
                          zIndex: '9999',
                          borderRadius: '6px'
                      });

                      const borderTop = document.createElement('div');
                      Object.assign(borderTop.style, { position: 'absolute', top: '0', left: '0', width: '0', height: '2px', backgroundColor: '#ff6b6b', animation: `border-top-anim ${memoryLongPressDuration / 4000}s linear forwards` });
                      
                      const borderRight = document.createElement('div');
                      Object.assign(borderRight.style, { position: 'absolute', top: '0', right: '0', width: '2px', height: '0', backgroundColor: '#ff6b6b', animation: `border-right-anim ${memoryLongPressDuration / 4000}s linear forwards ${memoryLongPressDuration / 4000}s` });
                      
                      const borderBottom = document.createElement('div');
                      Object.assign(borderBottom.style, { position: 'absolute', bottom: '0', right: '0', width: '0', height: '2px', backgroundColor: '#ff6b6b', animation: `border-bottom-anim ${memoryLongPressDuration / 4000}s linear forwards ${memoryLongPressDuration / 2000}s` });

                      const borderLeft = document.createElement('div');
                      Object.assign(borderLeft.style, { position: 'absolute', bottom: '0', left: '0', width: '2px', height: '0', backgroundColor: '#ff6b6b', animation: `border-left-anim ${memoryLongPressDuration / 4000}s linear forwards ${memoryLongPressDuration * 3 / 4000}s` });

                      indicator.append(borderTop, borderRight, borderBottom, borderLeft);
                      document.body.appendChild(indicator);
                      
                      memoryLongPressTimer = setTimeout(() => {
                          const memoryKey = memoryEvent.dataset.memoryKey;
                          const characterName = document.querySelector('#relationships-modal .character-card.active')?.dataset.characterName;
                          if (memoryKey && characterName) {
                              this.deleteMemoryEvent(characterName, memoryKey);
                          }
                          memoryLongPressTimer = null;
                          const existingIndicator = document.getElementById('memory-long-press-indicator');
                          if (existingIndicator) existingIndicator.remove();
                      }, memoryLongPressDuration);
                  };

                  const removeMemoryIndicator = () => {
                      const existingIndicator = document.getElementById('memory-long-press-indicator');
                      if (existingIndicator) existingIndicator.remove();
                  };

                  const handleMemoryPressEnd = () => {
                      removeMemoryIndicator();
                      if (memoryLongPressTimer) {
                          clearTimeout(memoryLongPressTimer);
                          memoryLongPressTimer = null;
                      }
                  };

                  // 移除旧的鼠标事件监听器（如果存在）
                  if (detailsPanel._mousedownHandler) {
                      detailsPanel.removeEventListener('mousedown', detailsPanel._mousedownHandler);
                  }
                  if (detailsPanel._mouseupHandler) {
                      detailsPanel.removeEventListener('mouseup', detailsPanel._mouseupHandler);
                  }
                  if (detailsPanel._mouseleaveHandler) {
                      detailsPanel.removeEventListener('mouseleave', detailsPanel._mouseleaveHandler);
                  }
                  if (detailsPanel._touchstartHandler) {
                      detailsPanel.removeEventListener('touchstart', detailsPanel._touchstartHandler);
                  }
                  if (detailsPanel._touchendHandler) {
                      detailsPanel.removeEventListener('touchend', detailsPanel._touchendHandler);
                  }
                  if (detailsPanel._touchcancelHandler) {
                      detailsPanel.removeEventListener('touchcancel', detailsPanel._touchcancelHandler);
                  }
                  
                  // 创建并保存新的事件处理器
                  detailsPanel._mousedownHandler = (e) => {
                      const inventoryItem = e.target.closest('.inventory-item');
                      if (inventoryItem) {
                          handleInventoryPressStart(e, inventoryItem);
                      }
                      
                      const memoryEvent = e.target.closest('.memory-event-new');
                      if (memoryEvent) {
                          handleMemoryPressStart(e, memoryEvent);
                      }
                  };
                  
                  detailsPanel._mouseupHandler = () => {
                      handleInventoryPressEnd();
                      handleMemoryPressEnd();
                  };
                  
                  detailsPanel._mouseleaveHandler = () => {
                      handleInventoryPressEnd();
                      handleMemoryPressEnd();
                  };
                  
                  // 触摸事件处理器
                  detailsPanel._touchstartHandler = (e) => {
                      const inventoryItem = e.target.closest('.inventory-item');
                      if (inventoryItem) {
                          handleInventoryPressStart(e, inventoryItem);
                      }
                      
                      const memoryEvent = e.target.closest('.memory-event-new');
                      if (memoryEvent) {
                          handleMemoryPressStart(e, memoryEvent);
                      }
                  };
                  
                  detailsPanel._touchendHandler = () => {
                      handleInventoryPressEnd();
                      handleMemoryPressEnd();
                  };
                  
                  detailsPanel._touchcancelHandler = () => {
                      handleInventoryPressEnd();
                      handleMemoryPressEnd();
                  };
                  
                  // 绑定新的事件处理器
                  detailsPanel.addEventListener('mousedown', detailsPanel._mousedownHandler);
                  detailsPanel.addEventListener('mouseup', detailsPanel._mouseupHandler);
                  detailsPanel.addEventListener('mouseleave', detailsPanel._mouseleaveHandler);
                  detailsPanel.addEventListener('touchstart', detailsPanel._touchstartHandler, { passive: true });
                  detailsPanel.addEventListener('touchend', detailsPanel._touchendHandler);
                  detailsPanel.addEventListener('touchcancel', detailsPanel._touchcancelHandler);
              }
          },

          // 处理储物袋操作按钮点击
          handleInventoryAction(action, itemName, characterName) {
              let commandText = '';
              switch (action) {
                  case 'request':
                      commandText = `[行动] 我向 ${characterName} 请求赠予物品【${itemName}】。`;
                      break;
                  case 'trade':
                      commandText = `[行动] 我向 ${characterName} 提出交易物品【${itemName}】。`;
                      break;
                  case 'ask':
                      commandText = `[行动] 我向 ${characterName} 询问关于物品【${itemName}】的信息。`;
                      break;
                  case 'steal':
                      commandText = `[行动] 我尝试从 ${characterName} 处盗取物品【${itemName}】。`;
                      break;
              }
              
              if (commandText) {
                  this.addCommand(commandText);
                  this.showTemporaryMessage(`已添加指令到指令中心`, 'success');
              }
          },

          // 删除储物袋物品
          async deleteInventoryItem(characterName, itemName) {
              if (!characterName || !itemName) {
                  this.showTemporaryMessage('参数无效', 'error');
                  return;
              }

              try {
                  const mvuData = this.currentMvuState;
                  if (!mvuData) {
                      this.showTemporaryMessage('无法获取MVU状态！', 'error');
                      return;
                  }

                  const inventory = Mvu.getMvuVariable(mvuData, `人物关系列表.${characterName}.储物袋`, { default_value: {} });
                  
                  if (!inventory[itemName]) {
                      this.showTemporaryMessage(`物品 "${itemName}" 不存在`, 'warning');
                      return;
                  }

                  await Mvu.setMvuVariable(
                      mvuData,
                      `人物关系列表.${characterName}.储物袋.${itemName}`,
                      undefined,
                      { reason: `删除${characterName}的储物袋物品：${itemName}` }
                  );

                  await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                  this.showTemporaryMessage(`已删除物品 "${itemName}"`, 'success');
                  
                  // 刷新详情面板
                  setTimeout(() => {
                      this.renderCharacterDetails(characterName);
                  }, 100);

              } catch (error) {
                  console.error('删除物品失败:', error);
                  this.showTemporaryMessage(`删除失败: ${error.message}`, 'error');
              }
          },

          // 删除记忆事件
          async deleteMemoryEvent(characterName, memoryKey) {
              if (!characterName || !memoryKey) {
                  this.showTemporaryMessage('参数无效', 'error');
                  return;
              }

              try {
                  const mvuData = this.currentMvuState;
                  if (!mvuData) {
                      this.showTemporaryMessage('无法获取MVU状态！', 'error');
                      return;
                  }

                  const memory = Mvu.getMvuVariable(mvuData, `人物关系列表.${characterName}.重要事件记录`, { default_value: {} });
                  
                  if (!memory[memoryKey]) {
                      this.showTemporaryMessage(`记忆 "${memoryKey}" 不存在`, 'warning');
                      return;
                  }

                  // 直接从对象中删除键
                  delete memory[memoryKey];
                  
                  // 更新整个重要事件记录对象
                  await Mvu.setMvuVariable(
                      mvuData,
                      `人物关系列表.${characterName}.重要事件记录`,
                      memory,
                      { reason: `删除${characterName}的记忆：${memoryKey}` }
                  );

                  await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                  this.showTemporaryMessage(`已删除记忆 "${memoryKey}"`, 'success');
                  
                  // 刷新详情面板
                  setTimeout(() => {
                      this.renderCharacterDetails(characterName);
                  }, 100);

              } catch (error) {
                  console.error('删除记忆失败:', error);
                  this.showTemporaryMessage(`删除失败: ${error.message}`, 'error');
              }
          },

          adjustRelationshipPanelWidth() {
            const container = document.querySelector('#relationships-modal .relationships-container');
            if (!container) return;
        
            const listPanel = container.querySelector('.character-list-panel');
            const detailsPanel = container.querySelector('.character-details-panel');
            if (!listPanel || !detailsPanel) return;
        
            const tabPanes = detailsPanel.querySelectorAll('.tab-pane');
            if (tabPanes.length === 0) return;
        
            let minContentWidth = Infinity;
            let maxContentWidth = 0;
            tabPanes.forEach(pane => {
                const originalDisplay = pane.style.display;
                pane.style.display = 'block'; 
                
                const currentWidth = pane.scrollWidth;
                if (currentWidth > 0) {
                    minContentWidth = Math.min(minContentWidth, currentWidth);
                }
                maxContentWidth = Math.max(maxContentWidth, currentWidth);
                
                pane.style.display = originalDisplay; 
            });
            if (minContentWidth === Infinity) {
                minContentWidth = 200;
            }
        
            const padding = 40; 
            const finalDetailsWidth = maxContentWidth + padding;
            detailsPanel.style.width = `${finalDetailsWidth}px`;
            detailsPanel.style.flexShrink = '0';
        
            tabPanes.forEach(pane => {
                pane.style.minWidth = `${minContentWidth}px`;
            });
        
            listPanel.style.flexGrow = '1';
          },

          renderIntimateRelationships(relationships) {
    return this.renderRelationships(relationships);
},

         // 新增：加载人物关系设置
         loadRelationshipSettings() {
           try {
             // 加载排序设置
             const savedSort = localStorage.getItem('guixu_relationship_sort');
             this.relationshipSortType = savedSort || 'default';
             
             // 加载显示模式设置
             const savedDisplayMode = localStorage.getItem('guixu_intimate_display_mode');
             this.intimateDisplayMode = savedDisplayMode === 'true';
             
             console.log('加载的排序设置:', this.relationshipSortType);
             console.log('加载的显示模式:', this.intimateDisplayMode);
           } catch (e) {
             console.error('加载人物关系设置失败:', e);
             this.relationshipSortType = 'default';
             this.intimateDisplayMode = false;
           }
         },
         
         setRelationshipSortValue() {
           setTimeout(() => {
             const sortSelect = document.getElementById('relationship-sort');
             if (sortSelect && this.relationshipSortType) {
               sortSelect.value = this.relationshipSortType;
               console.log('设置排序下拉框值为:', this.relationshipSortType);
             }
           }, 100);
         },

         saveRelationshipSortSettings() {
             localStorage.setItem('guixu_relationship_sort', this.relationshipSortType);
         },

         loadRelationshipSortSettings() {
             this.relationshipSortType = localStorage.getItem('guixu_relationship_sort') || 'default';
         },

         // 排序关系条目的函数
         sortRelationshipEntries(entries) {
           const sortType = this.relationshipSortType || 'default';
           
           switch (sortType) {
               case 'cultivation-desc':
               case 'cultivation-asc':
                   const tierOrder = {'凡人':0, '练气':1, '筑基':2, '洞玄':3, '合道':4, '飞升':5, '神桥':5 };
                   entries.sort(([nameA, relA], [nameB, relB]) => {
                       const cultivationA = this.SafeGetValue(relA, '当前修为', '凡人');
                       const cultivationB = this.SafeGetValue(relB, '当前修为', '凡人');

                       // 提取前两个字作为境界进行比较
                       const tierA = cultivationA.substring(0, 2);
                       const tierB = cultivationB.substring(0, 2);

                       const orderA = tierOrder.hasOwnProperty(tierA) ? tierOrder[tierA] : -1;
                       const orderB = tierOrder.hasOwnProperty(tierB) ? tierOrder[tierB] : -1;

                       // 如果两个境界都在排序列表中
                       if (orderA !== -1 && orderB !== -1) {
                           if (orderA !== orderB) {
                               return sortType === 'cultivation-desc' ? orderB - orderA : orderA - orderB;
                           }
                       }
                       // 如果只有一个在列表中，在列表中的排前面
                       else if (orderA !== -1) { return sortType === 'cultivation-desc' ? -1 : 1; }
                       else if (orderB !== -1) { return sortType === 'cultivation-desc' ? 1 : -1; }

                       // 如果都不在列表或境界相同，则按默认名称排序
                       return nameA.localeCompare(nameB);
                   });
                   break;
               case 'favor-desc':
               case 'favor-asc':
                   entries.sort(([nameA, relA], [nameB, relB]) => {
                       const favA = parseInt(this.SafeGetValue(relA, '好感度', 0), 10);
                       const favB = parseInt(this.SafeGetValue(relB, '好感度', 0), 10);
                       if (favA !== favB) {
                           return sortType === 'favor-desc' ? favB - favA : favA - favB;
                       }
                       return nameA.localeCompare(nameB);
                   });
                   break;
               case 'default':
               default:
                   entries.sort(([nameA], [nameB]) => nameA.localeCompare(nameB));
                   break;
           }
           return entries;
         },

         // 新增：处理排序变更
         handleRelationshipSort(sortType) {
           this.relationshipSortType = sortType;
           localStorage.setItem('guixu_relationship_sort', sortType);
           this.showRelationships(); // 重新渲染
         },




// ===人物关系模块（极为重要）结束===

// ===宗门模块开始===

async showSects() {
    this.loadSectSortSettings();
    this.openModal('sects-modal');
    
    const container = document.querySelector('#sects-modal .sects-container');
    if (!container) return;

    const listPanel = container.querySelector('.sect-list-panel .sect-list');
    const detailsPanel = container.querySelector('.sect-details-panel');
    if (!listPanel || !detailsPanel) {
        return;
    }

    listPanel.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">正在整理宗门信息...</p>';
    detailsPanel.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">请先在左侧选择宗门</p>';

    try {
        if (!this.currentMvuState) {
            listPanel.innerHTML = '<p class="modal-placeholder">无法获取宗门数据（状态未初始化）。</p>';
            return;
        }
        const sects = this.SafeGetValue(this.currentMvuState.stat_data, '宗门列表', {});
        this.currentSectData = sects;
        
        this.renderSectList();
        
        const savedSect = localStorage.getItem('guixu_last_selected_sect');
        let targetSectName = null;
        
        if (savedSect && sects[savedSect]) {
            targetSectName = savedSect;
        } else {
            targetSectName = listPanel.querySelector('.sect-card')?.dataset.sectName;
        }
        
        if (targetSectName) {
            const targetCard = listPanel.querySelector(`.sect-card[data-sect-name="${targetSectName}"]`);
            if (targetCard) {
                targetCard.classList.add('active');
            }
            this.renderSectDetails(targetSectName);
            this.lastSelectedSect = targetSectName;
        } else {
            detailsPanel.innerHTML = '<p class="modal-placeholder">暂无宗门详情。</p>';
        }
        
        this.adjustSectPanelWidth();
        const rootContainer = document.querySelector('.guixu-root-container');
        const modalContent = document.querySelector('#sects-modal .modal-content');
        if (rootContainer && modalContent) {
            const rect = rootContainer.getBoundingClientRect();
            modalContent.style.setProperty('width', `${rect.width}px`, 'important');
            modalContent.style.setProperty('height', `${rect.height}px`, 'important');
            modalContent.style.setProperty('top', `${rect.top}px`, 'important');
            modalContent.style.setProperty('left', `${rect.left}px`, 'important');
            modalContent.style.setProperty('max-width', 'none', 'important');
            modalContent.style.setProperty('max-height', 'none', 'important');
        }

    } catch (error) {
        console.error('加载宗门信息时出错:', error);
        listPanel.innerHTML = `<p class="modal-placeholder">加载宗门信息时出错: ${error.message}</p>`;
    }
    
    this.bindSectEvents();
},

renderSectList() {
    const listPanel = document.querySelector('#sects-modal .sect-list');
    const listHeader = document.querySelector('#sects-modal .sect-list-header');
    if (!listPanel || !this.currentSectData || !listHeader) return;

    const sects = this.currentSectData;
    let allSectEntries = Object.entries(sects).filter(([name, sect]) => {
        return name && name !== '$meta' && sect && typeof sect === 'object';
    });

    const searchTerm = listHeader.querySelector('.sect-search-input')?.value || '';
    if (searchTerm) {
        allSectEntries = allSectEntries.filter(([name, sect]) => {
            return name.toLowerCase().includes(searchTerm.toLowerCase());
        });
    }

    const subtitleElement = document.querySelector('#sects-modal .sect-list-header .subtitle');
    if (subtitleElement) {
        subtitleElement.textContent = `共 ${allSectEntries.length} 个宗门`;
    }

    const sortedEntries = this.sortSectEntries(allSectEntries);

    if (sortedEntries.length === 0) {
        listPanel.innerHTML = '<p class="modal-placeholder">暂无宗门信息。</p>';
        return;
    }

    try {
        listPanel.innerHTML = sortedEntries.map(([name, sect]) => {
            const level = this.SafeGetValue(sect, '等级', 1);
            const reputation = this.SafeGetValue(sect, '声望值', 0);
            const status = this.SafeGetValue(sect, '当前状态', '正常');
            const discipleCount = this.SafeGetValue(sect, '弟子人数', 0);
            
            // 获取等级染色背景类名
            const cardBgClass = this.getSectLevelCardBg(level);
            const levelNameHTML = this.getSectLevelDisplayHTML(level);
            
            return `
                <div class="sect-card ${cardBgClass}" data-sect-name="${name}">
                    <div class="sect-card-header">
                        <div class="sect-name">${name}</div>
                        <div class="sect-level">${levelNameHTML}</div>
                    </div>
                    <div class="sect-card-info">
                        <div class="sect-info-item">
                            <span class="sect-info-label">声望:</span>
                            <span class="sect-info-value">${reputation}</span>
                        </div>
                        <div class="sect-info-item">
                            <span class="sect-info-label">弟子:</span>
                            <span class="sect-info-value">${discipleCount}</span>
                        </div>
                    </div>
                    <div class="sect-status">${status}</div>
                </div>
            `;
        }).join('');

    } catch (error) {
        console.error('渲染宗门列表时出错:', error);
        listPanel.innerHTML = '<p class="modal-placeholder">渲染宗门列表时出错。</p>';
    }
},

async renderSectDetails(sectName) {
    const detailsPanel = document.querySelector('#sects-modal .sect-details-panel');
    if (!detailsPanel || !this.currentSectData) return;

    const sectData = this.currentSectData[sectName];
    if (!sectData) {
        detailsPanel.innerHTML = `<p class="modal-placeholder">无法找到 ${sectName} 的信息。</p>`;
        return;
    }

    const name = sectName;
    const level = this.SafeGetValue(sectData, '等级', 1);
    const location = this.SafeGetValue(sectData, '位置', '未知');
    const discipleCount = this.SafeGetValue(sectData, '弟子人数', 0);
    const status = this.SafeGetValue(sectData, '当前状态', '正常');
    const coordinates = this.SafeGetValue(sectData, '位置坐标', '');

    // 获取宗门等级染色样式（直接应用到名称上）
    const nameStyle = this.getSectLevelStyle(level);
    
    let html = `
        <div class="details-header">
            <div class="main-info">
                <div class="name" style="${nameStyle} font-size: 24px; font-weight: bold;">${name}</div>
                <div style="display: flex; align-items: center; gap: 15px; margin-top: 5px;">
                    <div class="title">等级 ${level} · ${location}</div>
                    <div class="location-tag"><i class="fas fa-users"></i> ${discipleCount} 名弟子</div>
                    <div class="status-tag">${status}</div>
                </div>
            </div>
        </div>
        <div class="details-tabs">
            <button class="tab-button active" data-tab="info">详情</button>
            <button class="tab-button" data-tab="members">人物</button>
            <button class="tab-button" data-tab="resources">资源</button>
            <button class="tab-button" data-tab="diplomacy">外交</button>
            <button class="tab-button" data-tab="events">事件</button>
            <button class="tab-button" data-tab="advanced">高级</button>
        </div>
        <div class="details-content" style="display: flex; flex-direction: column; flex-grow: 1; min-height: 0;">
            <div class="tab-pane active" id="tab-info">
                ${this._renderSectInfoSection(sectData)}
            </div>
            <div class="tab-pane" id="tab-members">
                ${this._renderSectMembersSection(sectData)}
            </div>
            <div class="tab-pane" id="tab-resources">
                ${this._renderSectResourcesSection(sectData)}
            </div>
            <div class="tab-pane" id="tab-diplomacy">
                ${this._renderSectDiplomacySection(sectData)}
            </div>
            <div class="tab-pane" id="tab-events">
                ${this._renderSectEventsSection(sectData)}
            </div>
            <div class="tab-pane" id="tab-advanced">
                ${this._renderSectAdvancedSection(sectData, sectName)}
            </div>
        </div>
    `;

    detailsPanel.innerHTML = html;
    this.bindSectEvents();
},

_renderSectInfoSection(sectData) {
    const description = this.SafeGetValue(sectData, '描述', '暂无');
    const philosophy = this.SafeGetValue(sectData, '宗旨理念', '暂无');
    const rules = this.SafeGetValue(sectData, '宗门规矩', '暂无');
    const reputation = this.SafeGetValue(sectData, '声望值', 0);
    const foundedTime = this.SafeGetValue(sectData, '创立时间', '未知');
    const cultivationEnvDesc = this.SafeGetValue(sectData, '修炼环境描述', '暂无');
    const cultivationEnvLevel = this.SafeGetValue(sectData, '修炼环境等级', 1);

    return `
        <div class="info-section">
            <div class="info-item full-width"><strong style="color: #c9aa71;">描述:</strong> ${description}</div>
            <div class="info-item full-width"><strong style="color: #c9aa71;">宗旨理念:</strong> ${philosophy}</div>
            <div class="info-item full-width"><strong style="color: #c9aa71;">宗门规矩:</strong> ${rules}</div>
            <div class="info-item"><strong style="color: #c9aa71;">声望值:</strong> ${reputation}</div>
            <div class="info-item"><strong style="color: #c9aa71;">创立时间:</strong> ${foundedTime}</div>
            <div class="info-item full-width">
                <strong style="color: #c9aa71;">修炼环境:</strong> ${cultivationEnvDesc}
                <span style="color: #e8dcc6;">(等级 ${cultivationEnvLevel})</span>
            </div>
        </div>
    `;
},

_renderSectMembersSection(sectData) {
    const members = this.SafeGetValue(sectData, '宗门人物', {});
    const entries = Object.entries(members).filter(([key]) => key !== '$meta');
    
    if (entries.length === 0) {
        return '<p class="modal-placeholder">暂无宗门成员信息。</p>';
    }

    entries.sort((a, b) => {
        const weightA = this.SafeGetValue(a[1], '职位权重', 0);
        const weightB = this.SafeGetValue(b[1], '职位权重', 0);
        return weightB - weightA;
    });

    // 获取人物关系列表用于补充信息
    const relationships = this.SafeGetValue(this.currentMvuState?.stat_data, '人物关系列表', {});

    let html = '<div class="members-grid">';
    entries.forEach(([key, member]) => {
        const name = this.SafeGetValue(member, '姓名', key);
        const position = this.SafeGetValue(member, '职位', '弟子');
        
        // 从人物关系列表中获取详细信息
        const relationshipData = relationships[name];
        
        // 判断是否有人物关系数据
        const hasRelationshipData = relationshipData && Object.keys(relationshipData).length > 0;
        
        if (!hasRelationshipData) {
            // 如果没有人物关系数据，只显示基本信息
            html += `
                <div class="sect-member-card">
                    <div class="sect-member-header">
                        <span class="sect-member-position">${position}</span>
                        <span class="sect-member-name" style="color: #e8dcc6;">${name}</span>
                    </div>
                </div>
            `;
        } else {
            // 有人物关系数据，显示完整信息
            const cultivation = this.SafeGetValue(relationshipData, '当前修为', '未知');
            const identity = this.SafeGetValue(relationshipData, '身份背景', '暂无');
            const appearance = this.SafeGetValue(relationshipData, '外貌', '暂无');
            const charm = this.SafeGetValue(relationshipData, '魅力', 0);
            const qiyun = this.SafeGetValue(relationshipData, '气运', 0);
            const wuxing = this.SafeGetValue(relationshipData, '悟性', 0);
            
            // 提取境界用于染色
            const tierMatch = cultivation.match(/^(练气|筑基|洞玄|合道|飞升|神桥|凡人)/);
            const tier = tierMatch ? tierMatch[0] : '凡人';
            const nameStyle = this.getJingJieStyle(tier);
            
            // 获取魅力、气运、悟性显示HTML
            const charmHTML = this.getCharmDisplayHTML(charm);
            const qiyunHTML = this.getQiyunDisplayHTML(qiyun);
            const wuxingHTML = this.getWuxingDisplayHTML(wuxing);
            
            html += `
                <div class="sect-member-card">
                    <div class="sect-member-header">
                        <span class="sect-member-position">${position}</span>
                        <span class="sect-member-name" style="${nameStyle}">${name}</span>
                        <span class="sect-member-cultivation">${cultivation}</span>
                        <button class="sect-member-detail-btn" data-character-name="${name}" title="查看详情">查看详情</button>
                    </div>
                    <div class="sect-member-divider"></div>
                    <div class="sect-member-identity">
                        <strong style="color: #c9aa71;">身份背景：</strong><span style="color: #e8dcc6;">${identity}</span>
                    </div>
                    <div class="sect-member-divider"></div>
                    <div class="sect-member-attributes">
                        <div class="sect-member-attr-item">
                            <strong style="color: #c9aa71;">外貌：</strong><span style="color: #e8dcc6;">${appearance}</span>
                        </div>
                        <div class="sect-member-attr-item">
                            <strong style="color: #c9aa71;">魅力：</strong>${charmHTML}
                        </div>
                    </div>
                    <div class="sect-member-divider"></div>
                    <div class="sect-member-attributes">
                        <div class="sect-member-attr-item">
                            <strong style="color: #c9aa71;">气运：</strong>${qiyunHTML}
                        </div>
                        <div class="sect-member-attr-item">
                            <strong style="color: #c9aa71;">悟性：</strong>${wuxingHTML}
                        </div>
                    </div>
                </div>
            `;
        }
    });
    html += '</div>';
    return html;
},

_renderSectResourcesSection(sectData) {
    let html = '<div class="resources-section">';
    
    const mainSkills = this.SafeGetValue(sectData, '镇派功法', {});
    const specialResources = this.SafeGetValue(sectData, '特产资源', {});
    const otherResources = this.SafeGetValue(sectData, '其他资源', {});

    html += '<div class="resource-category">';
    html += '<h4 style="color: #c9aa71; margin-bottom: 10px;">镇派功法</h4>';
    html += this._renderResourceItems(mainSkills);
    html += '</div>';

    html += '<div class="resource-category">';
    html += '<h4 style="color: #c9aa71; margin-bottom: 10px;">特产资源</h4>';
    html += this._renderResourceItems(specialResources);
    html += '</div>';

    html += '<div class="resource-category">';
    html += '<h4 style="color: #c9aa71; margin-bottom: 10px;">其他资源</h4>';
    html += this._renderResourceItems(otherResources);
    html += '</div>';

    html += '</div>';
    return html;
},

_renderResourceItems(resources) {
    const entries = Object.entries(resources).filter(([key]) => key !== '$meta');
    
    if (entries.length === 0) {
        return '<p style="color: #8b7355; font-size: 12px;">暂无</p>';
    }

    let html = '<div class="resource-items">';
    entries.forEach(([name, item]) => {
        const tier = this.SafeGetValue(item, 'tier', '') || this.SafeGetValue(item, '品阶', '');
        const description = this.SafeGetValue(item, 'description', '') || this.SafeGetValue(item, '描述', '');
        // 使用品阶染色系统
        const tierStyle = tier ? this.getItemTierStyle(tier) : 'color: #e8dcc6;';
        
        html += `
            <details class="resource-item">
                <summary>
                    <span style="${tierStyle}">${name}</span>
                    ${tier ? `<span class="resource-tier" style="${tierStyle}">${tier}</span>` : ''}
                </summary>
                <div class="resource-details">
                    ${description ? `<p><strong>描述:</strong> ${description}</p>` : ''}
                </div>
            </details>
        `;
    });
    html += '</div>';
    return html;
},

_renderSectDiplomacySection(sectData) {
    const diplomacy = this.SafeGetValue(sectData, '外交关系', {});
    const entries = Object.entries(diplomacy).filter(([key]) => key !== '$meta');
    
    if (entries.length === 0) {
        return '<p class="modal-placeholder">暂无外交关系。</p>';
    }

    let html = '<div class="sect-diplomacy-grid">';
    entries.forEach(([key, relation]) => {
        const factionName = this.SafeGetValue(relation, '势力名称', key);
        const relationStatus = this.SafeGetValue(relation, '关系状态', '中立');
        const description = this.SafeGetValue(relation, '描述', '暂无描述');
        
        // 根据关系状态对卡片进行染色
        let borderColor = 'rgba(201, 170, 113, 0.2)'; // 默认边框
        let bgColor = 'rgba(26, 26, 46, 0.5)'; // 默认背景
        const statusLower = relationStatus.toLowerCase();
        
        if (statusLower.includes('友好') || statusLower.includes('盟友') || statusLower.includes('友善')) {
            borderColor = 'rgba(102, 205, 170, 0.6)'; // 绿色边框
            bgColor = 'rgba(102, 205, 170, 0.1)'; // 绿色背景
        } else if (statusLower.includes('敌对') || statusLower.includes('敌人') || statusLower.includes('仇敌')) {
            borderColor = 'rgba(220, 20, 60, 0.6)'; // 红色边框
            bgColor = 'rgba(220, 20, 60, 0.1)'; // 红色背景
        } else if (statusLower.includes('中立')) {
            borderColor = 'rgba(255, 215, 0, 0.6)'; // 黄色边框
            bgColor = 'rgba(255, 215, 0, 0.1)'; // 黄色背景
        }
        
        html += `
            <div class="social-card" style="border-color: ${borderColor}; background: ${bgColor};">
                <div class="social-card-name">${factionName}</div>
                <div class="social-card-relationship">${relationStatus}</div>
                <div class="social-card-description">${description}</div>
            </div>
        `;
    });
    html += '</div>';
    return html;
},

_renderSectEventsSection(sectData) {
    const events = this.SafeGetValue(sectData, '特殊事件', {});
    const entries = Object.entries(events).filter(([key]) => key !== '$meta');
    
    if (entries.length === 0) {
        return '<p class="modal-placeholder">暂无特殊事件记录。</p>';
    }

    let html = '<div class="sect-events-grid">';
    entries.forEach(([key, event]) => {
        const eventName = this.SafeGetValue(event, '名称', key);
        const eventDesc = this.SafeGetValue(event, '描述', '暂无描述');
        const eventTime = this.SafeGetValue(event, '时间', '未知');
        
        html += `
            <div class="social-card">
                <div class="social-card-name">${eventName}</div>
                <div class="social-card-intimacy">时间: ${eventTime}</div>
                <div class="social-card-description">${eventDesc}</div>
            </div>
        `;
    });
    html += '</div>';
    return html;
},

_renderSectAdvancedSection(sectData, sectName) {
    const tokenCount = this.calculateSectTokenCount(sectData);
    
    return `
        <div class="advanced-section">
            <div class="info-item">
                <strong style="color: #c9aa71;">Token占用估算:</strong>
                <span style="color: #e8dcc6;">${tokenCount} 字符</span>
            </div>
            <div style="margin-top: 20px;">
                <button id="btn-delete-sect" class="interaction-btn btn-danger" style="width: 100%;">
                    删除此宗门
                </button>
            </div>
        </div>
    `;
},

calculateSectTokenCount(sectData) {
    try {
        const jsonString = JSON.stringify(sectData, null, 2);
        return jsonString.length;
    } catch (error) {
        console.error('计算宗门Token数量失败:', error);
        return 0;
    }
},

async deleteSect(sectName) {
    if (!sectName) {
        this.showTemporaryMessage('宗门名称无效', 'error');
        return;
    }

    this.showCustomConfirm(
        `确定要删除 "${sectName}" 吗？\n\n此操作将从宗门列表中移除该宗门，且无法撤销。`,
        async () => {
            try {
                const mvuData = this.currentMvuState;
                if (!mvuData) {
                    this.showTemporaryMessage('无法获取MVU状态！', 'error');
                    return;
                }

                const sects = Mvu.getMvuVariable(mvuData, '宗门列表', { default_value: {} });
                
                if (!sects[sectName]) {
                    this.showTemporaryMessage(`宗门 "${sectName}" 不存在`, 'warning');
                    return;
                }

                await Mvu.setMvuVariable(
                    mvuData,
                    `宗门列表.${sectName}`,
                    undefined,
                    { reason: `删除宗门：${sectName}` }
                );

                await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                this.showTemporaryMessage(`已成功删除 "${sectName}"`, 'success');
                
                // 直接刷新宗门列表，不关闭模态框
                this.currentSectData = Mvu.getMvuVariable(mvuData, '宗门列表', { default_value: {} });
                this.renderSectList();
                
                // 清空详情面板
                const detailsPanel = document.querySelector('#sects-modal .sect-details-panel');
                if (detailsPanel) {
                    detailsPanel.innerHTML = '<p class="modal-placeholder">请在左侧选择宗门。</p>';
                }

            } catch (error) {
                console.error('删除宗门失败:', error);
                this.showTemporaryMessage(`删除失败: ${error.message}`, 'error');
            }
        },
        () => {
            this.showTemporaryMessage('已取消删除');
        },
        true
    );
},

bindSectEvents() {
    const searchIcon = document.querySelector('#sects-modal .header-icon[title="搜索"]');
    const searchInput = document.querySelector('#sects-modal .sect-search-input');
    const listHeader = document.querySelector('#sects-modal .sect-list-header');

    if (searchIcon && searchInput && listHeader) {
        if (!searchIcon.dataset.listenerAttached) {
            searchIcon.addEventListener('click', () => {
                listHeader.classList.toggle('is-searching');
                if (listHeader.classList.contains('is-searching')) {
                    searchInput.focus();
                }
            });
            searchInput.addEventListener('input', () => {
                this.renderSectList();
            });
            searchIcon.dataset.listenerAttached = 'true';
        }
    }

    const listPanel = document.querySelector('#sects-modal .sect-list');
    if(listPanel) {
        listPanel.addEventListener('click', (e) => {
            const card = e.target.closest('.sect-card');
            if (card && card.dataset.sectName) {
                listPanel.querySelectorAll('.sect-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                const sectName = card.dataset.sectName;
                this.lastSelectedSect = sectName;
                localStorage.setItem('guixu_last_selected_sect', sectName);
                this.renderSectDetails(sectName);
            }
        });
    }

    const sortDropdown = document.querySelector('#sects-modal .sort-dropdown');
    if (sortDropdown && !sortDropdown.dataset.listenerAttached) {
        const sortIcon = sortDropdown.querySelector('.header-icon');
        const sortMenu = sortDropdown.querySelector('.sort-menu');

        sortIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            sortMenu.classList.toggle('active');
        });

        sortMenu.addEventListener('click', (e) => {
            const option = e.target.closest('.sort-option');
            if (option && option.dataset.sort) {
                this.sectSortType = option.dataset.sort;
                this.saveSectSortSettings();
                this.renderSectList();
                
                sortMenu.querySelectorAll('.sort-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');

                sortMenu.classList.remove('active');
            }
        });

        document.addEventListener('click', (e) => {
            if (!sortDropdown.contains(e.target)) {
                sortMenu.classList.remove('active');
            }
        });

        sortDropdown.dataset.listenerAttached = 'true';
    }

    const detailsPanel = document.querySelector('#sects-modal .sect-details-panel');
    if(detailsPanel) {
        if (detailsPanel._clickHandler) {
            detailsPanel.removeEventListener('click', detailsPanel._clickHandler);
        }
        
        detailsPanel._clickHandler = (e) => {
            const tab = e.target.closest('.tab-button');
            if (tab && tab.dataset.tab) {
                detailsPanel.querySelectorAll('.tab-button').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                detailsPanel.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
                const targetPane = detailsPanel.querySelector(`#tab-${tab.dataset.tab}`);
                if (targetPane) {
                    targetPane.classList.add('active');
                    this.currentSectTab = tab.dataset.tab;
                    localStorage.setItem('guixu_sect_tab', tab.dataset.tab);
                }
            }
            
            // 处理"查看详情"按钮点击事件
            const detailBtn = e.target.closest('.sect-member-detail-btn');
            if (detailBtn && detailBtn.dataset.characterName) {
                const characterName = detailBtn.dataset.characterName;
                // 直接打开人物关系模态框，保持宗门模态框打开
                this.openModal('relationships-modal', true);
                
                // 初始化人物关系数据
                const container = document.querySelector('#relationships-modal .relationships-container');
                if (container) {
                    const listPanel = container.querySelector('.character-list-panel .character-list');
                    const detailsPanel = container.querySelector('.character-details-panel');
                    
                    if (listPanel && detailsPanel) {
                        listPanel.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">正在整理人物关系...</p>';
                        detailsPanel.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">请先在左侧选择人物</p>';
                        
                        // 加载人物关系数据
                        const relationships = this.SafeGetValue(this.currentMvuState?.stat_data, '人物关系列表', {});
                        this.currentRelationshipData = relationships;
                        
                        // 渲染人物列表
                        this.renderCharacterList();
                        
                        // 等待渲染完成后跳转到目标人物
                        setTimeout(() => {
                            const characterCard = document.querySelector(`#relationships-modal .character-card[data-character-name="${characterName}"]`);
                            if (characterCard) {
                                // 移除其他卡片的激活状态
                                document.querySelectorAll('#relationships-modal .character-card').forEach(c => c.classList.remove('active'));
                                // 激活目标卡片
                                characterCard.classList.add('active');
                                // 渲染详情
                                this.renderCharacterDetails(characterName);
                                // 滚动到目标卡片
                                characterCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                        }, 100);
                        
                        // 调整面板宽度
                        this.adjustRelationshipPanelWidth();
                        
                        // 绑定事件
                        this.bindRelationshipEvents();
                    }
                }
            }
        };
        
        detailsPanel.addEventListener('click', detailsPanel._clickHandler);
    }

    const deleteBtn = detailsPanel?.querySelector('#btn-delete-sect');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
            const sectName = document.querySelector('#sects-modal .sect-card.active')?.dataset.sectName;
            if (sectName) {
                this.deleteSect(sectName);
            }
        });
    }
},

sortSectEntries(entries) {
    const sortType = this.sectSortType || 'default';
    
    if (sortType === 'default') {
        return entries;
    }
    
    return entries.sort((a, b) => {
        const [nameA, sectA] = a;
        const [nameB, sectB] = b;
        
        switch(sortType) {
            case 'level-desc':
                return this.SafeGetValue(sectB, '等级', 0) - this.SafeGetValue(sectA, '等级', 0);
            case 'level-asc':
                return this.SafeGetValue(sectA, '等级', 0) - this.SafeGetValue(sectB, '等级', 0);
            case 'reputation-desc':
                return this.SafeGetValue(sectB, '声望值', 0) - this.SafeGetValue(sectA, '声望值', 0);
            case 'reputation-asc':
                return this.SafeGetValue(sectA, '声望值', 0) - this.SafeGetValue(sectB, '声望值', 0);
            default:
                return 0;
        }
    });
},

adjustSectPanelWidth() {
    const container = document.querySelector('#sects-modal .sects-container');
    if (!container) return;

    const listPanel = container.querySelector('.sect-list-panel');
    const detailsPanel = container.querySelector('.sect-details-panel');
    if (!listPanel || !detailsPanel) return;

    const containerWidth = container.offsetWidth;
    const listWidth = 280;
    const detailsWidth = containerWidth - listWidth;

    listPanel.style.width = `${listWidth}px`;
    detailsPanel.style.width = `${detailsWidth}px`;
},

loadSectSortSettings() {
    const saved = localStorage.getItem('guixu_sect_sort_type');
    if (saved) {
        this.sectSortType = saved;
    }
},

saveSectSortSettings() {
    if (this.sectSortType) {
        localStorage.setItem('guixu_sect_sort_type', this.sectSortType);
    }
},

// ===宗门模块结束===



// ===品阶、境界排序、染色模块（极为重要）开始===



          // 品阶排序核心函数
          getTierOrder(tier) {
            // 品阶等级映射：数值越高，品阶越高
            // 定义了所有品阶的排序规则，用于 sortByTier 函数。
            const tierOrder = {
              // 练气期
              '凡品': 1,
              '玄品': 2,
              '道品': 3,
              '见我': 4,
              '知命': 5,
              // 筑基期
              '人阶': 6,
              '地阶': 7,
              '天阶': 8,

              // 洞玄境
              '凡尘': 9,
              '灵脉': 10,
              '天象': 11,
              '本源': 12,
              
              // 合道境
              '极品': 13,
              '天品': 14,
              '仙品': 15,

              // 神妙
              '一字神妙': 16,
              '二字神妙': 17,
              '三字神妙': 18,
              '历劫': 19,
              '真一': 20,
              '独仙': 21,

              // 飞升期
              '神品': 22,
              '伪仙器': 23,
              '仙器': 24,

              // 兼容道痕
              '凡尘流韵之痕': 9,
              '灵脉奔涌之痕': 10,
              '天象显化之痕': 11,
              '本源铭刻之痕': 12
            };
            return tierOrder[tier] || 0; // 未知品阶排在最前
          },

          // --- 新增：通用品阶排序函数 ---
          sortByTier(items, getTierFn) {
            if (!Array.isArray(items)) return items;
            
            return [...items].sort((a, b) => {
              const tierA = getTierFn(a);
              const tierB = getTierFn(b);
              const orderA = this.getTierOrder(tierA);
              const orderB = this.getTierOrder(tierB);
              
              // 按 getTierOrder 中定义的品阶顺序从高到低进行稳定排序。
              if (orderA === orderB) {
                return 0;
              }
              return orderB - orderA;
            });
          },

          // 境界染色系统 
          getJingJieStyle(jingjie) {
              const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
              const baseStyle = 'font-style: italic;';
              const gradientAnimation = 'god-tier-animation 5s linear infinite';
              
              const styles = {
                  '练气': 'color: #B0C4DE;', 
                  '筑基': 'color: #66CDAA;', 
                  '洞玄': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`, // 原元婴颜色
                  '合道': `background: linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585); ${animatedStyle} animation: ${gradientAnimation};`,
                  '飞升': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation};`
              };
              return (styles[jingjie] || 'color: #e0dcd1;') + baseStyle;
          },

          // --- 体系分离: 品阶染色系统 ---
          getItemTierStyle(tier) {
              if (typeof tier !== 'string' || !tier) {
                  return 'color: #e0dcd1; font-style: italic;';
              }

              const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
              const baseStyle = 'font-style: italic;';
              const gradientAnimation = 'god-tier-animation 5s linear infinite';
              const fluorescentAnimation = 'breathing-glow 4s ease-in-out infinite';

              const styles = {
                // 练气期品阶
                '凡品': 'color: #FFFFFF;',
                '玄品': `background: linear-gradient(90deg, #87CEFA, #B0E0E6, #ADD8E6, #B0E0E6, #87CEFA); ${animatedStyle} animation: ${gradientAnimation};`,
                '道品': `background: linear-gradient(90deg, #FFD700, #FFFFFF, #FFD700, #FFFFFF, #FFD700); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                '见我': `background: linear-gradient(90deg, #cccccc, #FFFACD, #ffffff, #FFFACD, #bbbbbb, #FFFACD, #cccccc); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                '知命': `background: linear-gradient(90deg, #FFFACD, #206864, #ffffff, #206864, #FFFACD); ${animatedStyle} animation: ${gradientAnimation};`,
                // 筑基期品阶
                '人阶': 'color: #66CDAA;',
                '地阶': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`,
                '天阶': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                // 洞玄境品阶
                '凡尘': 'color: #66CDAA;',
                '灵脉': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`,
                '天象': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle} animation: ${gradientAnimation};`,
                '本源': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                
                // 洞天道痕兼容
                '凡尘流韵之痕': 'color: #66CDAA;',
                '灵脉奔涌之痕': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`,
                '天象显化之痕': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle} animation: ${gradientAnimation};`,
                '本源铭刻之痕': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,

                // 合道境品阶
                '极品': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle} animation: ${gradientAnimation};`,
                '天品': `background: linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585); ${animatedStyle} animation: ${gradientAnimation};`,
                '仙品': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation};`,
                // 飞升期品阶
                '神品': `background: linear-gradient(90deg, #cccccc, #ffffff, #bbbbbb, #ffffff, #cccccc); ${animatedStyle} animation: ${gradientAnimation};`,
                '伪仙器': `background: linear-gradient(90deg, #cccccc, #FFFACD, #ffffff, #FFFACD, #bbbbbb, #FFFACD, #cccccc); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                '仙器': `background: linear-gradient(90deg, #FFFACD, #206864, #ffffff, #206864, #FFFACD); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                // 神妙/本命神妙品阶
                '一字神妙': `background: linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                '二字神妙': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                '三字神妙': `background: linear-gradient(90deg, #cccccc, #ffffff, #bbbbbb, #ffffff, #cccccc); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                '历劫': `background: linear-gradient(90deg, #6A1B9A, #FFFFFF, #6A1B9A); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                '真一': `background: linear-gradient(90deg, #FFD700, rgba(255, 255, 255, 0.8), #FFD700); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                '独仙': `background: linear-gradient(135deg, #a8ff78, #78ffd6, #a8ff78); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
              };

              // 优先完全匹配
              if (styles[tier]) {
                  return styles[tier] + baseStyle;
              }

              // 如果完全匹配失败，则尝试提取核心品阶进行匹配
              const coreTiers = ['玄品', '道品', '人阶', '地阶', '天阶', '极品', '天品', '仙品', '神品', '伪仙器', '仙器'];
              for (const coreTier of coreTiers) {
                  if (tier.startsWith(coreTier)) {
                      return styles[coreTier] + baseStyle;
                  }
              }

              // 如果都失败，返回默认样式
              return 'color: #e0dcd1;' + baseStyle;
          },
          // --- 新增：通用魅力染色系统 ---
          // 根据魅力数值返回对应的等级名称
          getCharmLevelName(charmValue) {
              const charm = parseInt(charmValue, 10);
              if (isNaN(charm)) return '未知';
              
              if (charm >= 181) return '仙姿';
              if (charm >= 141) return '倾国倾城';
              if (charm >= 101) return '绝色';
              if (charm >= 61) return '出众';
              if (charm >= 21) return '清秀';
              if (charm >= 1) return '寻常';
              if (charm >= -100) return '偏丑';
              if (charm >= -200) return '极丑';
              return '未知';
          },

          // 根据魅力数值返回对应的染色样式
          getCharmStyle(charmValue) {
              const charm = parseInt(charmValue, 10);
              if (isNaN(charm)) return 'color: #e0dcd1;';
              
              const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
              const gradientAnimation = 'god-tier-animation 5s linear infinite';
              const fluorescentAnimation = 'breathing-glow 4s ease-in-out infinite';
              
              // 181 到 200：仙姿——粉-红渐变+呼吸+荧光
              if (charm >= 181) {
                  return `background: linear-gradient(90deg, #FFB6C1, #FF69B4, #FF1493, #FF69B4, #FFB6C1); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 141 到 180：倾国倾城——粉-红渐变
              if (charm >= 141) {
                  return `background: linear-gradient(90deg, #FFB6C1, #FF69B4, #FF1493, #FF69B4, #FFB6C1); ${animatedStyle} animation: ${gradientAnimation};`;
              }
              // 101 到 140：绝色——粉色渐变
              if (charm >= 101) {
                  return `background: linear-gradient(90deg, #FFB6C1, #FFC0CB, #FFB6C1); ${animatedStyle} animation: ${gradientAnimation};`;
              }
              // 61 到 100：出众——蓝色
              if (charm >= 61) {
                  return 'color: #6495ED;';
              }
              // 21 到 60：清秀——绿色
              if (charm >= 21) {
                  return 'color: #66CDAA;';
              }
              // 1 到 20：寻常——白色
              if (charm >= 1) {
                  return 'color: #FFFFFF;';
              }
              // -100 到 0：偏丑——灰色
              if (charm >= -100) {
                  return 'color: #808080;';
              }
              // -200 到 -100：极丑——黑色
              if (charm >= -200) {
                  return 'color: #2F2F2F;';
              }
              return 'color: #e0dcd1;';
          },

          // 获取魅力的完整显示HTML（名称+数值）
          getCharmDisplayHTML(charmValue) {
              const charm = parseInt(charmValue, 10);
              if (isNaN(charm)) return '<span style="color: #e0dcd1;">未知</span>';
              
              const levelName = this.getCharmLevelName(charm);
              const style = this.getCharmStyle(charm);
              
              return `<span style="${style}">${levelName}</span><span style="color: #e0dcd1;">（${charm}）</span>`;
          },

          // --- 新增：悟性染色系统 ---
          // 根据悟性数值返回对应的等级名称
          getWuxingLevelName(wuxingValue) {
              const wuxing = parseInt(wuxingValue, 10);
              if (isNaN(wuxing)) return '未知';
              
              if (wuxing >= 151) return '衍道';
              if (wuxing >= 121) return '冠灵';
              if (wuxing >= 81) return '通玄';
              if (wuxing >= 41) return '灵窍';
              if (wuxing >= 21) return '杂鱼';
              if (wuxing >= 0) return '笨蛋';
              return '未知';
          },

          // 根据悟性数值返回对应的染色样式
          getWuxingStyle(wuxingValue) {
              const wuxing = parseInt(wuxingValue, 10);
              if (isNaN(wuxing)) return 'color: #e0dcd1;';
              
              const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
              const gradientAnimation = 'god-tier-animation 5s linear infinite';
              const fluorescentAnimation = 'breathing-glow 4s ease-in-out infinite';
              
              // 151 到 200：衍道——金色（渐变+呼吸+荧光+渐变的颜色数量较多）
              if (wuxing >= 151) {
                  return `background: linear-gradient(90deg, #FFD700, #FFA500, #FFFF00, #FFD700, #FFA500, #FFFF00, #FFD700); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 121 到 150：冠灵——红色（渐变+呼吸+荧光+渐变的颜色数量较多）
              if (wuxing >= 121) {
                  return `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF6347, #DC143C, #FF4500, #B22222); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 81 到 120：通玄——紫色（渐变+呼吸+荧光）
              if (wuxing >= 81) {
                  return `background: linear-gradient(90deg, #9370DB, #8A2BE2, #9932CC, #8A2BE2, #9370DB); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 41 到 80：灵窍——蓝色（渐变）
              if (wuxing >= 41) {
                  return `background: linear-gradient(90deg, #4169E1, #1E90FF, #6495ED, #1E90FF, #4169E1); ${animatedStyle} animation: ${gradientAnimation};`;
              }
              // 21 到 40：杂鱼——白色
              if (wuxing >= 21) {
                  return 'color: #FFFFFF;';
              }
              // 0 到 20：笨蛋——灰色
              if (wuxing >= 0) {
                  return 'color: #808080;';
              }
              return 'color: #e0dcd1;';
          },

          // 获取悟性的完整显示HTML（名称+数值）
          getWuxingDisplayHTML(wuxingValue) {
              const wuxing = parseInt(wuxingValue, 10);
              if (isNaN(wuxing)) return '<span style="color: #e0dcd1;">未知</span>';
              
              const levelName = this.getWuxingLevelName(wuxing);
              const style = this.getWuxingStyle(wuxing);
              
              return `<span style="${style}">${levelName}</span><span style="color: #e0dcd1;">（${wuxing}）</span>`;
          },

          // --- 新增：气运染色系统 ---
          // 根据气运数值返回对应的等级名称
          getQiyunLevelName(qiyunValue) {
              const qiyun = parseInt(qiyunValue, 10);
              if (isNaN(qiyun)) return '未知';
              
              if (qiyun >= 181) return '天命之子';
              if (qiyun >= 161) return '洪福齐天';
              if (qiyun >= 141) return '气运亨通';
              if (qiyun >= 121) return '福缘渐显';
              if (qiyun >= 101) return '小有福缘';
              if (qiyun >= 81) return '气运尚可';
              if (qiyun >= 61) return '凡夫俗子';
              if (qiyun >= 41) return '时运不济';
              if (qiyun >= 21) return '霉运缠身';
              if (qiyun >= 0) return '天煞孤星';
              return '未知';
          },

          // 根据气运数值返回对应的染色样式
          getQiyunStyle(qiyunValue) {
              const qiyun = parseInt(qiyunValue, 10);
              if (isNaN(qiyun)) return 'color: #e0dcd1;';
              
              const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
              const gradientAnimation = 'god-tier-animation 5s linear infinite';
              const fluorescentAnimation = 'breathing-glow 4s ease-in-out infinite';
              
              // 181 到 200+：天命之子——金红（渐变+呼吸+荧光+渐变的颜色数量较多）
              if (qiyun >= 181) {
                  return `background: linear-gradient(90deg, #FFD700, #FF6347, #FF4500, #FFD700, #DC143C, #FFD700, #FF6347); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 161 到 180：洪福齐天——红色（渐变+呼吸+荧光+渐变的颜色数量较多）
              if (qiyun >= 161) {
                  return `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF6347, #DC143C, #FF4500, #B22222); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 141 到 160：气运亨通——紫色（渐变+呼吸+荧光）
              if (qiyun >= 141) {
                  return `background: linear-gradient(90deg, #9370DB, #8A2BE2, #9932CC, #8A2BE2, #9370DB); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 121 到 140：福缘渐显——橙色（渐变+呼吸）
              if (qiyun >= 121) {
                  return `background: linear-gradient(90deg, #FF8C00, #FFA500, #FFB347, #FFA500, #FF8C00); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 101 到 120：小有福缘——蓝色（渐变）
              if (qiyun >= 101) {
                  return `background: linear-gradient(90deg, #4169E1, #1E90FF, #6495ED, #1E90FF, #4169E1); ${animatedStyle} animation: ${gradientAnimation};`;
              }
              // 81 到 100：气运尚可——绿色
              if (qiyun >= 81) {
                  return 'color: #66CDAA;';
              }
              // 61 到 80：凡夫俗子——白色
              if (qiyun >= 61) {
                  return 'color: #FFFFFF;';
              }
              // 41 到 60：时运不济——灰色
              if (qiyun >= 41) {
                  return 'color: #808080;';
              }
              // 21 到 40：霉运缠身——黑色
              if (qiyun >= 21) {
                  return 'color: #2F2F2F;';
              }
              // 0 到 20：天煞孤星——黑带波动（渐变+呼吸）
              if (qiyun >= 0) {
                  return `background: linear-gradient(90deg, #000000, #1a1a1a, #000000, #0d0d0d, #000000); ${animatedStyle} animation: ${gradientAnimation};`;
              }
              return 'color: #e0dcd1;';
          },

          // 获取气运的完整显示HTML（名称+数值）
          getQiyunDisplayHTML(qiyunValue) {
              const qiyun = parseInt(qiyunValue, 10);
              if (isNaN(qiyun)) return '<span style="color: #e0dcd1;">未知</span>';
              
              const levelName = this.getQiyunLevelName(qiyun);
              const style = this.getQiyunStyle(qiyun);
              
              return `<span style="${style}">${levelName}</span><span style="color: #e0dcd1;">（${qiyun}）</span>`;
          },

          // --- 新增：通用数值染色组件 ---
          // 统一的数值显示接口，支持魅力、悟性、气运
          getAttributeDisplayHTML(attributeType, value) {
              switch(attributeType) {
                  case '魅力':
                      return this.getCharmDisplayHTML(value);
                  case '悟性':
                      return this.getWuxingDisplayHTML(value);
                  case '气运':
                      return this.getQiyunDisplayHTML(value);
                  default:
                      return `<span style="color: #e0dcd1;">${value}</span>`;
              }
          },

          // --- 新增：通用属性百分比进度条颜色系统 ---
          // 根据百分比返回从红到绿的渐变色
          getPercentageColor(percentage) {
              const percent = Math.max(0, Math.min(100, percentage)); // 限制在0-100之间
              
              // 使用HSL色彩空间，从红色(0)到绿色(120)
              // 0% = 红色 (hsl(0, 100%, 50%))
              // 50% = 黄色 (hsl(60, 100%, 50%))
              // 100% = 绿色 (hsl(120, 100%, 50%))
              const hue = (percent * 1.2).toFixed(0); // 0-120度
              return `hsl(${hue}, 70%, 45%)`;
          },

          // 生成属性进度条的HTML
          getAttributeProgressHTML(currentValue, maxValue, attributeName) {
              const current = parseInt(currentValue, 10) || 0;
              const max = parseInt(maxValue, 10) || 1;
              const percentage = Math.min(100, (current / max) * 100);
              const color = this.getPercentageColor(percentage);
              
              return `
                  <div class="info-item full-width" style="margin-top: 8px;">
                      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                          <strong style="white-space: nowrap; color: #c9aa71;">${attributeName}:</strong>
                          <span style="color: #e8dcc6; font-size: 13px;">${current} / ${max} (${percentage.toFixed(1)}%)</span>
                      </div>
                      <div class="progress-bar-bg" style="width: 100%; height: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; overflow: hidden;">
                          <div class="progress-bar-fill" style="width: ${percentage}%; height: 100%; background: ${color}; transition: width 0.3s ease, background 0.3s ease;"></div>
                      </div>
                  </div>
              `;
          },

        // ---新增：宗门等级染色系统 ---
        // 根据宗门等级返回对应的等级名称
          getSectLevelName(levelValue) {
            const level = parseInt(levelValue, 10);
            if (isNaN(level)) return '未知';  

            if (level >= 10) return '长生道统';
            if (level >= 9) return '圣地';
            if (level >= 8) return '仙道十宗';
            if (level >= 7) return '一流';
            if (level >= 6) return '二流';
            if (level >= 5) return '三流';
            if (level >= 4) return '超级无敌杂鱼大王';
            if (level >= 3) return '高级杂鱼';
            if (level >= 2) return '中等杂鱼';
            if (level >= 1) return '低等杂鱼';
            return '未知';
          },

              // 根据宗门等级返回对应的染色样式
              getSectLevelStyle(levelValue) {
                    const level = parseInt(levelValue, 10);
                        if (isNaN(level)) return 'color: #e0dcd1;';
        
                    const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
                    const gradientAnimation = 'god-tier-animation 8s linear infinite';
                    const fluorescentAnimation = 'breathing-glow 6s ease-in-out infinite';
        
                    // 10级：圣地 - 仙器渐变+呼吸+荧光
                    if (level >= 10) {
                        return `background: linear-gradient(90deg, #FFFACD, #206864, #ffffff, #206864, #FFFACD); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
                    }
                      // 9级：顶尖 - 红色渐变+呼吸+荧光
                    if (level >= 9) {
                        return `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF6347, #DC143C, #FF4500, #B22222); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
                    }
                    // 8级：一流 - 道品渐变+呼吸+荧光
                    if (level >= 8) {
                        return `background: linear-gradient(90deg, #FFD700, #FFFFFF, #FFD700, #FFFFFF, #FFD700); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
                    }
                    // 7级：二流 - 橙色渐变+呼吸+荧光
                      if (level >= 7) {
                        return `background: linear-gradient(90deg, #FF8C00, #FFA500, #FFB347, #FFA500, #FF8C00); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
                    }
                    // 6级：三流 - 浅蓝色渐变+呼吸
                    if (level >= 6) {
                        return `background: linear-gradient(90deg, #87CEFA, #B0E0E6, #ADD8E6, #B0E0E6, #87CEFA); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
                    }
                    // 5级：四流 - 玄品渐变
                    if (level >= 5) {
                        return `background: linear-gradient(90deg, #87CEFA, #B0E0E6, #ADD8E6, #B0E0E6, #87CEFA); ${animatedStyle} animation: ${gradientAnimation};`;
                    }
                    // 4级：五流 - 白色
                    if (level >= 4) {
                        return 'color: #FFFFFF;';
                    }
                    // 3级：六流 - 灰色
                    if (level >= 3) {
                        return 'color: #A9A9A9;';
                    }
                    // 2级：七流 - 深灰
                    if (level >= 2) {
                        return 'color: #808080;';
                    }
                    // 1级：八流 - 暗灰
                    if (level >= 1) {
                        return 'color: #696969;';
                    }
                        return 'color: #e0dcd1;';
              },

            // 获取宗门等级的完整显示HTML（名称+数值）
          getSectLevelDisplayHTML(levelValue) {
                const level = parseInt(levelValue, 10);
                  if (isNaN(level)) return '<span style="color: #e0dcd1;">未知</span>';
    
                  const levelName = this.getSectLevelName(level);
                  const style = this.getSectLevelStyle(level);
    
                return `<span style="${style}">${levelName}</span>`;
          },

            // 获取宗门等级的卡片背景CSS类名（用于左侧列表）
          getSectLevelCardBg(levelValue) {
                const level = parseInt(levelValue, 10);
                if (isNaN(level)) return '';
    
                if (level >= 10) return 'sect-bg-level-10';
                if (level >= 9) return 'sect-bg-level-9';
                if (level >= 8) return 'sect-bg-level-8';
                if (level >= 7) return 'sect-bg-level-7';
                if (level >= 6) return 'sect-bg-level-6';
                if (level >= 5) return 'sect-bg-level-5';
                return '';
          },

// ===品阶、境界排序、染色模块（极为重要）结束===



// ===天赋、灵根处理、渲染模块开始===



          updateTalentAndLinggen(data) {
            const container = document.getElementById('talent-linggen-list');
            if (!container) return;
            container.innerHTML = '';

            let html = '';
            const linggenList = this.SafeGetValue(data, '灵根列表', {});
            const linggenEntries = Object.entries(linggenList).filter(([name]) => name !== '$meta');

            if (linggenEntries.length > 0) {
              const sortedLinggen = this.sortByTier(linggenEntries, ([, linggen]) =>
                this.SafeGetValue(linggen, 'tier', '凡品')
              );

              sortedLinggen.forEach(([name, linggen]) => {
                const tier = this.SafeGetValue(linggen, 'tier', '凡品');
                const description = this.SafeGetValue(linggen, 'description', '无描述');
                const tierStyle = this.getItemTierStyle(tier);
                const itemDetailsHtml = this.renderItemDetailsForInventory(linggen);

                html += `
                     <details class="details-container" style="margin-top: 10px;">
                         <summary>
                             <span class="attribute-name">灵根</span>
                             <span class="attribute-value" style="${tierStyle}">【${tier}】 ${name}</span>
                         </summary>
                         <div class="details-content">
                             <p>${description}</p>
                             ${itemDetailsHtml ? `<div class="item-details" style="border-top: 1px solid rgba(201, 170, 113, 0.2); padding-top: 10px; margin-top: 10px;">${itemDetailsHtml}</div>` : ''}
                         </div>
                     </details>
                 `;
              });
            } else {
                 html += `
                   <div class="attribute-item">
                       <span class="attribute-name">灵根</span>
                       <span class="attribute-value">未觉醒</span>
                   </div>
               `;
            }
            const tianfuList = this.SafeGetValue(data, '天赋列表', {});
            const tianfuEntries = Object.entries(tianfuList).filter(([name]) => name !== '$meta');
            
            if (tianfuEntries.length > 0) {
              const sortedTianfu = this.sortByTier(tianfuEntries, ([, tianfu]) =>
                this.SafeGetValue(tianfu, 'tier', '凡品')
              );

              sortedTianfu.forEach(([name, tianfu]) => {
                const tier = this.SafeGetValue(tianfu, 'tier', '凡品');
                const description = this.SafeGetValue(tianfu, 'description', '无描述');
                const tierStyle = this.getItemTierStyle(tier);
                const itemDetailsHtml = this.renderItemDetailsForInventory(tianfu);

                html += `
                         <details class="details-container" style="margin-top: 10px;">
                             <summary>
                                 <span class="attribute-name">天赋</span>
                                 <span class="attribute-value" style="${tierStyle}">【${tier}】 ${name}</span>
                             </summary>
                             <div class="details-content">
                                 <p>${description}</p>
                                 ${itemDetailsHtml ? `<div class="item-details" style="border-top: 1px solid rgba(201, 170, 113, 0.2); padding-top: 10px; margin-top: 10px;">${itemDetailsHtml}</div>` : ''}
                             </div>
                         </details>
                     `;
              });
            } else {
              html += `
                   <div class="attribute-item">
                       <span class="attribute-name">天赋</span>
                       <span class="attribute-value">未觉醒</span>
                   </div>
               `;
            }

            container.innerHTML = html;
          },



// ===天赋、灵根处理、渲染模块开始===



// ===背包模块（极为重要）开始===

          // 存储当前激活的tab和搜索关键词
          currentInventoryTab: '功法',
          currentInventorySearchKeyword: '',

          renderInventoryWithTabs(stat_data) {
            if (!stat_data || Object.keys(stat_data).length === 0) {
              const contentArea = document.querySelector('#inventory-modal .inventory-content-area');
              if (contentArea) {
                contentArea.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">背包数据为空。</p>';
              }
              return;
            }

            this.renderInventoryTabs();
            this.renderInventoryContent(stat_data, this.currentInventoryTab);
            this.initInventorySearch();
          },

          renderInventoryTabs() {
            const categories = [
              { title: '功法', key: '功法列表', equipable: true },
              { title: '武器', key: '武器列表', equipable: true },
              { title: '防具', key: '防具列表', equipable: true },
              { title: '饰品', key: '饰品列表', equipable: true },
              { title: '法宝', key: '法宝列表', equipable: true },
              { title: '丹药', key: '丹药列表', equipable: false },
              { title: '杂物', key: '其他列表', equipable: false },
            ];

            const tabsContainer = document.querySelector('#inventory-modal .inventory-tabs');
            if (!tabsContainer) return;

            const stat_data = this.currentMvuState?.stat_data || {};

            let tabsHtml = '';
            categories.forEach(cat => {
              const isActive = cat.title === this.currentInventoryTab ? 'active' : '';
              
              const rawItems = this.SafeGetValue(stat_data, cat.key, {});
              const itemEntries = Object.entries(rawItems).filter(([name]) => name !== '$meta');
              
              const validItems = itemEntries.filter(([name, item]) => {
                const hasQuantity = item && item.hasOwnProperty('quantity');
                if (hasQuantity) {
                  const quantity = parseInt(this.SafeGetValue(item, 'quantity', 1), 10);
                  return quantity > 0;
                }
                return true;
              });
              
              const itemCount = validItems.length;
              const badgeHtml = itemCount > 0 ? `<span class="inventory-tab-badge">${itemCount}</span>` : '';
              
              tabsHtml += `<button class="inventory-tab-btn ${isActive}" data-category="${cat.title}"><span>${cat.title}</span>${badgeHtml}</button>`;
            });

            tabsContainer.innerHTML = tabsHtml;

            tabsContainer.addEventListener('click', (e) => {
              const btn = e.target.closest('.inventory-tab-btn');
              if (btn) {
                const category = btn.dataset.category;
                this.switchInventoryTab(category);
              }
            });
          },

          switchInventoryTab(category) {
            this.currentInventoryTab = category;
            
            const tabButtons = document.querySelectorAll('#inventory-modal .inventory-tab-btn');
            tabButtons.forEach(btn => {
              btn.classList.toggle('active', btn.dataset.category === category);
            });

            const messages = this.currentMvuState?.stat_data;
            if (messages) {
              this.renderInventoryContent(messages, category);
              // 切换tab后重新应用搜索过滤
              if (this.currentInventorySearchKeyword) {
                this.filterInventoryItems(this.currentInventorySearchKeyword);
              }
            }
          },

          renderInventoryContent(stat_data, categoryTitle) {
            const categories = [
              { title: '功法', key: '功法列表', equipable: true },
              { title: '武器', key: '武器列表', equipable: true },
              { title: '防具', key: '防具列表', equipable: true },
              { title: '饰品', key: '饰品列表', equipable: true },
              { title: '法宝', key: '法宝列表', equipable: true },
              { title: '丹药', key: '丹药列表', equipable: false },
              { title: '杂物', key: '其他列表', equipable: false },
            ];

            const contentArea = document.querySelector('#inventory-modal .inventory-content-area');
            if (!contentArea) return;

            const cat = categories.find(c => c.title === categoryTitle);
            if (!cat) return;

            const rawItems = this.SafeGetValue(stat_data, cat.key, {});
            const itemEntries = Object.entries(rawItems).filter(([name]) => name !== '$meta');

            let html = '';

            if (itemEntries.length > 0) {
              html += '<div class="inventory-item-list">';
              
              const sortedItems = this.sortByTier(itemEntries, ([, item]) =>
                this.SafeGetValue(item, 'tier', '凡品')
              );

              sortedItems.forEach(([name, item]) => {
                try {
                  const itemWithFixName = { ...item, name };
                  const itemJson = JSON.stringify(itemWithFixName).replace(/'/g, "'");
                  
                  const tier = this.SafeGetValue(item, 'tier', '无');
                  const hasQuantity = item.hasOwnProperty('quantity');
                  const quantity = parseInt(this.SafeGetValue(item, 'quantity', 1), 10);
                  const description = this.SafeGetValue(
                    item,
                    'description',
                    this.SafeGetValue(item, 'effect', '无描述'),
                  );
                  const displayQuantity = quantity;

                  if (hasQuantity && displayQuantity <= 0) {
                    return;
                  }
                  const tierStyle = this.getItemTierStyle(tier);
                  const tierDisplay =
                    tier !== '无' ? `<span style="${tierStyle} margin-right: 15px;">品阶: ${tier}</span>` : '';
                  const quantityDisplay = hasQuantity ? `<span class="item-quantity">数量: ${displayQuantity}</span>` : '';
                  const currentEquipped = this._getEquipmentFromStatData(stat_data);
                  const isEquipped = Object.values(currentEquipped).some(equippedItem => equippedItem && equippedItem.name === name);
                  let actionButton = '';
                  if (cat.title === '功法') {
                    const isEquippedAsMain = currentEquipped.zhuxiuGongfa && currentEquipped.zhuxiuGongfa.name === name;
                    const isEquippedAsAux = currentEquipped.fuxiuXinfa && currentEquipped.fuxiuXinfa.name === name;
                    if (isEquippedAsMain) {
                      actionButton = `
                              <button class="item-unequip-btn" data-slot-id="equip-zhuxiuGongfa" style="margin-left: 5px;">卸下</button>
                              <button class="item-equip-btn" data-equip-type="fuxiu" style="margin-left: 5px; opacity: 0.5; cursor: not-allowed;" disabled>辅修</button>
                          `;
                    } else if (isEquippedAsAux) {
                      actionButton = `
                              <button class="item-equip-btn" data-equip-type="zhuxiu" style="margin-left: 5px; opacity: 0.5; cursor: not-allowed;" disabled>主修</button>
                              <button class="item-unequip-btn" data-slot-id="equip-fuxiuXinfa" style="margin-left: 5px;">卸下</button>
                          `;
                    } else {
                      actionButton = `
                              <button class="item-equip-btn" data-equip-type="zhuxiu" style="margin-left: 5px;">主修</button>
                              <button class="item-equip-btn" data-equip-type="fuxiu" style="margin-left: 5px;">辅修</button>
                          `;
                    }
                  } else if (cat.equipable) {
                    if (isEquipped) {
                      const slotKey = Object.keys(currentEquipped).find(
                        key => currentEquipped[key] && currentEquipped[key].name === name,
                      );
                      actionButton = `<button class="item-unequip-btn" data-slot-id="equip-${slotKey}">卸下</button>`;
                    } else {
                      actionButton = `<button class="item-equip-btn">装备</button>`;
                    }
                  } else if (cat.title === '丹药' || cat.title === '杂物') {
                    if (displayQuantity <= 0) {
                        actionButton = `<button class="item-use-btn" disabled>已用完</button>`;
                    } else {
                        actionButton = `<button class="item-use-btn">使用</button>`;
                    }
                  }

                  if (cat.title === '丹药' || cat.title === '杂物') {
                    actionButton += `<button class="item-discard-btn" style="margin-left: 5px; background: #8b0000; border-color: #ff6b6b;">丢弃</button>`;
                  } else {
                    actionButton += `<button class="item-discard-btn" style="margin-left: 5px; background: #8b0000; border-color: #ff6b6b;">丢弃</button>`;
                  }

                  let itemDetailsHtml = this.renderItemDetailsForInventory(item);

                  html += `
                                  <div class="inventory-item" data-item-details='${itemJson}' data-category='${cat.title}'>
                                      <div class="item-name" style="${tierStyle}">${name}</div>
                                      <div class="item-header">
                                          <div class="item-meta">
                                              ${tierDisplay}
                                              ${quantityDisplay}
                                          </div>
                                          <div class="item-actions">
                                              ${actionButton}
                                          </div>
                                      </div>
                                      <div class="item-description">${description}</div>
                                      ${itemDetailsHtml ? `<div class="item-details">${itemDetailsHtml}</div>` : ''}
                                  </div>
                              `;
                } catch (e) {
                  console.error('解析背包物品失败:', item, e);
                  html += `<div class="inventory-item"><p class="item-description">物品数据格式错误</p></div>`;
                }
              });
              html += '</div>';
            } else {
              html += '<div class="inventory-item-list"><p class="empty-category-text">空空如也</p></div>';
            }

            contentArea.innerHTML = html;
          },



          // 初始化背包搜索功能
          initInventorySearch() {
            const searchInput = document.getElementById('inventory-search-input');
            const clearBtn = document.getElementById('inventory-search-clear');
            
            if (!searchInput || !clearBtn) return;

            let lastSearchValue = '';
            let searchInterval = null;

            // 执行搜索的函数
            const performSearch = () => {
              const currentValue = searchInput.value.trim();
              lastSearchValue = currentValue;
              this.currentInventorySearchKeyword = currentValue;
              
              // 显示/隐藏清除按钮
              clearBtn.style.display = currentValue ? 'flex' : 'none';
              
              // 执行全局搜索
              this.filterInventoryItems(currentValue);
            };

            // 实时检查输入框内容并搜索（每50ms检查一次，更快响应）
            const startRealTimeSearch = () => {
              if (searchInterval) {
                clearInterval(searchInterval);
              }
              
              searchInterval = setInterval(() => {
                const currentValue = searchInput.value.trim();
                
                // 只有当值发生变化时才执行搜索
                if (currentValue !== lastSearchValue) {
                  performSearch();
                }
              }, 50); // 每50ms检查一次，实现真正的实时搜索
            };

            // 输入框获得焦点时开始实时搜索
            searchInput.addEventListener('focus', () => {
              startRealTimeSearch();
            });

            // 输入框失去焦点时停止实时搜索
            searchInput.addEventListener('blur', () => {
              if (searchInterval) {
                clearInterval(searchInterval);
                searchInterval = null;
              }
            });

            // 回车键强制搜索
            searchInput.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') {
                e.preventDefault();
                performSearch();
              }
            });

            // input事件作为备用，确保即时响应
            searchInput.addEventListener('input', () => {
              const currentValue = searchInput.value.trim();
              clearBtn.style.display = currentValue ? 'flex' : 'none';
            });

            // 清除按钮事件
            clearBtn.addEventListener('click', () => {
              searchInput.value = '';
              lastSearchValue = '';
              this.currentInventorySearchKeyword = '';
              clearBtn.style.display = 'none';
              this.filterInventoryItems('');
            });

            // 恢复之前的搜索关键词
            if (this.currentInventorySearchKeyword) {
              searchInput.value = this.currentInventorySearchKeyword;
              lastSearchValue = this.currentInventorySearchKeyword;
              clearBtn.style.display = 'flex';
              // 立即执行一次搜索
              this.filterInventoryItems(this.currentInventorySearchKeyword);
            }

            // 如果输入框已经有焦点，立即开始实时搜索
            if (document.activeElement === searchInput) {
              startRealTimeSearch();
            }
          },

          // 过滤背包物品 - 全局搜索版本
          filterInventoryItems(keyword) {
            if (!keyword) {
              // 如果没有关键词，显示当前tab的所有物品
              this.renderInventoryContent(this.currentMvuState?.stat_data, this.currentInventoryTab);
              return;
            }

            const stat_data = this.currentMvuState?.stat_data;
            if (!stat_data) return;

            const categories = [
              { title: '功法', key: '功法列表', equipable: true },
              { title: '武器', key: '武器列表', equipable: true },
              { title: '防具', key: '防具列表', equipable: true },
              { title: '饰品', key: '饰品列表', equipable: true },
              { title: '法宝', key: '法宝列表', equipable: true },
              { title: '丹药', key: '丹药列表', equipable: false },
              { title: '杂物', key: '其他列表', equipable: false },
            ];

            const lowerKeyword = keyword.toLowerCase();
            const matchedItems = [];

            // 全局搜索所有分类，并计算匹配优先级
            categories.forEach(cat => {
              const rawItems = this.SafeGetValue(stat_data, cat.key, {});
              const itemEntries = Object.entries(rawItems).filter(([name]) => name !== '$meta');

              itemEntries.forEach(([name, item]) => {
                const tier = this.SafeGetValue(item, 'tier', '无');
                const description = this.SafeGetValue(
                  item,
                  'description',
                  this.SafeGetValue(item, 'effect', '无描述')
                );
                
                // 获取所有词条文本
                const specialEffects = this.SafeGetValue(item, 'special_effects', {});
                const effectsText = Object.entries(specialEffects)
                  .filter(([key]) => key !== '$meta')
                  .map(([key, value]) => `${key}: ${value}`)
                  .join(' ');

                // 计算匹配优先级
                const nameLower = name.toLowerCase();
                const descriptionLower = description.toLowerCase();
                const tierLower = tier.toLowerCase();
                const effectsLower = effectsText.toLowerCase();
                
                let priority = 0;
                let matched = false;
                
                // 优先级1：键名完全匹配
                if (nameLower === lowerKeyword) {
                  priority = 1;
                  matched = true;
                }
                // 优先级2：键名包含关键词
                else if (nameLower.includes(lowerKeyword)) {
                  priority = 2;
                  matched = true;
                }
                // 优先级3：品阶匹配
                else if (tierLower.includes(lowerKeyword)) {
                  priority = 3;
                  matched = true;
                }
                // 优先级4：词条匹配
                else if (effectsLower.includes(lowerKeyword)) {
                  priority = 4;
                  matched = true;
                }
                // 优先级5：描述匹配
                else if (descriptionLower.includes(lowerKeyword)) {
                  priority = 5;
                  matched = true;
                }
                
                if (matched) {
                  matchedItems.push({
                    name,
                    item,
                    category: cat.title,
                    categoryKey: cat.key,
                    equipable: cat.equipable,
                    priority
                  });
                }
              });
            });

            // 按优先级排序，优先级数字越小越靠前
            matchedItems.sort((a, b) => {
              if (a.priority !== b.priority) {
                return a.priority - b.priority;
              }
              // 同优先级按品阶排序（从高到低）
              const tierA = this.SafeGetValue(a.item, 'tier', '凡品');
              const tierB = this.SafeGetValue(b.item, 'tier', '凡品');
              const orderA = this.getTierOrder(tierA);
              const orderB = this.getTierOrder(tierB);
              return orderB - orderA; // 品阶高的排前面
            });

            // 渲染搜索结果
            const contentArea = document.querySelector('#inventory-modal .inventory-content-area');
            if (!contentArea) return;

            if (matchedItems.length === 0) {
              contentArea.innerHTML = `<div class="inventory-item-list"><p class="empty-category-text">未找到包含"${keyword}"的物品</p></div>`;
              return;
            }

            // matchedItems已经按优先级排序，直接渲染
            let html = '<div class="inventory-item-list">';
            
            matchedItems.forEach(matchedItem => {
              const { name, item, category, equipable } = matchedItem;
              
              try {
                const itemWithFixName = { ...item, name };
                const itemJson = JSON.stringify(itemWithFixName).replace(/'/g, "'");
                
                const tier = this.SafeGetValue(item, 'tier', '无');
                const hasQuantity = item.hasOwnProperty('quantity');
                const quantity = parseInt(this.SafeGetValue(item, 'quantity', 1), 10);
                const description = this.SafeGetValue(
                  item,
                  'description',
                  this.SafeGetValue(item, 'effect', '无描述')
                );

                if (hasQuantity && quantity <= 0) {
                  return;
                }

                const tierStyle = this.getItemTierStyle(tier);
                const tierDisplay = tier !== '无' ? `<span style="${tierStyle} margin-right: 15px;">品阶: ${tier}</span>` : '';
                const quantityDisplay = hasQuantity ? `<span class="item-quantity">数量: ${quantity}</span>` : '';
                const categoryDisplay = `<span style="color: #8b7355; margin-right: 15px;">分类: ${category}</span>`;
                
                const currentEquipped = this._getEquipmentFromStatData(stat_data);
                const isEquipped = Object.values(currentEquipped).some(equippedItem => equippedItem && equippedItem.name === name);
                
                let actionButton = '';
                if (category === '功法') {
                  const isEquippedAsMain = currentEquipped.zhuxiuGongfa && currentEquipped.zhuxiuGongfa.name === name;
                  const isEquippedAsAux = currentEquipped.fuxiuXinfa && currentEquipped.fuxiuXinfa.name === name;
                  if (isEquippedAsMain) {
                    actionButton = `
                      <button class="item-unequip-btn" data-slot-id="equip-zhuxiuGongfa" style="margin-left: 5px;">卸下</button>
                      <button class="item-equip-btn" data-equip-type="fuxiu" style="margin-left: 5px; opacity: 0.5; cursor: not-allowed;" disabled>辅修</button>
                    `;
                  } else if (isEquippedAsAux) {
                    actionButton = `
                      <button class="item-equip-btn" data-equip-type="zhuxiu" style="margin-left: 5px; opacity: 0.5; cursor: not-allowed;" disabled>主修</button>
                      <button class="item-unequip-btn" data-slot-id="equip-fuxiuXinfa" style="margin-left: 5px;">卸下</button>
                    `;
                  } else {
                    actionButton = `
                      <button class="item-equip-btn" data-equip-type="zhuxiu" style="margin-left: 5px;">主修</button>
                      <button class="item-equip-btn" data-equip-type="fuxiu" style="margin-left: 5px;">辅修</button>
                    `;
                  }
                } else if (equipable) {
                  if (isEquipped) {
                    const slotKey = Object.keys(currentEquipped).find(
                      key => currentEquipped[key] && currentEquipped[key].name === name
                    );
                    actionButton = `<button class="item-unequip-btn" data-slot-id="equip-${slotKey}">卸下</button>`;
                  } else {
                    actionButton = `<button class="item-equip-btn">装备</button>`;
                  }
                } else if (category === '丹药' || category === '杂物') {
                  if (quantity <= 0) {
                    actionButton = `<button class="item-use-btn" disabled>已用完</button>`;
                  } else {
                    actionButton = `<button class="item-use-btn">使用</button>`;
                  }
                }

                actionButton += `<button class="item-discard-btn" style="margin-left: 5px; background: #8b0000; border-color: #ff6b6b;">丢弃</button>`;

                let itemDetailsHtml = this.renderItemDetailsForInventory(item);

                html += `
                  <div class="inventory-item" data-item-details='${itemJson}' data-category='${category}'>
                    <div class="item-name" style="${tierStyle}">${name}</div>
                    <div class="item-header">
                      <div class="item-meta">
                        ${categoryDisplay}
                        ${tierDisplay}
                        ${quantityDisplay}
                      </div>
                      <div class="item-actions">
                        ${actionButton}
                      </div>
                    </div>
                    <div class="item-description">${description}</div>
                    ${itemDetailsHtml ? `<div class="item-details">${itemDetailsHtml}</div>` : ''}
                  </div>
                `;
              } catch (e) {
                console.error('解析背包物品失败:', item, e);
              }
            });

            html += '</div>';
            contentArea.innerHTML = html;
          },


// ===背包模块（极为重要）结束===



// ===装备系统模块（极为重要）开始===



          renderTooltipContent(item) {
            const tierStyle = this.getItemTierStyle(this.SafeGetValue(item, 'tier'));
            const level = this.SafeGetValue(item, 'level', '');
            const tierDisplay = level
              ? `${this.SafeGetValue(item, 'tier', '凡品')} ${level}`
              : this.SafeGetValue(item, 'tier', '凡品');

            const itemDetailsHtml = this.renderItemDetailsForInventory(item);

            return `
                    <div class="tooltip-title" style="${tierStyle}">${this.SafeGetValue(item, 'name')}</div>
                    <p><strong>品阶:</strong> ${tierDisplay}</p>
                    <p><i>${this.SafeGetValue(item, 'description', '无描述')}</i></p>
                    <div class="tooltip-section tooltip-attributes">${itemDetailsHtml}</div>
                `;
          },

          showEquipmentTooltip(element, event) {
            const tooltip = document.getElementById('equipment-tooltip');
            const itemDataString = element.dataset.itemDetails;
            if (!tooltip || !itemDataString) return;

            try {
              const item = JSON.parse(itemDataString.replace(/'/g, "'"));
              tooltip.innerHTML = this.renderTooltipContent(item);
              tooltip.style.display = 'block';
              const tooltipRect = tooltip.getBoundingClientRect();
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;
              let left = event.pageX + 15;
              let top = event.pageY + 15;

              // 如果Tooltip超出右边界，则显示在鼠标左侧
              if (left + tooltipRect.width > viewportWidth) {
                left = event.pageX - tooltipRect.width - 15;
              }

              // 如果Tooltip超出下边界，则显示在鼠标上侧
              if (top + tooltipRect.height > viewportHeight) {
                top = event.pageY - tooltipRect.height - 15;
              }

              tooltip.style.left = `${left}px`;
              tooltip.style.top = `${top}px`;
            } catch (e) {
              console.error('解析装备Tooltip数据失败:', e);
            }
          },

          hideEquipmentTooltip() {
            const tooltip = document.getElementById('equipment-tooltip');
            if (tooltip) tooltip.style.display = 'none';
          },

          renderItemDetailsForInventory(item) {
            let attributesHtml = '';
            const attributes = item.attributes_bonus;
            if (typeof attributes === 'object' && attributes !== null && Object.keys(attributes).length > 0) {
              attributesHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">固定加成</div>';
              for (const [key, value] of Object.entries(attributes)) {
                attributesHtml += `<p><strong>${key}:</strong> ${value > 0 ? '+' : ''}${value}</p>`;
              }
            }

            const percentBonuses = item['百分比加成'];
            if (typeof percentBonuses === 'object' && percentBonuses !== null && Object.keys(percentBonuses).length > 0) {
              attributesHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">百分比加成</div>';
              for (const [key, value] of Object.entries(percentBonuses)) {
                 const displayValue = String(value).endsWith('%') ? value : `${value}%`;
                 attributesHtml += `<p><strong>${key}:</strong> +${displayValue}</p>`;
              }
            }

            let proficiencyHtml = '';
            const proficiency = item.proficiency;
            if (proficiency && typeof proficiency === 'object') {
              const current = proficiency.current || 0;
              const max = proficiency.max || 100;
              const percentage = max > 0 ? Math.round((current / max) * 100) : 0;
              proficiencyHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">熟练度</div>';
              proficiencyHtml += `<p><strong>当前熟练度:</strong> ${current} / ${max} (${percentage}%)</p>`;
            }

            let skillEffectsHtml = '';
            const skillEffects = item.skill_effects;
            if (skillEffects && typeof skillEffects === 'object') {
              const effectEntries = Object.entries(skillEffects).filter(([key]) => key !== '$meta');
              if (effectEntries.length > 0) {
                skillEffectsHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">功法效果</div>';
                effectEntries.forEach(([key, effect]) => {
                  if (typeof effect === 'object' && effect !== null) {
                    const name = effect.name || key;
                    const description = effect.description || '';
                    skillEffectsHtml += `<p>- <strong>${name}:</strong> <span class="citiao-description">${description}</span></p>`;
                  } else {
                    skillEffectsHtml += `<p>- <strong>${key}:</strong> <span class="citiao-description">${effect}</span></p>`;
                  }
                });
              }
            }

            let skillMovesHtml = '';
            const skillMoves = item.skill_moves;
            if (skillMoves && typeof skillMoves === 'object') {
              const moveEntries = Object.entries(skillMoves).filter(([key]) => key !== '$meta');
              if (moveEntries.length > 0) {
                skillMovesHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">功法招式</div>';
                moveEntries.forEach(([key, move]) => {
                  if (typeof move === 'object' && move !== null) {
                    const name = move.name || key;
                    const description = move.description || '';
                    skillMovesHtml += `<p>- <strong>${name}:</strong> <span class="citiao-description">${description}</span></p>`;
                  } else {
                    skillMovesHtml += `<p>- <strong>${key}:</strong> <span class="citiao-description">${move}</span></p>`;
                  }
                });
              }
            }

            let effectsHtml = '';
            const effects = item.special_effects;

            if (effects) {
                effectsHtml += `<div class="tooltip-section-title" style="margin-top: 5px;">特殊词条</div>`;
                if (typeof effects === 'object' && !Array.isArray(effects) && effects !== null) {
                    for (const [key, value] of Object.entries(effects)) {
                        if (key === '$meta') continue;
                        
                        // 兼容嵌套格式：如果value是对象，则递归渲染
                        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                            effectsHtml += `<p>- <strong>${key}:</strong></p>`;
                            effectsHtml += '<div style="margin-left: 15px;">';
                            for (const [subKey, subValue] of Object.entries(value)) {
                                if (subKey === '$meta') continue;
                                effectsHtml += `<p>- <strong>${subKey}:</strong> <span class="citiao-description">${subValue}</span></p>`;
                            }
                            effectsHtml += '</div>';
                        } else {
                            effectsHtml += `<p>- <strong>${key}:</strong> <span class="citiao-description">${value}</span></p>`;
                        }
                    }
                } else if (Array.isArray(effects)) {
                    effectsHtml += effects.filter(eff => eff !== '$__META_EXTENSIBLE__$').map(eff => `<p>- ${eff}</p>`).join('');
                } else if (typeof effects === 'string' && effects.trim() !== '') {
                    effectsHtml += effects.split('\n').map(e => e.trim()).filter(e => e).map(eff => `<p>- ${eff}</p>`).join('');
                }
            }

            return `${attributesHtml}${percentBonuses ? '' : ''}${proficiencyHtml}${skillEffectsHtml}${skillMovesHtml}${effectsHtml}`;
          },

          async equipItem(item, category, buttonElement, equipType = null) {


            const itemName = this.SafeGetValue(item, 'name');
            if (!itemName || itemName === 'N/A') {
              console.warn('[装备系统] 物品无名称，装备失败');
              this.showTemporaryMessage('物品无名称，无法装备。');
              return;
            }
            
            // 基于stat_data检查功法是否已被装备在另一个槽位
            if (category === '功法') {
              const currentEquipped = this._getEquipmentFromStatData(this.currentMvuState?.stat_data);
              const isEquippedAsMain = currentEquipped.zhuxiuGongfa?.name === itemName;
              const isEquippedAsAux = currentEquipped.fuxiuXinfa?.name === itemName;
              if (
                (equipType === 'fuxiuXinfa' && isEquippedAsMain) ||
                (equipType === 'zhuxiuGongfa' && isEquippedAsAux)
              ) {
                console.warn('[装备系统] 该功法已被装备在另一槽位');
                this.showTemporaryMessage('该功法已被装备在另一槽位。');
                return;
              }
            }

            let slotKey;
            if (category === '功法') {
                slotKey = equipType; // 功法直接使用equipType作为slotKey
            } else {
                const categoryMap = { 武器: 'wuqi', 防具: 'fangju', 饰品: 'shipin', 法宝: 'fabao1' };
                slotKey = categoryMap[category];
            }

            console.log('[装备系统] 槽位映射', { category, equipType, slotKey });

            if (!slotKey) {
              console.error('[装备系统] 错误的装备分类或类型', { category, equipType });
              this.showTemporaryMessage('错误的装备分类或类型。');
              return;
            }
            const currentEquipped = this._getEquipmentFromStatData(this.currentMvuState?.stat_data);
            const currentlyEquippedSlot = Object.keys(currentEquipped).find(
              key => currentEquipped[key]?.name === itemName,
            );
            if (currentlyEquippedSlot && currentlyEquippedSlot !== slotKey) {
              console.log('[装备系统] 在其他槽位发现同名装备，先卸载');
              const oldSlotElement = document.getElementById(`equip-${currentlyEquippedSlot}`);
              if (oldSlotElement) {
                this.unequipItem(`equip-${currentlyEquippedSlot}`, oldSlotElement, false); // 静默卸载
              }
            }

            const slotElement = document.getElementById(`equip-${slotKey}`);
            if (!slotElement) {
              console.error('[装备系统] 找不到槽位元素', { slotKey });
              return;
            }

            // 如果该槽位已有装备，先执行卸载操作
            const oldItem = currentEquipped[slotKey];
            if (oldItem) {
              console.log('[装备系统] 槽位已有装备，先卸载', { oldItem: oldItem.name });
              this.unequipItem(`equip-${slotKey}`, slotElement, false);
            }

            // 更新UI显示
            const tier = this.SafeGetValue(item, 'tier', '凡品');
            const tierStyle = this.getItemTierStyle(tier);
            slotElement.textContent = this.SafeGetValue(item, 'name');
            slotElement.setAttribute('style', tierStyle);
            slotElement.classList.add('equipped');
            slotElement.dataset.itemDetails = JSON.stringify(item).replace(/'/g, "'");

            // 生成MVU命令 - 使用实际的MVU键名
            const slotToMvuKeyMap = {
              wuqi: '武器',
              fangju: '防具',
              shipin: '饰品',
              fabao1: '法宝栏', 
              zhuxiuGongfa: '主修功法',
              fuxiuXinfa: '辅修心法',
            };
            const mvuKey = slotToMvuKeyMap[slotKey] || category;
            
            // --- MVU API 重构开始 ---
            const mvuData = this.currentMvuState;
            if (!mvuData) {
              console.error('[装备系统] 无法获取MVU状态，操作中断');
              this.showTemporaryMessage('发生内部错误，装备失败');
              return;
            }

            console.log(`[装备系统] 开始通过MVU API装备 ${itemName} 到 ${mvuKey}`);

            // 1. 设置装备槽
            const cleanedItem = JSON.parse(JSON.stringify(item, (key, value) => (value === undefined ? null : value)));
            await Mvu.setMvuVariable(mvuData, mvuKey, cleanedItem, { reason: `装备 ${itemName}` });
            // 2.1 首先更新总百分比加成对象
            const percentBonuses = item['百分比加成'];
            if (percentBonuses && typeof percentBonuses === 'object') {
              for (const [mvuName, bonusValue] of Object.entries(percentBonuses)) {
                const value = parseFloat(String(bonusValue).replace('%', '')) || 0;
                if (value !== 0) {
                  const path = `当前百分比加成.${mvuName}`;
                  const currentValueStr = Mvu.getMvuVariable(mvuData, path, { default_value: '0%' });
                  const currentValue = parseFloat(currentValueStr.replace('%', '')) || 0;
                  await Mvu.setMvuVariable(mvuData, path, `${currentValue + value}%`, { reason: `装备 ${itemName}` });
                }
              }
            }

            // 2.2 然后用【更新后】的总百分比计算最终增益
            const updatedPercentBonusesData = Mvu.getMvuVariable(mvuData, '当前百分比加成', { default_value: {} });
            const flatBonuses = item.attributes_bonus;
            if (flatBonuses && typeof flatBonuses === 'object') {
              for (const [mvuName, bonusValue] of Object.entries(flatBonuses)) {
                const value = parseInt(bonusValue, 10) || 0;
                if (value !== 0) {
                  const percentStr = String(updatedPercentBonusesData[mvuName] || '0%');
                  const percent = (parseFloat(percentStr.replace('%', '')) || 0) / 100;
                  const finalGain = Math.floor(value * (1 + percent));
                  
                  const currentValue = Mvu.getMvuVariable(mvuData, mvuName, { default_value: 0 });
                  await Mvu.setMvuVariable(mvuData, mvuName, currentValue + finalGain, { reason: `装备 ${itemName} (+${value} -> +${finalGain})` });
                }
              }
            }

            // 4. 更新血量上限
            await this._updateHealthCap(mvuData);

            // 5. 乐观更新UI：在与后端同步前，立刻刷新前端界面，消除延迟感
            this.renderUI(this.currentMvuState.stat_data);
            this.showTemporaryMessage(`已装备 ${this.SafeGetValue(item, 'name')}`);
            const inventoryModal = document.getElementById('inventory-modal');
            if (inventoryModal && inventoryModal.style.display !== 'none') {
                this.showInventory(true); // 修复：强制使用本地状态刷新背包UI
            }

            // 6. 将所有变更一次性同步到后端（在后台进行）
            await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });
            console.log('[装备系统] MVU状态已同步到后端');
          },

          async unequipItem(slotId, slotElement, showMessage = true, refreshInventoryUI = true) {
            const slotKey = slotId.replace('equip-', '');
            const defaultTextMap = {
              wuqi: '武器',
              fangju: '防具',
              shipin: '饰品',
              fabao1: '法宝',
              zhuxiuGongfa: '主修功法',
              fuxiuXinfa: '辅修心法',
            };

            const itemDataString = slotElement.dataset.itemDetails;
            if (!itemDataString) {
              console.warn('[装备系统] 槽位没有装备数据，跳过卸载');
              return; // 如果没有物品，则不执行任何操作
            }

            let itemName = '一件装备';
            let item = null;
            try {
              item = JSON.parse(itemDataString.replace(/'/g, "'"));
              itemName = this.SafeGetValue(item, 'name');
            } catch (e) {
              console.error('[装备系统] 卸载时解析物品数据失败', e);
            }

            // 更新UI显示
            slotElement.textContent = defaultTextMap[slotKey] || '空';
            slotElement.classList.remove('equipped');
            slotElement.removeAttribute('style');
            delete slotElement.dataset.itemDetails;
            const mvuData = this.currentMvuState;
            if (!mvuData) {
              console.error('[装备系统] 无法获取MVU状态，卸载操作中断');
              this.showTemporaryMessage('发生内部错误，卸载失败');
              return;
            }
            const mvuKey = defaultTextMap[slotKey];
            console.log(`[装备系统] 开始通过MVU API卸载 ${itemName} 从 ${mvuKey}`);

            // 1. 清空装备槽
            await Mvu.setMvuVariable(mvuData, mvuKey, null, { reason: `卸下 ${itemName}` });

            if (item) {
              // 2.1 首先计算出【卸下前】的最终减益值
              // 注意：减益必须基于卸下前的百分比来计算，否则会多扣
              const originalPercentBonusesData = Mvu.getMvuVariable(mvuData, '当前百分比加成', { default_value: {} });
              const flatBonuses = item.attributes_bonus;
              if (flatBonuses && typeof flatBonuses === 'object') {
                for (const [mvuName, bonusValue] of Object.entries(flatBonuses)) {
                  const value = parseInt(bonusValue, 10) || 0;
                  if (value !== 0) {
                    const percentStr = String(originalPercentBonusesData[mvuName] || '0%');
                    const percent = (parseFloat(percentStr.replace('%', '')) || 0) / 100;
                    const finalLoss = Math.floor(value * (1 + percent));
                    
                    const currentValue = Mvu.getMvuVariable(mvuData, mvuName, { default_value: 0 });
                    await Mvu.setMvuVariable(mvuData, mvuName, currentValue - finalLoss, { reason: `卸下 ${itemName} (-${value} -> -${finalLoss})` });
                  }
                }
              }

              // 2.2 然后再更新总百分比加成对象
              const percentBonuses = item['百分比加成'];
              if (percentBonuses && typeof percentBonuses === 'object') {
                for (const [mvuName, bonusValue] of Object.entries(percentBonuses)) {
                  const value = parseFloat(String(bonusValue).replace('%', '')) || 0;
                  if (value !== 0) {
                    const path = `当前百分比加成.${mvuName}`;
                    const currentValueStr = Mvu.getMvuVariable(mvuData, path, { default_value: '0%' });
                    const currentValue = parseFloat(currentValueStr.replace('%', '')) || 0;
                    await Mvu.setMvuVariable(mvuData, path, `${currentValue - value}%`, { reason: `卸下 ${itemName}` });
                  }
                }
              }
            }

            // 4. 更新血量上限
            await this._updateHealthCap(mvuData);

            // 5. 乐观更新UI：在与后端同步前，立刻刷新前端界面
            this.renderUI(this.currentMvuState.stat_data);
            if (showMessage) {
              this.showTemporaryMessage(`已卸下 ${itemName}`);
            }
            const inventoryModal = document.getElementById('inventory-modal');
            if (inventoryModal && inventoryModal.style.display !== 'none') {
                this.showInventory(true); // 修复：强制使用本地状态刷新背包UI
            }

            // 6. 将所有变更一次性同步到后端（在后台进行）
            await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });
            console.log('[装备系统] MVU状态已同步到后端');
          },

          loadEquipmentFromMVU(data) {  
            const equipmentMap = {
              武器: 'wuqi',
              主修功法: 'zhuxiuGongfa',
              辅修心法: 'fuxiuXinfa',
              防具: 'fangju',
              饰品: 'shipin',
              法宝栏: 'fabao1', 
            };
            const defaultTextMap = {
              wuqi: '武器',
              fangju: '防具',
              shipin: '饰品',
              fabao1: '法宝',
              zhuxiuGongfa: '主修功法',
              fuxiuXinfa: '辅修心法',
            };

            for (const [mvuKey, slotKey] of Object.entries(equipmentMap)) {
              const slot = document.getElementById(`equip-${slotKey}`);
              if (!slot) {
                continue;
              }
              const item = _.get(data, mvuKey, null);
              if (item && typeof item === 'object' && item.name) {
                const tier = this.SafeGetValue(item, 'tier', '凡品');
                const tierStyle = this.getItemTierStyle(tier);
                
                slot.textContent = this.SafeGetValue(item, 'name');
                slot.setAttribute('style', tierStyle);
                slot.classList.add('equipped');
                slot.dataset.itemDetails = JSON.stringify(item).replace(/'/g, "'");
              } else {
                slot.textContent = defaultTextMap[slotKey];
                slot.classList.remove('equipped');
                slot.removeAttribute('style');
                delete slot.dataset.itemDetails;
              }
            }
          },

          _getEquipmentFromStatData(stat_data) {
              const equipmentMap = {
                武器: 'wuqi',
                主修功法: 'zhuxiuGongfa',
                辅修心法: 'fuxiuXinfa',
                防具: 'fangju',
                饰品: 'shipin',
                法宝栏: 'fabao1', 
              };
              const equippedItems = {};
              for (const [mvuKey, slotKey] of Object.entries(equipmentMap)) {
                  const item = _.get(stat_data, mvuKey, null);
                  if (item && typeof item === 'object' && item.name) {
                      equippedItems[slotKey] = item;
                  }
              }
              return equippedItems;
          },



// ===装备系统模块（极为重要）开始===



// ===各类数值处理、渲染模块（超级重要）开始===
// mvu变量


          updateDisplayedAttributes(stat_data_param = null) {
            // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享
            // **重构第一步：统一数据源**
            // 严格使用传入的 stat_data_param 作为唯一数据源。
            // 仅当 stat_data_param 为 null 时，才安全地回退到 this.currentMvuState.stat_data。
            const stat_data = stat_data_param || (this.currentMvuState ? this.currentMvuState.stat_data : null);
            if (!stat_data) {
                console.warn('[属性更新] stat_data不可用，计算终止。');
                // 当数据不可用时，显示默认的"..."而不是"0 / 0"
                document.getElementById('attr-xueliang').innerText = '...';
                document.getElementById('attr-fali').innerText = '...';
                document.getElementById('attr-shenhai').innerText = '...';
                document.getElementById('attr-daoxin').innerText = '...';
                document.getElementById('attr-kongsu').innerText = '...';
                document.getElementById('attr-qiyun').innerText = '...';
                document.getElementById('attr-wuxing').innerText = '...';
                document.getElementById('attr-meili').innerText = '...';
                return;
            }
            
            
            // **简化版渲染函数**
            // 本函数现在只负责读取MVU中的最终值并将其渲染到UI，不再进行任何计算。
            // 复杂的属性计算逻辑已移至 equipItem 和 unequipItem 中。

            // 1. 读取所有相关的上限和当前值
            const finalMaxAttrs = {
              fali: parseInt(this.SafeGetValue(stat_data, '法力', 0), 10),
              shenhai: parseInt(this.SafeGetValue(stat_data, '神海', 0), 10),
              daoxin: parseInt(this.SafeGetValue(stat_data, '道心', 0), 10),
              kongsu: parseInt(this.SafeGetValue(stat_data, '空速', 0), 10),
              qiyun: parseInt(this.SafeGetValue(stat_data, '气运', 0), 10),
              wuxing: parseInt(this.SafeGetValue(stat_data, '悟性', 0), 10),
              meili: parseInt(this.SafeGetValue(stat_data, '魅力', 0), 10),
              xueliang: parseInt(this.SafeGetValue(stat_data, '血量', 0), 10)
            };
            
            const currentAttrs = {
                fali: parseInt(this.SafeGetValue(stat_data, '当前法力', finalMaxAttrs.fali), 10),
                shenhai: parseInt(this.SafeGetValue(stat_data, '当前神海', finalMaxAttrs.shenhai), 10),
                daoxin: parseInt(this.SafeGetValue(stat_data, '当前道心', finalMaxAttrs.daoxin), 10),
                kongsu: parseInt(this.SafeGetValue(stat_data, '当前空速', finalMaxAttrs.kongsu), 10),
                xueliang: parseInt(this.SafeGetValue(stat_data, '当前血量', finalMaxAttrs.xueliang), 10)
            };

            // 2. 更新UI
            const updateAttr = (elementId, current, max) => {
                const element = document.getElementById(elementId);
                if (element) element.innerText = `${current} / ${max}`;
            };
            const updateSingleAttr = (elementId, value) => {
                const element = document.getElementById(elementId);
                if (element) element.innerText = value;
            };

            updateAttr('attr-xueliang', currentAttrs.xueliang, finalMaxAttrs.xueliang);
            updateAttr('attr-fali', currentAttrs.fali, finalMaxAttrs.fali);
            updateAttr('attr-shenhai', currentAttrs.shenhai, finalMaxAttrs.shenhai);
            updateAttr('attr-daoxin', currentAttrs.daoxin, finalMaxAttrs.daoxin);
            updateAttr('attr-kongsu', currentAttrs.kongsu, finalMaxAttrs.kongsu);
            updateSingleAttr('attr-qiyun', finalMaxAttrs.qiyun);
            updateSingleAttr('attr-wuxing', finalMaxAttrs.wuxing);
            updateSingleAttr('attr-meili', finalMaxAttrs.meili);
            const xiuxingjindu = this.SafeGetValue(stat_data, '修为进度', '0');
            const xiuxingpingjing = this.SafeGetValue(stat_data, '修为瓶颈', '无');
            const jingjieYingshe = this.SafeGetValue(stat_data, '境界映射', '1');
            document.getElementById('attr-xiuxing-jindu').innerText = `${xiuxingjindu}%`;
            document.getElementById('attr-xiuxing-pingjing').innerText = xiuxingpingjing;
            document.getElementById('attr-jingjie-yingshe').innerText = jingjieYingshe;
            const progressBar = document.getElementById('progress-xiuxing');
            if (progressBar) {
              progressBar.style.width = `${xiuxingjindu}%`;
            }

            this.updateSpecialAttributes(stat_data);
          },

          async _updateHealthCap(mvuData) {
              if (!mvuData) return;
              const stat_data = mvuData.stat_data;
              
              const fali = parseInt(Mvu.getMvuVariable(mvuData, '法力', { default_value: 0 }), 10);
              const shenhai = parseInt(Mvu.getMvuVariable(mvuData, '神海', { default_value: 0 }), 10);
              const daoxin = parseInt(Mvu.getMvuVariable(mvuData, '道心', { default_value: 0 }), 10);
              const kongsu = parseInt(Mvu.getMvuVariable(mvuData, '空速', { default_value: 0 }), 10);

              const newHealthCap = Math.floor((fali * 0.2) + (daoxin * 0.5) + (shenhai * 0.3) + (kongsu * 0.1));
              
              const existingHealthCap = parseInt(Mvu.getMvuVariable(mvuData, '血量', { default_value: 0 }), 10);

              if (newHealthCap !== existingHealthCap) {
                  await Mvu.setMvuVariable(mvuData, '血量', newHealthCap, { reason: '四维属性变化导致血量上限更新' });
                  // 同时更新当前血量，确保不会超过新上限
                  const currentHealth = parseInt(Mvu.getMvuVariable(mvuData, '当前血量', { default_value: 0 }), 10);
                  if (currentHealth > newHealthCap) {
                      await Mvu.setMvuVariable(mvuData, '当前血量', newHealthCap, { reason: '血量上限变化' });
                  }
              }
          },

          updateSpecialAttributes(stat_data) {
            const container = document.getElementById('xiuwei-details-list');
            const oldSpecialAttrs = container.querySelectorAll('.details-container');
            oldSpecialAttrs.forEach(el => el.remove());

            const specialAttrs = {
              '真气': 'zhenqi',
              '筑基奇物': 'zhujiqiwu',
              '洞天': 'dongtian',
              '神妙': 'shenmiao',
              '本命神妙': 'benmingshenmiao'
            };

            // 处理仙灵之气
            const xianlingzhiqi = this.SafeGetValue(stat_data, '仙灵之气', null);
            // 确保在处理其他属性 *之后* 再处理仙灵之气，以保证其在最下方
            const finalHtmlProcessing = () => {
              const existingEl = document.getElementById('xianlingzhiqi-dynamic-item');
              if(existingEl) existingEl.remove();

              if (xianlingzhiqi !== null && xianlingzhiqi > 0) {
                const detailsContainer = document.getElementById('xiuwei-details-list');
                if(detailsContainer){
                  const xianlingzhiqiHtml = `
                    <div class="attribute-item" id="xianlingzhiqi-dynamic-item">
                      <span class="attribute-name xianlingzhiqi-special">仙灵之气</span>
                      <span id="attr-xianlingzhiqi" class="attribute-value xianlingzhiqi-special">${xianlingzhiqi}</span>
                    </div>
                  `;
                  detailsContainer.insertAdjacentHTML('beforeend', xianlingzhiqiHtml);
                }
              }
            };

            let finalHtml = '';
            for (const [name, idPrefix] of Object.entries(specialAttrs)) {
                const data = this.SafeGetValue(stat_data, name, null);
                if (!data || typeof data !== 'object') continue;

                const entries = Object.entries(data).filter(([key]) => key !== '$meta');
                if (entries.length === 0) continue;

                let sectionHtml = '';
                // 统一处理所有特殊属性
                let itemsHtml = '';
                entries.forEach(([itemName, itemDetails]) => {
                        const tier = this.SafeGetValue(itemDetails, '品阶', '凡品');
                        const tierStyle = this.getItemTierStyle(tier);
                        const itemDetailsHtml = this.renderRecursiveDetails(itemDetails, ['品阶']);
                        itemsHtml += `
                           <details class="details-container">
                               <summary>
                                   <span class="attribute-name">${name}</span>
                                   <span class="attribute-value" style="${tierStyle}">${tier ? `【${tier}】 ` : ''}${itemName}</span>
                               </summary>
                               <div class="details-content">${itemDetailsHtml}</div>
                           </details>
                        `;
                    });
                    // 修改：不再创建独立的section，直接使用itemsHtml
                    if (itemsHtml) {
                        sectionHtml = itemsHtml;
                    }
                 if(sectionHtml) {
                    finalHtml += sectionHtml;
                }
            }
            // 修改：使用appendChild追加内容，而不是innerHTML覆盖
            container.insertAdjacentHTML('beforeend', finalHtml);
            
            // 最后处理仙灵之气
            finalHtmlProcessing();
          },

          renderRecursiveDetails(obj, excludeKeys = []) {
            if (!obj || typeof obj !== 'object') return '';

            let mainContentHtml = '';
            let descriptionHtml = '';
            let citiaoHtml = '';
            let bonusHtml = '';
            let percentBonusHtml = '';
            let nestedCollectionHtml = '';
            let historyHtml = '';

            const tempObj = { ...obj };

            // 提取并分离各类数据
            const description = tempObj['描述'] || '';
            if(description) delete tempObj['描述'];

            const citiaoData = tempObj['词条'] || null;
            if(citiaoData) {
                citiaoHtml = this.renderCitiaoBlock(citiaoData);
                delete tempObj['词条'];
            }
            
            const bonusData = tempObj['attributes_bonus'] || null;
            if(bonusData) {
                bonusHtml = this.renderBonusBlock('固定加成', bonusData);
                delete tempObj['attributes_bonus'];
            }

            const percentBonusData = tempObj['百分比加成'] || null;
            if(percentBonusData) {
                percentBonusHtml = this.renderBonusBlock('百分比加成', percentBonusData, true);
                delete tempObj['百分比加成'];
            }
            
            const timeKeys = ['获取时间', '开辟时间', '凝练时间', '炼就时间'];
            let timeStr = '';
            timeKeys.forEach(key => {
                if (tempObj[key]) {
                    timeStr = tempObj[key];
                    delete tempObj[key];
                }
            });
            let historyStr = tempObj['经历'] || '';
            if(historyStr) delete tempObj['经历'];

            if (timeStr || historyStr) {
                 let combinedGossip = '';
                if (timeStr) combinedGossip += timeStr;
                if (historyStr) combinedGossip += (timeStr ? '，' : '') + historyStr;
                historyHtml = `
                    <details class="details-container">
                        <summary>
                            <span class="attribute-name">获取经历</span>
                            <span class="attribute-value"></span>
                        </summary>
                        <div class="details-content"><p>${combinedGossip}</p></div>
                    </details>
                `;
            }

            // 渲染剩余的嵌套集合
            for (const [key, value] of Object.entries(tempObj)) {
                 if (key !== '$meta' && typeof value === 'object' && value !== null) {
                    nestedCollectionHtml += this.renderNestedCollection(key, value);
                 }
            }

            // 组装最终HTML
            if(description) mainContentHtml += `<p>${description}</p>`;
            if(citiaoHtml) mainContentHtml += `<div class="item-details">${citiaoHtml}</div>`;
            if(nestedCollectionHtml) mainContentHtml += nestedCollectionHtml;
            if(bonusHtml) mainContentHtml += bonusHtml;
            if(percentBonusHtml) mainContentHtml += percentBonusHtml;
            if(historyHtml) mainContentHtml += historyHtml;

            return mainContentHtml;
          },

          renderCitiaoBlock(citiaoObj) {
            if (!citiaoObj || typeof citiaoObj !== 'object') return '';
            let html = '<p><strong>词条</strong></p>';
            for (const [name, description] of Object.entries(citiaoObj)) {
              if (name === '$meta') continue;
              html += `<p><span class="attribute-value">${name}</span>: <span class="citiao-description">${description}</span></p>`;
            }
            return html;
          },

          renderBonusBlock(title, bonusObj, isPercentage = false) {
            if (!bonusObj || typeof bonusObj !== 'object') return '';
            let html = `<p><strong>${title}</strong></p>`;
            for (const [attr, value] of Object.entries(bonusObj)) {
              if (attr === '$meta') continue;
              const displayValue = isPercentage ? `${value}` : `+${value}`;
              html += `<p><strong style="color: white;">${attr}</strong>: ${displayValue}</p>`;
            }
            return html;
          },

          renderNestedCollection(collectionName, collectionObj) {
            if (!collectionObj || typeof collectionObj !== 'object') return '';
            let html = `<p><strong>${collectionName}</strong></p>`;
            for (const [itemName, itemData] of Object.entries(collectionObj)) {
              if (itemName === '$meta') continue;
              
              const tier = itemData.品阶 || '';
              const tierStyle = tier ? this.getItemTierStyle(tier) : '';
              const quantity = itemData.数量 ? ` x${itemData.数量}` : '';
              const subDetails = this.renderRecursiveDetails(itemData, ['品阶', '数量']);
              
              html += `
                <details class="details-container">
                  <summary>
                    <span class="attribute-name">${itemName}${quantity}</span>
                    <span class="attribute-value" ${tierStyle ? `style="${tierStyle}"` : ''}>${tier ? `【${tier}】` : ''}</span>
                  </summary>
                  <div class="details-content">
                    ${subDetails}
                  </div>
                </details>
              `;
            }
            return html;
          },



          
// ===各类数值处理、渲染模块（超级重要）结束===




// 【临时消息提示 (支持类型和颜色)】
          showTemporaryMessage(message, type = 'info', duration = 3000) {
              const existingMsg = document.querySelector('.temp-message-popup');
              if (existingMsg) existingMsg.remove();

              const colors = {
                  info: { bg: 'rgba(45, 27, 61, 0.9)', text: '#c9aa71' },
                  success: { bg: 'rgba(40, 167, 69, 0.9)', text: '#ffffff' },
                  warning: { bg: 'rgba(255, 193, 7, 0.9)', text: '#000000' },
                  error: { bg: 'rgba(220, 53, 69, 0.9)', text: '#ffffff' }
              };
              const selectedColor = colors[type] || colors.info;

              const msgElement = document.createElement('div');
              msgElement.className = 'temp-message-popup';
              msgElement.textContent = message;
              msgElement.style.cssText = `
                      position: absolute;
                      top: 20px;
                      left: 50%;
                      transform: translateX(-50%);
                      background: ${selectedColor.bg};
                      color: ${selectedColor.text};
                      padding: 10px 20px;
                      border-radius: 5px;
                      z-index: 2000;
                      font-size: 14px;
                      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
                      text-align: center;
                      transition: opacity 0.5s ease-out;
                      max-width: 90%;
                  `;
              document.querySelector('.guixu-root-container').appendChild(msgElement);

              setTimeout(() => {
                  msgElement.style.opacity = '0';
                  setTimeout(() => msgElement.remove(), 500);
              }, duration - 500);
          },

          showCommandCenter() {
              this.openModal('command-center-modal');
              const body = document.querySelector('#command-center-modal .modal-body');
              if (!body) return;
              
              if (this.pendingActions.length === 0) {
                  body.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">暂无待执行的指令。</p>';
                  return;
              }
              
              let html = '<ul class="command-center-actions">';
              this.pendingActions.forEach(commandText => {
                  if (commandText) {
                      html += `<li class="command-center-action-item">${commandText}</li>`;
                  }
              });
              html += '</ul>';
              body.innerHTML = html;
          },

          clearPendingActions() {
              this.pendingActions = [];
              this.savePendingActions();
              this.showTemporaryMessage('指令已清空');
              if (document.getElementById('command-center-modal').style.display === 'flex') {
                  this.showCommandCenter();
              }
              if (document.getElementById('gacha-settings-popup').style.display === 'flex') {
                  this._renderGachaSettingsTab('command_center');
              }
              if (document.getElementById('gacha-gallery-popup').style.display === 'flex') {
                  this.showGachaGalleryPopup();
              }
          },

          async executePendingActions() {
            await this.handleAction();
          },

          useItem(item, buttonElement) {
            const itemName = this.SafeGetValue(item, 'name');
            if (itemName === 'N/A') {
              this.showTemporaryMessage('物品信息错误，无法使用。');
              return;
            }
            this.addCommand(`使用 1 个 [${itemName}]。`);
            this.showTemporaryMessage(`已将 [使用 ${itemName}] 加入指令队列`);
            this.savePendingActions();
            this.showInventory();
          },

          discardItem(item, category, itemElement) {
            const itemName = this.SafeGetValue(item, 'name');
            if (itemName === 'N/A') {
              this.showTemporaryMessage('物品信息错误，无法丢弃。');
              return;
            }

            const hasQuantity = item.hasOwnProperty('quantity');
            
            if (hasQuantity && (category === '丹药' || category === '杂物')) {
              // 有数量的物品，需要输入丢弃数量
              this.promptDiscardQuantity(item, category, itemElement);
            } else {
              // 装备类物品，直接确认丢弃
              this.confirmDiscardItem(item, category, itemElement, 1);
            }
          },

          async promptDiscardQuantity(item, category, itemElement) {
            const itemName = this.SafeGetValue(item, 'name');
            const currentQuantity = parseInt(this.SafeGetValue(item, 'quantity', 0), 10);
            const availableQuantity = currentQuantity;

            if (availableQuantity <= 0) {
              this.showTemporaryMessage(`${itemName} 没有可丢弃的数量。`);
              return;
            }

            return new Promise((resolve) => {
              // 创建数量输入模态框
              const modal = document.createElement('div');
              modal.className = 'modal-overlay';
              modal.style.display = 'flex';
              modal.style.zIndex = '2000';
              modal.innerHTML = `
                <div class="modal-content" style="width: 400px; height: auto; max-height: none;">
                  <div class="modal-header">
                    <h2 class="modal-title">丢弃物品</h2>
                  </div>
                  <div class="modal-body" style="padding: 20px;">
                    <p style="margin-bottom: 15px; color: #c9aa71;">请输入要丢弃的 <strong>${itemName}</strong> 数量：</p>
                    <p style="font-size: 12px; color: #8b7355; margin-bottom: 10px;">当前可丢弃数量：${availableQuantity}</p>
                    <input type="number" id="discard-quantity-input" min="1" max="${availableQuantity}" value="1"
                           style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355;
                                  color: #e0dcd1; border-radius: 4px; font-size: 14px; margin-bottom: 20px;">
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                      <button id="discard-quantity-cancel" class="interaction-btn">取消</button>
                      <button id="discard-quantity-confirm" class="interaction-btn" style="background: #8b0000; border-color: #ff6b6b;">确认丢弃</button>
                    </div>
                  </div>
                </div>
              `;

              const container = document.querySelector('.guixu-root-container');
              container.appendChild(modal);

              const input = modal.querySelector('#discard-quantity-input');
              const confirmBtn = modal.querySelector('#discard-quantity-confirm');
              const cancelBtn = modal.querySelector('#discard-quantity-cancel');

              confirmBtn.addEventListener('click', () => {
                const quantity = parseInt(input.value, 10);
                if (isNaN(quantity) || quantity <= 0 || quantity > availableQuantity) {
                  this.showTemporaryMessage('请输入有效的丢弃数量');
                  return;
                }
                modal.remove();
                this.confirmDiscardItem(item, category, itemElement, quantity);
                resolve();
              });

              cancelBtn.addEventListener('click', () => {
                modal.remove();
                resolve();
              });

              // 自动聚焦
              setTimeout(() => input.focus(), 100);
            });
          },

          async confirmDiscardItem(item, category, itemElement, quantity = 1) {
            const itemName = this.SafeGetValue(item, 'name');
            const hasQuantity = item.hasOwnProperty('quantity');
            
            let confirmMessage;
            if (hasQuantity) {
              confirmMessage = `确定要丢弃 ${quantity} 个 ${itemName} 吗？此操作不可恢复。`;
            } else {
              confirmMessage = `确定要丢弃 ${itemName} 吗？此操作不可恢复。`;
            }

            this.showCustomConfirm(confirmMessage, async () => {
              try {
                // 第一步：获取最新的"本地草稿"
                const mvuData = this.currentMvuState;
                if (!mvuData) {
                  this.showTemporaryMessage('无法获取MVU状态！', 'error');
                  return;
                }

                // 映射category到对应的列表键名
                const categoryKeyMap = {
                  '功法': '功法列表',
                  '武器': '武器列表',
                  '防具': '防具列表',
                  '饰品': '饰品列表',
                  '法宝': '法宝列表',
                  '丹药': '丹药列表',
                  '杂物': '其他列表'
                };

                const listKey = categoryKeyMap[category];
                if (!listKey) {
                  this.showTemporaryMessage(`未知的物品类别：${category}`, 'error');
                  return;
                }

                // 第二步：在"本地草稿"上进行删除操作
                if (hasQuantity) {
                  // 有数量的物品，减少数量或删除
                  const currentQuantity = parseInt(this.SafeGetValue(item, 'quantity', 0), 10);
                  const newQuantity = currentQuantity - quantity;

                  if (newQuantity <= 0) {
                    // 数量归零，删除整个物品 - 使用delete操作符确保键被完全移除
                    const itemList = Mvu.getMvuVariable(mvuData, listKey, { default_value: {} });
                    delete itemList[itemName];
                    await Mvu.setMvuVariable(
                      mvuData,
                      listKey,
                      itemList,
                      { reason: `丢弃物品：${itemName}` }
                    );
                  } else {
                    // 减少数量
                    await Mvu.setMvuVariable(
                      mvuData,
                      `${listKey}.${itemName}.quantity`,
                      newQuantity,
                      { reason: `丢弃 ${quantity} 个 ${itemName}` }
                    );
                  }
                } else {
                  // 装备类物品，直接删除 - 使用delete操作符确保键被完全移除
                  const itemList = Mvu.getMvuVariable(mvuData, listKey, { default_value: {} });
                  delete itemList[itemName];
                  await Mvu.setMvuVariable(
                    mvuData,
                    listKey,
                    itemList,
                    { reason: `丢弃物品：${itemName}` }
                  );
                }

                // 第三步：将修改后的"本地草稿"同步回"云端正本"
                await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                // 第四步：刷新UI并给予反馈
                if (hasQuantity) {
                  this.showTemporaryMessage(`已成功丢弃 ${quantity} 个 ${itemName}`, 'success');
                } else {
                  this.showTemporaryMessage(`已成功丢弃 ${itemName}`, 'success');
                }

                // 刷新背包UI
                this.showInventory(true);

              } catch (error) {
                console.error('丢弃物品失败:', error);
                this.showTemporaryMessage(`丢弃失败: ${error.message}`, 'error');
              }
            }, null, true);
          },



// ===查看提取内容模块开始===      



          showExtractedContent() {
            this.openModal('extracted-content-modal');
            const journeyEl = document.getElementById('extracted-journey');
            const pastLivesEl = document.getElementById('extracted-past-lives');
            const mapCommandsEl = document.getElementById('extracted-map-commands');
            const variablesEl = document.getElementById('extracted-variable-changes');
            const sentPromptEl = document.getElementById('sent-prompt-display');
            const currentMvuEl = document.getElementById('current-mvu-variables');

            if (currentMvuEl) {
              if (this.currentMvuState) {
                currentMvuEl.textContent = JSON.stringify(this.currentMvuState, null, 2);
              } else {
                currentMvuEl.textContent = 'MVU 状态尚未加载。';
              }
            }

            if (sentPromptEl) {
              sentPromptEl.textContent = this.lastSentPrompt || '尚未发送任何内容';
            }
            if (journeyEl) {
              journeyEl.textContent = this.lastExtractedJourney || '未提取到内容';
            }
            if (pastLivesEl) {
              pastLivesEl.textContent = this.lastExtractedPastLives || '未提取到内容';
            }
            if (variablesEl) {
              variablesEl.textContent = this.lastExtractedVariables || '本次无变量改变';
            }
            const novelModeEl = document.getElementById('extracted-novel-mode');
            const novelModeBtn = document.getElementById('btn-write-novel-mode');
            if (novelModeEl && novelModeBtn) {
              // 始终显示提取到的内容。按钮可用性仅取决于内容是否存在。
              novelModeEl.textContent = this.lastExtractedNovelText || '当前AI回复中未提取到正文内容。';
              novelModeBtn.disabled = !this.lastExtractedNovelText;

              // 更新标签文本以提供关于自动写入状态的即时反馈
              const label = document.querySelector('label[for="novel-mode-enabled-checkbox"]');
              if (label) {
                const statusText = this.isNovelModeEnabled ? '开启' : '关闭';
                label.title = `点击切换自动写入状态，当前为：${statusText}`;
              }
            }

            // 新增：处理提取的角色卡
            const characterCardEl = document.getElementById('extracted-character-card');
            const characterCardBtn = document.getElementById('btn-write-character-card');
            if (characterCardEl && characterCardBtn) {
              characterCardEl.textContent = this.lastExtractedCharacterCard || '未提取到角色卡内容。';
              characterCardBtn.disabled = !this.lastExtractedCharacterCard;
            }
          },

          async showJourney() {
            this.openModal('history-modal');
            this.loadUnifiedIndex(); // 确保输入框显示正确的序号
            const titleEl = document.getElementById('history-modal-title');
            if (titleEl) titleEl.textContent = '本世历程';

            // 新增：向模态框头部注入修剪相关的UI元素
            const headerControls = document.querySelector('#history-modal .modal-header > div');
            if (headerControls) {
                 headerControls.innerHTML = ``; // 清空旧的修剪按钮
            }
             // 显示修剪控制台并加载状态
            const trimConsole = document.getElementById('trim-console');
            if (trimConsole) {
                trimConsole.style.display = 'block';
                this.loadTrimFieldsState(); // 确保每次打开都加载最新的状态
            }

            const body = document.getElementById('history-modal-body');
            if (!body) return;

            // 修复BUG：不再完全覆盖innerHTML，而是只更新时间线部分
            const timelinePlaceholder = document.createElement('div');
            timelinePlaceholder.id = 'timeline-placeholder';
            timelinePlaceholder.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">正在读取命运之卷...</p>';
            
            const existingTimeline = body.querySelector('#timeline-placeholder, .timeline-container');
            if (existingTimeline) {
                existingTimeline.remove();
            }
            body.appendChild(timelinePlaceholder);

            try {
              const bookName = '1归墟';
              const index = this.unifiedIndex;
              const journeyKey = index > 1 ? `本世历程(${index})` : '本世历程';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

              if (!journeyEntry) {
                console.warn(`在世界书 "${bookName}" 中未找到标题为 "${journeyKey}" 的条目。`);
              }
              // 将渲染好的时间线内容替换掉占位符
              timelinePlaceholder.innerHTML = this.renderJourneyFromContent(journeyEntry);
              // 绑定点击事件监听器
              this.bindJourneyListeners();

              // 新增：为动态添加的修剪UI绑定事件
              document.querySelectorAll('.trim-field-checkbox').forEach(checkbox => {
                  checkbox.addEventListener('change', () => this.saveTrimFieldsState());
              });
              document.getElementById('btn-precise-trim')?.addEventListener('click', () => this.handlePreciseTrim());
              document.getElementById('btn-auto-trim')?.addEventListener('click', () => this.handleAutoTrim());
              document.getElementById('btn-full-trim')?.addEventListener('click', () => this.handleFullTrim());

            } catch (error) {
              console.error('读取"本世历程"时出错:', error);
              body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">读取记忆时出现错误：${error.message}</p>`;
            }
          },

          async showPastLives() {
            this.openModal('history-modal');
            this.loadUnifiedIndex(); 
            const titleEl = document.getElementById('history-modal-title');
            if (titleEl) titleEl.textContent = '往世涟漪';
            // 隐藏修剪控制台
            const trimConsole = document.getElementById('trim-console');
            if (trimConsole) {
                trimConsole.style.display = 'none';
            }
            const body = document.getElementById('history-modal-body');
            if (!body) return;

            // 统一使用占位符和DOM操作，避免innerHTML覆盖
            const timelinePlaceholder = document.createElement('div');
            timelinePlaceholder.id = 'timeline-placeholder';
            timelinePlaceholder.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">正在回溯时光长河...</p>';

            const existingTimeline = body.querySelector('#timeline-placeholder, .timeline-container');
            if (existingTimeline) {
                existingTimeline.remove();
            }
            body.appendChild(timelinePlaceholder);

            try {
              const bookName = '1归墟';
              const index = this.unifiedIndex;
              const pastLivesKey = index > 1 ? `往世涟漪(${index})` : '往世涟漪';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const pastLivesEntry = allEntries.find(entry => entry.comment === pastLivesKey);

              if (!pastLivesEntry) {
                console.warn(`在世界书 "${bookName}" 中未找到标题为 "${pastLivesKey}" 的条目。`);
              }

              timelinePlaceholder.innerHTML = this.renderPastLives(pastLivesEntry);
            } catch (error) {
              console.error('读取“往世涟漪”时出错:', error);
              timelinePlaceholder.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">回溯时光长河时出现错误：${error.message}</p>`;
            }
          },

         async showNovelMode() {
          if (this.isFromSettingsModal) {
            this.closeModal('settings-modal');
          }
          this.openModal('novel-mode-modal');
          this.loadUnifiedIndex(); 
          const input = document.getElementById('novel-mode-index-input');
          if (input) {
            input.value = this.unifiedIndex;
          }
          const titleEl = document.getElementById('novel-mode-modal-title');
          if (titleEl) titleEl.textContent = '小说模式';

          const body = document.getElementById('novel-mode-modal-body');
          const chapterNav = document.getElementById('novel-chapter-nav');
          if (!body) return;

          body.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">正在加载小说内容...</p>';
          
          try {
            const bookName = '1归墟';
            const index = this.unifiedIndex; // 使用统一的世界书写入序号
            const novelModeKey = index > 1 ? `小说模式(${index})` : '小说模式';
            const allEntries = await TavernHelper.getLorebookEntries(bookName);
            const novelModeEntry = allEntries.find(entry => entry.comment === novelModeKey);

            if (novelModeEntry && novelModeEntry.content) {
                // 解析章节
                this.novelChapters = this.parseNovelChapters(novelModeEntry.content);
                this.loadNovelBookmarks(); // 加载书签
                this.loadNovelDisplayMode(); // 加载显示模式
                this.loadNovelBackgroundSettings(); // 加载背景设置
                
                if (this.novelChapters.length > 1) {
                    // 显示章节导航
                    if (chapterNav) chapterNav.style.display = 'block';
                    
                    // 更新章节选择器
                    const chapterSelect = document.getElementById('chapter-select');
                    if (chapterSelect) {
                        chapterSelect.innerHTML = '<option value="">选择章节...</option>';
                        this.novelChapters.forEach((chapter, index) => {
                            const option = document.createElement('option');
                            option.value = index;
                            option.textContent = chapter.title;
                            chapterSelect.appendChild(option);
                        });
                    }
                    
                    // 更新书签选择器
                    this.updateBookmarkSelect();
                    
                    // 根据显示模式显示内容
                    if (this.novelDisplayMode === 'continuous') {
                        this.showAllChaptersContinuous();
                    } else {
                        this.showNovelChapter(0);
                    }
                } else {
                    // 没有章节，隐藏导航，显示全部内容
                    if (chapterNav) chapterNav.style.display = 'none';
                    body.innerHTML = `<div class="game-text-container" style="white-space: pre-wrap; padding: 10px;">${this.formatMessageContent(novelModeEntry.content)}</div>`;
                }
                
                // 应用背景设置
                this.applyNovelBackground();
            } else {
                if (chapterNav) chapterNav.style.display = 'none';
                body.innerHTML = '<p style="text-align:center; color:#8b7355; font-size:12px; padding-top: 20px;">该序号下没有小说内容。</p>';
            }

          } catch (error) {
            console.error('读取"小说模式"时出错:', error);
            if (chapterNav) chapterNav.style.display = 'none';
            body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">读取小说时出现错误：${error.message}</p>`;
          }
        },



// ===查看提取内容模块结束===     




// 【本世历程、往世涟漪数据解析模块】


          parseJourneyEntry(contentString) {
            if (!contentString || typeof contentString !== 'string') return [];
            try {
              const events = [];
              const eventBlocks = contentString
                .trim()
                .split(/序号\|/g)
                .slice(1);

              eventBlocks.forEach(block => {
                const fullBlock = `序号|${block}`.trim();
                const event = {};
                
                // 定义字段顺序，用于正确解析多行内容
                const fieldOrder = ['序号', '日期', '标题', '地点', '人物', '描述', '人物关系', '标签', '重要信息', '暗线与伏笔', '自动化系统'];
                
                let currentFieldIndex = 0;
                let currentKey = '';
                let currentValue = '';
                
                const lines = fullBlock.split('\n');
                
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  let foundField = false;
                  
                  // 检查是否是新字段的开始
                  for (let j = currentFieldIndex; j < fieldOrder.length; j++) {
                    const field = fieldOrder[j];
                    if (line.startsWith(field + '|')) {
                      // 保存前一个字段的值
                      if (currentKey && currentValue.trim()) {
                        event[currentKey] = currentValue.trim();
                      }
                      
                      // 开始新字段
                      currentKey = field;
                      currentValue = line.substring(field.length + 1);
                      currentFieldIndex = j;
                      foundField = true;
                      break;
                    }
                  }
                  
                  // 如果不是新字段，则追加到当前字段值
                  if (!foundField && currentKey) {
                    currentValue += '\n' + line;
                  }
                }
                
                // 保存最后一个字段
                if (currentKey && currentValue.trim()) {
                  event[currentKey] = currentValue.trim();
                }
                
                if (event['序号']) {
                  events.push(event);
                }
              });
              return events;
            } catch (e) {
              console.error('解析本世历程条目失败:', e);
              return [];
            }
          },

          parsePastLifeEntry(contentString) {
            if (!contentString || typeof contentString !== 'string') return {};
            try {
                const data = {};
                // 通过前瞻断言 (?=...) 按每个字段的起始标志进行分割，同时保留分隔符
                const parts = contentString.trim().split(/\n(?=^(?:第\d+世|事件脉络|本世概述|本世成就|本世获得物品|本世人物关系网|死亡原因|本世总结|本世评价)\|)/m);

                for (const part of parts) {
                    if (!part.trim()) continue;
                    
                    const separatorIndex = part.indexOf('|');
                    if (separatorIndex > 0) {
                        const key = part.substring(0, separatorIndex).trim();
                        const value = part.substring(separatorIndex + 1).trim();
                        data[key] = value;
                    }
                }
                return data;
            } catch (e) {
              console.error('解析往世涟漪条目失败:', e);
              return {};
            }
          },


// 【本世历程显示模块】


          renderJourneyFromContent(entry) {
            if (!entry || !entry.content)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">此生尚未留下任何印记。</p>';

            const events = this.parseJourneyEntry(entry.content);
            if (events.length === 0)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">内容格式有误，无法解析事件。</p>';

            events.sort((a, b) => (parseInt(a.序号, 10) || 0) - (parseInt(b.序号, 10) || 0));

            let html = '<div class="timeline-container"><div class="timeline-line"></div>';
            events.forEach((eventData, index) => {
              const eventId = `event-${entry.uid}-${index}`;
              const date = eventData['日期'] || '未知时间';
              const sequence = eventData['序号'] || '?';
              const title = eventData['标题'] || '无标题';
              const displayTitle = `第${sequence}章 ${title}`;
              const location = eventData['地点'] || '未知地点';
              const description = eventData['描述'] || '无详细描述。';
              const characters = eventData['人物'] || '';
              const relationships = eventData['人物关系'] || '';
              const importantInfo = eventData['重要信息'] || '';
              const hiddenPlot = eventData['暗线与伏笔'] || '';
              const autoSystem = eventData['自动化系统'] || '';

              const tagsHtml = (eventData['标签'] || '')
                .split('|')
                .map(tag => tag.trim())
                .filter(tag => tag)
                .map(tag => `<span class="tag-item">${tag}</span>`)
                .join('');

              const basicInfo = `
                <div style="display: flex; align-items: baseline; gap: 8px; margin-bottom: 8px;">
                    <div class="timeline-date">${date}</div>
                    <input type="checkbox" class="journey-trim-checkbox" data-sequence-id="${eventData['序号']}" style="cursor: pointer;">
                </div>
                <div class="timeline-tags">${tagsHtml}</div>
                <div class="timeline-title">${displayTitle}</div>
                <div class="timeline-location" style="font-size: 12px; color: #8b7355; margin: 5px 0;">地点：${location}</div>
                <div class="timeline-description">${description}</div>
              `;

              // 详细信息（需要点击2次才显示）
              const detailedInfo = `
                <div class="timeline-detailed-info" id="detailed-${eventId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(201, 170, 113, 0.3);">
                  ${characters ? `<div class="detail-section"><strong>人物：</strong>${characters}</div>` : ''}
                  ${relationships ? `<div class="detail-section"><strong>人物关系：</strong>${relationships}</div>` : ''}
                  ${importantInfo ? `<div class="detail-section"><strong>重要信息：</strong>${importantInfo}</div>` : ''}
                  ${hiddenPlot ? `<div class="detail-section"><strong>暗线与伏笔：</strong>${hiddenPlot}</div>` : ''}
                  ${autoSystem ? `<div class="detail-section"><strong>自动化系统：</strong><pre style="white-space: pre-wrap; font-size: 11px; color: #a09c91;">${autoSystem}</pre></div>` : ''}
                </div>
              `;

              html += `
                <div class="timeline-event" data-event-id="${eventId}" data-click-count="0" style="cursor: pointer;">
                  <div class="timeline-content">
                    ${basicInfo}
                    ${detailedInfo}
                  </div>
                </div>`;
            });
            html += '</div>';
            return html;
          },


// 【往世涟漪显示模块】

          renderPastLives(entry) {
            if (!entry || !entry.content || !entry.content.trim())
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">未发现任何往世的痕迹。</p>';

            // 使用前瞻断言来分割，这样不会消耗分隔符，可以正确处理每一世的记录
            const pastLifeBlocks = entry.content.trim().split(/\n\n?(?=第\d+世\|)/);
            
            if (pastLifeBlocks.length === 0)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">内容格式有误，无法解析往世记录。</p>';

            let html = '<div class="timeline-container"><div class="timeline-line"></div>';
            pastLifeBlocks.forEach(block => {
              if (!block.trim()) return; // 跳过可能产生的空块
              const data = this.parsePastLifeEntry(block);
              
              const titleKey = Object.keys(data).find(k => k.startsWith('第') && k.endsWith('世'));
              let title;
              if (titleKey && data.hasOwnProperty(titleKey)) {
                  const titleValue = data[titleKey] || '无题';
                  title = `${titleKey} | ${titleValue}`;
              } else {
                  title = block.split('\n')[0].trim();
              }
              let detailsHtml = '';
              const fieldOrder = ['事件脉络', '本世概述', '本世成就', '本世获得物品', '本世人物关系网', '死亡原因', '本世总结', '本世评价'];
              fieldOrder.forEach(field => {
                  if (data[field]) {
                      // 使用<pre>标签来保留多行文本的换行和格式
                      const fieldClassMap = {
                        '死亡原因': 'death-reason',
                        '本世成就': 'achievement',
                        '本世获得物品': 'items-obtained',
                        '本世总结': 'summary-evaluation',
                        '本世评价': 'summary-evaluation'
                      };
                      const specificClass = fieldClassMap[field] || '';
                      const itemClass = `detail-item ${specificClass}`.trim();
                      detailsHtml += `<div class="${itemClass}"><strong>${field}:</strong> <pre style="white-space: pre-wrap; font-family: inherit; margin: 0;">${data[field]}</pre></div>`;
                  }
              });

              html += `
                        <div class="timeline-event">
                            <div class="timeline-content">
                                <div class="timeline-title">${title}</div>
                                <div class="past-life-details">
                                    ${detailsHtml || '<div class="detail-item">内容不详</div>'}
                                </div>
                            </div>
                        </div>`;
            });
            html += '</div>';
            return html;
          },

          async renderPastLifeDetails(bookName) {
            const detailsContainer = document.getElementById('past-life-details');
            if (!detailsContainer) return;
            detailsContainer.style.display = 'block';
            detailsContainer.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">正在读取此世记忆...</p>';
            try {
              const entries = await TavernHelper.getLorebookEntries(bookName, 'summary');
              if (entries && entries.length > 0) {
                const summaryData = JSON.parse(entries[0].content);
                detailsContainer.innerHTML = `
                            <h4>${bookName} - 结局总览</h4>
                            <p><strong>最终境界:</strong> ${summaryData.finalStats.境界}</p>
                            <p><strong>存活时间:</strong> ${summaryData.finalStats.存活时间}</p>
                            <p><strong>主要成就:</strong> ${summaryData.achievements.join('、 ')}</p>
                            <p><strong>最终悔憾:</strong> ${summaryData.regrets}</p>
                            <p><strong>关键事件:</strong></p>
                            <ul style="padding-left: 20px;">${summaryData.keyEvents
                              .map(e => `<li>${e}</li>`)
                              .join('')}</ul>`;
              } else {
                detailsContainer.innerHTML =
                  '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">未能找到此世的结局总览。</p>';
              }
            } catch (error) {
              console.error(`Error fetching details for ${bookName}:`, error);
              detailsContainer.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">读取此世记忆时出错：${error.message}</p>`;
            }
          },


          bindJourneyListeners() {
            const timelineContainer = document.querySelector('.timeline-container');
            if (timelineContainer) {
              timelineContainer.addEventListener('click', (e) => {
                const timelineEvent = e.target.closest('.timeline-event');
                if (timelineEvent) {
                  this.handleJourneyEventClick(timelineEvent);
                }
              });
            }
          },

// 【本世历程详细内容模块】
          handleJourneyEventClick(eventElement) {
            const detailedInfo = eventElement.querySelector('.timeline-detailed-info');
            if (detailedInfo && detailedInfo.style.display === 'block') {
              detailedInfo.style.display = 'none';
              eventElement.style.cursor = 'pointer';
              eventElement.dataset.clickCount = '0';
            } else {
              const currentCount = parseInt(eventElement.dataset.clickCount || '0', 10);
              const newCount = currentCount + 1;
              eventElement.dataset.clickCount = newCount;

              // 当点击2次时显示详细信息
              if (newCount >= 2) {
                if (detailedInfo) {
                  detailedInfo.style.display = 'block';
                }
                eventElement.style.cursor = 'pointer';
              }
            }
          },



// ===本世历程、往世涟漪渲染/解析模块结束===





// ===核心格式提取、处理、解析模块开始===
// - loadAndDisplayCurrentScene从消息中提取正文、本世历程、往世涟漪、小说模式、角色提取、行动选项标签内容（核心提取函数）
// - 写入模块、轮询写入
// - 自动创建相关世界书
// - 行动选项的渲染



// 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享



          async writeJourneyToLorebook(silent = false) {
            const content = this.lastExtractedJourney;
            await this.writeToLorebook('本世历程', content, silent);
          },

          async writePastLivesToLorebook(silent = false) {
            const content = this.lastExtractedPastLives;
            await this.writeToLorebook('往世涟漪', content, silent);
          },

          async writeNovelModeToLorebook(silent = false) {
            const novelText = this.lastExtractedNovelText;
            // 如果没有正文内容，则不执行任何操作
            if (!novelText || novelText.trim() === '') {
              if (!silent) this.showTemporaryMessage('没有可写入的小说正文。');
              return;
            }

            const journeyText = this.lastExtractedJourney;
            let chapterHeader = '';

            // 尝试从本世历程中提取章节信息
            if (journeyText) {
              try {
                const events = this.parseJourneyEntry(journeyText);
                if (events.length > 0) {
                  // 假设数组中最后一个事件是最新的
                  const latestEvent = events[events.length - 1];
                  const sequence = this.SafeGetValue(latestEvent, '序号', null);
                  const title = this.SafeGetValue(latestEvent, '标题', null);

                  if (sequence && title) {
                    chapterHeader = `第${sequence}章 ${title}\n\n`;
                  }
                }
              } catch (e) {
                console.error('为小说模式解析章节标题时出错:', e);
              }
            }

            const finalContent = chapterHeader + novelText;
            await this.writeToLorebook('小说模式', finalContent, silent);
          },

          // 支持动态索引和条目创建
          async writeToLorebook(baseEntryKey, contentToWrite, silent = false) {
            if (!contentToWrite || contentToWrite.trim() === '') {
              if (!silent) this.showTemporaryMessage('没有可写入的内容。');
              return;
            }

            // 1. 根据序号生成最终的条目名称
            const index = this.unifiedIndex; // 所有类型都使用统一的世界书写入序号
            const finalEntryKey = index > 1 ? `${baseEntryKey}(${index})` : baseEntryKey;
            const bookName = '1归墟';

            let reformattedContent = contentToWrite.trim();
            let buttonId;

            // 2. 内容格式化 (逻辑保持不变)
            if (baseEntryKey === '往世涟漪') {
                const parsePastLivesRobust = (text) => {
                    const data = {};
                    const lines = text.trim().split('\n');
                    let currentKey = null;
                    let tempValue = [];
                    const keyRegex = /^(第\d+世|事件脉络|本世概述|本世成就|本世获得物品|本世人物关系网|死亡原因|本世总结|本世评价)\|/;

                    for (const line of lines) {
                        const match = line.match(keyRegex);
                        if (match) {
                            if (currentKey) {
                                data[currentKey] = tempValue.join('\n').trim();
                            }
                            currentKey = match[1];
                            tempValue = [line.substring(match[0].length)];
                        } else if (currentKey) {
                            tempValue.push(line);
                        }
                    }
                    if (currentKey) {
                        data[currentKey] = tempValue.join('\n').trim();
                    }
                    return data;
                };

                const parsedData = parsePastLivesRobust(contentToWrite);
                if (Object.keys(parsedData).length === 0) {
                    if (!silent) this.showTemporaryMessage(`无法解析“${baseEntryKey}”的内容，写入操作已取消。`);
                    return;
                }
                
                const dynamicKey = Object.keys(parsedData).find(k => k.startsWith('第') && k.endsWith('世'));
                const fields = [
                    dynamicKey, '事件脉络', '本世概述', '本世成就', '本世获得物品',
                    '本世人物关系网', '死亡原因', '本世总结', '本世评价',
                ].filter(Boolean);

                reformattedContent = fields
                    .map(key => (parsedData[key] ? `${key}|${parsedData[key]}` : null))
                    .filter(Boolean)
                    .join('\n');
                
                buttonId = 'btn-write-past-lives';

            } else if (baseEntryKey === '本世历程') {
                const journeyFields = ['序号', '日期', '标题', '描述', '标签'];
                const parseContent = (text, fieldList) => {
                  const data = {};
                  let tempText = text.replace(/\r\n/g, '\n');
                  fieldList.forEach((field, fIndex) => {
                    const nextField = fieldList[fIndex + 1];
                    const startMarker = `${field}|`;
                    const startIndex = tempText.indexOf(startMarker);
                    if (startIndex !== -1) {
                      let endIndex;
                      if (nextField) {
                        const nextMarkerIndex = tempText.indexOf(`${nextField}|`, startIndex);
                        endIndex = nextMarkerIndex !== -1 ? nextMarkerIndex : undefined;
                      }
                      let value = tempText.substring(startIndex + startMarker.length, endIndex);
                      data[field] = value.trim();
                    }
                  });
                  return data;
                };
                const parsedData = parseContent(contentToWrite, journeyFields);
                 if (Object.keys(parsedData).length === 0) {
                    if (!silent) this.showTemporaryMessage(`无法解析“${baseEntryKey}”的内容，写入操作已取消。`);
                    return;
                }
                reformattedContent = journeyFields
                    .map(key => (parsedData[key] ? `${key}|${parsedData[key]}` : null))
                    .filter(Boolean)
                    .join('\n');
                buttonId = 'btn-write-journey';
            } else if (baseEntryKey === '小说模式') {
              buttonId = 'btn-write-novel-mode';
            }

            const button = document.getElementById(buttonId);
            if (button && !silent) button.textContent = '写入中...';

            try {
              // 3. 检查条目是否存在，如果不存在则创建
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              let targetEntry = allEntries.find(entry => entry.comment === finalEntryKey);

              if (!targetEntry) {
                if (!silent) this.showTemporaryMessage(`条目 "${finalEntryKey}" 不存在，正在创建...`);
                
                let finalContentToWrite = reformattedContent;
                // 新增：如果是本世历程且开启了自动修剪，则对新创建的内容也进行一次检查（虽然通常是第一个事件，但逻辑上完整）
                if (baseEntryKey === '本世历程' && this.isAutoTrimEnabled) {
                    finalContentToWrite = this._getTrimmedJourneyContent(finalContentToWrite);
                }

                const baseEntryTemplate = allEntries.find(entry => entry.comment === baseEntryKey);
                
                // 构建完整的条目数据，确保所有必需的属性都存在
                const newEntryData = {
                  comment: finalEntryKey,
                  content: finalContentToWrite, // 使用可能被修剪过的内容
                  keys: baseEntryTemplate ? [...baseEntryTemplate.keys, finalEntryKey] : [finalEntryKey],
                  enabled: false,
                  // 复制模板的所有属性，如果没有模板则使用默认值，优先使用保存的设置
                  type: (() => {
                    if (baseEntryKey === '本世历程') return this.worldbookSettings?.journey?.type || baseEntryTemplate?.type || 'selective';
                    if (baseEntryKey === '往世涟漪') return this.worldbookSettings?.pastLives?.type || baseEntryTemplate?.type || 'selective';
                    if (baseEntryKey === '小说模式') return this.worldbookSettings?.novel?.type || baseEntryTemplate?.type || 'selective';
                    if (baseEntryKey === '分段正文') return this.worldbookSettings?.segmented?.type || baseEntryTemplate?.type || 'constant';
                    if (baseEntryKey === '小总结') return this.worldbookSettings?.smallSummary?.type || baseEntryTemplate?.type || 'constant';
                    if (baseEntryKey === '大总结') return this.worldbookSettings?.largeSummary?.type || baseEntryTemplate?.type || 'constant';
                    return baseEntryTemplate?.type || 'selective';
                  })(),
                  position: (() => {
                    if (baseEntryKey === '本世历程') return this.worldbookSettings?.journey?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === '往世涟漪') return this.worldbookSettings?.pastLives?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === '小说模式') return this.worldbookSettings?.novel?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === '分段正文') return this.worldbookSettings?.segmented?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === '小总结') return this.worldbookSettings?.smallSummary?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === '大总结') return this.worldbookSettings?.largeSummary?.position || baseEntryTemplate?.position || 'before_character_definition';
                    return baseEntryTemplate?.position || 'before_character_definition';
                  })(),
                  order: (() => {
                    if (baseEntryKey === '本世历程') return this.worldbookSettings?.journey?.order || baseEntryTemplate?.order || 20;
                    if (baseEntryKey === '往世涟漪') return this.worldbookSettings?.pastLives?.order || baseEntryTemplate?.order || 19;
                    if (baseEntryKey === '小说模式') return this.worldbookSettings?.novel?.order || baseEntryTemplate?.order || 18;
                    if (baseEntryKey === '分段正文') return this.worldbookSettings?.segmented?.order || baseEntryTemplate?.order || 21;
                    if (baseEntryKey === '小总结') return this.worldbookSettings?.smallSummary?.order || baseEntryTemplate?.order || 20;
                    if (baseEntryKey === '大总结') return this.worldbookSettings?.largeSummary?.order || baseEntryTemplate?.order || 19;
                    return baseEntryTemplate?.order || 20;
                  })(),
                  filters: baseEntryTemplate?.filters || [],
                  scan_depth: baseEntryTemplate?.scan_depth || 'same_as_global',
                  case_sensitive: baseEntryTemplate?.case_sensitive || 'same_as_global',
                  match_whole_words: baseEntryTemplate?.match_whole_words || 'same_as_global',
                  use_group_scoring: baseEntryTemplate?.use_group_scoring || 'same_as_global',
                  probability: baseEntryTemplate?.probability !== undefined ? baseEntryTemplate.probability : 100,
                  exclude_recursion: baseEntryTemplate?.exclude_recursion || false,
                  prevent_recursion: baseEntryTemplate?.prevent_recursion || false,
                  delay_until_recursion: baseEntryTemplate?.delay_until_recursion || false,
                  depth: (() => {
                    const position = (() => {
                      if (baseEntryKey === '本世历程') return this.worldbookSettings?.journey?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === '往世涟漪') return this.worldbookSettings?.pastLives?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === '小说模式') return this.worldbookSettings?.novel?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === '分段正文') return this.worldbookSettings?.segmented?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === '小总结') return this.worldbookSettings?.smallSummary?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === '大总结') return this.worldbookSettings?.largeSummary?.position || baseEntryTemplate?.position || 'before_character_definition';
                      return baseEntryTemplate?.position || 'before_character_definition';
                    })();
                    
                    if (position.startsWith('at_depth')) {
                      if (baseEntryKey === '本世历程') return this.worldbookSettings?.journey?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === '往世涟漪') return this.worldbookSettings?.pastLives?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === '小说模式') return this.worldbookSettings?.novel?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === '分段正文') return this.worldbookSettings?.segmented?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === '小总结') return this.worldbookSettings?.smallSummary?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === '大总结') return this.worldbookSettings?.largeSummary?.depth || baseEntryTemplate?.depth || 1;
                      return baseEntryTemplate?.depth || 1;
                    }
                    return null;
                  })(),
                  automation_id: baseEntryTemplate?.automation_id || null,
                  group: baseEntryTemplate?.group || '',
                  group_prioritized: baseEntryTemplate?.group_prioritized || false,
                  group_weight: baseEntryTemplate?.group_weight || 100,
                  sticky: baseEntryTemplate?.sticky || null,
                  cooldown: baseEntryTemplate?.cooldown || null,
                  delay: baseEntryTemplate?.delay || null
                };

                await TavernHelper.createLorebookEntries(bookName, [newEntryData]);
                if (!silent) this.showTemporaryMessage(`已成功创建并写入到“${finalEntryKey}”。`);
                
                if (this.isAutoToggleLorebookEnabled) {
                    this.updateAutoToggledEntries();
                }

              } else {
                // 4. 如果条目存在，则根据类型决定是追加还是覆盖
                let updatedContent;

                if (baseEntryKey === '小说模式') {
                    // 对于小说模式，检查重复后追加内容
                    const existingContent = targetEntry.content || '';
                    if (existingContent.includes(reformattedContent.trim())) {
                        if (!silent) this.showTemporaryMessage(`内容已存在，跳过写入。`);
                        console.log(`[归墟] 内容重复 (小说模式)，跳过写入: ${finalEntryKey}`);
                        if (button && !silent) {
                            button.textContent = '写入世界书';
                        }
                        return;
                    }
                    updatedContent = existingContent + (existingContent ? '\n\n' : '') + reformattedContent;
                    if (!silent) this.showTemporaryMessage(`已成功追加内容到“${finalEntryKey}”`);
                } else {
                    // 对于其他类型（如本世历程），检查重复后追加内容
                    const existingContent = targetEntry.content || '';

                    // 新增：基于序号的更可靠的重复检查，以解决修剪冲突
                    const getSeq = (text) => {
                        if (!text) return null;
                        // Match '序号|' at the very beginning of the block
                        const match = text.match(/^序号\|(\d+)/);
                        return match ? match[1] : null;
                    };

                    const newEventSeq = getSeq(reformattedContent.trim());
                    let isDuplicate = false;

                    if (newEventSeq && baseEntryKey === '本世历程') {
                        const existingSequences = (existingContent)
                            .split('\n\n') // Events are separated by double newlines
                            .map(block => getSeq(block.trim()))
                            .filter(seq => seq !== null);
                        
                        if (existingSequences.includes(newEventSeq)) {
                            isDuplicate = true;
                        }
                    } else {
                        // 如果新内容没有序号，或不是“本世历程”，则退回旧的基于内容的检查
                        isDuplicate = existingContent.includes(reformattedContent.trim());
                    }

                    if (isDuplicate) {
                        const message = newEventSeq ? `事件 (序号 ${newEventSeq}) 已存在` : '内容已存在';
                        if (!silent) this.showTemporaryMessage(`${message}，跳过写入。`);
                        console.log(`[归墟] 内容重复 (${message})，跳过写入: ${finalEntryKey}`);

                        if (baseEntryKey === '本世历程') this.lastWrittenJourney = this.lastExtractedJourney;
                        if (baseEntryKey === '往世涟漪') this.lastWrittenPastLives = this.lastExtractedPastLives;

                        if (button && !silent) {
                            button.textContent = '写入世界书';
                        }
                        return; // 提前退出函数
                    }

                    updatedContent = existingContent + (existingContent ? '\n\n' : '') + reformattedContent;
                    if (!silent) this.showTemporaryMessage(`已成功追加内容到“${finalEntryKey}”`);
                }
                
                // 在合并内容后、写入之前执行修剪
                if (baseEntryKey === '本世历程' && this.isAutoTrimEnabled) {
                    console.log('[归墟] 自动修剪已开启，正在处理合并后的内容...');
                    updatedContent = this._getTrimmedJourneyContent(updatedContent);
                }

                await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: updatedContent }]);
              }

              if (button && !silent) {
                button.textContent = '写入成功';
                setTimeout(() => { button.textContent = '写入世界书'; }, 2000);
              }

            } catch (error) {
              console.error(`写入世界书 "${finalEntryKey}" 时出错:`, error);
              if (!silent) {
                this.showTemporaryMessage(`写入失败: ${error.message}`);
                if (button) button.textContent = '写入失败';
              }
            } finally {
                if (button && !silent && button.textContent === '写入中...') {
                    button.textContent = '写入世界书';
                }
            }
          },

          async writeCharacterCardToLorebook() {
            const content = this.lastExtractedCharacterCard;
            if (!content) {
              this.showTemporaryMessage('没有可写入的角色内容。');
              return;
            }

            const button = document.getElementById('btn-write-character-card');
            if (button) button.textContent = '写入中...';

            try {
              const lines = content.trim().split('\n');
              const characterData = {};
              lines.forEach(line => {
                const parts = line.split('|');
                if (parts.length >= 2) {
                  const key = parts[0].trim();
                  const value = parts.slice(1).join('|').trim();
                  characterData[key] = value;
                }
              });

              const characterName = characterData['姓名'];
              if (!characterName) {
                throw new Error('无法从提取内容中找到角色“姓名”。');
              }

              const bookName = '1归墟';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const existingEntry = allEntries.find(entry => entry.comment === characterName);

              if (existingEntry) {
                this.showTemporaryMessage(`角色“${characterName}”已存在，请手动修改。`);
                if (button) button.textContent = '写入世界书';
                return;
              }

              await TavernHelper.createLorebookEntries(bookName, [
                {
                  comment: characterName,
                  keys: [characterName],
                  content: content.trim(),
                  enabled: true,
                },
              ]);

              this.showTemporaryMessage(`已成功创建角色“${characterName}”。`);
              if (button) button.textContent = '写入成功';
              setTimeout(() => {
                if (button) button.textContent = '写入世界书';
              }, 2000);
            } catch (error) {
              console.error('写入角色卡到世界书时出错:', error);
              this.showTemporaryMessage(`写入失败: ${error.message}`);
              if (button) button.textContent = '写入失败';
            }
          },

          async updateCurrentSceneLorebook(sceneContent) {
            // 增加健壮性检查，防止写入空内容
            if (!sceneContent || sceneContent.trim() === '') {
              console.warn('[归墟] 尝试向“当前场景”写入空内容，操作已取消。');
              return;
            }
            const bookName = '1归墟';
            const sceneKey = '当前场景';
            try {
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const sceneEntry = allEntries.find(entry => entry.comment === sceneKey);

              if (!sceneEntry) {
                console.warn(
                  `[归墟] 未找到世界书条目 "${sceneKey}"，无法更新场景正文。请在'${bookName}'世界书中创建它。`,
                );
                // 如果条目不存在，我们可以选择创建一个
                await TavernHelper.createLorebookEntries(bookName, [
                  {
                    comment: sceneKey,
                    content: sceneContent,
                    keys: [],
                  },
                ]);
                console.log(`[归墟] 已创建并更新 "${sceneKey}" 内容。`);
                return;
              }

              // 使用覆盖式更新
              await TavernHelper.setLorebookEntries(bookName, [{ uid: sceneEntry.uid, content: sceneContent }]);
              console.log(`[归墟] 成功更新 "${sceneKey}" 内容。`);
            } catch (error) {
              console.error(`[归墟] 更新 "${sceneKey}" 时出错:`, error);
            }
          },

          async loadAndDisplayCurrentScene(messageContent = null) {
            const gameTextDisplay = document.getElementById('game-text-display');
            if (!gameTextDisplay) return;

            try {
              let contentToParse = messageContent;

              // 如果没有直接提供内容，则从聊天记录中获取
              if (contentToParse === null) {
                const messages = await getChatMessages(getCurrentMessageId());
                if (!messages || messages.length === 0) return;
                const lastAiMessage = [...messages].reverse().find(m => m.role === 'assistant');
                if (lastAiMessage) {
                  contentToParse = lastAiMessage.message;
                }
              }

              if (contentToParse) {
                // 1. 更新主界面正文 (使用新的健壮的提取函数)
                const displayText = this._getDisplayText(contentToParse);
                const finalHTML = this.formatMessageContent(displayText);
                gameTextDisplay.innerHTML = finalHTML;
                this.updateLiveWordCount(); // 新增：调用字数统计函数
                console.groupEnd();
                // 2. 同步提取所有标签内容到变量，用于“查看提取内容”模态框
                this.lastExtractedNovelText = this._extractLastTagContent('gametxt', contentToParse);
                this.lastExtractedJourney = this._extractLastTagContent('本世历程', contentToParse);
                this.lastExtractedPastLives = this._extractLastTagContent('往世涟漪', contentToParse);
                this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', contentToParse, true);
                this.lastExtractedCharacterCard = this._extractLastTagContent('角色提取', contentToParse);
                this.updateVariableChangesReminder();// 更新变量改变提醒
                // 3. 新增：提取并渲染行动选项
                let actionOptionsContent = this._extractLastTagContent('行动选项', contentToParse);
                if (!actionOptionsContent) {
                   actionOptionsContent = this._extractLastTagContent('action', contentToParse);
                }
                this.renderActionOptions(actionOptionsContent);
              }
            } catch (error) {
              console.error(`[归墟] 加载并显示当前场景时出错:`, error);
              gameTextDisplay.innerHTML = `<gametxt>加载场景时出错。</gametxt>`;
              this.updateLiveWordCount(); // 新增：调用字数统计函数
            }
          },



// ===行动选项渲染模块开始===



          // 行动选项渲染函数
          renderActionOptions(content) {
            const container = document.getElementById('action-options-container');
            if (!container) return;

            container.innerHTML = ''; // 清空旧选项

            const hasContent = content && typeof content === 'string' && content.trim() !== '';

            // 如果开关关闭或没有有效内容，则隐藏容器并返回
            if (!this.isActionOptionsEnabled || !hasContent) {
                container.style.display = 'none';
                return;
            }

            // 有内容则显示容器
            container.style.display = 'block';

            const lines = content.trim().split('\n');
            lines.forEach(line => {
                line = line.trim();
                const match = line.match(/^(?:\d+\.\s*)?(.+)/);
                if (match) {
                    const optionText = match[1].trim();
                    if (optionText) {
                        const btn = document.createElement('button');
                        btn.className = 'action-option-btn';
                        btn.textContent = optionText;
                        btn.dataset.actionText = optionText; // 将选项文本存入data属性
                        btn.style.display = 'block';
                        btn.style.width = '100%';
                        container.appendChild(btn);
                    }
                }
            });
            // 如果解析后没有生成任何按钮，也隐藏容器
            if (container.childElementCount === 0) {
                container.style.display = 'none';
            }
          },



// ===行动选项渲染模块开始===




// ===自动写入世界书模块开始===
// 根据序号x，写入相关序号的本世历程、往世涟漪、小说模式（x）世界书

          // 状态保存与自动写入逻辑
          saveAutoWriteState(state) {
            try {
              localStorage.setItem('guixu_auto_write_enabled', state);
            } catch (e) {
              console.error('保存自动写入状态失败:', e);
            }
          },

          loadAutoWriteState() {
            try {
              const savedState = localStorage.getItem('guixu_auto_write_enabled');
              // 如果localStorage中没有保存过状态，则默认为true (开启)
              this.isAutoWriteEnabled = savedState === null ? true : savedState === 'true';
              const checkbox = document.getElementById('auto-write-checkbox');
              if (checkbox) {
                checkbox.checked = this.isAutoWriteEnabled;
              }
              // 根据加载的状态决定是否启动轮询
              if (this.isAutoWriteEnabled) {
                this.startAutoWritePolling();
              }
            } catch (e) {
              console.error('加载自动写入状态失败:', e);
              this.isAutoWriteEnabled = false;
            }
          },
          saveNovelModeState(state) {
            try {
              localStorage.setItem('guixu_novel_mode_enabled', state);
            } catch (e) {
              console.error('保存小说模式状态失败:', e);
            }
          },

          loadNovelModeState() {
            try {
              const savedState = localStorage.getItem('guixu_novel_mode_enabled');
              this.isNovelModeEnabled = savedState === 'true';
              const checkbox = document.getElementById('novel-mode-enabled-checkbox');
              if (checkbox) {
                checkbox.checked = this.isNovelModeEnabled;
              }
              // 根据加载的状态决定是否启动小说模式的轮询
              if (this.isNovelModeEnabled) {
                this.startNovelModeAutoWritePolling();
              }
            } catch (e) {
              console.error('加载小说模式状态失败:', e);
              this.isNovelModeEnabled = false;
            }
          },

// 【本世历程、往世涟漪写入】

          startAutoWritePolling() {
            this.stopAutoWritePolling();
            console.log('[归墟] 启动自动写入轮询 (setTimeout模式)...');
            const poll = async () => {
                if (!this.isAutoWriteEnabled) return;
                if (this.lastExtractedJourney && this.lastExtractedJourney !== this.lastWrittenJourney) {
                    await this.writeJourneyToLorebook(true);
                    this.lastWrittenJourney = this.lastExtractedJourney;//标记已经写入
                }
                if (this.lastExtractedPastLives && this.lastExtractedPastLives !== this.lastWrittenPastLives) {
                    await this.writePastLivesToLorebook(true);
                    this.lastWrittenPastLives = this.lastExtractedPastLives; //标记已经写入
                }
                if (this.isAutoWriteEnabled) {
                    this.autoWriteIntervalId = setTimeout(poll, 2000);
                }
            };
            this.autoWriteIntervalId = setTimeout(poll, 2000);
          },        
// 【小说模式写入】
          startNovelModeAutoWritePolling() {
            this.stopNovelModeAutoWritePolling();
            console.log('[归墟] 启动小说模式自动写入轮询 (setTimeout模式)...');
            const poll = async () => {
                if (!this.isNovelModeEnabled) return;

                // Check for new Novel Mode content
                if (this.lastExtractedNovelText && this.lastExtractedNovelText !== this.lastWrittenNovelText) {
                    await this.writeNovelModeToLorebook(true);
                    this.lastWrittenNovelText = this.lastExtractedNovelText; //标记已经写入
                }

                if (this.isNovelModeEnabled) {
                    this.novelModeAutoWriteIntervalId = setTimeout(poll, 2000);
                }
            };
            this.novelModeAutoWriteIntervalId = setTimeout(poll, 2000);
          },

// 停止轮询写入

          stopNovelModeAutoWritePolling() {
            if (this.novelModeAutoWriteIntervalId) {
              clearTimeout(this.novelModeAutoWriteIntervalId); 
              this.novelModeAutoWriteIntervalId = null;
            }
          },

          stopAutoWritePolling() {
            if (this.autoWriteIntervalId) {
              clearTimeout(this.autoWriteIntervalId); 
              this.autoWriteIntervalId = null;
            }
          },


          savePendingActions() {
            try {
              localStorage.setItem('guixu_pending_actions', JSON.stringify(this.pendingActions));
            } catch (e) {
              console.error('保存指令队列状态失败:', e);
            }
          },

          loadPendingActions() {
            try {
              const savedActions = localStorage.getItem('guixu_pending_actions');
              if (savedActions) {
                this.pendingActions = JSON.parse(savedActions) || [];
              }
            } catch (e) {
              console.error('加载指令队列状态失败:', e);
              this.pendingActions = [];
              localStorage.removeItem('guixu_pending_actions');
            }
          },
 
// 统一读写序号存取

          saveUnifiedIndex() {
            try {
              localStorage.setItem('guixu_unified_index', this.unifiedIndex);
            } catch (e) {
              console.error('保存统一读写序号失败:', e);
            }
          },
 
          loadUnifiedIndex() {
            try {
              const savedIndex = localStorage.getItem('guixu_unified_index');
              if (savedIndex) {
                this.unifiedIndex = parseInt(savedIndex, 10) || 1;
              }
              const input = document.getElementById('unified-index-input');
              if (input) {
                input.value = this.unifiedIndex;
              }
            } catch (e) {
              console.error('加载统一读写序号失败:', e);
              this.unifiedIndex = 1; // 出错时重置为1
            }
          },

          loadNovelModeIndex() {
           try {
             const savedIndex = localStorage.getItem('guixu_novel_mode_index');
             if (savedIndex) {
               this.novelModeIndex = parseInt(savedIndex, 10) || 1;
             }
             const input = document.getElementById('novel-mode-index-input');
             if (input) {
               input.value = this.novelModeIndex;
             }
           } catch (e) {
             console.error('加载小说模式读写序号失败:', e);
             this.novelModeIndex = 1; // 出错时重置为1
           }
          },
// ===自动写入世界书模块开始===


// ===核心格式提取、处理、解析模块结束===



// ===小说模式模块开始===
          // --- 新增：小说模式章节和书签功能 ---
          novelChapters: [], // 存储解析出的章节信息
          novelBookmarks: [], // 存储书签信息
          currentChapterIndex: 0, // 当前章节索引
          novelDisplayMode: 'single', // 显示模式：single(单章节) 或 continuous(连贯显示)
          novelBackgroundEnabled: false, // 小说模式背景图开关
          novelBackgroundOpacity: 0.3, // 小说模式背景透明度
          novelBackgroundImage: '', // 小说模式背景图片URL

          // 解析小说内容中的章节
          parseNovelChapters(content) {
            if (!content) return [];
            
            const chapters = [];
            const lines = content.split('\n');
            let currentChapter = null;
            let chapterContent = [];
            let lineIndex = 0;

            for (const line of lines) {
              // 匹配章节标题：第x章 或 第x回 等格式
              const chapterMatch = line.match(/^\s*(第\s*[零一二三四五六七八九十百千万\d]+\s*[章回节部卷篇].*?)$/);
              
              if (chapterMatch) {
                // 保存上一章节
                if (currentChapter) {
                  currentChapter.content = chapterContent.join('\n');
                  currentChapter.endLine = lineIndex - 1;
                  chapters.push(currentChapter);
                }
                
                // 开始新章节
                currentChapter = {
                  title: chapterMatch[1].trim(),
                  startLine: lineIndex,
                  endLine: -1,
                  content: ''
                };
                chapterContent = [line];
              } else if (currentChapter) {
                chapterContent.push(line);
              } else {
                // 没有章节标题的内容，归入"序章"
                if (chapters.length === 0) {
                  chapters.push({
                    title: '序章',
                    startLine: 0,
                    endLine: -1,
                    content: ''
                  });
                  currentChapter = chapters[0];
                  chapterContent = [];
                }
                chapterContent.push(line);
              }
              lineIndex++;
            }

            // 保存最后一章
            if (currentChapter) {
              currentChapter.content = chapterContent.join('\n');
              currentChapter.endLine = lineIndex - 1;
              if (!chapters.includes(currentChapter)) {
                chapters.push(currentChapter);
              }
            }

            return chapters;
          },

          // 保存书签
          saveNovelBookmarks() {
            try {
              const key = `guixu_novel_bookmarks_${this.unifiedIndex}`;
              localStorage.setItem(key, JSON.stringify(this.novelBookmarks));
            } catch (e) {
              console.error('保存小说书签失败:', e);
            }
          },

          // 加载书签
          loadNovelBookmarks() {
            try {
              const key = `guixu_novel_bookmarks_${this.unifiedIndex}`;
              const saved = localStorage.getItem(key);
              this.novelBookmarks = saved ? JSON.parse(saved) : [];
            } catch (e) {
              console.error('加载小说书签失败:', e);
              this.novelBookmarks = [];
            }
          },

          // 添加书签
          addNovelBookmark() {
            const chapterSelect = document.getElementById('chapter-select');
            const currentChapter = chapterSelect.value;
            
            if (!currentChapter) {
              this.showTemporaryMessage('请先选择一个章节', 'error');
              return;
            }

            const chapterTitle = chapterSelect.options[chapterSelect.selectedIndex].text;
            const timestamp = new Date().toLocaleString('zh-CN');
            
            const bookmark = {
              id: Date.now(),
              chapterIndex: parseInt(currentChapter),
              chapterTitle: chapterTitle,
              timestamp: timestamp,
              note: `${chapterTitle} - ${timestamp}`
            };

            // 检查是否已存在相同章节的书签
            const existingIndex = this.novelBookmarks.findIndex(b => b.chapterIndex === bookmark.chapterIndex);
            if (existingIndex >= 0) {
              this.novelBookmarks[existingIndex] = bookmark;
              this.showTemporaryMessage('书签已更新');
            } else {
              this.novelBookmarks.push(bookmark);
              this.showTemporaryMessage('书签已添加');
            }

            this.saveNovelBookmarks();
            this.updateBookmarkSelect();
          },

          // 更新书签选择器
          updateBookmarkSelect() {
            const select = document.getElementById('bookmark-select');
            if (!select) return;

            select.innerHTML = '<option value="">选择书签...</option>';
            
            this.novelBookmarks.forEach(bookmark => {
              const option = document.createElement('option');
              option.value = bookmark.chapterIndex;
              option.textContent = bookmark.note;
              select.appendChild(option);
            });
          },

          // 跳转到书签
          gotoBookmark() {
            const bookmarkSelect = document.getElementById('bookmark-select');
            const chapterIndex = parseInt(bookmarkSelect.value);
            
            if (isNaN(chapterIndex)) {
              this.showTemporaryMessage('请选择一个书签', 'error');
              return;
            }

            this.showNovelChapter(chapterIndex);
            this.showTemporaryMessage('已跳转到书签位置');
          },

          // 删除书签
          deleteBookmark() {
            const bookmarkSelect = document.getElementById('bookmark-select');
            const chapterIndex = parseInt(bookmarkSelect.value);
            
            if (isNaN(chapterIndex)) {
              this.showTemporaryMessage('请选择要删除的书签', 'error');
              return;
            }

            const bookmarkIndex = this.novelBookmarks.findIndex(b => b.chapterIndex === chapterIndex);
            if (bookmarkIndex >= 0) {
              this.novelBookmarks.splice(bookmarkIndex, 1);
              this.saveNovelBookmarks();
              this.updateBookmarkSelect();
              this.showTemporaryMessage('书签已删除');
            }
          },

          // 显示指定章节
          showNovelChapter(chapterIndex) {
            if (!this.novelChapters || chapterIndex >= this.novelChapters.length) return;

            const chapter = this.novelChapters[chapterIndex];
            const body = document.getElementById('novel-mode-modal-body');
            
            if (body && chapter) {
              // 使用格式化内容显示章节
              const formattedContent = this.formatMessageContent(chapter.content);
              
              // 创建章节内容容器
              const chapterContainer = document.createElement('div');
              chapterContainer.className = 'single-chapter-container';
              chapterContainer.style.cssText = 'position: relative; min-height: 100%;';
              
              // 添加章节内容
              chapterContainer.innerHTML = `
                <div class="game-text-container" style="white-space: pre-wrap; padding: 10px; padding-bottom: 80px;">
                  ${formattedContent}
                </div>
              `;
              
              // 添加底部导航（仅在单章节模式下）
              if (this.novelDisplayMode === 'single' && this.novelChapters.length > 1) {
                const bottomNav = this.createBottomChapterNav(chapterIndex);
                chapterContainer.appendChild(bottomNav);
              }
              
              body.innerHTML = '';
              body.appendChild(chapterContainer);
              
              // 更新章节选择器
              const chapterSelect = document.getElementById('chapter-select');
              if (chapterSelect) {
                chapterSelect.value = chapterIndex;
              }
              
              this.currentChapterIndex = chapterIndex;
              this.updateChapterNavButtons();
            }
          },

          // 创建底部章节导航
          createBottomChapterNav(currentIndex) {
            const nav = document.createElement('div');
            nav.className = 'bottom-chapter-nav';
            nav.style.cssText = `
              position: absolute;
              bottom: 0;
              left: 0;
              right: 0;
              background: rgba(15, 15, 35, 0.7);
              backdrop-filter: blur(5px);
              border-top: 1px solid rgba(139, 115, 85, 0.3);
              padding: 10px 20px;
              display: flex;
              justify-content: space-between;
              align-items: center;
              opacity: 0.8;
              transition: opacity 0.3s ease;
            `;
            
            // 鼠标悬停时增加不透明度
            nav.addEventListener('mouseenter', () => {
              nav.style.opacity = '1';
            });
            nav.addEventListener('mouseleave', () => {
              nav.style.opacity = '0.8';
            });
            
            // 上一章按钮
            const prevBtn = document.createElement('button');
            prevBtn.innerHTML = '← 上一章';
            prevBtn.style.cssText = `
              background: rgba(139, 115, 85, 0.8);
              color: #c9aa71;
              border: none;
              padding: 8px 16px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
              transition: background 0.3s ease;
            `;
            
            if (currentIndex <= 0) {
              prevBtn.disabled = true;
              prevBtn.style.opacity = '0.5';
              prevBtn.style.cursor = 'not-allowed';
            } else {
              prevBtn.addEventListener('click', () => this.prevChapter());
              prevBtn.addEventListener('mouseenter', () => {
                prevBtn.style.background = 'rgba(139, 115, 85, 1)';
              });
              prevBtn.addEventListener('mouseleave', () => {
                prevBtn.style.background = 'rgba(139, 115, 85, 0.8)';
              });
            }
            
            // 章节信息
            const chapterInfo = document.createElement('span');
            chapterInfo.textContent = `${currentIndex + 1} / ${this.novelChapters.length}`;
            chapterInfo.style.cssText = `
              color: #8b7355;
              font-size: 11px;
              user-select: none;
            `;
            
            // 下一章按钮
            const nextBtn = document.createElement('button');
            nextBtn.innerHTML = '下一章 →';
            nextBtn.style.cssText = `
              background: rgba(139, 115, 85, 0.8);
              color: #c9aa71;
              border: none;
              padding: 8px 16px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
              transition: background 0.3s ease;
            `;
            
            if (currentIndex >= this.novelChapters.length - 1) {
              nextBtn.disabled = true;
              nextBtn.style.opacity = '0.5';
              nextBtn.style.cursor = 'not-allowed';
            } else {
              nextBtn.addEventListener('click', () => this.nextChapter());
              nextBtn.addEventListener('mouseenter', () => {
                nextBtn.style.background = 'rgba(139, 115, 85, 1)';
              });
              nextBtn.addEventListener('mouseleave', () => {
                nextBtn.style.background = 'rgba(139, 115, 85, 0.8)';
              });
            }
            
            nav.appendChild(prevBtn);
            nav.appendChild(chapterInfo);
            nav.appendChild(nextBtn);
            
            return nav;
          },

          // 更新章节导航按钮状态
          updateChapterNavButtons() {
            const prevBtn = document.getElementById('prev-chapter-btn');
            const nextBtn = document.getElementById('next-chapter-btn');
            
            if (prevBtn) {
              prevBtn.disabled = this.currentChapterIndex <= 0;
              prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
            }
            
            if (nextBtn) {
              nextBtn.disabled = this.currentChapterIndex >= this.novelChapters.length - 1;
              nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';
            }
          },

          // 上一章
          prevChapter() {
            if (this.currentChapterIndex > 0) {
              this.showNovelChapter(this.currentChapterIndex - 1);
            }
          },

          // 下一章
          nextChapter() {
            if (this.currentChapterIndex < this.novelChapters.length - 1) {
              this.showNovelChapter(this.currentChapterIndex + 1);
            }
          },

          // 切换显示模式
          switchNovelDisplayMode(mode) {
            this.novelDisplayMode = mode;
            this.saveNovelDisplayMode();
            
            // 更新导航控件的显示状态
            this.updateNovelNavControls(mode);
            
            if (mode === 'continuous') {
              this.showAllChaptersContinuous();
            } else {
              this.showNovelChapter(this.currentChapterIndex);
            }
          },

          // 更新小说导航控件状态
          updateNovelNavControls(mode) {
            const chapterSelect = document.getElementById('chapter-select');
            const prevBtn = document.getElementById('prev-chapter-btn');
            const nextBtn = document.getElementById('next-chapter-btn');
            
            if (mode === 'continuous') {
              // 连贯模式：禁用章节导航控件
              if (chapterSelect) chapterSelect.disabled = true;
              if (prevBtn) {
                prevBtn.disabled = true;
                prevBtn.style.opacity = '0.5';
              }
              if (nextBtn) {
                nextBtn.disabled = true;
                nextBtn.style.opacity = '0.5';
              }
            } else {
              // 单章节模式：启用章节导航控件
              if (chapterSelect) chapterSelect.disabled = false;
              this.updateChapterNavButtons(); // 根据当前章节更新按钮状态
            }
          },

          // 连贯显示所有章节
          showAllChaptersContinuous() {
            const body = document.getElementById('novel-mode-modal-body');
            if (!body || !this.novelChapters.length) return;

            let allContent = '';
            this.novelChapters.forEach((chapter, index) => {
              // 添加章节标题锚点，用于书签跳转
              allContent += `<div id="chapter-anchor-${index}" class="chapter-section">`;
              
              // 在连贯模式下始终显示章节标题（除了序章）
              if (chapter.title && chapter.title !== '序章') {
                allContent += `<h3 class="novel-chapter-title" style="
                  margin-top: ${index > 0 ? '3em' : '1em'};
                  margin-bottom: 1em;
                  border-bottom: 2px solid #8b7355;
                  padding-bottom: 0.8em;
                  color: #c9aa71;
                  font-weight: bold;
                  font-size: 18px;
                  text-align: center;
                  position: relative;
                ">${chapter.title}</h3>`;
              } else if (chapter.title === '序章') {
                // 序章也显示标题，但样式稍有不同
                allContent += `<h3 class="novel-chapter-title" style="
                  margin-top: ${index > 0 ? '2em' : '0.5em'};
                  margin-bottom: 1em;
                  border-bottom: 1px solid #8b7355;
                  padding-bottom: 0.5em;
                  color: #a0926d;
                  font-weight: normal;
                  font-size: 16px;
                  text-align: center;
                  font-style: italic;
                ">${chapter.title}</h3>`;
              }
              
              // 检查内容第一行是否重复了标题
              const contentLines = chapter.content.split('\n');
              const firstLine = contentLines[0]?.trim();
              const hasTitle = firstLine && chapter.title && firstLine.includes(chapter.title);
              
              // 如果内容第一行重复了标题，则跳过第一行
              const contentToShow = hasTitle ? contentLines.slice(1).join('\n') : chapter.content;
              
              // 添加章节内容，并在章节间增加适当间距
              allContent += `<div class="chapter-content" style="
                line-height: 1.8;
                margin-bottom: ${index < this.novelChapters.length - 1 ? '4em' : '2em'};
                text-indent: 2em;
              ">`;
              allContent += this.formatMessageContent(contentToShow);
              allContent += '</div>';
              allContent += '</div>';
            });

            body.innerHTML = `<div class="game-text-container continuous-reading" style="
              white-space: pre-wrap;
              padding: 20px;
              max-width: 800px;
              margin: 0 auto;
              font-size: 14px;
              line-height: 1.6;
            ">${allContent}</div>`;
            
            // 更新导航控件状态
            this.updateNovelNavControls('continuous');
          },

          // 保存显示模式
          saveNovelDisplayMode() {
            try {
              localStorage.setItem('guixu_novel_display_mode', this.novelDisplayMode);
            } catch (e) {
              console.error('保存小说显示模式失败:', e);
            }
          },

          // 加载显示模式
          loadNovelDisplayMode() {
            try {
              const saved = localStorage.getItem('guixu_novel_display_mode');
              this.novelDisplayMode = saved || 'single';
              
              // 更新UI
              const radios = document.querySelectorAll('input[name="novel-display-mode"]');
              radios.forEach(radio => {
                radio.checked = radio.value === this.novelDisplayMode;
              });
            } catch (e) {
              console.error('加载小说显示模式失败:', e);
              this.novelDisplayMode = 'single';
            }
          },

          // 小说模式背景设置
          async showNovelBackgroundSettings() {
            console.log('[归墟小说背景] 打开背景设置面板 - 使用通用图库组件');
            
            // 先加载当前设置
            this.loadNovelBackgroundSettings();
            
            // 使用通用图库组件
            await this.showUnifiedGalleryPicker({
              title: '小说模式背景设置',
              mode: 'novel',
              allowEmpty: true,
              enablePagination: true,
              pageSize: 20,
              enableSourceSwitch: true,
              enableLazyLoad: true,
              extraControlsHtml: `
                <!-- 背景开关 -->
                <div style="padding: 10px; border-bottom: 1px solid rgba(201, 170, 113, 0.3);">
                  <label style="display: flex; align-items: center; gap: 8px; color: #c9aa71; font-size: 14px;">
                    <input type="checkbox" id="novel-bg-enabled" ${this.novelBackgroundEnabled ? 'checked' : ''}>
                    启用小说模式背景图
                  </label>
                </div>
                
                <!-- 透明度设置 -->
                <div style="padding: 10px; border-bottom: 1px solid rgba(201, 170, 113, 0.3);">
                  <label style="color: #c9aa71; font-size: 12px; display: block; margin-bottom: 5px;">
                    背景透明度: <span id="novel-bg-opacity-value">${this.novelBackgroundOpacity || 0.3}</span>
                  </label>
                  <input type="range" id="novel-bg-opacity" min="0.0" max="1.0" step="0.05" value="${this.novelBackgroundOpacity || 0.3}"
                         style="width: 100%; accent-color: #8b7355;">
                </div>
              `,
              onSelect: (imageData) => {
                console.log('[归墟小说背景] 选择背景:', imageData);
                
                // 处理选择的图片
                if (imageData.source === 'empty') {
                  this.novelBackgroundImage = '';
                  console.log('[归墟小说背景] 选择了无背景');
                } else {
                  this.novelBackgroundImage = imageData.dataUrl;
                  console.log('[归墟小说背景] 选择了背景图:', imageData.name);
                }
                
                // 保存设置并应用背景
                this.saveNovelBackgroundSettings();
                this.applyNovelBackground();
                
                // 显示选择反馈
                this.showTemporaryMessage(`已选择背景: ${imageData.source === 'empty' ? '无背景' : imageData.name}`);
                console.log('[归墟小说背景] 背景选择完成并已实时应用');
              },
              onClose: () => {
                console.log('[归墟小说背景] 关闭背景设置面板');
              }
            });
            
            // 绑定额外控件的事件（在模态框创建后）
            setTimeout(() => {
              const enabledCheckbox = document.getElementById('novel-bg-enabled');
              const opacitySlider = document.getElementById('novel-bg-opacity');
              const opacityValue = document.getElementById('novel-bg-opacity-value');
              
              // 实时响应：背景开关切换事件
              enabledCheckbox?.addEventListener('change', (e) => {
                this.novelBackgroundEnabled = e.target.checked;
                this.saveNovelBackgroundSettings();
                this.applyNovelBackground();
                console.log('[归墟小说背景] 实时切换背景开关:', this.novelBackgroundEnabled);
              });

              // 实时响应：透明度滑块事件
              opacitySlider?.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                opacityValue.textContent = value.toFixed(2);
                this.novelBackgroundOpacity = value;
                this.saveNovelBackgroundSettings();
                this.applyNovelBackground();
                console.log('[归墟小说背景] 实时调整透明度:', value);
              });
            }, 100);
          },

          // 加载小说模式背景图网格
          loadNovelBackgroundGrid() {
            const grid = document.getElementById('novel-bg-grid');
            if (!grid) return;

            // 先加载背景图数据
            this.loadBackgroundSettings();

            // 清空网格
            grid.innerHTML = '';

            // 添加"无背景"选项
            const noneOption = document.createElement('div');
            noneOption.className = 'novel-bg-option';
            noneOption.dataset.bgId = '';
            noneOption.style.cssText = `
              width: 100%;
              height: 80px;
              border: 2px solid ${this.novelBackgroundImage === '' ? '#c9aa71' : '#8b7355'};
              border-radius: 4px;
              display: flex;
              align-items: center;
              justify-content: center;
              cursor: pointer;
              background: rgba(26, 26, 46, 0.8);
              color: #8b7355;
              font-size: 11px;
              transition: border-color 0.3s ease;
            `;
            noneOption.textContent = '无背景';
            noneOption.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              this.selectNovelBackground('');
            });
            grid.appendChild(noneOption);

            // 添加现有背景图
            if (this.backgroundImages && this.backgroundImages.length > 0) {
              this.backgroundImages.forEach(bg => {
                const option = document.createElement('div');
                option.className = 'novel-bg-option';
                option.dataset.bgId = bg.id;
                option.dataset.bgUrl = bg.dataUrl || bg.url;
                option.style.cssText = `
                  width: 100%;
                  height: 80px;
                  border: 2px solid ${this.novelBackgroundImage === (bg.dataUrl || bg.url) ? '#c9aa71' : '#8b7355'};
                  border-radius: 4px;
                  background-image: url("${bg.dataUrl || bg.url}");
                  background-size: cover;
                  background-position: center;
                  cursor: pointer;
                  position: relative;
                  transition: border-color 0.3s ease;
                `;
                
                // 添加标题覆盖层
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                  position: absolute;
                  bottom: 0;
                  left: 0;
                  right: 0;
                  background: rgba(0, 0, 0, 0.7);
                  color: #fff;
                  font-size: 10px;
                  padding: 2px 4px;
                  text-align: center;
                  border-radius: 0 0 2px 2px;
                  pointer-events: none;
                `;
                overlay.textContent = bg.name || `背景 ${bg.id}`;
                option.appendChild(overlay);
                
                option.addEventListener('click', (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  this.selectNovelBackground(bg.dataUrl || bg.url);
                });
                grid.appendChild(option);
              });
            }

            // 如果没有背景图，显示提示
            if (!this.backgroundImages || this.backgroundImages.length === 0) {
              const emptyTip = document.createElement('div');
              emptyTip.style.cssText = `
                grid-column: 1 / -1;
                text-align: center;
                color: #8b7355;
                font-size: 12px;
                padding: 20px;
              `;
              emptyTip.textContent = '暂无可用背景图，请先在背景设置中添加背景图';
              grid.appendChild(emptyTip);
            }
          },

          // 选择小说背景
          selectNovelBackground(bgUrl) {
            console.log('[归墟小说背景] 选择背景:', bgUrl);
            this.novelBackgroundImage = bgUrl;
            
            // 更新选中状态
            const options = document.querySelectorAll('.novel-bg-option');
            options.forEach(option => {
              const isSelected = (bgUrl === '' && option.dataset.bgId === '') ||
                               (bgUrl !== '' && option.dataset.bgUrl === bgUrl);
              option.style.borderColor = isSelected ? '#c9aa71' : '#8b7355';
              option.style.boxShadow = isSelected ? '0 0 10px rgba(201, 170, 113, 0.5)' : '';
            });
            
            // 实时响应：立即保存设置并应用背景
            this.saveNovelBackgroundSettings();
            this.applyNovelBackground();
            
            // 显示选择反馈
            this.showTemporaryMessage(`已选择背景: ${bgUrl === '' ? '无背景' : '背景图'}`);
            console.log('[归墟小说背景] 背景选择完成并已实时应用');
          },

          // 绑定小说背景面板事件
          bindNovelBackgroundPanelEvents(panel) {
            const enabledCheckbox = panel.querySelector('#novel-bg-enabled');
            const opacitySlider = panel.querySelector('#novel-bg-opacity');
            const opacityValue = panel.querySelector('#novel-bg-opacity-value');
            const cancelBtn = panel.querySelector('#novel-bg-cancel');

            // 实时响应：背景开关切换事件
            enabledCheckbox?.addEventListener('change', (e) => {
              this.novelBackgroundEnabled = e.target.checked;
              this.saveNovelBackgroundSettings();
              this.applyNovelBackground();
              console.log('[归墟小说背景] 实时切换背景开关:', this.novelBackgroundEnabled);
            });

            // 实时响应：透明度滑块事件
            opacitySlider?.addEventListener('input', (e) => {
              const value = parseFloat(e.target.value);
              opacityValue.textContent = value.toFixed(2);
              this.novelBackgroundOpacity = value;
              this.saveNovelBackgroundSettings();
              this.applyNovelBackground();
              console.log('[归墟小说背景] 实时调整透明度:', value);
            });

            // 关闭按钮
            cancelBtn?.addEventListener('click', () => {
              panel.remove();
            });
          },

          // 加载小说模式背景选项
          loadNovelBackgroundOptions() {
            try {
              const settings = JSON.parse(localStorage.getItem('guixu_background_settings') || '{}');
              const novelSettings = JSON.parse(localStorage.getItem('guixu_novel_background_settings') || '{}');
              const select = document.getElementById('novel-bg-select');
              if (!select) return;

              // 清空现有选项（保留默认选项）
              const defaultOptions = select.querySelectorAll('option[value=""], option[value="random"]');
              select.innerHTML = '';
              defaultOptions.forEach(option => select.appendChild(option));

              // 添加可用背景图
              if (settings.backgrounds && settings.backgrounds.length > 0) {
                settings.backgrounds.forEach((bg, index) => {
                  const option = document.createElement('option');
                  option.value = bg;
                  option.textContent = `背景图 ${index + 1}`;
                  select.appendChild(option);
                });
              }

              // 设置当前选中的背景
              if (novelSettings.image) {
                select.value = novelSettings.image;
              }
            } catch (e) {
              console.error('加载背景选项失败:', e);
            }
          },

          // 绑定小说背景设置事件
          bindNovelBackgroundEvents(panel) {
            const enabledCheckbox = panel.querySelector('#novel-bg-enabled');
            const opacitySlider = panel.querySelector('#novel-bg-opacity');
            const opacityValue = panel.querySelector('#novel-bg-opacity-value');
            const bgSelect = panel.querySelector('#novel-bg-select');
            const preview = panel.querySelector('#novel-bg-preview');
            const applyBtn = panel.querySelector('#novel-bg-apply');
            const cancelBtn = panel.querySelector('#novel-bg-cancel');

            // 透明度滑块事件
            opacitySlider?.addEventListener('input', (e) => {
              const value = parseFloat(e.target.value);
              opacityValue.textContent = value;
              this.updateNovelBackgroundPreview(preview, bgSelect.value, value);
            });

            // 背景选择事件
            bgSelect?.addEventListener('change', (e) => {
              this.updateNovelBackgroundPreview(preview, e.target.value, parseFloat(opacitySlider.value));
            });

            // 应用按钮
            applyBtn?.addEventListener('click', () => {
              this.novelBackgroundEnabled = enabledCheckbox.checked;
              this.novelBackgroundOpacity = parseFloat(opacitySlider.value);
              this.novelBackgroundImage = bgSelect.value;
              
              this.saveNovelBackgroundSettings();
              this.applyNovelBackground();
              
              panel.remove();
              this.showTemporaryMessage('小说背景设置已应用');
            });

            // 取消按钮
            cancelBtn?.addEventListener('click', () => {
              panel.remove();
            });

            // 初始预览
            this.updateNovelBackgroundPreview(preview, bgSelect.value, parseFloat(opacitySlider.value));
          },

          // 更新背景预览
          updateNovelBackgroundPreview(preview, bgValue, opacity) {
            if (!preview) return;

            if (!bgValue || bgValue === '') {
              preview.style.backgroundImage = '';
              preview.textContent = '无背景';
              return;
            }

            if (bgValue === 'random') {
              preview.style.backgroundImage = '';
              preview.textContent = '随机背景（应用时随机选择）';
              return;
            }

            preview.style.backgroundImage = `url(${bgValue})`;
            preview.style.opacity = opacity;
            preview.textContent = '';
          },

          // 应用小说模式背景
          applyNovelBackground() {
            const novelModal = document.getElementById('novel-mode-modal');
            if (!novelModal) return;

            console.log('[归墟小说背景] 应用背景设置:', {
              enabled: this.novelBackgroundEnabled,
              image: this.novelBackgroundImage,
              opacity: this.novelBackgroundOpacity
            });

            if (this.novelBackgroundEnabled && this.novelBackgroundImage) {
              // 应用背景图到模态框
              novelModal.style.backgroundImage = `url(${this.novelBackgroundImage})`;
              novelModal.style.backgroundSize = 'cover';
              novelModal.style.backgroundPosition = 'center';
              novelModal.style.backgroundRepeat = 'no-repeat';
              novelModal.style.backgroundAttachment = 'fixed';
              const opacity = this.novelBackgroundOpacity || 0.3;
              const modalContent = novelModal.querySelector('.modal-content');
              if (modalContent) {
                const contentOpacity = Math.max(0.7, 1 - opacity);
                modalContent.style.backgroundColor = `rgba(15, 15, 35, ${contentOpacity})`;
                modalContent.style.backdropFilter = 'blur(1px)';
                console.log('[归墟小说背景] 设置内容透明度:', contentOpacity);
              }
              const existingOverlay = novelModal.querySelector('.novel-bg-overlay');
              if (existingOverlay) {
                existingOverlay.remove();
              }              
              const overlay = document.createElement('div');
              overlay.className = 'novel-bg-overlay';
              overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, ${0.3 - opacity * 0.2});
                pointer-events: none;
                z-index: 1;
              `;
              novelModal.appendChild(overlay);
              
              console.log('[归墟小说背景] 背景图已应用');
            } else {
              // 移除背景
              novelModal.style.backgroundImage = '';
              novelModal.style.backgroundAttachment = '';
              const modalContent = novelModal.querySelector('.modal-content');
              if (modalContent) {
                modalContent.style.backgroundColor = '';
                modalContent.style.backdropFilter = '';
              }
              
              // 移除背景遮罩
              const existingOverlay = novelModal.querySelector('.novel-bg-overlay');
              if (existingOverlay) {
                existingOverlay.remove();
              }
              
              console.log('[归墟小说背景] 背景图已移除');
            }
          },

          // 获取随机小说背景
          getRandomNovelBackground() {
            try {
              const settings = JSON.parse(localStorage.getItem('guixu_background_settings') || '{}');
              if (settings.backgrounds && settings.backgrounds.length > 0) {
                const randomIndex = Math.floor(Math.random() * settings.backgrounds.length);
                return settings.backgrounds[randomIndex];
              }
            } catch (e) {
              console.error('获取随机背景失败:', e);
            }
            return null;
          },

          // 保存小说背景设置
          saveNovelBackgroundSettings() {
            try {
              const settings = {
                enabled: this.novelBackgroundEnabled,
                opacity: this.novelBackgroundOpacity || 0.3,
                image: this.novelBackgroundImage || ''
              };
              localStorage.setItem('guixu_novel_background_settings', JSON.stringify(settings));
            } catch (e) {
              console.error('保存小说背景设置失败:', e);
            }
          },

          // 加载小说背景设置
          loadNovelBackgroundSettings() {
            try {
              const saved = localStorage.getItem('guixu_novel_background_settings');
              if (saved) {
                const settings = JSON.parse(saved);
                this.novelBackgroundEnabled = settings.enabled || false;
                this.novelBackgroundOpacity = settings.opacity || 0.3;
                this.novelBackgroundImage = settings.image || '';
              } else {
                // 兼容旧版本设置
                const oldSaved = localStorage.getItem('guixu_novel_background_enabled');
                this.novelBackgroundEnabled = oldSaved === 'true';
                this.novelBackgroundOpacity = 0.3;
                this.novelBackgroundImage = '';
              }
            } catch (e) {
              console.error('加载小说背景设置失败:', e);
              this.novelBackgroundEnabled = false;
              this.novelBackgroundOpacity = 0.3;
              this.novelBackgroundImage = '';
            }
          },
 // ===小说模式模块结束===




// ===世界书高级设置/自动开关/创建模块开始===   



// 世界书高级设置存取
           saveWorldbookSettings() {
             try {
               const settings = {
                 journey: {
                   position: document.getElementById('journey-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('journey-order')?.value) || 17,
                   depth: parseInt(document.getElementById('journey-depth')?.value) || 1,
                   type: document.getElementById('journey-type')?.value || 'selective',
                   enabled: document.getElementById('journey-enabled')?.checked || false
                 },
                 pastLives: {
                   position: document.getElementById('past-lives-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('past-lives-order')?.value) || 16,
                   depth: parseInt(document.getElementById('past-lives-depth')?.value) || 1,
                   type: document.getElementById('past-lives-type')?.value || 'selective',
                   enabled: document.getElementById('past-lives-enabled')?.checked || false
                 },
                 novel: {
                   position: document.getElementById('novel-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('novel-order')?.value) || 18,
                   depth: parseInt(document.getElementById('novel-depth')?.value) || 1,
                   type: document.getElementById('novel-type')?.value || 'selective',
                   enabled: document.getElementById('novel-enabled')?.checked || false
                 },
                 segmented: {
                   position: document.getElementById('segmented-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('segmented-order')?.value) || 21,
                   depth: parseInt(document.getElementById('segmented-depth')?.value) || 1,
                   type: document.getElementById('segmented-type')?.value || 'constant',
                   enabled: document.getElementById('segmented-enabled')?.checked || false
                 },
                 largeSummary: {
                   position: document.getElementById('large-summary-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('large-summary-order')?.value) || 19,
                   depth: parseInt(document.getElementById('large-summary-depth')?.value) || 1,
                   type: document.getElementById('large-summary-type')?.value || 'constant',
                   enabled: document.getElementById('large-summary-enabled')?.checked || false
                 },
                 smallSummary: {
                   position: document.getElementById('small-summary-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('small-summary-order')?.value) || 20,
                   depth: parseInt(document.getElementById('small-summary-depth')?.value) || 1,
                   type: document.getElementById('small-summary-type')?.value || 'constant',
                   enabled: document.getElementById('small-summary-enabled')?.checked || false
                 }
               };
               
               localStorage.setItem('guixu_worldbook_settings', JSON.stringify(settings));
               this.worldbookSettings = settings;
             } catch (e) {
               console.error('保存世界书设置失败:', e);
             }
           },

           loadWorldbookSettings() {
             try {
               const savedSettings = localStorage.getItem('guixu_worldbook_settings');
               if (savedSettings) {
                 this.worldbookSettings = JSON.parse(savedSettings);
               } else {
                 // 默认设置
                 this.worldbookSettings = {
                   journey: { position: 'before_character_definition', order: 17, depth: 1, type: 'selective', enabled: false },
                   pastLives: { position: 'before_character_definition', order: 16, depth: 1, type: 'constant', enabled: false },
                   novel: { position: 'before_character_definition', order: 18, depth: 1, type: 'selective', enabled: false },
                   segmented: { position: 'at_depth_as_system', order: 3, depth: 4, type: 'constant', enabled: true },
                   largeSummary: { position: 'at_depth_as_system', order: 1, depth: 4, type: 'constant', enabled: true },
                   smallSummary: { position: 'at_depth_as_system', order: 2, depth: 4, type: 'constant', enabled: true },
                 };
               }
               
               // 更新UI
               if (document.getElementById('journey-position')) {
                 document.getElementById('journey-position').value = this.worldbookSettings.journey.position;
                 document.getElementById('journey-order').value = this.worldbookSettings.journey.order;
                 document.getElementById('journey-depth').value = this.worldbookSettings.journey.depth;
                 document.getElementById('journey-type').value = this.worldbookSettings.journey.type;
                 document.getElementById('journey-enabled').checked = this.worldbookSettings.journey.enabled;
                 
                 document.getElementById('past-lives-position').value = this.worldbookSettings.pastLives.position;
                 document.getElementById('past-lives-order').value = this.worldbookSettings.pastLives.order;
                 document.getElementById('past-lives-depth').value = this.worldbookSettings.pastLives.depth;
                 document.getElementById('past-lives-type').value = this.worldbookSettings.pastLives.type;
                 document.getElementById('past-lives-enabled').checked = this.worldbookSettings.pastLives.enabled;
                 
                 document.getElementById('novel-position').value = this.worldbookSettings.novel.position;
                 document.getElementById('novel-order').value = this.worldbookSettings.novel.order;
                 document.getElementById('novel-depth').value = this.worldbookSettings.novel.depth;
                 document.getElementById('novel-type').value = this.worldbookSettings.novel.type;
                 document.getElementById('novel-enabled').checked = this.worldbookSettings.novel.enabled;

                 if(document.getElementById('segmented-position') && this.worldbookSettings.segmented) {
                   document.getElementById('segmented-position').value = this.worldbookSettings.segmented.position;
                   document.getElementById('segmented-order').value = this.worldbookSettings.segmented.order;
                   document.getElementById('segmented-depth').value = this.worldbookSettings.segmented.depth;
                   document.getElementById('segmented-type').value = this.worldbookSettings.segmented.type;
                   document.getElementById('segmented-enabled').checked = this.worldbookSettings.segmented.enabled;
                 }

                 if(document.getElementById('large-summary-position') && this.worldbookSettings.largeSummary) {
                   document.getElementById('large-summary-position').value = this.worldbookSettings.largeSummary.position;
                   document.getElementById('large-summary-order').value = this.worldbookSettings.largeSummary.order;
                   document.getElementById('large-summary-depth').value = this.worldbookSettings.largeSummary.depth;
                   document.getElementById('large-summary-type').value = this.worldbookSettings.largeSummary.type;
                   document.getElementById('large-summary-enabled').checked = this.worldbookSettings.largeSummary.enabled;
                 }

                 if(document.getElementById('small-summary-position') && this.worldbookSettings.smallSummary) {
                   document.getElementById('small-summary-position').value = this.worldbookSettings.smallSummary.position;
                   document.getElementById('small-summary-order').value = this.worldbookSettings.smallSummary.order;
                   document.getElementById('small-summary-depth').value = this.worldbookSettings.smallSummary.depth;
                   document.getElementById('small-summary-type').value = this.worldbookSettings.smallSummary.type;
                   document.getElementById('small-summary-enabled').checked = this.worldbookSettings.smallSummary.enabled;
                 }
                 
                 // 更新深度输入框的显示状态
                 ['journey', 'past-lives', 'novel', 'segmented', 'large-summary', 'small-summary'].forEach(type => {
                   const positionSelect = document.getElementById(`${type}-position`);
                   const depthContainer = document.getElementById(`${type}-depth-container`);
                   if (positionSelect && depthContainer) {
                     depthContainer.style.display = positionSelect.value.startsWith('at_depth') ? 'contents' : 'none';
                   }
                 });
               }
             } catch (e) {
               console.error('加载世界书设置失败:', e);
               this.worldbookSettings = {
                 journey: { position: 'before_character_definition', order: 17, depth: 1, logic: 'and_any' },
                 pastLives: { position: 'before_character_definition', order: 16, depth: 1, logic: 'and_any' },
                 novel: { position: 'before_character_definition', order: 18, depth: 1, logic: 'and_any' },
               };
             }
           },

           resetWorldbookSettings() {
             try {
               localStorage.removeItem('guixu_worldbook_settings');
               this.worldbookSettings = {
                   journey: { position: 'before_character_definition', order: 17, depth: 1, type: 'selective', enabled: false },
                   pastLives: { position: 'before_character_definition', order: 16, depth: 1, type: 'constant', enabled: false },
                   novel: { position: 'before_character_definition', order: 18, depth: 1, type: 'selective', enabled: false },
                   segmented: { position: 'at_depth_as_system', order: 3, depth: 4, type: 'constant', enabled: true },
                   largeSummary: { position: 'at_depth_as_system', order: 1, depth: 4, type: 'constant', enabled: true },
                   smallSummary: { position: 'at_depth_as_system', order: 2, depth: 4, type: 'constant', enabled: true },
               };
             } catch (e) {
               console.error('重置世界书设置失败:', e);
             }
           },

// 自动开关世界书轮询逻辑 (条目自动创建) 
          async updateAutoToggledEntries(andDisableAll = false) {
            const bookName = '1归墟';
            const index = this.unifiedIndex;
            const journeyKey = index > 1 ? `本世历程(${index})` : '本世历程';
            const pastLivesKey = index > 1 ? `往世涟漪(${index})` : '往世涟漪';
            const segmentedKey = index > 1 ? `分段正文(${index})` : '分段正文';
            const smallSummaryKey = index > 1 ? `小总结(${index})` : '小总结';
            const largeSummaryKey = index > 1 ? `大总结(${index})` : '大总结';
            try {
                let allEntries = await TavernHelper.getLorebookEntries(bookName);
                const entriesToCreate = [];

                // 检查并创建缺失的条目 
                const targetJourneyEntry = allEntries.find(e => e.comment === journeyKey);
                if (!targetJourneyEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === '本世历程');
                    if (baseTemplate) {
                        // 完整复制模板属性，确保所有必需字段都存在
                        const newJourneyEntry = { ...baseTemplate };
                        delete newJourneyEntry.uid;
                        delete newJourneyEntry.display_index;
                        newJourneyEntry.comment = journeyKey;
                        newJourneyEntry.content = '';
                        newJourneyEntry.keys = [...(baseTemplate.keys || []), journeyKey];
                        const journeySettings = this.worldbookSettings?.journey || { position: 'before_character_definition', order: 17, depth: 1, type: 'selective', enabled: false };
                        newJourneyEntry.enabled = journeySettings.enabled;
                        // 确保设置所有必需的属性，使用保存的设置
                        newJourneyEntry.type = journeySettings.type;
                        newJourneyEntry.position = journeySettings.position;
                        newJourneyEntry.order = journeySettings.order;
                        newJourneyEntry.depth = journeySettings.position.startsWith('at_depth') ? journeySettings.depth : null;
                        newJourneyEntry.scan_depth = baseTemplate.scan_depth || 'same_as_global';
                        newJourneyEntry.case_sensitive = baseTemplate.case_sensitive || 'same_as_global';
                        newJourneyEntry.match_whole_words = baseTemplate.match_whole_words || 'same_as_global';
                        newJourneyEntry.use_group_scoring = baseTemplate.use_group_scoring || 'same_as_global';
                        newJourneyEntry.probability = baseTemplate.probability !== undefined ? baseTemplate.probability : 100;
                        newJourneyEntry.exclude_recursion = baseTemplate.exclude_recursion || false;
                        newJourneyEntry.prevent_recursion = baseTemplate.prevent_recursion || false;
                        newJourneyEntry.delay_until_recursion = baseTemplate.delay_until_recursion || false;
                        entriesToCreate.push(newJourneyEntry);
                    } else {
                        // 如果没有模板，创建一个全新的条目
                        console.warn('[归墟自动开关] 未找到"本世历程"基础模板，将创建默认条目');
                        entriesToCreate.push({
                            comment: journeyKey,
                            content: '',
                            keys: [journeyKey],
                            enabled: this.worldbookSettings?.journey?.enabled || false, // 本世历程默认关闭
                            type: this.worldbookSettings?.journey?.type || 'selective',
                            position: this.worldbookSettings?.journey?.position || 'before_character_definition',
                            order: this.worldbookSettings?.journey?.order || 17,
                            depth: (this.worldbookSettings?.journey?.position || '').startsWith('at_depth') ? (this.worldbookSettings?.journey?.depth || 1) : null,
                            scan_depth: 'same_as_global',
                            case_sensitive: 'same_as_global',
                            match_whole_words: 'same_as_global',
                            use_group_scoring: 'same_as_global',
                            probability: 100,
                            exclude_recursion: false,
                            prevent_recursion: false,
                            delay_until_recursion: false,
                            filters: [],
                            depth: null,
                            automation_id: null,
                            group: '',
                            group_prioritized: false,
                            group_weight: 100,
                            sticky: null,
                            cooldown: null,
                            delay: null
                        });
                    }
                }

                const targetPastLivesEntry = allEntries.find(e => e.comment === pastLivesKey);
                if (!targetPastLivesEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === '往世涟漪');
                    if (baseTemplate) {
                        // 完整复制模板属性，确保所有必需字段都存在
                        const newPastLivesEntry = { ...baseTemplate };
                        delete newPastLivesEntry.uid;
                        delete newPastLivesEntry.display_index;
                        newPastLivesEntry.comment = pastLivesKey;
                        newPastLivesEntry.content = '';
                        newPastLivesEntry.keys = [...(baseTemplate.keys || []), pastLivesKey];
                        const pastLivesSettings = this.worldbookSettings?.pastLives || { position: 'before_character_definition', order: 16, depth: 1, type: 'selective', enabled: true };
                        newPastLivesEntry.enabled = pastLivesSettings.enabled;
                        // 确保设置所有必需的属性，使用保存的设置
                        newPastLivesEntry.type = pastLivesSettings.type;
                        newPastLivesEntry.position = pastLivesSettings.position;
                        newPastLivesEntry.order = pastLivesSettings.order;
                        newPastLivesEntry.depth = pastLivesSettings.position.startsWith('at_depth') ? pastLivesSettings.depth : null;
                        newPastLivesEntry.scan_depth = baseTemplate.scan_depth || 'same_as_global';
                        newPastLivesEntry.case_sensitive = baseTemplate.case_sensitive || 'same_as_global';
                        newPastLivesEntry.match_whole_words = baseTemplate.match_whole_words || 'same_as_global';
                        newPastLivesEntry.use_group_scoring = baseTemplate.use_group_scoring || 'same_as_global';
                        newPastLivesEntry.probability = baseTemplate.probability !== undefined ? baseTemplate.probability : 100;
                        newPastLivesEntry.exclude_recursion = baseTemplate.exclude_recursion || false;
                        newPastLivesEntry.prevent_recursion = baseTemplate.prevent_recursion || false;
                        newPastLivesEntry.delay_until_recursion = baseTemplate.delay_until_recursion || false;
                        entriesToCreate.push(newPastLivesEntry);
                    } else {
                        // 如果没有模板，创建一个全新的条目
                        console.warn('[归墟自动开关] 未找到"往世涟漪"基础模板，将创建默认条目');
                        entriesToCreate.push({
                            comment: pastLivesKey,
                            content: '',
                            keys: [pastLivesKey],
                            enabled: this.worldbookSettings?.pastLives?.enabled || true,
                            type: this.worldbookSettings?.pastLives?.type || 'selective',
                            position: this.worldbookSettings?.pastLives?.position || 'before_character_definition',
                            order: this.worldbookSettings?.pastLives?.order || 16,
                            depth: (this.worldbookSettings?.pastLives?.position || '').startsWith('at_depth') ? (this.worldbookSettings?.pastLives?.depth || 1) : null,
                            scan_depth: 'same_as_global',
                            case_sensitive: 'same_as_global',
                            match_whole_words: 'same_as_global',
                            use_group_scoring: 'same_as_global',
                            probability: 100,
                            exclude_recursion: false,
                            prevent_recursion: false,
                            delay_until_recursion: false,
                            filters: [],
                            automation_id: null,
                            group: '',
                            group_prioritized: false,
                            group_weight: 100,
                            sticky: null,
                            cooldown: null,
                            delay: null
                        });
                    }
                }

               const targetSegmentedEntry = allEntries.find(e => e.comment === segmentedKey);
               if (!targetSegmentedEntry) {
                   const baseTemplate = allEntries.find(e => e.comment === '分段正文');
                   const segmentedSettings = this.worldbookSettings?.segmented || { position: 'before_character_definition', order: 21, depth: 1, type: 'constant' };
                   
                   let newEntry;
                   if (baseTemplate) {
                       newEntry = { ...baseTemplate };
                       delete newEntry.uid;
                       delete newEntry.display_index;
                   } else {
                       newEntry = {
                           keys: [],
                           scan_depth: 'same_as_global',
                           case_sensitive: 'same_as_global',
                           match_whole_words: 'same_as_global',
                           use_group_scoring: 'same_as_global',
                           probability: 100,
                           exclude_recursion: false,
                           prevent_recursion: false,
                           delay_until_recursion: false,
                           filters: [],
                           automation_id: null,
                           group: '',
                           group_prioritized: false,
                           group_weight: 100,
                           sticky: null,
                           cooldown: null,
                           delay: null
                       };
                   }

                   Object.assign(newEntry, {
                       comment: segmentedKey,
                       content: '',
                       enabled: segmentedSettings.enabled,
                       type: segmentedSettings.type,
                       position: segmentedSettings.position,
                       order: segmentedSettings.order,
                       depth: segmentedSettings.position.startsWith('at_depth') ? segmentedSettings.depth : null,
                   });

                   entriesToCreate.push(newEntry);
               }

                // 检查并创建小总结
                const targetSmallSummaryEntry = allEntries.find(e => e.comment === smallSummaryKey);
                if (!targetSmallSummaryEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === '小总结');
                    const smallSummarySettings = this.worldbookSettings?.smallSummary || { position: 'before_character_definition', order: 20, depth: 1, type: 'constant' };
                    let newEntry;
                    if (baseTemplate) {
                        newEntry = { ...baseTemplate };
                        delete newEntry.uid;
                        delete newEntry.display_index;
                    } else {
                        newEntry = { keys: [], scan_depth: 'same_as_global', case_sensitive: 'same_as_global', match_whole_words: 'same_as_global', use_group_scoring: 'same_as_global', probability: 100, exclude_recursion: false, prevent_recursion: false, delay_until_recursion: false, filters: [], automation_id: null, group: '', group_prioritized: false, group_weight: 100, sticky: null, cooldown: null, delay: null };
                    }
                    Object.assign(newEntry, {
                        comment: smallSummaryKey,
                        content: '',
                        enabled: smallSummarySettings.enabled,
                        type: smallSummarySettings.type,
                        position: smallSummarySettings.position,
                        order: smallSummarySettings.order,
                        depth: smallSummarySettings.position.startsWith('at_depth') ? smallSummarySettings.depth : null,
                    });
                    entriesToCreate.push(newEntry);
                }

                // 检查并创建大总结
                const targetLargeSummaryEntry = allEntries.find(e => e.comment === largeSummaryKey);
                if (!targetLargeSummaryEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === '大总结');
                    const largeSummarySettings = this.worldbookSettings?.largeSummary || { position: 'before_character_definition', order: 19, depth: 1, type: 'constant' };
                    let newEntry;
                    if (baseTemplate) {
                        newEntry = { ...baseTemplate };
                        delete newEntry.uid;
                        delete newEntry.display_index;
                    } else {
                        newEntry = { keys: [], scan_depth: 'same_as_global', case_sensitive: 'same_as_global', match_whole_words: 'same_as_global', use_group_scoring: 'same_as_global', probability: 100, exclude_recursion: false, prevent_recursion: false, delay_until_recursion: false, filters: [], automation_id: null, group: '', group_prioritized: false, group_weight: 100, sticky: null, cooldown: null, delay: null };
                    }
                    Object.assign(newEntry, {
                        comment: largeSummaryKey,
                        content: '',
                        enabled: largeSummarySettings.enabled,
                        type: largeSummarySettings.type,
                        position: largeSummarySettings.position,
                        order: largeSummarySettings.order,
                        depth: largeSummarySettings.position.startsWith('at_depth') ? largeSummarySettings.depth : null,
                    });
                    entriesToCreate.push(newEntry);
                }

                if (entriesToCreate.length > 0) {
                    await TavernHelper.createLorebookEntries(bookName, entriesToCreate);
                    console.log(`[归墟自动开关] 已自动创建 ${entriesToCreate.length} 个新世界书条目。`);
                    // 重新获取所有条目，以包含新创建的条目
                    allEntries = await TavernHelper.getLorebookEntries(bookName);
                }

                const entriesToUpdate = allEntries
                    .filter(entry => entry.comment.startsWith('本世历程') || entry.comment.startsWith('往世涟漪') || entry.comment.startsWith('分段正文') || entry.comment.startsWith('小总结') || entry.comment.startsWith('大总结') || entry.comment.startsWith('小说模式'))
                    .map(entry => {
                        let shouldBeEnabled;
                        if (andDisableAll) {
                            shouldBeEnabled = false;
                        } else {
                            // 根据comment key从settings中找到对应的配置决定是否启用
                            if (entry.comment === journeyKey) shouldBeEnabled = this.worldbookSettings.journey.enabled;
                            else if (entry.comment === pastLivesKey) shouldBeEnabled = this.worldbookSettings.pastLives.enabled;
                            else if (entry.comment === segmentedKey) shouldBeEnabled = this.worldbookSettings.segmented.enabled;
                            else if (entry.comment === smallSummaryKey) shouldBeEnabled = this.worldbookSettings.smallSummary.enabled;
                            else if (entry.comment === largeSummaryKey) shouldBeEnabled = this.worldbookSettings.largeSummary.enabled;
                            else if (entry.comment === (index > 1 ? `小说模式(${index})` : '小说模式')) shouldBeEnabled = this.worldbookSettings.novel.enabled;
                            else shouldBeEnabled = false; // 默认不启用未知条目
                        }

                        // 只在状态需要改变时才加入更新队列
                        if (entry.enabled !== shouldBeEnabled) {
                            return { uid: entry.uid, enabled: shouldBeEnabled };
                        }
                        return null;
                    }).filter(Boolean); // 过滤掉null的项

                if (entriesToUpdate.length > 0) {
                    await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
                    console.log(`[归墟自动开关] 更新了 ${entriesToUpdate.length} 个世界书条目状态。`);
                }
            } catch (error) {
                console.error('[归墟自动开关] 更新世界书条目状态时出错:', error);
            }
          },

          startAutoTogglePolling() {
              this.stopAutoTogglePolling(false); // 先停止任何可能存在的旧轮询, 但不禁用条目
              console.log('[归墟] 启动世界书自动开关轮询...');
              this.updateAutoToggledEntries(); // 立即执行一次
              this.autoToggleIntervalId = setInterval(() => this.updateAutoToggledEntries(), 5000); // 每5秒轮询一次
          },

          stopAutoTogglePolling(disableEntries = true) {
              if (this.autoToggleIntervalId) {
                  console.log('[归墟] 停止世界书自动开关轮询。');
                  clearInterval(this.autoToggleIntervalId);
                  this.autoToggleIntervalId = null;
              }
              if (disableEntries) {
                  // 停止时，确保所有相关条目都被禁用
                  this.updateAutoToggledEntries(true);
              }
          },
// ===世界书高级设置/自动开关/创建模块结束===   




// ===背景图应用模块开始===
           applyRandomBackground() {
             const container = document.querySelector('.guixu-root-container');
             if (!container) {
               console.warn('[归墟背景] 找不到根容器，无法应用背景图');
               return;
             }
             console.log('[归墟背景] 应用背景图，模式:', this.backgroundMode, '图片数量:', this.backgroundImages.length);
             if (this.backgroundImages.length > 0) {
               let backgroundToApply;
               
               if (this.backgroundMode === 'fixed' && this.selectedBackgroundId) {
// 1.【固定模式：使用选中的背景图】
                 backgroundToApply = this.backgroundImages.find(bg => bg.id === this.selectedBackgroundId);
               } else if (this.backgroundMode === 'random') {
// 2.【随机模式：随机选择一张背景图】
                 backgroundToApply = this.backgroundImages[Math.floor(Math.random() * this.backgroundImages.length)];
               }
               if (backgroundToApply && backgroundToApply.dataUrl) {
                 const isObjectUrl = backgroundToApply.dataUrl.startsWith('blob:');
                 const isUrlImage = backgroundToApply.isUrlImage;                 
                 if (isObjectUrl) {
                   const img = new Image();
                   img.onload = () => {
                     container.style.backgroundImage = `url('${backgroundToApply.dataUrl}')`;
                   };
                   img.onerror = () => {
                     this.handleInvalidBackground(backgroundToApply);
                   };
                   img.src = backgroundToApply.dataUrl;
                 } else if (isUrlImage) {
                   const img = new Image();
                   img.onload = () => {
                     container.style.backgroundImage = `url('${backgroundToApply.dataUrl}')`;
                   };
                   img.onerror = () => {
                     this.handleInvalidBackground(backgroundToApply);
                   };
                   img.crossOrigin = 'anonymous';
                   img.src = backgroundToApply.dataUrl;
                 } else {
                   container.style.backgroundImage = `url('${backgroundToApply.dataUrl}')`;
                 }
                 return;
               }
             }

             // 如果没有用户背景图，使用默认背景
             const defaultBackgrounds = [
               'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png',
               'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png',
             ];
             const bgUrl = defaultBackgrounds[Math.floor(Math.random() * defaultBackgrounds.length)];
             container.style.backgroundImage = `url('${bgUrl}')`;
           },

           // 新增：处理无效背景的函数
           handleInvalidBackground(invalidBackground) {
             const bgType = invalidBackground.isUrlImage ? '外链图片' :
                           invalidBackground.dataUrl.startsWith('blob:') ? 'Object URL图片' : '本地图片';
             console.warn(`[归墟背景] 处理无效背景: ${invalidBackground.name} (${bgType})`);
             
             // 显示用户友好的提示信息
             if (invalidBackground.isUrlImage) {
               this.showTemporaryMessage(`外链图片"${invalidBackground.name}"无法访问，已自动移除`, 4000);
             }
             
             // 从背景列表中移除无效背景
             const index = this.backgroundImages.findIndex(bg => bg.id === invalidBackground.id);
             if (index !== -1) {
               this.backgroundImages.splice(index, 1);
               this.saveBackgroundSettings();
               console.log(`[归墟背景] 已移除无效背景: ${invalidBackground.name}`);
               
               // 如果删除的是当前选中的背景，清除选择
               if (this.selectedBackgroundId === invalidBackground.id) {
                 this.selectedBackgroundId = null;
                 this.backgroundMode = 'random'; // 切换到随机模式
                 this.saveBackgroundSettings();
               }
               if (this.backgroundImages.length > 0) {
                 this.applyRandomBackground();
               } else {
                 const container = document.querySelector('.guixu-root-container');
                 if (container) {
                   const defaultBackgrounds = [
                     'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png',
                     'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png',
                   ];
                   const bgUrl = defaultBackgrounds[Math.floor(Math.random() * defaultBackgrounds.length)];
                   container.style.backgroundImage = `url('${bgUrl}')`;
                 }
               }
               
               // 刷新背景列表显示
               if (document.getElementById('background-settings-modal') &&
                   document.getElementById('background-settings-modal').style.display === 'flex') {
                 this.renderBackgroundList();
                 this.updateBackgroundModeUI(); // 更新模式UI
               }
             }
           },

          // 初始化背景图系统
          async initBackgroundSystem() {
            console.log('[归墟背景] 初始化背景图系统...');
            
          
            this.loadBackgroundSettings();  // 背景图设置
            this.loadOpacitySettings();// 透明度设置
            // 预设背景图
            if (this.backgroundImages.length === 0) {
              this.backgroundImages = [
                {
                  id: 'preset1',
                  name: '仙境云海',
                  dataUrl: 'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png',
                  isPreset: true
                },
                {
                  id: 'preset2',
                  name: '古风山水',
                  dataUrl: 'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png',
                  isPreset: true
                }
              ];
              this.saveBackgroundSettings();
            }
            // 应用背景图
            this.applyRandomBackground();
          },
// ===背景图应用模块结束===



// ===提示词构建和生成回复模块开始===


// 1.【发送保存输入历史】
          async executeQuickSend() {
            const input = document.getElementById('quick-send-input');
            if (!input) return;
            const userMessage = input.value.trim();

            if (userMessage) {
                this.saveInputToHistory(userMessage); // 发送时保存到历史
            }

            await this.handleAction(userMessage);
          },

          // 处理所有动作的核心函数

          async handleAction(userMessage = '') {
              const gameTextDisplay = document.getElementById('game-text-display');
              if (gameTextDisplay) {
                  this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
              }
              const thinkingDisplay = document.getElementById('thinking-content-display');
              if (thinkingDisplay) {
                  thinkingDisplay.style.display = 'none';
              }
              this.lastExtractedThinking = null;
              this.saveLastThinking(); // 清除持久化存储
              this.updateThinkingButtonVisibility();
              this.updateCurrentLifeButtonVisibility(); // 新增:更新本世历程按钮显示
              this.updatePastLivesButtonVisibility(); // 新增:更新往世涟漪按钮显示
              document.getElementById('action-options-container').innerHTML = ''; // 隐藏行动选项
              this.hideVariableChangesReminder(); // 隐藏变量改变提醒
              this.isStreamingGametxt = false; // 重置流式状态

              // 隐藏上一次的章节标题和历史正文
              const titleContainer = document.getElementById('current-chapter-title');
              if (titleContainer) {
                  titleContainer.style.display = 'none';
              }
              const historicalTextContainer = document.getElementById('historical-text-container');
              if (historicalTextContainer) {
                  historicalTextContainer.style.display = 'none';
              }

              // 极简化处理：直接拼接所有指令文本
              let commandText = '';
              if (this.pendingActions.length > 0) {
                  commandText += '[本轮行动指令]\n';
                  this.pendingActions.forEach(command => {
                      if (command) {
                          commandText += command + '\n';
                      }
                  });
                  // 清空指令队列
                  this.pendingActions = [];
              }

              if (!userMessage && !commandText) {
                  this.showTemporaryMessage('请输入回复或添加指令后发送。');
                  return;
              }

// 2. 【检查生成模式并分发】
              const generationMode = this.generationMode || 'once';
              console.log(`[归墟] 当前生成模式: ${generationMode}`);

              if (generationMode === 'stepwise') {
                  // 步进式变量更新模式
                  await this.handleStepwiseGeneration(userMessage, commandText);
              } else {
                  // 一次性生成模式（原有逻辑）
                  await this.handleOnceGeneration(userMessage, commandText);
              }
           },

           // 一次性生成模式处理函数
           async handleOnceGeneration(userMessage, commandText) {
              console.log('[归墟] 执行一次性生成模式');

// 2. 【构建提示词】
              const generateConfig = {
                  injects: [],
                  should_stream: this.isStreamingEnabled, // 修改：使用状态变量
              };

              // 将用户输入和指令合并为一个 user-role 注入
              let combinedContent = '';
              if (commandText) {
                  combinedContent += commandText + '\n'; // 指令在前
              }
              if (userMessage) {
                  combinedContent += `<行动选择>\n${userMessage}\n</行动选择>`;
              }

              if (combinedContent) {
                  generateConfig.injects.push({
                      role: 'user',
                      content: combinedContent,
                      position: 'in_chat', // 插入到聊天记录中
                      depth: 0,
                      should_scan: true, // 允许扫描关键字
                  });
              }

              this.lastSentPrompt = combinedContent; // 更新调试信息


// 控制台发送内容报告
              console.group('[归墟] 本次发送内容报告');
              console.log('发送时间:', new Date().toLocaleString('zh-CN'));
              console.log('生成模式:', '一次性生成');
              console.log('流式模式:', this.isStreamingEnabled ? '开启' : '关闭');
              
              if (commandText) {
                  console.log('⚡ 指令内容:');
                  console.log(commandText);
              }
              
              if (userMessage) {
                  console.log('💬 用户输入:');
                  console.log(userMessage);
              }
              
              console.log('📋 完整发送内容:');
              console.log(combinedContent);
              
              console.log('🔧 GenerateConfig:');
              console.log(generateConfig);
              console.groupEnd();
              
              this.showWaitingMessage();

              try {
// 3. 【调用 generate，后续处理移至 handleStreamEnd】
                  this.generationStep = 0; // 重置生成步骤
                  await TavernHelper.generate(generateConfig);
                  
              } catch (error) {
                  console.error('处理动作时出错:', error);
                  this.showTemporaryMessage(`和伟大梦星沟通失败: ${error.message}`);
                  this.hideWaitingMessage(); // 确保隐藏等待消息
              }
           },

           // 步进式变量更新模式处理函数
           async handleStepwiseGeneration(userMessage, commandText) {
              console.log('[归墟] 执行步进式变量更新模式');
              
              // 步骤1：生成主内容（不含变量）
              this.generationStep = 1;
              this.cachedMainContent = null;
              
              // 显示等待消息
              this.showWaitingMessage();
              
              // 第一步只发送【only剧情】和无前缀的条目
              this.isStepwiseFirstStep = true;
              this.isStepwiseSecondStep = false;
              const generateConfig = {
                  injects: [],
                  should_stream: this.isStreamingEnabled,
              };

              // 构建主内容生成的prompt
              let combinedContent = '';
              if (commandText) {
                  combinedContent += commandText + '\n';
              }
              if (userMessage) {
                  combinedContent += `<行动选择>\n${userMessage}\n</行动选择>`;
              }
              if (combinedContent) {
                  generateConfig.injects.push({
                      role: 'user',
                      content: combinedContent,
                      position: 'in_chat',
                      depth: 0,
                      should_scan: true,
                  });
              }

              this.lastSentPrompt = combinedContent;

              console.group('[归墟] 步进式生成 - 第一步');
              console.log('发送时间:', new Date().toLocaleString('zh-CN'));
              console.log('生成模式:', '步进式变量更新 - 步骤1（主内容）');
              console.log('流式模式:', this.isStreamingEnabled ? '开启' : '关闭');
              console.log('📋 完整发送内容:');
              console.log(combinedContent);
              console.groupEnd();
              try {
                  await TavernHelper.generate(generateConfig);
                  // 第二步将在handleStreamEnd中触发
              } catch (error) {
                  console.error('[归墟] 步进式生成第一步出错:', error);
                  this.showTemporaryMessage(`生成主内容失败: ${error.message}`);
                  this.hideWaitingMessage();
                  this.generationStep = 0;
              }
           },

          // ===步进式文本处理模块开始===

          // 【接口函数】处理第一步完整文本，提取需要发送给第二步的内容
          _processFirstStepTextForSecondStep(firstStepFullText) {
              const gametxtContent = this._extractLastTagContent('gametxt', firstStepFullText);
              if (gametxtContent) {
                  // 将提取的内容包裹在<本次正文>标签中，并添加提示文字
                  return `需要根据以下文本，进行变量更新的指令：\n\n<本次正文>\n${gametxtContent}\n</本次正文>`;
              }
              // 如果没有gametxt标签，返回空文本
              return '';
          },

          // 【接口函数】处理第二步返回的文本，提取需要合并的内容
          _processSecondStepResponse(secondStepFullText) {
               
              const updateVarContent = this._extractLastTagContent('UpdateVariable', secondStepFullText);
              if (updateVarContent) {
                  return '<UpdateVariable>\n' + updateVarContent + '\n</UpdateVariable>';
              }
              // 如果没有UpdateVariable标签，返回空文本
              return '';
          },
          
           //【接口函数】合并第一步和第二步的文本
          _mergeStepwiseTexts(firstStepFullText, processedSecondStepText) {
              return firstStepFullText + '\n\n' + processedSecondStepText;
          },

          async generateVariablesStep(mainContent) {
              this.generationStep = 2;
              this.isStepwiseAppendMode = true;
              this.isStepwiseFirstStep = false;
              this.isStepwiseSecondStep = true;
              this.updateWaitingMessage('分步变量更新ing');
              // 处理第一步文本，提取需要发送的内容
              const processedContent = this._processFirstStepTextForSecondStep(mainContent);
              console.log('[归墟] 📋 处理后发送给第二步的内容预览:', processedContent);

              const config = this.stepwiseConfig || {};
              const useCustomApi = (config.modelSource === '自定义');
              const auxSettings = this.auxModelSettings;
              const useAuxModel = useCustomApi && auxSettings && auxSettings.isEnabled;
              const generateConfig = {
                  user_input: processedContent,
                  should_stream: useAuxModel ? auxSettings.isStreaming : this.isStreamingEnabled,
                  injects: [{ role: 'user', content: '', position: 'in_chat', depth: 0, should_scan: true }],
                  max_chat_history: 0,  // 第二步不包含聊天历史
              };

              if (useAuxModel && auxSettings.apiUrl && auxSettings.modelName) {
                  generateConfig.custom_api = {
                      apiurl: auxSettings.apiUrl,
                      key: auxSettings.apiKey,
                      model: auxSettings.modelName,
                      source: auxSettings.source || 'openai'
                  };
              }

              console.groupCollapsed('[归墟] 📊 步进式生成 - 第二步（变量生成）');
              console.log('🔌 使用API:', useAuxModel ? '第二API' : '主插头');    
              console.groupEnd();
              
              try {
                  await TavernHelper.generate(generateConfig);
              } catch (error) {
                  console.error('[归墟] ❌ 步进式生成第二步调用出错:', error);
                  this.showTemporaryMessage(`生成变量失败: ${error.message}`);
                  this.hideWaitingMessage();
                  this.generationStep = 0;
              }
           },

          // ===步进式文本处理模块结束===


// ===提示词构建和生成回复模块结束===




// ===指令中心模块开始===



           // 快速指令列表相关函数
           toggleQuickCommands() {
             const popup = document.getElementById('quick-command-popup');
            if (!popup) return;

            if (popup.style.display === 'block') {
              this.hideQuickCommands();
            } else {
              this.showQuickCommands();
            }
          },

          // 极简化指令中心：统一的添加指令接口
          addCommand(commandText) {
              if (!commandText || typeof commandText !== 'string') {
                  console.warn('指令文本不能为空或非字符串类型');
                  return;
              }              
              this.pendingActions.push(commandText.trim());
              this.savePendingActions();
          },

          // 兼容性：旧的格式化函数现在直接返回文本
          _formatActionText(cmd) {
              // 如果已经是字符串，直接返回
              if (typeof cmd === 'string') {
                  return cmd;
              }
              if (!cmd) return '';
              if (cmd.text) return cmd.text;
              if (cmd.command) return cmd.command;
              switch (cmd.action) {
                  case 'equip': return `装备 [${cmd.itemName}] 到 [${cmd.category}] 槽位。`;
                  case 'unequip': return `卸下 [${cmd.itemName}] 从 [${cmd.category}] 槽位。`;
                  case 'use': return `使用 ${cmd.quantity} 个 [${cmd.itemName}]。`;
                  case 'discard': return `丢弃 ${cmd.quantity ? cmd.quantity + ' 个 ' : ''}[${cmd.itemName}]。`;
                  case 'travel': return `[行动] "我"动身前往【${cmd.locationName}】。`;
                  case 'do_action': return cmd.text || '[行动]';
                  case 'variable_update': return cmd.command || cmd.text || '[变量更新]';
                  case 'send_as_is': return cmd.command || cmd.text || '[指令]';
                  case 'join_world': return `[角色加入] ${cmd.itemName}`;
                  default: return `[指令] ${cmd.action || '未知操作'}`;
              }
          },
          showQuickCommands() {
              const popup = document.getElementById('quick-command-popup');
              if (!popup) return;
              if (this.pendingActions.length === 0) {
                  popup.innerHTML = '<div class="quick-command-empty">暂无待执行的指令</div>';
              } else {
                  let listHtml = '<ul class="quick-command-list">';
                  this.pendingActions.forEach(commandText => {
                      if (commandText) {
                          listHtml += `<li class="quick-command-item">${commandText}</li>`;
                      }
                  });
                  listHtml += '</ul>';
                  popup.innerHTML = listHtml;
              }
              popup.style.display = 'block';
          },

          hideQuickCommands() {
            const popup = document.getElementById('quick-command-popup');
            if (popup) {
              popup.style.display = 'none';
            }
          },
// ===指令中心模块结束===


      

// ===mvu数据修复模块开始===        
// 深度检测和修复MVU状态数据
          _deepFixMvuState(mvuState) {
              if (!mvuState || typeof mvuState !== 'object') {
                  return mvuState;
              }              
          },

// 安全的数据加载和修复
          _safeLoadMvuData(rawData) {
              if (!rawData) return null;              
              try {
                  // 首先进行深度修复
                  const fixedData = this._deepFixMvuState(rawData);                  
                  // 验证关键数据结构
                  if (fixedData && fixedData.stat_data) {
                      return fixedData;
                  } else {
                      return rawData;
                  }
              } catch (error) {
                  return rawData;
              }
          },

// ===mvu数据修复模块结束===


// 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享
// ===前端MVU处理器开始===
// _applyUpdateFallback 关键mvu处理函数
// 前端实时修改mvu的关键
          _applyUpdateFallback(script, currentMvuState) {
              if (!script || !currentMvuState) return null;
              
              const newState = currentMvuState; // 直接修改，移除深拷贝
              let modified = false;

              const commands = this._extractCommands(script);

              for (const command of commands) {
                  try {
                      const path = this._trimQuotes(command.args[0]);
                      
                      switch (command.command) {
                          case 'set': {
                              const newValueStr = command.args.length >= 2 ? command.args[1] : undefined;
                              if(newValueStr === undefined) continue;
                              let newValue = this._parseCommandValue(newValueStr);
                              
                              if (newValue instanceof Date) newValue = newValue.toISOString();

                              _.set(newState.stat_data, path, newValue);
                              modified = true;
                              break;
                          }
                          case 'add': {
                              const value = _.get(newState.stat_data, path);
                              const delta = this._parseCommandValue(command.args[1]);
                              if (typeof value === 'number' && typeof delta === 'number') {
                                  _.set(newState.stat_data, path, value + delta);
                                  modified = true;
                              }
                              break;
                          }
                          case 'remove': {
                              _.unset(newState.stat_data, path);
                              modified = true;
                              break;
                          }
                          case 'assign':
                          case 'insert': {
                              if (command.args.length === 2) {
                                  // Handles _.assign('path', value)
                                  const valueToAssign = this._parseCommandValue(command.args[1]);
                                  const parentCollection = _.get(newState.stat_data, path);

                                  // Special handling for our [data_array, "description"] structure
                                  if (Array.isArray(parentCollection) && parentCollection.length === 2 && Array.isArray(parentCollection[0]) && typeof parentCollection[1] === 'string') {
                                      const innerArray = parentCollection[0];
                                      const description = parentCollection[1];
                                      const newInnerArray = innerArray.concat(Array.isArray(valueToAssign) ? valueToAssign : [valueToAssign]);
                                      const newParentArray = [newInnerArray, description];
                                      _.set(newState.stat_data, path, newParentArray);
                                      modified = true;
                                  } else if (Array.isArray(parentCollection)) {
                                      // Standard immutable update for regular arrays
                                      const newCollection = parentCollection.concat(Array.isArray(valueToAssign) ? valueToAssign : [valueToAssign]);
                                      _.set(newState.stat_data, path, newCollection);
                                      modified = true;
                                  } else if (_.isObject(parentCollection)) {
                                      // 修复：使用安全的对象合并，避免重复嵌套
                                      const safeValueToAssign = this._sanitizeAssignValue(valueToAssign, path);
                                      const mergedObject = this._safeMergeObjects(parentCollection, safeValueToAssign, path);
                                      _.set(newState.stat_data, path, mergedObject);
                                      modified = true;
                                  } else {
                                      // If path doesn't exist, just set it
                                      _.set(newState.stat_data, path, valueToAssign);
                                      modified = true;
                                  }
                              } else if (command.args.length >= 3) {
                                  // Handles _.assign('path', key, value)
                                  const keyOrIndex = this._parseCommandValue(command.args[1]);
                                  const valueToAssign = this._parseCommandValue(command.args[2]);
                                  let collection = _.get(newState.stat_data, path);

                                  if (Array.isArray(collection)) {
                                      if (typeof keyOrIndex === 'number') {
                                          const newCollection = [...collection]; // Create a shallow copy for immutability
                                          newCollection.splice(keyOrIndex, 0, valueToAssign);
                                          _.set(newState.stat_data, path, newCollection);
                                          modified = true;
                                      }
                                  } else if (_.isObject(collection)) {
                                      // 修复：使用安全的键值设置，避免重复嵌套
                                      const safeValue = this._sanitizeAssignValue(valueToAssign, `${path}.${keyOrIndex}`);
                                      _.set(collection, String(keyOrIndex), safeValue);
                                      modified = true;
                                  } else {
                                      // If collection doesn't exist, create it
                                      const newCollection = {};
                                      const safeValue = this._sanitizeAssignValue(valueToAssign, `${path}.${keyOrIndex}`);
                                      _.set(newCollection, String(keyOrIndex), safeValue);
                                      _.set(newState.stat_data, path, newCollection);
                                      modified = true;
                                  }
                              }
                              break;
                          }
                      }
                  } catch (e) {
                      console.error(`[归墟-备用方案] 处理指令失败:`, command, e);
                  }
              }

              return modified ? newState : null;
          },

          _trimQuotes(str) {
              if (typeof str !== 'string') return str;
              return str.replace(/^['"` ]*(.*?)['"` ]*$/, '$1');
          },
          
          _parseCommandValue(valStr) {
              if (typeof valStr !== 'string') return valStr;
              const trimmed = valStr.trim();
              if (trimmed === 'true') return true;
              if (trimmed === 'false') return false;
              if (trimmed === 'null') return null;
              if (trimmed === 'undefined') return undefined;
              try {
                  return JSON.parse(trimmed);
              } catch (e) {
                  if ((trimmed.startsWith('{') && trimmed.endsWith('}')) || (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
                      try {
                          return new Function(`return ${trimmed};`)();
                      } catch (err) { /* continue */ }
                  }
              }
              return this._trimQuotes(valStr);
          },

          _extractCommands(inputText) {
              const results = [];
              let i = 0;
              while (i < inputText.length) {
                  const match = inputText.substring(i).match(/_\.(set|assign|remove|add|insert)\(/);
                  if (!match || match.index === undefined) break;
                  
                  const commandType = match[1];
                  const start = i + match.index;
                  const openParen = start + match[0].length;
                  const closeParen = this._findMatchingCloseParen(inputText, openParen);
                  
                  if (closeParen === -1) {
                      i = openParen;
                      continue;
                  }
                  
                  let endPos = closeParen + 1;
                  if (endPos >= inputText.length || inputText[endPos] !== ';') {
                      i = closeParen + 1;
                      continue;
                  }
                  endPos++;
                  
                  const paramsString = inputText.substring(openParen, closeParen);
                  const params = this._parseParameters(paramsString);
                  
                  results.push({ command: commandType, args: params });
                  i = endPos;
              }
              return results;
          },

          _findMatchingCloseParen(str, startPos) {
              let parenCount = 1;
              let inQuote = false;
              let quoteChar = '';
              for (let i = startPos; i < str.length; i++) {
                  const char = str[i];
                  if ((char === '"' || char === "'" || char === '`') && str[i - 1] !== '\\') {
                      if (!inQuote) {
                          inQuote = true;
                          quoteChar = char;
                      } else if (char === quoteChar) {
                          inQuote = false;
                      }
                  }
                  if (!inQuote) {
                      if (char === '(') parenCount++;
                      else if (char === ')') {
                          parenCount--;
                          if (parenCount === 0) return i;
                      }
                  }
              }
              return -1;
          },

          _parseParameters(paramsString) {
              const params = [];
              let currentParam = '';
              let inQuote = false;
              let quoteChar = '';
              let bracketCount = 0;
              let braceCount = 0;
              let parenCount = 0;
              for (let i = 0; i < paramsString.length; i++) {
                  const char = paramsString[i];
                  if ((char === '"' || char === "'" || char === '`') && (i === 0 || paramsString[i - 1] !== '\\')) {
                      if (!inQuote) {
                          inQuote = true;
                          quoteChar = char;
                      } else if (char === quoteChar) {
                          inQuote = false;
                      }
                  }
                  if (!inQuote) {
                      if (char === '(') parenCount++;
                      if (char === ')') parenCount--;
                      if (char === '[') bracketCount++;
                      if (char === ']') bracketCount--;
                      if (char === '{') braceCount++;
                      if (char === '}') braceCount--;
                  }
                  if (char === ',' && !inQuote && parenCount === 0 && bracketCount === 0 && braceCount === 0) {
                      params.push(currentParam.trim());
                      currentParam = '';
                      continue;
                  }
                  currentParam += char;
              }
              if (currentParam.trim()) {
                  params.push(currentParam.trim());
              }
              return params;
          },
// ===前端MVU处理器结束===
// 【HTML转义辅助函数】
          escapeHtml(text) {
            if (typeof text !== 'string') return text;
            return text
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
          },




// ===正文/文本提取和处理模块开始===
// 优先提取 <gametxt> 的内容
// 染色的逻辑完全交给 formatMessageContent 处理。
// 移除HTML注释，修复因注释导致的存档逻辑崩溃问题

          _getDisplayText(aiResponse) {
            try {
              if (!aiResponse || typeof aiResponse !== 'string') return '';
              
              const gameText = this._extractLastTagContent('gametxt', aiResponse);
              if (gameText !== null) {

                  return gameText.replace(/<!--[\s\S]*?-->/g, '').trim();
              }
              return aiResponse.trim();
            } catch (e) {
              console.error("解析显示文本时出错:", e, "原始输入:", aiResponse);
              return "[摘要解析失败]";
            }
          },

// 【工具：可重用的、健壮的标签提取函数】
           _extractLastTagContent(tagName, text, ignoreCase = false) {
               if (!text || typeof text !== 'string') return null;
               const flags = ignoreCase ? 'gi' : 'g';
               const regex = new RegExp(`<${tagName}>([\\s\\S]*?)<\\/${tagName}>`, flags);             
               const matches = [...text.matchAll(regex)];             
               if (matches.length > 0) {
                   return matches[matches.length - 1][1].trim();
               }
               return null;
           },



// ===正文/文本提取和处理模块结束===




// ===mvu语法中文转义模块开始===



           parseMvuCommands(mvuText) {
               if (!mvuText || typeof mvuText !== 'string') return [];
               const changes = [];
               const lines = mvuText.split('\n');
               const commandRegex = /_\.(set|add|assign|remove)\s*\(([^)]+)\);?/;

               for (const line of lines) {
                   const trimmedLine = line.trim();
                   const match = trimmedLine.match(commandRegex);

                   if (match) {
                       const [, type, argsString] = match;
                       const args = this._parseParameters(argsString);
                       if (args.length === 0) continue;

                       const path = args[0];
                       let description = '';

                       switch (type) {
                           case 'set':
                               if (args.length >= 2) {
                                   const value = this.formatValue(args[args.length - 1]);
                                   description = `<b>${this.translatePath(path)}</b> 设置为 <i>${value}</i>`;
                               }
                               break;
                           case 'add':
                               if (args.length >= 2) {
                                   const value = this.formatValue(args[1]);
                                   description = `<b>${this.translatePath(path)}</b> 增加了 <i>${value}</i>`;
                               }
                               break;
                           case 'assign':
                               if (args.length === 2) {
                                   const value = this.formatValue(args[1]);
                                   description = `在 <b>${this.translatePath(path)}</b> 中添加了 <i>${value}</i>`;
                               } else if (args.length >= 3) {
                                   const key = this.formatValue(args[1]);
                                   const value = this.formatValue(args[2]);
                                   description = `在 <b>${this.translatePath(path)}</b> 中，将 <i>${key}</i> 设置为 <i>${value}</i>`;
                               }
                               break;
                           case 'remove':
                               description = `移除了 <b>${this.translatePath(path)}</b>`;
                               break;
                       }
                       
                       if (description) {
                           changes.push({
                               type: type,
                               path: path,
                               description: description
                           });
                       }
                   }
               }
               return changes;
           },

// 路径翻译：将英文路径转换为中文描述
           translatePath(path) {
               const translations = {
                   '当前境界': '当前境界',
                   '境界映射': '境界映射',
                   '修为进度': '修为进度',
                   '修为瓶颈': '修为瓶颈',
                   '法力': '法力上限',
                   '当前法力': '当前法力',
                   '神海': '神海上限',
                   '当前神海': '当前神海',
                   '道心': '道心上限',
                   '当前道心': '当前道心',
                   '空速': '空速上限',
                   '当前空速': '当前空速',
                   '气运': '气运',
                   '生理年龄': '生理年龄',
                   '心理年龄': '心理年龄',
                   '当前时间纪年': '当前时间',
                   '归真数': '归真数',
                   '天赋列表': '天赋',
                   '灵根列表': '灵根',
                   '武器列表': '武器',
                   '防具列表': '防具',
                   '饰品列表': '饰品',
                   '法宝列表': '法宝',
                   '丹药列表': '丹药',
                   '其他列表': '其他物品',
                   '人物关系列表': '人物关系',
                   '当前状态': '状态效果',
                   '当前位置': '当前位置'
               };
               let translatedPath = path.replace(/\[0\]/g, '');
               const segments = translatedPath.split('.');
               const translatedSegments = segments.map(segment => {
                   return translations[segment] || segment;
               });
               
               return translatedSegments.join(' → ');
           },
           formatValue(value) {
               if (typeof value === 'string') {
                   const cleaned = value.replace(/^['"`]|['"`]$/g, '');
                   return cleaned;
               }
               return String(value);
           },
           updateVariableChangesReminder() {
               if (!this.lastExtractedVariables) {
                   this.hideVariableChangesReminder();
                   return;
               }

               const changes = this.parseMvuCommands(this.lastExtractedVariables);
               if (changes.length === 0) {
                   this.hideVariableChangesReminder();
                   return;
               }

               this.showVariableChangesReminder(changes);
           },

           showVariableChangesReminder(changes) {
               const reminder = document.getElementById('variable-changes-reminder');
               const count = document.getElementById('variable-changes-count');
               const content = document.getElementById('variable-changes-content');
               if (!reminder || !count || !content) return;
               count.textContent = changes.length;
               const changesHtml = changes.map(change => {
                   const typeText = {
                       'set': '设置',
                       'add': '增加',
                       'assign': '添加',
                       'remove': '删除'
                   }[change.type] || change.type;

                   return `
                       <div class="variable-change-item">
                           <div class="variable-change-type-icon ${change.type}">${typeText}</div>
                           <div class="variable-change-description">
                               ${change.description}
                           </div>
                       </div>
                   `;
               }).join('');

               content.innerHTML = changesHtml;
               reminder.style.display = 'block';
           },

           hideVariableChangesReminder() {
               const reminder = document.getElementById('variable-changes-reminder');
               if (reminder) {
                   reminder.style.display = 'none';
               }
           },

           _parseParameters(argsString) {
               const params = [];
               let currentParam = '';
               let inQuotes = false;
               let quoteChar = '';
               let depth = 0;

               for (let i = 0; i < argsString.length; i++) {
                   const char = argsString[i];

                   if (inQuotes) {
                       if (char === quoteChar) {
                           inQuotes = false;
                       }
                       currentParam += char;
                   } else {
                       if (char === '"' || char === "'" || char === '`') {
                           inQuotes = true;
                           quoteChar = char;
                           currentParam += char;
                       } else if (char === '{' || char === '[') {
                           depth++;
                           currentParam += char;
                       } else if (char === '}' || char === ']') {
                           depth--;
                           currentParam += char;
                       } else if (char === ',' && depth === 0) {
                           params.push(currentParam.trim());
                           currentParam = '';
                       } else {
                           currentParam += char;
                       }
                   }
               }
               if (currentParam) {
                   params.push(currentParam.trim());
               }
               return params;
           },
            toggleVariableChanges() {
                const content = document.getElementById('variable-changes-content');
                const icon = document.getElementById('variable-changes-icon');
 
                if (!content || !icon) return;
 
                const isExpanded = content.classList.contains('expanded');
                
                if (isExpanded) {
                    content.classList.remove('expanded');
                    icon.classList.add('collapsed');
                    icon.textContent = '▶';
                } else {
                    content.classList.add('expanded');
                    icon.classList.remove('collapsed');
                    icon.textContent = '▼';
                }
            },
 
            _parseParameters(argsString) {
                const params = [];
                let currentParam = '';
                let inQuotes = false;
                let quoteChar = '';
                let depth = 0;
 
                for (let i = 0; i < argsString.length; i++) {
                    const char = argsString[i];
 
                    if (inQuotes) {
                        if (char === quoteChar) {
                            inQuotes = false;
                        }
                        currentParam += char;
                    } else {
                        if (char === '"' || char === "'" || char === '`') {
                            inQuotes = true;
                            quoteChar = char;
                            currentParam += char;
                        } else if (char === '{' || char === '[') {
                            depth++;
                            currentParam += char;
                        } else if (char === '}' || char === ']') {
                            depth--;
                            currentParam += char;
                        } else if (char === ',' && depth === 0) {
                            params.push(currentParam.trim());
                            currentParam = '';
                        } else {
                            currentParam += char;
                        }
                    }
                }
                if (currentParam) {
                    params.push(currentParam.trim());
                }
                return params;
            },
 // ===mvu中文转义模块结束===




// ===历史正文显示/隐藏模块开始===
             toggleHistoricalTextDisplay() {
                const content = document.getElementById('historical-text-content');
                const icon = document.getElementById('historical-text-icon');
                const container = document.getElementById('historical-text-container');
                
                if (content && icon) {
                    const isCurrentlyHidden = content.style.display === 'none' || !content.style.display;
                    
                    if (isCurrentlyHidden) {
                        content.style.display = 'block';
                        icon.textContent = '▼';
                        if (container) container.style.maxHeight = '400px';
                    } else {
                        content.style.display = 'none';
                        icon.textContent = '▶';
                        if (container) container.style.maxHeight = 'auto';
                    }
                }
             },

             // 更新历史正文内容
             async updateHistoricalText() {
                const container = document.getElementById('historical-text-container');
                const titleContainer = document.getElementById('current-chapter-title');
                if (!container) return;

                // 如果设置为0，隐藏整个容器
                if (this.historicalTextCount === 0) {
                    container.style.display = 'none';
                    if (titleContainer) titleContainer.style.display = 'none';
                    return;
                }

                try {
                    // 从小说模式世界书读取内容
                    const bookName = '1归墟';
                    const index = this.unifiedIndex;
                    const novelModeKey = index > 1 ? `小说模式(${index})` : '小说模式';
                    const allEntries = await TavernHelper.getLorebookEntries(bookName);
                    const novelEntry = allEntries.find(entry => entry.comment === novelModeKey);

                    if (!novelEntry || !novelEntry.content) {
                        container.style.display = 'none';
                        if (titleContainer) titleContainer.style.display = 'none';
                        return;
                    }

                    // 解析小说模式内容，按章节分割
                    const novelContent = novelEntry.content;
                    const chapters = this.parseNovelChapters(novelContent);

                    if (chapters.length <= 1) { // 如果只有一章或没有，则不显示历史
                        container.style.display = 'none';
                        if (titleContainer) titleContainer.style.display = 'none';
                        return;
                    }
                    
                    // 显示最新章节标题(当前正文的标题)
                    if (titleContainer && chapters.length > 0) {
                        const currentChapter = chapters[chapters.length - 1]; // 获取最后一章(最新章节)
                        titleContainer.textContent = currentChapter.title;
                        titleContainer.style.display = 'block';
                        console.log('[归墟标题] 显示最新章节标题:', currentChapter.title);
                    }

                    // 根据设置决定显示多少章节
                    let chaptersToShow = [];
                    const historicalChapters = chapters.slice(0, -1);

                    if (this.historicalTextCount === -1) {
                        chaptersToShow = historicalChapters;
                    } else if (this.historicalTextCount > 0) {
                        const startIndex = Math.max(0, historicalChapters.length - this.historicalTextCount);
                        chaptersToShow = historicalChapters.slice(startIndex);
                    }

                    if (chaptersToShow.length === 0) {
                        container.style.display = 'none';
                        return;
                    }

                    // 渲染历史正文
                    let html = '';
                    chaptersToShow.forEach((chapter, index) => {
                        html += this.formatMessageContent(chapter.content);
                        // 在章节之间添加分隔
                        if (index < chaptersToShow.length - 1) {
                            html += '<div style="width: 100%; text-align: center; margin: 20px 0;"><span style="color: #8b7355; font-size: 12px;">...</span></div>';
                        }
                    });

                    container.innerHTML = html;
                    container.style.display = 'block';

                    // 更新章节导航状态
                    if (typeof this.updateChapterNavigation === 'function') {
                        this.updateChapterNavigation();
                    }

                } catch (error) {
                    console.error('更新历史正文时出错:', error);
                    container.style.display = 'none';
                }
             },

             

             // 加载历史正文设置
             loadHistoricalTextSettings() {
                try {
                    const savedCount = localStorage.getItem('guixu_historical_text_count');
                    if (savedCount !== null) {
                        this.historicalTextCount = parseInt(savedCount);
                    }
                    const input = document.getElementById('historical-text-count');
                    if (input) input.value = this.historicalTextCount;
                    
                    // 立即更新一次历史正文
                    this.updateHistoricalText();
                } catch (error) {
                    console.error('加载历史正文设置失败:', error);
                }
             },

             // 保存历史正文设置
             saveHistoricalTextSettings() {
                try {
                    localStorage.setItem('guixu_historical_text_count', this.historicalTextCount.toString());
                } catch (error) {
                    console.error('保存历史正文设置失败:', error);
                }
             },
// ===历史正文显示/隐藏模块结束===

// ===思维过程显示/隐藏模块开始===
             toggleThinkingDisplay() {
                const content = document.getElementById('thinking-process-content');
                const icon = document.getElementById('thinking-process-icon');

                if (!content || !icon) return;

                const isExpanded = content.classList.contains('expanded');

                if (isExpanded) {
                    content.classList.remove('expanded');
                    icon.classList.add('collapsed');
                    icon.textContent = '▶';
                } else {
                    if (this.lastExtractedThinking) {
                        try {
                            if (typeof formatAsDisplayedMessage === 'function') {
                                const cleanedContent = this.lastExtractedThinking
                                    .replace(/<thinking>/g, '')
                                    .replace(/<\/thinking>/g, '');
                                content.innerHTML = formatAsDisplayedMessage(cleanedContent);
                            } else {
                                content.innerHTML = this.simpleMarkdownParse(this.lastExtractedThinking);
                            }
                        } catch (error) {
                            console.error('Error formatting thinking content:', error);
                            content.textContent = this.lastExtractedThinking;
                        }
                        content.classList.add('expanded');
                        icon.classList.remove('collapsed');
                        icon.textContent = '▼';
                    }
                }
            },

            // ===本世历程显示/隐藏模块开始===
            toggleCurrentLifeDisplay() {
                const content = document.getElementById('current-life-content');
                const icon = document.getElementById('current-life-icon');

                if (!content || !icon) return;

                const isExpanded = content.classList.contains('expanded');

                if (isExpanded) {
                    content.classList.remove('expanded');
                    icon.classList.add('collapsed');
                    icon.textContent = '▶';
                } else {
                    if (this.lastExtractedJourney) {
                        try {
                            if (typeof formatAsDisplayedMessage === 'function') {
                                content.innerHTML = formatAsDisplayedMessage(this.lastExtractedJourney);
                            } else {
                                content.innerHTML = this.simpleMarkdownParse(this.lastExtractedJourney);
                            }
                        } catch (error) {
                            console.error('Error formatting current life content:', error);
                            content.textContent = this.lastExtractedJourney;
                        }
                        content.classList.add('expanded');
                        icon.classList.remove('collapsed');
                        icon.textContent = '▼';
                    }
                }
            },

            updateCurrentLifeButtonVisibility() {
                const container = document.getElementById('current-life-container');
                if (container) {
                    if (this.lastExtractedJourney && this.lastExtractedJourney.trim() !== '') {
                        container.style.display = 'block';
                    } else {
                        container.style.display = 'none';
                    }
                }
            },
            // ===本世历程显示/隐藏模块结束===

            // ===往世涟漪显示/隐藏模块开始===
            togglePastLivesDisplay() {
                const content = document.getElementById('past-lives-content');
                const icon = document.getElementById('past-lives-icon');

                if (!content || !icon) return;

                const isExpanded = content.classList.contains('expanded');

                if (isExpanded) {
                    content.classList.remove('expanded');
                    icon.classList.add('collapsed');
                    icon.textContent = '▶';
                } else {
                    if (this.lastExtractedPastLives) {
                        try {
                            if (typeof formatAsDisplayedMessage === 'function') {
                                content.innerHTML = formatAsDisplayedMessage(this.lastExtractedPastLives);
                            } else {
                                content.innerHTML = this.simpleMarkdownParse(this.lastExtractedPastLives);
                            }
                        } catch (error) {
                            console.error('Error formatting past lives content:', error);
                            content.textContent = this.lastExtractedPastLives;
                        }
                        content.classList.add('expanded');
                        icon.classList.remove('collapsed');
                        icon.textContent = '▼';
                    }
                }
            },

            updatePastLivesButtonVisibility() {
                const container = document.getElementById('past-lives-container');
                if (container) {
                    if (this.lastExtractedPastLives && this.lastExtractedPastLives.trim() !== '') {
                        container.style.display = 'block';
                    } else {
                        container.style.display = 'none';
                    }
                }
            },
            // ===往世涟漪显示/隐藏模块结束===

            updateThinkingButtonVisibility() {
                const container = document.getElementById('thinking-process-container');
                if (container) {
                    if (this.lastExtractedThinking && this.lastExtractedThinking.trim() !== '') {
                        container.style.display = 'block';
                    } else {
                        container.style.display = 'none';
                    }
                }
            },
//思维过程持久化
            saveLastThinking() {
                try {
                    if (this.lastExtractedThinking) {
                        localStorage.setItem('guixu_last_thinking', this.lastExtractedThinking);
                    } else {
                        localStorage.removeItem('guixu_last_thinking');
                    }
                } catch (e) {
                    console.error('保存思维过程失败:', e);
                }
            },

            loadLastThinking() {
                try {
                    this.lastExtractedThinking = localStorage.getItem('guixu_last_thinking') || null;
                } catch (e) {
                    console.error('加载思维过程失败:', e);
                    this.lastExtractedThinking = null;
                }
            },
// ===思维过程显示/隐藏模块结束===



//===存档模块开始===
          async showNewSaveLoadManager() {
            this.openModal('save-load-modal');
            
            // 应用全屏样式
            const rootContainer = document.querySelector('.guixu-root-container');
            const modalContent = document.querySelector('#save-load-modal .modal-content');
            if (rootContainer && modalContent) {
                const rect = rootContainer.getBoundingClientRect();
                modalContent.style.setProperty('width', `${rect.width}px`, 'important');
                modalContent.style.setProperty('height', `${rect.height}px`, 'important');
                modalContent.style.setProperty('top', `${rect.top}px`, 'important');
                modalContent.style.setProperty('left', `${rect.left}px`, 'important');
                modalContent.style.setProperty('max-width', 'none', 'important');
                modalContent.style.setProperty('max-height', 'none', 'important');
            }
            
            // 初始化系列选择器
            this.initializeSeriesSelector();
            
            // 当前选中的系列(默认为空字符串代表"无系列")
            if (!this.activeSeries) {
                this.activeSeries = '';
            }
            
            // 渲染系列列表(左侧tabs)
            this.renderSeriesTabs();
            
            // 渲染存档列表(右侧内容)
            await this.renderSavesForSeries(this.activeSeries);
          },
          
          // 渲染系列标签页
          renderSeriesTabs() {
              const tabsContainer = document.getElementById('series-tabs');
              if (!tabsContainer) return;
              
              const allSeries = this.loadSeriesList();
              
              let html = '';
              
              // "无系列"选项卡
              html += `
                  <div class="series-tab ${this.activeSeries === '' ? 'active' : ''}" data-series-id="">
                      无系列
                  </div>
              `;
              
              // 其他系列选项卡
              allSeries.forEach(series => {
                  html += `
                      <div class="series-tab ${this.activeSeries === series.seriesId ? 'active' : ''}" data-series-id="${series.seriesId}">
                          ${series.name}
                      </div>
                  `;
              });
              
              tabsContainer.innerHTML = html;
              
              // 绑定点击事件
              tabsContainer.querySelectorAll('.series-tab').forEach(tab => {
                  tab.addEventListener('click', async () => {
                      const seriesId = tab.getAttribute('data-series-id');
                      this.activeSeries = seriesId;
                      this.renderSeriesTabs();
                      await this.renderSavesForSeries(seriesId);
                  });
              });
          },
          
          // 渲染指定系列的存档列表
          async renderSavesForSeries(seriesId) {
              const container = document.getElementById('new-save-load-container');
              if (!container) return;
              
              container.innerHTML = '<div class="loader">正在加载存档...</div>';
              
              const allSaves = await this.getAllGameSaves();
              
              // 筛选出属于当前系列的存档(兼容旧版本:没有series字段的存档算作"无系列")
              const filteredSaves = allSaves.filter(save => {
                  const saveSeries = save.series || '';
                  return saveSeries === seriesId;
              });
              
              if (filteredSaves.length === 0) {
                  container.innerHTML = '<div class="empty-save-list">该系列暂无存档</div>';
                  return;
              }
              
              let html = '<div class="accordion">';
              filteredSaves.forEach(save => {
                  const date = new Date(save.timestamp).toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' });
                  const saveType = save.auto_generated ? '自动' : '手动';
                  const saveColor = save.auto_generated ? '#8b7355' : '#c9aa71';
                  const novelContent = save.worldbook_contents?.novel_mode || '';
                  const summary = novelContent ? (novelContent.length > 50 ? '...' : '') + novelContent.substring(novelContent.length - 50) : '暂无摘要';

                  html += `
                      <div class="accordion-item" data-save-id="${save.id}">
                          <div class="accordion-header">
                              <div class="save-header-info">
                                  <div class="save-header-top">
                                      <span class="save-name" style="color: ${saveColor};">${save.name}</span>
                                      <span class="save-time">${date}</span>
                                      <span class="save-type">[${saveType}]</span>
                                  </div>
                                  <div class="save-summary">${summary}</div>
                              </div>
                              <div class="save-header-actions">
                                  <button class="btn-load-new">读档</button>
                                  <button class="btn-rename-new">命名</button>
                                  <button class="btn-delete-new">删除</button>
                                  <button class="btn-export-new">导出</button>
                              </div>
                          </div>
                          <div class="accordion-content">
                  `;

                  const contentMap = [
                      { key: 'novel_mode', title: '小说模式', content: save.worldbook_contents?.novel_mode || '', charLimit: 50 },
                      { key: 'journey', title: '本世历程', content: save.worldbook_contents?.journey || '', charLimit: 200 },
                      { key: 'past_lives', title: '往世涟漪', content: save.worldbook_contents?.past_lives || '', charLimit: 200 },
                      { key: 'segmented_content', title: '分段正文', content: save.worldbook_contents?.segmented_content || '', charLimit: 200 },
                      { key: 'large_summary', title: '大总结', content: save.worldbook_contents?.large_summary || '', charLimit: 200 },
                      { key: 'small_summary', title: '小总结', content: save.worldbook_contents?.small_summary || '', charLimit: 200 }
                  ];

                  html += '<div class="content-grid" style="display: none;">';
                  contentMap.forEach(item => {
                      const content = item.content || '';
                      const summary = content ? (content.length > item.charLimit ? '...' : '') + content.substring(content.length - item.charLimit) : '无内容';
                      html += `
                          <details class="content-preview">
                              <summary>${item.title} <span class="char-count">(${item.content.length}字)</span></summary>
                              <div class="content-full">${item.content.replace(/\n/g, '<br>')}</div>
                          </details>
                      `;
                  });
                  html += '</div>';

                  html += '</div></div>';
              });
              html += '</div>';

              container.innerHTML = html;
          },
          
          // 显示系列管理界面
          showSeriesManager() {
              this.openModal('series-manager-modal', true); // 保持存档界面打开
              this.renderSeriesManagerList();
              
              // 绑定添加系列按钮事件
              const addBtn = document.getElementById('btn-add-series');
              if (addBtn && !addBtn.hasAttribute('data-bound')) {
                  addBtn.setAttribute('data-bound', 'true');
                  addBtn.addEventListener('click', () => {
                      this.promptAddSeries();
                  });
              }
          },
          
          // 关闭系列管理界面,返回存档界面
          closeSeriesManager() {
              this.closeModal('series-manager-modal');
              this.showNewSaveLoadManager(); // 刷新存档界面以显示更新后的系列
          },
          
          // 渲染系列管理列表
          renderSeriesManagerList() {
              const container = document.getElementById('series-list');
              if (!container) return;
              
              const allSeries = this.loadSeriesList();
              
              if (allSeries.length === 0) {
                  container.innerHTML = '<div class="empty-save-list">暂无系列</div>';
                  return;
              }
              
              let html = '';
              allSeries.forEach(series => {
                  html += `
                      <div class="series-item" data-series-id="${series.seriesId}">
                          <div class="series-item-name">${series.name}</div>
                          <div class="series-item-actions">
                              <button class="btn-rename-series" data-series-id="${series.seriesId}">重命名</button>
                              <button class="btn-delete-series" data-series-id="${series.seriesId}">删除</button>
                          </div>
                      </div>
                  `;
              });
              
              container.innerHTML = html;
              
              // 绑定重命名按钮事件
              container.querySelectorAll('.btn-rename-series').forEach(btn => {
                  btn.addEventListener('click', (e) => {
                      const seriesId = e.target.getAttribute('data-series-id');
                      const series = allSeries.find(s => s.seriesId === seriesId);
                      if (series) {
                          this.promptRenameSeries(seriesId, series.name);
                      }
                  });
              });
              
              // 绑定删除按钮事件
              container.querySelectorAll('.btn-delete-series').forEach(btn => {
                  btn.addEventListener('click', async (e) => {
                      const seriesId = e.target.getAttribute('data-series-id');
                      const series = allSeries.find(s => s.seriesId === seriesId);
                      if (series) {
                          this.showCustomConfirm(
                              `确定要删除系列"${series.name}"吗?该系列下的所有存档将变为"无系列"。`,
                              async () => {
                                  await this.deleteSeries(seriesId);
                                  this.renderSeriesManagerList();
                              },
                              null,
                              true
                          );
                      }
                  });
              });
          },
          // 提示用户输入新系列名称
          async promptAddSeries() {
              const name = await this.promptForSeriesName('添加新系列');
              if (name) {
                  const result = this.addSeries(name);
                  if (result) {
                      this.renderSeriesManagerList();
                      this.initializeSeriesSelector(); // 更新选择器
                  }
              }
          },
          
          // 提示用户重命名系列
          async promptRenameSeries(seriesId, oldName) {
              const newName = await this.promptForSeriesName('重命名系列', oldName);
              if (newName && newName !== oldName) {
                  if (this.renameSeries(seriesId, newName)) {
                      this.renderSeriesManagerList();
                      this.initializeSeriesSelector(); // 更新选择器
                  }
              }
          },
          // 提示用户输入系列名称（自定义模态框）
          async promptForSeriesName(title, defaultValue = '') {
            return new Promise((resolve) => {
              const modal = document.getElementById('series-name-modal');
              const titleEl = document.getElementById('series-name-modal-title');
              const inputEl = document.getElementById('series-name-input');
              const confirmBtn = document.getElementById('series-name-confirm-btn');
              const cancelBtn = document.getElementById('series-name-cancel-btn');
              const closeBtn = modal.querySelector('.modal-close-btn');
              titleEl.textContent = title;
              inputEl.value = defaultValue;

              const cleanup = () => {
                this.closeModal('series-name-modal');
                // 返回到存档界面
                this.showNewSaveLoadManager();
                confirmBtn.replaceWith(confirmBtn.cloneNode(true));
                cancelBtn.replaceWith(cancelBtn.cloneNode(true));
                closeBtn.replaceWith(closeBtn.cloneNode(true));
              };

              confirmBtn.onclick = () => {
                const value = inputEl.value.trim();
                if (value) {
                  cleanup();
                  resolve(value);
                } else {
                  this.showTemporaryMessage('名称不能为空');
                }
              };

              cancelBtn.onclick = () => {
                cleanup();
                resolve(null);
              };

              closeBtn.onclick = () => {
                cleanup();
                resolve(null);
              };

              this.openModal('series-name-modal', true);
              
              // 设置模态框尺寸 - 使其更小更符合直觉
              const modalContent = modal.querySelector('.modal-content');
              if (modalContent) {
                modalContent.style.setProperty('width', '350px', 'important');
                modalContent.style.setProperty('max-width', '90%', 'important');
                modalContent.style.setProperty('height', 'auto', 'important');
              }
              
              setTimeout(() => inputEl.focus(), 100);
            });
          },
                
          // 提示用户重命名系列
          promptRenameSeries(seriesId, oldName) {
              const newName = prompt(`请输入新的系列名称:`, oldName);
              if (newName && newName.trim() && newName.trim() !== oldName) {
                  if (this.renameSeries(seriesId, newName.trim())) {
                      this.renderSeriesManagerList();
                      this.initializeSeriesSelector(); // 更新选择器
                  }
              }
          },
          getSavesFromStorage() {
            try {
              const saves = localStorage.getItem('guixu_multi_save_data');
              return saves ? JSON.parse(saves) : {};
            } catch (e) {
              console.error("获取存档失败:", e);
              return {};
            }
          },

          async saveGame(isAutoSave = false, customName = null) {
            try {
              console.log('[归墟存档] 开始新版存档流程，自动存档:', isAutoSave);

              // 获取当前MVU数据和消息内容
              let currentMvuData = this.currentMvuState;
              let currentMessageContent = '';
              
              if (!currentMvuData) {
                console.log('[归墟存档] 缓存状态为空，尝试从消息获取...');
                const messages = await getChatMessages(getCurrentMessageId());
                if (!messages || messages.length === 0) {
                  this.showTemporaryMessage('错误：无法获取当前消息数据，无法存档。');
                  return false;
                }
                currentMvuData = messages[0].data;
                currentMessageContent = messages[0].message || '';
              } else {
                // 如果有缓存状态，也尝试获取当前消息内容
                try {
                  const messages = await getChatMessages(getCurrentMessageId());
                  if (messages && messages.length > 0) {
                    currentMessageContent = messages[0].message || '';
                  }
                } catch (e) {
                  console.warn('[归墟存档] 获取消息内容失败，使用空内容:', e);
                }
              }
              
              if (!currentMvuData || !currentMvuData.stat_data) {
                this.showTemporaryMessage('错误：MVU数据不完整，无法存档。请先进行一次游戏操作。');
                return false;
              }

              // 获取六大核心世界书条目的内容
              const bookName = '1归墟';
              const index = this.unifiedIndex;
              const journeyKey = index > 1 ? `本世历程(${index})` : '本世历程';
              const pastLivesKey = index > 1 ? `往世涟漪(${index})` : '往世涟漪';
              const novelModeKey = index > 1 ? `小说模式(${index})` : '小说模式';
              const segmentedKey = index > 1 ? `分段正文(${index})` : '分段正文';
              const largeSummaryKey = index > 1 ? `大总结(${index})` : '大总结';
              const smallSummaryKey = index > 1 ? `小总结(${index})` : '小总结';

              let worldbookContents = {
                journey: '',
                past_lives: '',
                novel_mode: '',
                segmented_content: '',
                large_summary: '',
                small_summary: ''
              };

              try {
                const allEntries = await TavernHelper.getLorebookEntries(bookName);
                const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);
                const pastLivesEntry = allEntries.find(entry => entry.comment === pastLivesKey);
                const novelModeEntry = allEntries.find(entry => entry.comment === novelModeKey);
                const segmentedEntry = allEntries.find(entry => entry.comment === segmentedKey);
                const largeSummaryEntry = allEntries.find(entry => entry.comment === largeSummaryKey);
                const smallSummaryEntry = allEntries.find(entry => entry.comment === smallSummaryKey);

                worldbookContents.journey = journeyEntry?.content || '';
                worldbookContents.past_lives = pastLivesEntry?.content || '';
                worldbookContents.novel_mode = novelModeEntry?.content || '';
                worldbookContents.segmented_content = segmentedEntry?.content || '';
                worldbookContents.large_summary = largeSummaryEntry?.content || '';
                worldbookContents.small_summary = smallSummaryEntry?.content || '';

                console.log('[归墟存档] 世界书内容获取完成，各条目长度:');
                console.log('- 本世历程:', worldbookContents.journey.length);
                console.log('- 往世涟漪:', worldbookContents.past_lives.length);
                console.log('- 小说模式:', worldbookContents.novel_mode.length);
                console.log('- 分段正文:', worldbookContents.segmented_content.length);
                console.log('- 大总结:', worldbookContents.large_summary.length);
                console.log('- 小总结:', worldbookContents.small_summary.length);

              } catch (e) {
                console.error("获取世界书内容时出错:", e);
                this.showTemporaryMessage("警告：获取世界书内容失败，存档可能不完整。");
              }

              // 确定存档名称
              let saveName;
              let defaultName = '';
              const chapters = this.parseNovelChapters(worldbookContents.novel_mode);
              if (chapters.length > 0) {
                defaultName = chapters[chapters.length - 1].title;
              }

              if (isAutoSave) {
                saveName = defaultName || `自动存档 ${new Date().toLocaleString('zh-CN', {month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit'})}`;
              } else {
                // 手动存档
                saveName = await this.promptForSaveName(defaultName);
                if (!saveName) {
                  this.showTemporaryMessage('存档已取消');
                  return false;
                }
              }

              // 构建新的存档数据结构
              const saveData = {
                id: this.generateSaveId(),
                name: saveName,
                timestamp: new Date().toISOString(),
                auto_generated: isAutoSave,
                series: this.currentSeries || '', // 添加系列字段
                
                // 保持原有数据结构
                message_content: currentMessageContent,
                mvu_data: _.cloneDeep({
                  stat_data: currentMvuData.stat_data,
                  schema: currentMvuData.schema,
                  initialized_lorebooks: currentMvuData.initialized_lorebooks,
                  display_data: currentMvuData.display_data,
                  delta_data: currentMvuData.delta_data,
                }),
                gacha_data: {
                  state: _.cloneDeep(this.gachaState),
                  collection: _.cloneDeep(this.gachaCollection),
                  history: _.cloneDeep(this.gachaHistory)
                },
                
                // 世界书内容直接存档
                worldbook_contents: _.cloneDeep(worldbookContents)
              };

              // 去重检查
              if (await this.isDuplicateSave(saveData)) {
                console.log('[归墟存档] 检测到重复存档，跳过保存');
                if (!isAutoSave) {
                  this.showTemporaryMessage('检测到与最近存档内容相同，跳过保存');
                }
                return false;
              }
              // 保存到存储
              const success = await this.saveGameToStorage(saveData);    
              if (success) {
                const saveTypeText = isAutoSave ? '自动存档' : '手动存档';
                this.showTemporaryMessage(`${saveTypeText}"${saveName}"保存成功`);
                if (document.getElementById('save-load-modal').style.display !== 'none') {
                  this.showNewSaveLoadManager();
                }
                console.log(`[归墟存档] ${saveTypeText}成功:`, saveName);
                return true;
              } else {
                this.showTemporaryMessage('存档保存失败，请稍后重试');
                return false;
              }
            } catch (error) {
              console.error('[归墟存档] 存档过程出错:', error);
              this.showTemporaryMessage(`存档失败: ${error.message}`);
              return false;
            }
          },
          async loadGame(saveId) {
            try {
              // 兼容新旧存档格式
              let saveData;              
              // 检查是否为新格式存档ID
              if (saveId.startsWith('save_')) {
                // 新格式：从新存储系统获取
                const allSaves = await this.getAllGameSaves();
                saveData = allSaves.find(save => save.id === saveId);
              } else {
                // 旧格式：从旧存储系统获取
                const allSaves = this.getSavesFromStorage();
                saveData = allSaves[saveId];
              }
              
              if (!saveData) {
                this.showTemporaryMessage('没有找到存档文件。');
                return false;
              }

              const saveName = saveData.name || saveData.save_name || `存档${saveId}`;
              
              this.showCustomConfirm(`确定要读取存档"${saveName}"吗？当前所有未保存的进度将会被覆盖。`, async () => {
                try {
                  console.log(`[归墟无缝读档] 开始读取存档"${saveName}"`);          
                  const messages = await getChatMessages(getCurrentMessageId());
                  if (!messages || messages.length === 0) {
                    this.hideWaitingMessage();
                    this.showTemporaryMessage('错误：无法获取当前消息，无法读档。');
                    return;
                  }                
                  const messageZero = messages[0];
                  const loadedData = saveData.mvu_data;
                  const loadedMessageContent = saveData.message_content || '';

                  // 1. 更新消息数据（使用无刷新模式）
                  messageZero.data = loadedData;
                  messageZero.message = loadedMessageContent;

                  // 2. 恢复世界书数据
                  this.updateWaitingMessage('正在恢复世界书数据...');
                  
                  if (saveData.worldbook_contents) {
                    // 新格式：从嵌入的世界书内容恢复
                    await this.restoreWorldbookFromEmbedded(saveData.worldbook_contents);
                  } else if (saveData.lorebook_entries) {
                    // 旧格式：从独立世界书条目恢复
                    await this.restoreWorldbookFromEntries(saveData.lorebook_entries);
                  }
                  // 3. 无缝更新消息数据（关键：使用 refresh: 'none'）
                  this.updateWaitingMessage('正在更新界面数据...');
                  await TavernHelper.setChatMessages([messageZero], { refresh: 'none' });                
                  // 4. 直接更新MVU状态和UI（无需重新初始化）
                  this.currentMvuState = this._safeLoadMvuData(loadedData);                  
                  // 恢复Gacha状态到内存
                  if (saveData.gacha_data) {
                    this._loadGachaDataFromSave(saveData);
                  }                  
                  // 5. 直接更新游戏文本显示
                  const gameTextDisplay = document.getElementById('game-text-display');
                  if (gameTextDisplay && loadedMessageContent) {
                    const displayText = this._getDisplayText(loadedMessageContent);
                    gameTextDisplay.innerHTML = this.formatMessageContent(displayText);
                    this.updateLiveWordCount();                    
                    // 更新有效内容缓存，支持后续回退功能
                    this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
                  }                
                  // 6. 更新UI显示（只更新必要部分，保持其他状态）
                  this.renderUI(this.currentMvuState.stat_data);                  
                  // 7. 提取并更新相关内容
                  if (loadedMessageContent) {
                    this.lastExtractedNovelText = this._extractLastTagContent('gametxt', loadedMessageContent);
                    this.lastExtractedJourney = this._extractLastTagContent('本世历程', loadedMessageContent);
                    this.lastExtractedPastLives = this._extractLastTagContent('往世涟漪', loadedMessageContent);
                    this.lastExtractedThinking = this._extractLastTagContent('thinking', loadedMessageContent, true);
                    this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', loadedMessageContent, true);
                    
                    // 🔧 修复：提取并渲染行动选项
                    let actionOptionsContent = this._extractLastTagContent('行动选项', loadedMessageContent);
                    if (!actionOptionsContent) {
                      actionOptionsContent = this._extractLastTagContent('action', loadedMessageContent);
                    }
                    this.renderActionOptions(actionOptionsContent);
                    
                    // 🔧 修复：如果思维链已展开,立即渲染新内容到DOM
                    const thinkingContent = document.getElementById('thinking-process-content');
                    if (thinkingContent && thinkingContent.classList.contains('expanded') && this.lastExtractedThinking) {
                      try {
                        if (typeof formatAsDisplayedMessage === 'function') {
                          const cleanedContent = this.lastExtractedThinking
                            .replace(/<thinking>/g, '')
                            .replace(/<\/thinking>/g, '');
                          thinkingContent.innerHTML = formatAsDisplayedMessage(cleanedContent);
                        } else {
                          thinkingContent.innerHTML = this.simpleMarkdownParse(this.lastExtractedThinking);
                        }
                      } catch (error) {
                        console.error('Error formatting thinking content:', error);
                        thinkingContent.textContent = this.lastExtractedThinking;
                      }
                    }
                    
                    // 更新相关UI组件
                    this.updateThinkingButtonVisibility();
                    this.updateCurrentLifeButtonVisibility(); // 新增:更新本世历程按钮显示
                    this.updatePastLivesButtonVisibility(); // 新增:更新往世涟漪按钮显示
                    this.updateVariableChangesReminder();
                  }
                  // 8. 更新历史正文和章节标题
                  await this.updateHistoricalText();
                  
                  // 9. 触发分段记忆更新
                  if (this.isSegmentedMemoryAutoGenerateEnabled) {
                      console.log('[归墟] 读档完成，触发分段记忆更新...');
                      await this.generateSegmentedMemory(false);
                  }
                  this.hideWaitingMessage();
                  this.showTemporaryMessage(`无缝读档"${saveName}"成功！`);                
                  // 9. 读档完成后关闭存档界面，显示主界面
                  this.closeAllModals();                
                  return true;
                } catch (error) {
                  console.error('无缝读档失败:', error);
                  this.hideWaitingMessage();
                  this.showTemporaryMessage(`读档失败: ${error.message}`);
                  return false;
                }
              });              
            } catch (error) {
              console.error('[归墟读档] 读档过程出错:', error);
              this.showTemporaryMessage(`读档失败: ${error.message}`);
              return false;
            }
          },
          // 从嵌入的世界书内容恢复（新格式）
          async restoreWorldbookFromEmbedded(worldbookContents) {
            try {
              const bookName = '1归墟';
              const index = this.unifiedIndex;              
              const worldbookKeys = {
                journey: index > 1 ? `本世历程(${index})` : '本世历程',
                past_lives: index > 1 ? `往世涟漪(${index})` : '往世涟漪',
                novel_mode: index > 1 ? `小说模式(${index})` : '小说模式',
                segmented_content: index > 1 ? `分段正文(${index})` : '分段正文',
                large_summary: index > 1 ? `大总结(${index})` : '大总结',
                small_summary: index > 1 ? `小总结(${index})` : '小总结'
              };
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const entriesToUpdate = [];
              const entriesToCreate = [];
              // 处理六个核心条目
              for (const [contentKey, entryKey] of Object.entries(worldbookKeys)) {
                const contentToRestore = worldbookContents[contentKey] || '';
                const existingEntry = allEntries.find(entry => entry.comment === entryKey);

                if (existingEntry) {
                  entriesToUpdate.push({
                    uid: existingEntry.uid,
                    content: contentToRestore
                  });
                  console.log(`[归墟无缝读档] 更新${entryKey}条目，内容长度: ${contentToRestore.length}`);
                } else {
                  // 创建新条目
                  const newEntry = {
                    comment: entryKey,
                    content: contentToRestore,
                    keys: [entryKey],
                    enabled: contentKey === 'novel_mode' ? false : true, // 小说模式默认禁用
                    position: 'before_character_definition',
                    order: this.getEntryOrder(contentKey)
                  };
                  entriesToCreate.push(newEntry);
                  console.log(`[归墟无缝读档] 创建${entryKey}条目，内容长度: ${contentToRestore.length}`);
                }
              }
              // 批量更新和创建
              if (entriesToUpdate.length > 0) {
                await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
              }
              if (entriesToCreate.length > 0) {
                await TavernHelper.createLorebookEntries(bookName, entriesToCreate);
              }

              console.log(`[归墟无缝读档] 世界书内容恢复完成，更新${entriesToUpdate.length}个，创建${entriesToCreate.length}个条目`);

            } catch (e) {
              console.error("从嵌入内容恢复世界书数据时出错:", e);
              this.showTemporaryMessage("警告：恢复世界书数据失败，但主数据已恢复。");
            }
          },

          // 从独立条目恢复（旧格式兼容）
          async restoreWorldbookFromEntries(lorebookEntries) {
            try {
              const bookName = '1归墟';
              const currentIndex = this.unifiedIndex;
              const currentJourneyKey = currentIndex > 1 ? `本世历程(${currentIndex})` : '本世历程';
              const currentPastLivesKey = currentIndex > 1 ? `往世涟漪(${currentIndex})` : '往世涟漪';
              const currentNovelModeKey = currentIndex > 1 ? `小说模式(${currentIndex})` : '小说模式';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const saveJourneyEntry = allEntries.find(entry => entry.comment === lorebookEntries.journey_entry_name);
              const savePastLivesEntry = allEntries.find(entry => entry.comment === lorebookEntries.past_lives_entry_name);
              const saveNovelModeEntry = allEntries.find(entry => entry.comment === lorebookEntries.novel_mode_entry_name);          
              const currentJourneyEntry = allEntries.find(entry => entry.comment === currentJourneyKey);
              const currentPastLivesEntry = allEntries.find(entry => entry.comment === currentPastLivesKey);
              const currentNovelModeEntry = allEntries.find(entry => entry.comment === currentNovelModeKey);          
              const entriesToUpdate = [];
              if (saveJourneyEntry) {
                const contentToRestore = saveJourneyEntry.content || '';
                if (currentJourneyEntry) {
                  entriesToUpdate.push({
                    uid: currentJourneyEntry.uid,
                    content: contentToRestore
                  });
                } else {
                  await TavernHelper.createLorebookEntries(bookName, [{
                    comment: currentJourneyKey,
                    content: contentToRestore,
                    keys: [currentJourneyKey],
                    enabled: true,
                    position: 'before_character_definition',
                    order: 20
                  }]);
                }
              }
              
              if (savePastLivesEntry) {
                const contentToRestore = savePastLivesEntry.content || '';
                if (currentPastLivesEntry) {
                  entriesToUpdate.push({
                    uid: currentPastLivesEntry.uid,
                    content: contentToRestore
                  });
                } else {
                  await TavernHelper.createLorebookEntries(bookName, [{
                    comment: currentPastLivesKey,
                    content: contentToRestore,
                    keys: [currentPastLivesKey],
                    enabled: true,
                    position: 'before_character_definition',
                    order: 19
                  }]);
                }
              }

              if (saveNovelModeEntry) {
                const contentToRestore = saveNovelModeEntry.content || '';
                if (currentNovelModeEntry) {
                  entriesToUpdate.push({
                    uid: currentNovelModeEntry.uid,
                    content: contentToRestore
                  });
                } else {
                  await TavernHelper.createLorebookEntries(bookName, [{
                    comment: currentNovelModeKey,
                    content: contentToRestore,
                    keys: [currentNovelModeKey],
                    enabled: false,
                    position: 'before_character_definition',
                    order: 18
                  }]);
                }
              }              
              if (entriesToUpdate.length > 0) {
                await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
              }            
            } catch (e) {
              this.showTemporaryMessage("警告：恢复世界书数据失败，但主数据已恢复。");
            }
          },
          getEntryOrder(contentKey) {
            const orderMap = {
              journey: 20,
              past_lives: 19,
              novel_mode: 18,
              segmented_content: 17,
              large_summary: 16,
              small_summary: 15
            };
            return orderMap[contentKey] || 10;
          },
          async renameSave(saveId) {
            const allSaves = await this.getAllGameSaves();
            const saveData = allSaves.find(save => save.id === saveId);
            if (!saveData) {
                this.showTemporaryMessage('未找到存档，无法重命名。');
                return;
            }
            const newName = await this.promptForSaveName(saveData.name, '重命名存档');
            if (newName && newName !== saveData.name) {
                saveData.name = newName;
                await this.saveGameToStorage(saveData);
                this.showTemporaryMessage('存档已重命名。');
                this.showNewSaveLoadManager();
            }
          },
          async deleteGameSave(saveId) {
            try {
                if (this.dbAvailable && this.db) {
                    await this.db.game_saves.delete(saveId);
                } else {
                    const allSaves = this.getLocalStorageGameSaves();
                    delete allSaves[saveId];
                    localStorage.setItem('guixu_new_save_data', JSON.stringify(allSaves));
                }
                 return true;
            } catch (error) {
                console.error('[归墟存档] 删除存档失败:', error);
                return false;
            }
          },
          async deleteAllSaves() {
            try {
                if (this.dbAvailable && this.db) {
                    await this.db.game_saves.clear();
                } else {
                    localStorage.removeItem('guixu_new_save_data');
                }
                return true;
            } catch (error) {
                console.error('[归墟存档] 清除所有存档失败:', error);
                return false;
            }
          },
          clearAllSaves() {
            this.showCustomConfirm(`你确定要清除所有存档吗？这个操作不可恢复。`, () => {
              try {
                localStorage.removeItem('guixu_multi_save_data');
                this.showTemporaryMessage(`所有存档已清除。`);
                this.showSaveLoadManager(); 
              } catch (error) {
                console.error('清除所有存档失败:', error);
                this.showTemporaryMessage(`清除存档失败: ${error.message}`);
              }
            });
          },
          // 存档命名输入框
          async promptForSaveName(defaultName = '', title = '存档命名') {
            return new Promise((resolve) => {
              try {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.display = 'flex';
                modal.style.zIndex = '2000';
                modal.innerHTML = `
                  <div class="modal-content" style="width: 400px; height: auto; max-height: none;">
                    <div class="modal-header">
                      <h2 class="modal-title">${title}</h2>
                    </div>
                    <div class="modal-body" style="padding: 20px;">
                      <p style="margin-bottom: 15px; color: #c9aa71;">请输入存档名称：</p>
                      <input type="text" id="save-name-input" value="${defaultName}" placeholder="例如：突破金丹期"
                             style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355;
                                    color: #e0dcd1; border-radius: 4px; font-size: 14px; margin-bottom: 15px;">
                      <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="save-name-cancel" class="interaction-btn">取消</button>
                        <button id="save-name-confirm" class="interaction-btn primary-btn">确认</button>
                      </div>
                    </div>
                  </div>
                `;

                const container = document.querySelector('.guixu-root-container');
                if (!container) {
                  console.error('[归墟存档] 找不到根容器');
                  resolve(null);
                  return;
                }
                container.appendChild(modal);

                const input = modal.querySelector('#save-name-input');
                const confirmBtn = modal.querySelector('#save-name-confirm');
                const cancelBtn = modal.querySelector('#save-name-cancel');

                if (!input || !confirmBtn || !cancelBtn) {
                  console.error('[归墟存档] 模态框元素创建失败');
                  modal.remove();
                  resolve(null);
                  return;
                }
                confirmBtn.addEventListener('click', () => {
                  const saveName = input.value.trim();
                  if (!saveName) {
                    this.showTemporaryMessage('请输入存档名称');
                    return;
                  }
                  console.log('[归墟存档] 用户输入存档名称:', saveName);
                  modal.remove();
                  resolve(saveName);
                });
                cancelBtn.addEventListener('click', () => {
                  modal.remove();
                  resolve(null);
                });
                input.addEventListener('keypress', (e) => {
                  if (e.key === 'Enter') {
                    confirmBtn.click();
                  }
                });
                setTimeout(() => {
                  try {
                    input.focus();
                  } catch (e) {
                    console.warn('[归墟存档] 自动聚焦失败:', e);
                  }
                }, 100);

              } catch (error) {
                console.error('[归墟存档] 创建存档命名对话框时出错:', error);
                resolve(null);
              }
            });
          },

// 【自动存档核心模块】
          saveAutoSaveState() {
            try {
              localStorage.setItem('guixu_auto_save_enabled', this.isAutoSaveEnabled);
            } catch (e) {
              console.error('保存自动存档状态失败:', e);
            }
          },
          loadAutoSaveState() {
            try {
              const savedState = localStorage.getItem('guixu_auto_save_enabled');
              this.isAutoSaveEnabled = savedState === 'true'; // 默认为 true
              const checkbox = document.getElementById('auto-save-checkbox');
              if (checkbox) {
                checkbox.checked = this.isAutoSaveEnabled;
              }
            } catch (e) {
              console.error('加载自动存档状态失败:', e);
              this.isAutoSaveEnabled = false;
            }
          },
          async performAutoSave() {
            try {
              if (!this.isAutoSaveEnabled) {
                console.log('[归墟自动存档] 自动存档已禁用，跳过');
                return;
              }
              console.log('[归墟] 执行自动存档...');
              const success = await this.saveGame(true);
              if (success) {
                  console.log('[归墟] 自动存档完成。');
                  this.showTemporaryMessage('已自动存档');
              }
            } catch (error) {
                console.error('自动存档失败:', error);
                this.showTemporaryMessage('自动存档失败');
            }
          },

// 【存档导入/导出模块】
          async exportSave(saveId) {
            this.showTemporaryMessage('正在准备导出数据...', 2000);
            try {
                const allSaves = await this.getAllGameSaves();
                const saveData = allSaves.find(save => save.id === saveId);
                if (!saveData) {
                    this.showTemporaryMessage('错误：找不到要导出的存档数据。');
                    return;
                }
                // 添加导出格式标识，便于验证
                const exportData = {
                    exportVersion: '2.0',
                    exportTime: new Date().toISOString(),
                    saveData: saveData
                };
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);                
                const a = document.createElement('a');
                a.href = url;
                const safeSaveName = (saveData.name || saveId).replace(/[^a-z0-9_\-\u4e00-\u9fa5]/gi, '_');
                a.download = `归墟存档_${safeSaveName}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.showTemporaryMessage('存档已成功导出！');
                console.log('[归墟导出] 存档导出成功:', saveData.name);
            } catch (error) {
                console.error('[归墟导出] 导出存档时出错:', error);
                this.showTemporaryMessage(`导出失败: ${error.message}`);
            }
          },
          async handleFileImport(event) {
              const file = event.target.files[0];
              if (!file) return;
              this.showTemporaryMessage('正在导入存档...', 3000);
              const reader = new FileReader();
              reader.onload = async (e) => {
                  try {
                      const importData = JSON.parse(e.target.result);
                      let saveData;
                      // 验证导入数据格式
                      if (importData.exportVersion === '2.0' && importData.saveData) {
                          saveData = importData.saveData;
                          console.log('[归墟导入] 检测到新版存档格式 v2.0');
                      } else if (importData.exportVersion === '1.0' && importData.saveData) {
                          saveData = importData.saveData;
                          console.log('[归墟导入] 检测到旧版存档格式 v1.0，进行兼容处理');
                      } else if (importData.id && importData.name && importData.mvu_data) {
                          saveData = importData;
                          console.log('[归墟导入] 检测到直接存档数据格式');
                      } else {
                          throw new Error('存档文件格式无效或已损坏。请确保导入的是有效的归墟存档文件。');
                      }
                      if (!saveData.mvu_data || !saveData.worldbook_contents) {
                          throw new Error('存档数据不完整，缺少必要的游戏数据或世界书内容。');
                      }
                      // 生成新的存档ID和更新信息
                      const newSaveData = _.cloneDeep(saveData);
                      newSaveData.id = this.generateSaveId();
                      newSaveData.name = `${saveData.name} (导入)`;
                      newSaveData.timestamp = new Date().toISOString();
                      newSaveData.auto_generated = false;
                      const success = await this.saveGameToStorage(newSaveData);
                      if (success) {
                          this.showTemporaryMessage(`存档"${newSaveData.name}"已成功导入到存档列表！`);
                          if (document.getElementById('save-load-modal').style.display !== 'none') {
                              this.showNewSaveLoadManager();
                          }                          
                          console.log('[归墟导入] 存档导入成功:', newSaveData.name);
                      } else {
                          throw new Error('保存导入的存档到存储失败');
                      }
                  } catch (error) {
                      console.error('[归墟导入] 导入存档时出错:', error);
                      this.showTemporaryMessage(`导入失败: ${error.message}`);
                  } finally {
                      // 清空file input的值，以便可以再次选择同一个文件
                      event.target.value = '';
                  }
              };
              reader.readAsText(file);
          },
//===存档模块结束===


// 【辅助模型设置模块】
          saveAuxModelSettings() {
            try {
              const settings = {
                isEnabled: this.auxModelSettings?.isEnabled || false,
                apiUrl: this.auxModelSettings?.apiUrl || '',
                apiKey: this.auxModelSettings?.apiKey || '',
                modelName: this.auxModelSettings?.modelName || '',
                source: this.auxModelSettings?.source || 'openai',
                isStreaming: this.auxModelSettings?.isStreaming !== false // 默认为true
              };
              AppStorage.saveData('aux-model-settings', settings);
              console.log('[归墟] 辅助模型设置已保存:', settings);
            } catch (e) {
              console.error('[归墟] 保存辅助模型设置失败:', e);
            }
          },

          loadAuxModelSettings() {
            try {
              const settings = AppStorage.loadData('aux-model-settings', {
                isEnabled: false,
                apiUrl: '',
                apiKey: '',
                modelName: '',
                source: 'openai',
                isStreaming: true
              });
              this.auxModelSettings = settings;
              
              // 更新UI
              const enableToggle = document.getElementById('toggle-aux-model-enabled');
              const apiUrlInput = document.getElementById('aux-model-api-url');
              const apiKeyInput = document.getElementById('aux-model-api-key');
              const modelNameInput = document.getElementById('aux-model-name');
              const sourceSelect = document.getElementById('aux-model-source');
              const streamingToggle = document.getElementById('toggle-aux-model-streaming');
              const configSection = document.getElementById('aux-model-config-section');
              
              if (enableToggle) enableToggle.checked = settings.isEnabled;
              if (apiUrlInput) apiUrlInput.value = settings.apiUrl;
              if (apiKeyInput) apiKeyInput.value = settings.apiKey;
              if (modelNameInput) modelNameInput.value = settings.modelName;
              if (sourceSelect) sourceSelect.value = settings.source;
              if (streamingToggle) streamingToggle.checked = settings.isStreaming;
              if (configSection) {
                configSection.style.display = settings.isEnabled ? 'block' : 'none';
              }
              
              console.log('[归墟] 辅助模型设置已加载:', settings);
            } catch (e) {
              console.error('[归墟] 加载辅助模型设置失败:', e);
              this.auxModelSettings = {
                isEnabled: false,
                apiUrl: '',
                apiKey: '',
                modelName: '',
                source: 'openai',
                isStreaming: true
              };
            }
          },

          // 切换世界书条目的启用状态
          async toggleWorldbookEntriesByMode(mode) {
            const bookNames = ['1归墟'];
            const globalBooks = TavernHelper.getGlobalWorldbookNames?.() || [];
            bookNames.push(...globalBooks.filter(name => name.startsWith('【归墟扩展】')));

            for (const bookName of bookNames) {
              await TavernHelper.updateWorldbookWith(bookName, (entries) => {
                return entries.map(entry => {
                  if (mode === 'once') {
                    if (entry.name.includes('【no单次】')) entry.enabled = false;
                    if (entry.name.includes('【yes单次】')) entry.enabled = true;
                  } else {
                    if (entry.name.includes('【no单次】')) entry.enabled = true;
                    if (entry.name.includes('【yes单次】')) entry.enabled = false;
                  }
                  return entry;
                });
              });
            }
          },

          // 分步变量更新设置
          async saveMvuUpdateMode() {
            const settings = {
              mvuUpdateMode: this.mvuUpdateMode || '随AI输出',
              generationMode: this.generationMode || 'once',
              stepwiseConfig: {
                modelSource: this.stepwiseConfig?.modelSource || '与插头相同'
              }
            };
            
            AppStorage.saveData('stepwise-variable-settings', settings);
            await this.toggleWorldbookEntriesByMode(this.generationMode);
          },

          loadMvuUpdateMode() {
            try {
              const settings = AppStorage.loadData('stepwise-variable-settings', {
                mvuUpdateMode: '随AI输出',
                generationMode: 'once',
                stepwiseConfig: {
                  modelSource: '与插头相同',
                  worldbookFilterMode: 'auto'
                }
              });
              
              // 加载设置
              this.mvuUpdateMode = settings.mvuUpdateMode;
              this.generationMode = settings.generationMode;
              this.stepwiseConfig = settings.stepwiseConfig;
              
              // 同步UI
              const withAiRadio = document.getElementById('mvu-mode-with-ai');
              const stepwiseRadio = document.getElementById('mvu-mode-stepwise');
              const stepwiseConfigSection = document.getElementById('stepwise-config-section');
              const sourceSameRadio = document.getElementById('stepwise-source-same');
              const sourceCustomRadio = document.getElementById('stepwise-source-custom');
              const worldbookFilterSelect = document.getElementById('worldbook-filter-mode');

              if (withAiRadio) withAiRadio.checked = (this.mvuUpdateMode === '随AI输出');
              if (stepwiseRadio) stepwiseRadio.checked = (this.mvuUpdateMode === '分步变量更新');
              if (stepwiseConfigSection) {
                stepwiseConfigSection.style.display = (this.mvuUpdateMode === '分步变量更新') ? 'block' : 'none';
              }
              if (sourceSameRadio) sourceSameRadio.checked = (this.stepwiseConfig.modelSource === '与插头相同');
              if (sourceCustomRadio) sourceCustomRadio.checked = (this.stepwiseConfig.modelSource === '自定义');
              if (worldbookFilterSelect) worldbookFilterSelect.value = this.stepwiseConfig.worldbookFilterMode;
              
              console.log('[归墟-分步变量] 设置已从LocalStorage加载:', settings);
            } catch (e) {
              console.error('[归墟-分步变量] 加载设置失败:', e);
              this.mvuUpdateMode = '随AI输出';
              this.generationMode = 'once';
              this.stepwiseConfig = {
                modelSource: '与插头相同',
                worldbookFilterMode: 'auto'
              };
            }
          },

          // 连接第二API并获取模型列表
          async connectAndFetchModels() {
            console.log('[归墟] 连接第二API并获取模型列表');
            
            const auxSettings = this.auxModelSettings;
            if (!auxSettings || !auxSettings.apiUrl) {
              this.showTemporaryMessage('请先配置API URL！', 3000);
              return;
            }

            this.showWaitingMessage('正在连接并获取模型列表...');

            try {
              // 构造获取模型列表的API端点
              let modelsEndpoint = auxSettings.apiUrl;
              // 移除末尾的 /v1 或 /v1/
              modelsEndpoint = modelsEndpoint.replace(/\/v1\/?$/, '');
              if (!modelsEndpoint.endsWith('/')) {
                modelsEndpoint += '/';
              }
              modelsEndpoint += 'v1/models';

              console.log('[归墟] 请求模型列表端点:', modelsEndpoint);

              // 发起fetch请求
              const response = await fetch(modelsEndpoint, {
                method: 'GET',
                headers: {
                  'Authorization': `Bearer ${auxSettings.apiKey}`,
                  'Content-Type': 'application/json'
                }
              });

              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }

              const data = await response.json();
              console.log('[归墟] 模型列表数据:', data);

              // 解析模型列表（OpenAI格式）
              let modelNames = [];
              if (data.data && Array.isArray(data.data)) {
                modelNames = data.data.map(m => m.id || m.model || m.name).filter(Boolean);
              } else if (Array.isArray(data)) {
                // 某些API直接返回数组
                modelNames = data.map(m => m.id || m.model || m.name || m).filter(Boolean);
              }

              if (modelNames.length === 0) {
                throw new Error('未找到任何模型');
              }

              this.hideWaitingMessage();
              
              // 更新下拉框
              const selectElement = document.getElementById('aux-model-name');
              if (selectElement) {
                selectElement.innerHTML = modelNames.map(name =>
                  `<option value="${name}">${name}</option>`
                ).join('');
                
                // 如果之前有选中的模型，保持选中
                if (auxSettings.modelName && modelNames.includes(auxSettings.modelName)) {
                  selectElement.value = auxSettings.modelName;
                } else if (modelNames.length > 0) {
                  // 否则选中第一个
                  selectElement.value = modelNames[0];
                  this.auxModelSettings.modelName = modelNames[0];
                  this.saveAuxModelSettings();
                }
              }
              
              this.showTemporaryMessage(`✅ 连接成功！找到 ${modelNames.length} 个模型`, 3000);
              console.log('[归墟] 所有可用模型:', modelNames);

            } catch (error) {
              this.hideWaitingMessage();
              this.showTemporaryMessage(`❌ 连接失败: ${error.message}`, 5000);
              console.error('[归墟] 连接失败:', error);
            }
          },

          // 测试第二API（完全独立，使用纯fetch，不触发SillyTavern任何流程）
          async testAuxModel() {
            console.log('[归墟] 测试第二API');
            
            const auxSettings = this.auxModelSettings;
            if (!auxSettings || !auxSettings.apiUrl || !auxSettings.modelName) {
              this.showTemporaryMessage('请先连接并选择模型！', 3000);
              return;
            }

            this.showWaitingMessage('正在测试API响应...');

            try {
              // 使用纯fetch调用，完全绕过SillyTavern
              let apiEndpoint = auxSettings.apiUrl;
              // 移除末尾的 /v1 或 /v1/
              apiEndpoint = apiEndpoint.replace(/\/v1\/?$/, '');
              if (!apiEndpoint.endsWith('/')) {
                apiEndpoint += '/';
              }
              apiEndpoint += 'v1/chat/completions';

              const requestBody = {
                model: auxSettings.modelName,
                messages: [
                  { role: 'user', content: '请回复"测试成功"（4个字）' }
                ],
                temperature: 0.7,
                max_tokens: 50
              };

              console.log('[归墟] 测试请求:', { endpoint: apiEndpoint, body: requestBody });

              const response = await fetch(apiEndpoint, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${auxSettings.apiKey}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
              });

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
              }

              const data = await response.json();
              console.log('[归墟] 测试响应数据:', data);

              // 解析响应（OpenAI格式）
              let responseText = '';
              if (data.choices && data.choices.length > 0) {
                responseText = data.choices[0].message?.content || data.choices[0].text || '';
              }

              if (!responseText) {
                throw new Error('未能从响应中提取内容');
              }

              this.hideWaitingMessage();
              
              // 显示响应内容
              const preview = responseText.length > 100 ? responseText.substring(0, 100) + '...' : responseText;
              this.showTemporaryMessage(`✅ 测试成功！\n\n响应内容:\n${preview}`, 8000);
              console.log('[归墟] 第二API测试成功，完整响应:', responseText);

            } catch (error) {
              this.hideWaitingMessage();
              this.showTemporaryMessage(`❌ 测试失败: ${error.message}`, 5000);
              console.error('[归墟] 第二API测试失败:', error);
            }
          },

// ===功能状态读取模块开始===



// 1.【行动选项状态存取】
           saveActionOptionsState() {
             try {
               localStorage.setItem('guixu_action_options_enabled', this.isActionOptionsEnabled);
             } catch (e) {
               console.error('保存行动选项状态失败:', e);
             }
         },
// 2.【行动选项自动发送状态存取】
         saveActionAutoSendState() {
           try {
             localStorage.setItem('guixu_action_auto_send_enabled', this.isActionAutoSend);
           } catch (e) {
             console.error('保存行动选项自动发送状态失败:', e);
           }
         },
         loadActionAutoSendState() {
           try {
             const savedState = localStorage.getItem('guixu_action_auto_send_enabled');
             this.isActionAutoSend = savedState === null ? true : savedState === 'true';
             const checkbox = document.getElementById('auto-send-action-checkbox');
             if (checkbox) {
               checkbox.checked = this.isActionAutoSend;
             }
           } catch (e) {
             console.error('加载行动选项自动发送状态失败:', e);
             this.isActionAutoSend = true;
           }
         },

           loadActionOptionsState() {
             try {
               const savedState = localStorage.getItem('guixu_action_options_enabled');
               this.isActionOptionsEnabled = savedState === null ? true : savedState === 'true';
               const checkbox = document.getElementById('action-options-enabled-checkbox');
               if (checkbox) {
                 checkbox.checked = this.isActionOptionsEnabled;
               }
             } catch (e) {
               console.error('加载行动选项状态失败:', e);
               this.isActionOptionsEnabled = true;
             }
           },
// 3.【流式开关状态存取】
         saveStreamingState() {
             try {
                 localStorage.setItem('guixu_streaming_enabled', this.isStreamingEnabled);
             } catch (e) {
                 console.error('保存流式状态失败:', e);
             }
         },
         loadStreamingState() {
             try {
                 const savedState = localStorage.getItem('guixu_streaming_enabled');
                 // 默认为 true (开启)
                 this.isStreamingEnabled = savedState === null ? true : savedState === 'true';
                 const checkbox = document.getElementById('streaming-enabled-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isStreamingEnabled;
                 }
             } catch (e) {
                 console.error('加载流式状态失败:', e);
                 this.isStreamingEnabled = true;
             }
         },

// 4.【格式审查状态存取】
         saveFormatValidationState() {
             try {
                 localStorage.setItem('guixu_format_validation_enabled', this.isFormatValidationEnabled);
             } catch (e) {
                 console.error('保存格式审查状态失败:', e);
             }
         },
         loadFormatValidationState() {
             try {
                 const savedState = localStorage.getItem('guixu_format_validation_enabled');
                 // 默认为 true (开启)
                 this.isFormatValidationEnabled = savedState === null ? true : savedState === 'true';
                 const checkbox = document.getElementById('format-validation-enabled-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isFormatValidationEnabled;
                 }
             } catch (e) {
                 console.error('加载格式审查状态失败:', e);
                 this.isFormatValidationEnabled = true;
             }
         },

// 5.【回车发送状态存取】
         saveEnterSendState() {
             try {
                 localStorage.setItem('guixu_enter_send_enabled', this.isEnterSendEnabled);
             } catch (e) {
                 console.error('保存回车发送状态失败:', e);
             }
         },
         loadEnterSendState() {
             try {
                 const savedState = localStorage.getItem('guixu_enter_send_enabled');
                 this.isEnterSendEnabled = savedState === 'true';
                 const checkbox = document.getElementById('enter-send-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isEnterSendEnabled;
                 }
             } catch (e) {
                 console.error('加载回车发送状态失败:', e);
                 this.isEnterSendEnabled = false;
             }
         },

// 6.【键盘快捷键状态存取】
         saveKeyboardShortcutsState() {
             try {
                 localStorage.setItem('guixu_keyboard_shortcuts_enabled', this.isKeyboardShortcutsEnabled);
             } catch (e) {
                 console.error('保存键盘快捷键状态失败:', e);
             }
         },
         loadKeyboardShortcutsState() {
             try {
                 const savedState = localStorage.getItem('guixu_keyboard_shortcuts_enabled');
                 this.isKeyboardShortcutsEnabled = savedState !== 'false';
                 const checkbox = document.getElementById('keyboard-shortcuts-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isKeyboardShortcutsEnabled;
                 }
             } catch (e) {
                 console.error('加载键盘快捷键状态失败:', e);
                 this.isKeyboardShortcutsEnabled = true;
             }
         },

// 7.【手机输入框适配状态存取】
         saveMobileInputAdaptState() {
             try {
                 localStorage.setItem('guixu_mobile_input_adapt_enabled', this.isMobileInputAdaptEnabled);
             } catch (e) {
                 console.error('保存手机输入框适配状态失败:', e);
             }
         },
         loadMobileInputAdaptState() {
             try {
                 const savedState = localStorage.getItem('guixu_mobile_input_adapt_enabled');
                 this.isMobileInputAdaptEnabled = savedState === 'true';
                 const checkbox = document.getElementById('mobile-input-adapt-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isMobileInputAdaptEnabled;
                 }
             } catch (e) {
                 console.error('加载手机输入框适配状态失败:', e);
                 this.isMobileInputAdaptEnabled = false;
             }
         },
//8.【自动开关世界书状态存取】
           saveAutoToggleState() {
             try {
               localStorage.setItem('guixu_auto_toggle_enabled', this.isAutoToggleLorebookEnabled);
             } catch (e) {
               console.error('保存自动开关状态失败:', e);
             }
           },
 
           loadAutoToggleState() {
             try {
               const savedState = localStorage.getItem('guixu_auto_toggle_enabled');
               this.isAutoToggleLorebookEnabled = savedState === 'true';
               const checkbox = document.getElementById('auto-toggle-lorebook-checkbox');
               if (checkbox) {
                 checkbox.checked = this.isAutoToggleLorebookEnabled;
               }
               // 根据加载的状态决定是否启动轮询
                if (this.isAutoToggleLorebookEnabled) {
                    this.startAutoTogglePolling();
                }
             } catch (e) {
               console.error('加载自动开关状态失败:', e);
               this.isAutoToggleLorebookEnabled = false;
             }
           },

// 8.【分段记忆保留数存取】
          saveSegmentedMemoryCounts() {
              try {
                  const segmentedCount = document.getElementById('segmented-memory-count')?.value || '3';
                  const smallSummaryCount = document.getElementById('small-summary-count')?.value || '25';
                  localStorage.setItem('guixu_segmented_memory_count', segmentedCount);
                  localStorage.setItem('guixu_small_summary_count', smallSummaryCount);
              } catch (e) {
                  console.error('保存分段记忆保留数失败:', e);
              }
          },

//9.【小说模式独立读写序号存取】
          saveNovelModeIndex() {
           try {
             localStorage.setItem('guixu_novel_mode_index', this.novelModeIndex);
           } catch (e) {
             console.error('保存小说模式读写序号失败:', e);
           }
          },

// ===功能状态读取模块结束===


         
// ===修剪控制台模块开始===
          reconstructJourneyEntry(events) {
            if (!Array.isArray(events)) return '';

            const fieldOrder = ['序号', '日期', '标题', '地点', '人物', '描述', '人物关系', '标签', '重要信息', '暗线与伏笔', '自动化系统'];

            return events.map(event => {
                return fieldOrder
                    .map(key => {
                        if (event[key] !== undefined && event[key] !== null) {
                            return `${key}|${String(event[key]).trim()}`;
                        }
                        return null;
                    })
                    .filter(Boolean) 
                    .join('\n');
            }).join('\n\n');
          },
          async handlePreciseTrim() {
            // 1. 获取要操作的条目
            const checkedBoxes = document.querySelectorAll('#history-modal-body .journey-trim-checkbox:checked');
            if (checkedBoxes.length === 0) {
                this.showTemporaryMessage('请先在下方历程中勾选需要修剪的条目。');
                return;
            }
            const sequenceIdsToTrim = Array.from(checkedBoxes).map(box => box.dataset.sequenceId);

            // 2. 获取要删除的字段
            const fieldsToRemove = Array.from(document.querySelectorAll('.trim-field-checkbox:checked')).map(cb => cb.value);
            if (fieldsToRemove.length === 0) {
                this.showTemporaryMessage('请先在上方控制台勾选需要修剪的字段。');
                return;
            }

            // 3. 弹出确认框
            this.showCustomConfirm(
                `你确定要从选中的 ${checkedBoxes.length} 个条目中，删除【${fieldsToRemove.join('、')}】字段吗？此操作不可恢复。`,
                async () => {
                    this.showTemporaryMessage('正在进行精确修剪...');
                    const bookName = '1归墟';
                    const index = this.unifiedIndex;
                    const journeyKey = index > 1 ? `本世历程(${index})` : '本世历程';

                    try {
                        const allEntries = await TavernHelper.getLorebookEntries(bookName);
                        const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

                        if (!journeyEntry || !journeyEntry.content) {
                            this.showTemporaryMessage('错误：找不到“本世历程”内容。');
                            return;
                        }

                        let events = this.parseJourneyEntry(journeyEntry.content);
                        let trimCount = 0;

                        events.forEach(event => {
                            if (sequenceIdsToTrim.includes(event['序号'])) {
                                let trimmedThisEvent = false;
                                fieldsToRemove.forEach(field => {
                                    if (event.hasOwnProperty(field)) {
                                        delete event[field];
                                        trimmedThisEvent = true;
                                    }
                                });
                                if (trimmedThisEvent) trimCount++;
                            }
                        });

                        if (trimCount === 0) {
                            this.showTemporaryMessage('选中的条目中没有可修剪的内容。');
                            return;
                        }

                        const newContent = this.reconstructJourneyEntry(events);
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]);
                        this.showTemporaryMessage(`修剪成功！已处理 ${trimCount} 个条目。`, 3000);
                        this.showJourney(); // 刷新视图

                    } catch (error) {
                        console.error('精确修剪失败:', error);
                        this.showTemporaryMessage(`修剪失败: ${error.message}`, 3000);
                    }
                },
                true // keepCurrentModal
            );
          },

          async handleAutoTrim() {
            // 1. 获取要删除的字段
            const fieldsToRemove = Array.from(document.querySelectorAll('.trim-field-checkbox:checked')).map(cb => cb.value);
            if (fieldsToRemove.length === 0) {
                this.showTemporaryMessage('请先在上方控制台勾选需要修剪的字段。');
                return;
            }

            // 2. 获取保留数量
            const keepCountInput = document.getElementById('trim-keep-count');
            const keepCount = parseInt(keepCountInput.value, 10);
            if (isNaN(keepCount) || keepCount < 0) {
                this.showTemporaryMessage('请输入有效的保留数量。');
                return;
            }

            // 3. 弹出确认框
            this.showCustomConfirm(
                `你确定要保留最新的 ${keepCount} 个条目，并从所有更早的条目中删除【${fieldsToRemove.join('、')}】字段吗？此操作不可恢复。`,
                async () => {
                    this.showTemporaryMessage('正在进行自动修剪...');
                    const bookName = '1归墟';
                    const index = this.unifiedIndex;
                    const journeyKey = index > 1 ? `本世历程(${index})` : '本世历程';

                    try {
                        const allEntries = await TavernHelper.getLorebookEntries(bookName);
                        const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

                        if (!journeyEntry || !journeyEntry.content) {
                            this.showTemporaryMessage('错误：找不到“本世历程”内容。');
                            return;
                        }

                        let events = this.parseJourneyEntry(journeyEntry.content);
                        if (events.length <= keepCount) {
                            this.showTemporaryMessage('无需修剪，当前条目数未超过保留数量。');
                            return;
                        }

                        let trimCount = 0;
                        const eventsToTrimCount = events.length - keepCount;

                        events.forEach((event, idx) => {
                            if (idx < eventsToTrimCount) {
                                let trimmedThisEvent = false;
                                fieldsToRemove.forEach(field => {
                                    if (event.hasOwnProperty(field)) {
                                        delete event[field];
                                        trimmedThisEvent = true;
                                    }
                                });
                                if (trimmedThisEvent) trimCount++;
                            }
                        });

                        if (trimCount === 0) {
                            this.showTemporaryMessage('没有可修剪的内容。');
                            return;
                        }

                        const newContent = this.reconstructJourneyEntry(events);
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]);
                        this.showTemporaryMessage(`自动修剪成功！已处理 ${trimCount} 个旧条目。`, 3000);
                        this.showJourney();

                    } catch (error) {
                        console.error('自动修剪失败:', error);
                        this.showTemporaryMessage(`修剪失败: ${error.message}`, 3000);
                    }
                },
                true
            );
          },

          async handleFullTrim() {
            const keepCountInput = document.getElementById('trim-keep-count');
            const keepCount = parseInt(keepCountInput.value, 10);
            if (isNaN(keepCount) || keepCount < 0) {
                this.showTemporaryMessage('请输入有效的保留数量。');
                return;
            }

            this.showCustomConfirm(
                `【高危操作】你确定要永久删除除最近 ${keepCount} 条外的所有历程记录吗？此操作将彻底删除数据，不可恢复！`,
                async () => {
                    this.showTemporaryMessage('正在进行完整删除...');
                    const bookName = '1归墟';
                    const index = this.unifiedIndex;
                    const journeyKey = index > 1 ? `本世历程(${index})` : '本世历程';

                    try {
                        const allEntries = await TavernHelper.getLorebookEntries(bookName);
                        const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

                        if (!journeyEntry || !journeyEntry.content) {
                            this.showTemporaryMessage('错误：找不到“本世历程”内容。');
                            return;
                        }

                        let events = this.parseJourneyEntry(journeyEntry.content);
                        if (events.length <= keepCount) {
                            this.showTemporaryMessage('无需删除，当前条目数未超过保留数量。');
                            return;
                        }
                        const deletedCount = events.length - keepCount;
                        const keptEvents = events.slice(deletedCount);
                        
                        const newContent = this.reconstructJourneyEntry(keptEvents);
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]);
                        this.showTemporaryMessage(`完整删除成功！已删除 ${deletedCount} 个旧条目。`, 3000);
                        this.showJourney();

                    } catch (error) {
                        console.error('完整删除失败:', error);
                        this.showTemporaryMessage(`删除失败: ${error.message}`, 3000);
                    }
                },
                true
            );
          },

          // 修剪字段状态的保存与加载
          saveTrimFieldsState() {
              const checkboxes = document.querySelectorAll('.trim-field-checkbox');
              const state = {};
              checkboxes.forEach(cb => {
                  state[cb.value] = cb.checked;
              });
              this.trimFieldsState = state;
              try {
                  localStorage.setItem('guixu_trim_fields_state', JSON.stringify(state));
              } catch (e) {
                  console.error('保存修剪字段状态失败:', e);
              }
          },

          loadTrimFieldsState() {
              try {
                  const savedState = localStorage.getItem('guixu_trim_fields_state');
                  if (savedState) {
                      this.trimFieldsState = JSON.parse(savedState);
                  } else {
                      this.saveTrimFieldsState();
                      return;
                  }
              } catch (e) {
                  console.error('加载修剪字段状态失败:', e);
                  this.trimFieldsState = {}; // 出错时重置
              }
              const checkboxes = document.querySelectorAll('.trim-field-checkbox');
              checkboxes.forEach(cb => {
                  // 如果状态对象中有这个值，则使用它；否则保持默认
                  if (this.trimFieldsState.hasOwnProperty(cb.value)) {
                      cb.checked = this.trimFieldsState[cb.value];
                  }
              });
           },
// ===修剪控制台模块结束===



// ===输入缓存/历史记录模块开始===
            getInputHistory() {
                try {
                    const history = localStorage.getItem('guixu_input_history');
                    return history ? JSON.parse(history) : [];
                } catch (e) {
                    return [];
                }
            },

            saveInputToHistory(content) {
                if (!content) return;
                try {
                    let history = this.getInputHistory();
                    if (history[0] === content) return;
                    history.unshift(content);
                    // 限制历史记录数量
                    if (history.length > 100) {
                        history.pop();
                    }
                    localStorage.setItem('guixu_input_history', JSON.stringify(history));
                } catch (e) {
                }
            },

            showInputCacheModal() {
                const history = this.getInputHistory();
                const recentListEl = document.getElementById('recent-inputs-list');
                const allListEl = document.getElementById('all-inputs-list');

                if (!recentListEl || !allListEl) return;

                recentListEl.innerHTML = '';
                allListEl.innerHTML = '';

                if (history.length === 0) {
                    recentListEl.innerHTML = '<li class="empty-category-text">暂无记录</li>';
                    allListEl.innerHTML = '<li class="empty-category-text">暂无记录</li>';
                } else {
                    // 填充最近两次输入
                    history.slice(0, 2).forEach((item, index) => {
                        const li = document.createElement('li');
                        li.className = 'input-cache-item';
                        li.dataset.content = item;
                        li.innerHTML = `<span class="item-index">${index + 1}.</span>${item}`;
                        recentListEl.appendChild(li);
                    });

                    // 填充所有历史记录
                    history.forEach((item, index) => {
                        const li = document.createElement('li');
                        li.className = 'input-cache-item';
                        li.dataset.content = item;
                        li.innerHTML = `<span class="item-index">${index + 1}.</span>${item}`;
                        allListEl.appendChild(li);
                    });
                }
                
                this.openModal('input-cache-modal');
            },

            applyInputFromHistory(content) {
                const inputEl = document.getElementById('quick-send-input');
                if (inputEl) {
                    inputEl.value = content;
                    this.closeModal('input-cache-modal');
                    this.showTemporaryMessage('已应用历史输入。');
                }
            },
// ===输入缓存/历史记录模块结束===



// ===分段记忆模块开始===
          // 新增：显示分段记忆模态框
          async showSegmentedMemoryModal() {
            this.loadSegmentedMemoryCounts(); // 新增：加载保留数设置
            this.updateUnifiedSummaryDisplay(); // 在打开模态框时更新统一预览
            const modal = document.getElementById('segmented-memory-modal');
            if (!modal) {
                this.showTemporaryMessage('分段记忆模态框加载失败', 'error');
                return;
            }
            this.openModal('segmented-memory-modal', true); // 确保在设置之上

            // 更新统一预览
            this.updateUnifiedSummaryDisplay();

            // 初始化UI状态
            const autoGenerateCheckbox = document.getElementById('auto-segmented-memory-checkbox');
            if(autoGenerateCheckbox) autoGenerateCheckbox.checked = this.isSegmentedMemoryAutoGenerateEnabled; // 主开关的状态

            // 由于其他开关已移除，不再需要单独初始化它们

            // 绑定模态框内部事件
            const closeBtn = modal.querySelector('.modal-close-btn');
            closeBtn?.addEventListener('click', () => {
                this.closeModal('segmented-memory-modal');
                if (this.isFromSettingsModal) {
                    this.showSettings();
                    this.isFromSettingsModal = false; // 重置标志位
                }
            });
            
            modal.addEventListener('click', (event) => {
                if (event.target === modal) {
                    this.closeModal('segmented-memory-modal');
                    if (this.isFromSettingsModal) {
                        this.showSettings();
                        this.isFromSettingsModal = false; // 重置标志位
                    }
                }
            });

            const generateBtn = document.getElementById('btn-generate-segmented-memory');
            generateBtn?.addEventListener('click', async () => {
                // 依次调用三个生成函数
                await this.generateSegmentedMemory();
                await this.generateSmallSummary();
                await this.generateLargeSummary();

                // 在手动生成后，如果模态框是打开的，则刷新统一预览
                const modal = document.getElementById('segmented-memory-modal');
                if (modal && modal.style.display !== 'none') {
                    this.updateUnifiedSummaryDisplay();
                }
            });

            // 新增：为预览列表添加点击展开/折叠事件 (优化版)
            const displayEl = document.getElementById('unified-summary-display');
            if (displayEl && !displayEl.dataset.listenerAttached) {
                displayEl.dataset.listenerAttached = 'true';
                displayEl.addEventListener('click', (e) => {
                    const header = e.target.closest('.summary-header');
                    if (header) {
                        const item = header.closest('.summary-item');
                        item.classList.toggle('expanded');
                    }
                });
            }

            const segmentedCountInput = document.getElementById('segmented-memory-count');
            const smallSummaryCountInput = document.getElementById('small-summary-count');

            segmentedCountInput?.addEventListener('input', () => {
                this.updateUnifiedSummaryDisplay();
                this.saveSegmentedMemoryCounts();
            });
            smallSummaryCountInput?.addEventListener('input', () => {
                this.updateUnifiedSummaryDisplay();
                this.saveSegmentedMemoryCounts();
            });

            autoGenerateCheckbox?.addEventListener('change', (e) => {
               const isEnabled = e.target.checked;
               this.isSegmentedMemoryAutoGenerateEnabled = isEnabled;
               this.isSmallSummaryAutoOn = isEnabled;
               this.isLargeSummaryAutoOn = isEnabled;

               this.saveSegmentedMemoryState();
               this.saveSmallSummaryState();
               this.saveLargeSummaryState();

               this.showTemporaryMessage(`分段记忆自动生成已${isEnabled ? '开启' : '关闭'}`);

               if (isEnabled) {
                   this.startSegmentedMemoryPolling();
                   // 注意：小总结和大总结的轮询逻辑可能需要单独的计时器或在分段记忆轮询中触发
               } else {
                   this.stopSegmentedMemoryPolling();
                   // 同样需要停止小总结和大总结的轮询
               }
            });

            // --- 整合后的事件绑定 ---
            document.getElementById('edit-small-summary-btn')?.addEventListener('click', () => this.showSummaryEditorModal('small'));
            document.getElementById('edit-large-summary-btn')?.addEventListener('click', () => this.showSummaryEditorModal('large'));
const generateSummariesBtn = document.getElementById('btn-generate-summaries');
generateSummariesBtn?.addEventListener('click', async () => {
    const statusEl = document.getElementById('summaries-status');
    if (generateSummariesBtn) {
        generateSummariesBtn.disabled = true;
        generateSummariesBtn.textContent = '正在生成...';
    }
    
    try {
        await this.generateSmallSummary();
        await this.generateLargeSummary();
        if (statusEl) statusEl.textContent = '生成完成！';
        this.showTemporaryMessage('小结与总结已更新', 'success');
        // 生成后刷新统一预览
        this.updateUnifiedSummaryDisplay();
    } catch (e) {
        // 错误已在各自函数中处理和显示
    } finally {
        if (generateSummariesBtn) {
            generateSummariesBtn.disabled = false;
            generateSummariesBtn.textContent = '立即生成小结与总结';
        }
        setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 3000);
    }
});
},
// --- 新增：总结编辑器 ---
async showSummaryEditorModal(summaryType) {
    const modal = document.getElementById('summary-editor-modal');
    const titleEl = document.getElementById('summary-editor-title');
    const textarea = document.getElementById('summary-editor-textarea');
    if (!modal || !titleEl || !textarea) return;

    const bookName = '1归墟';
    const index = this.unifiedIndex;
    const entryName = summaryType === 'small'
        ? (index > 1 ? `小总结(${index})` : '小总结')
        : (index > 1 ? `大总结(${index})` : '大总结');
    
    titleEl.textContent = `编辑${summaryType === 'small' ? '小总结' : '大总结'}`;
    textarea.value = '正在加载...';
    this.openModal('summary-editor-modal', true);

    try {
        const allEntries = await TavernHelper.getLorebookEntries(bookName);
        const entry = allEntries.find(e => e.comment === entryName);
        textarea.value = entry ? entry.content : '';
    } catch (error) {
        textarea.value = `加载失败: ${error.message}`;
    }

    // 绑定事件
    modal.querySelector('.modal-close-btn').onclick = () => this.closeModal('summary-editor-modal');
    modal.querySelector('#summary-editor-cancel').onclick = () => this.closeModal('summary-editor-modal');
    
    const saveBtn = modal.querySelector('#summary-editor-save');
    saveBtn.onclick = async () => {
        const newContent = textarea.value;
        saveBtn.textContent = '保存中...';
        saveBtn.disabled = true;

        try {
            // 反向更新本世历程
            await this.updateJourneyFromSummary(newContent, summaryType);
            
            // 重新生成总结
            await this.generateSmallSummary();
            await this.generateLargeSummary();

            this.showTemporaryMessage('保存并更新成功！', 'success');
            this.closeModal('summary-editor-modal');

            // 刷新主模态框的显示
            this.updateSmallSummaryDisplay();
            this.updateLargeSummaryDisplay();

        } catch (error) {
            console.error('保存总结失败:', error);
            this.showTemporaryMessage(`保存失败: ${error.message}`, 'error');
        } finally {
            saveBtn.textContent = '保存更改';
            saveBtn.disabled = false;
        }
    };
},

async updateJourneyFromSummary(summaryContent, summaryType) {
    const bookName = '1归墟';
    const index = this.unifiedIndex;
    const journeyKey = index > 1 ? `本世历程(${index})` : '本世历程';
    
    const allEntries = await TavernHelper.getLorebookEntries(bookName);
    const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);
    if (!journeyEntry) throw new Error('找不到“本世历程”世界书。');
    
    let journeyEvents = this.parseJourneyEntry(journeyEntry.content);
    const summaryEvents = summaryType === 'small'
        ? summaryContent.split('\n\n').filter(Boolean)
        : summaryContent.split('\n').filter(Boolean);

    if (journeyEvents.length < summaryEvents.length) {
        console.warn('总结中的事件数量多于本世历程，可能导致部分更新丢失。');
    }

    // 从后往前匹配和更新
    const journeyLen = journeyEvents.length;
    const summaryLen = summaryEvents.length;
    for (let i = 0; i < summaryLen; i++) {
        const journeyIndex = journeyLen - 1 - i;
        const summaryIndex = summaryLen - 1 - i;
        if (journeyIndex < 0) break;

        const journeyEvent = journeyEvents[journeyIndex];
        const summaryText = summaryEvents[summaryIndex];

        if (summaryType === 'small') {
            const lines = summaryText.split('\n');
            const firstLineContent = lines[0].replace(/^.+?，/, '').trim();
            journeyEvent['重要信息'] = firstLineContent;
            delete journeyEvent['暗线与伏笔'];
            delete journeyEvent['自动化系统'];
            lines.slice(1).forEach(line => {
                const parts = line.split('|');
                if (parts.length === 2) {
                    if (parts[0] === '暗线与伏笔') journeyEvent['暗线与伏笔'] = parts[1];
                    if (parts[0] === '自动化系统') journeyEvent['自动化系统'] = parts[1];
                }
            });
        } else { // large
            const contentWithoutDate = summaryText.replace(/^.+?，/, '').trim();
            journeyEvent['描述'] = contentWithoutDate;
        }
    }
    
    const newJourneyContent = this.reconstructJourneyEntry(journeyEvents);
    await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newJourneyContent }]);
},
// 新增：更新分段记忆模态框中的章节显示
async updateUnifiedSummaryDisplay() {
    const displayEl = document.getElementById('unified-summary-display');
    if (!displayEl) return;

    displayEl.innerHTML = '<div style="color: #8b7355; text-align: center;">正在加载...</div>';

    try {
        const bookName = '1归墟';
        const currentIndex = this.unifiedIndex;

        // 1. 并行获取所有需要的数据源
        const entryNames = [
            currentIndex > 1 ? `本世历程(${currentIndex})` : '本世历程',
            currentIndex > 1 ? `分段正文(${currentIndex})` : '分段正文',
            currentIndex > 1 ? `小总结(${currentIndex})` : '小总结',
            currentIndex > 1 ? `大总结(${currentIndex})` : '大总结'
        ];

        const allEntries = await TavernHelper.getLorebookEntries(bookName);
        const [journeyEntry, segmentedEntry, smallSummaryEntry, largeSummaryEntry] = entryNames.map(name =>
            allEntries.find(entry => entry.comment === name)
        );

        console.log('[归墟-预览系统] 数据源获取情况:', {
            '本世历程': journeyEntry ? '✅' : '❌',
            '分段正文': segmentedEntry ? '✅' : '❌',
            '小总结': smallSummaryEntry ? '✅' : '❌',
            '大总结': largeSummaryEntry ? '✅' : '❌',
        });
        console.log('[归墟-预览系统] 原始数据:', { journeyEntry, segmentedEntry, smallSummaryEntry, largeSummaryEntry });


        if (!journeyEntry || !journeyEntry.content) {
            displayEl.innerHTML = '<div class="modal-display-placeholder">“本世历程”内容为空</div>';
            return;
        }

        const journeyEvents = this.parseJourneyEntry(journeyEntry.content);
        if (journeyEvents.length === 0) {
            displayEl.innerHTML = '<div class="modal-display-placeholder">无事件可供预览</div>';
            return;
        }

        // 2. 解析三大产物的内容
        const segmentedContent = segmentedEntry ? segmentedEntry.content.split('\n——\n') : [];
        const smallSummaryContent = smallSummaryEntry ? smallSummaryEntry.content.split('\n——\n') : [];
        const largeSummaryContent = largeSummaryEntry ? largeSummaryEntry.content.split('\n——\n') : [];

        console.log('[归墟-预览系统] 解析后内容:', {
            journeyEvents,
            segmentedContent,
            smallSummaryContent,
            largeSummaryContent
        });

        const segmentedCount = parseInt(document.getElementById('segmented-memory-count').value, 10) || 0;
        const smallSummaryCount = parseInt(document.getElementById('small-summary-count').value, 10) || 0;
        const totalEvents = journeyEvents.length;
        const segmentedStartIndex = Math.max(0, totalEvents - segmentedCount);
        const smallSummaryStartIndex = Math.max(0, totalEvents - segmentedCount - smallSummaryCount);

        const reversedEvents = journeyEvents.slice().reverse();
        const html = reversedEvents.map((event, reversedIndex) => {
            const originalIndex = totalEvents - 1 - reversedIndex; // 获取原始索引
            let tag = '';
            let tagColor = '';
            let contentToShow = '<div class="summary-detail-placeholder">无对应内容</div>';

            // 3. 根据原始索引进行清晰的判断
            if (originalIndex >= segmentedStartIndex) {
                tag = '分段正文';
                tagColor = '#C9AA71';
                const contentIndex = originalIndex - segmentedStartIndex;
                if (segmentedContent[contentIndex]) {
                    contentToShow = `<div class="summary-detail-content text-language">${_.escape(segmentedContent[contentIndex]).replace(/\n/g, '<br>')}</div>`;
                }
            } else if (originalIndex >= smallSummaryStartIndex) {
                tag = '小总结';
                tagColor = '#A9C971';
                const contentIndex = originalIndex - smallSummaryStartIndex;
                if (smallSummaryContent[contentIndex]) {
                    contentToShow = `<div class="summary-detail-content text-psychology">${_.escape(smallSummaryContent[contentIndex]).replace(/\n/g, '<br>')}</div>`;
                }
            } else {
                tag = '大总结';
                tagColor = '#71A9C9';
                const contentIndex = originalIndex;
                if (largeSummaryContent[contentIndex]) {
                    contentToShow = `<div class="summary-detail-content text-scenery">${_.escape(largeSummaryContent[contentIndex]).replace(/\n/g, '<br>')}</div>`;
                }
            }
            
            const chapterNumber = event['序号'] || (originalIndex + 1);
            const chapterTitle = event['标题'] || '无标题';
            const title = `第${chapterNumber}章 ${chapterTitle}`;

            // 4. 构建UI，内容默认展开
            return `
                <div class="summary-item">
                    <div class="summary-header">
                        <span class="summary-arrow">▶</span>
                        <span class="summary-title">${_.escape(title)}</span>
                        <span class="summary-tag" style="background-color: ${tagColor};">${tag}</span>
                    </div>
                    <div class="summary-details" style="display: none;">
                        ${contentToShow}
                    </div>
                </div>
            `;
        }).join('');

        displayEl.innerHTML = html;
    } catch (error) {
        console.error('更新分段记忆预览失败:', error);
        displayEl.innerHTML = `<div style="color: #ff6b6b; text-align: center;">加载失败: ${error.message}</div>`;
    }
},

          // 新增：生成/更新分段记忆的核心逻辑
          async generateSegmentedMemory(isPolling = false) {
            const statusEl = document.getElementById('segmented-memory-status');
            const countInput = document.getElementById('segmented-memory-count');
            const generateBtn = document.getElementById('btn-generate-segmented-memory');

            if (!statusEl || !countInput || !generateBtn) {
                this.showTemporaryMessage('UI元素缺失，操作中断', 'error');
                return;
            }

            try {
                if (!isPolling) {
                    generateBtn.disabled = true;
                    generateBtn.textContent = '正在生成...';
                    statusEl.textContent = '正在读取小说模式数据...';
                }

                const count = parseInt(countInput.value, 10);
                if (isNaN(count) || count < 0) {
                    throw new Error('请输入一个有效的非负整数');
                }

                const bookName = '1归墟';
                const allEntries = await TavernHelper.getLorebookEntries(bookName);

                if (!allEntries || allEntries.length === 0) {
                    throw new Error(`世界书 "${bookName}" 中没有条目。`);
                }

                // 根据当前读写序号，精确定位源“小说模式”条目
                const currentIndex = this.unifiedIndex;
                const sourceEntryName = currentIndex > 1 ? `小说模式(${currentIndex})` : '小说模式';
                const sourceEntry = allEntries.find(entry => entry.comment === sourceEntryName);

                if (!sourceEntry || !sourceEntry.content) {
                    throw new Error(`未找到或内容为空的源条目: "${sourceEntryName}"`);
                }

                // 使用正则表达式分割章节
                const chapters = sourceEntry.content.split(/(?=第\d+章\s+.*)/g).filter(c => c.trim() !== '');

                // 从章节末尾提取最新的X个
                // 修复：当count为0时，slice(0)会返回整个数组，而不是空数组
                const latestChapters = count === 0 ? [] : chapters.slice(-count);

                // 合并内容
                const combinedContent = latestChapters.join('\n——\n');

                if (!isPolling) {
                    statusEl.textContent = '正在写入“分段正文”...';
                }

                // 根据统一序号生成目标条目名称
                const targetEntryName = currentIndex > 1 ? `分段正文(${currentIndex})` : '分段正文';

                // 查找现有的“分段正文”条目
                const existingEntry = allEntries.find(entry => entry.comment === targetEntryName);

                if (existingEntry) {
                    // 仅在内容有变化时才更新，避免不必要的写入
                    if (existingEntry.content !== combinedContent) {
                        await TavernHelper.setLorebookEntries(bookName, [{
                            uid: existingEntry.uid,
                            content: combinedContent,
                        }]);
                    }
                } else {
                    // 创建新条目
                    await TavernHelper.createLorebookEntries(bookName, [{
                        comment: targetEntryName,
                        content: combinedContent,
                        keys: [], // 作为一个常量条目，不需要关键词
                        type: 'constant',
                        enabled: true,
                    }]);
                }

                const successMsg = `分段记忆已更新，共聚合 ${latestChapters.length} 个最新章节。`;
                if (!isPolling) {
                    statusEl.textContent = successMsg;
                    this.showTemporaryMessage(successMsg, 'success');
                } else {
                    console.log(`[归墟-分段记忆] 自动更新成功，聚合 ${latestChapters.length} 个章节。`);
                }

                // 新增：如果分段记忆窗口是打开的，则静默刷新章节列表显示
                const modal = document.getElementById('segmented-memory-modal');
                if (modal && modal.style.display !== 'none') {
                    this.updateUnifiedSummaryDisplay();
                }

            } catch (error) {
                console.error('生成分段记忆时出错:', error);
                if (!isPolling) {
                    const errorMsg = `错误: ${error.message}`;
                    statusEl.textContent = errorMsg;
                    this.showTemporaryMessage(errorMsg, 'error', 5000);
                }
            } finally {
                if (!isPolling) {
                    generateBtn.disabled = false;
                    generateBtn.textContent = '立即生成/更新';
                }
            }
          },

          // 新增：生成/更新小总结的核心逻辑
          async generateSmallSummary(isPolling = false) {
            const statusEl = document.getElementById('segmented-memory-status');
            const smallSummaryCountInput = document.getElementById('small-summary-count');
            const segmentedCountInput = document.getElementById('segmented-memory-count'); // 获取分段正文的数量输入框

            if (!smallSummaryCountInput || !segmentedCountInput) {
                this.showTemporaryMessage('UI元素缺失，操作中断', 'error');
                return;
            }

            try {
                if (!isPolling && statusEl) {
                    statusEl.textContent = '正在读取(小总结)...';
                }

                const smallSummaryCount = parseInt(smallSummaryCountInput.value, 10);
                const segmentedCount = parseInt(segmentedCountInput.value, 10); // 获取分段正文的数量

                if (isNaN(smallSummaryCount) || smallSummaryCount < 0 || isNaN(segmentedCount) || segmentedCount < 0) {
                    throw new Error('请输入一个有效的非负整数');
                }

                const bookName = '1归墟';
                const allEntries = await TavernHelper.getLorebookEntries(bookName);

                if (!allEntries || allEntries.length === 0) {
                    throw new Error(`世界书 "${bookName}" 中没有条目。`);
                }

                const currentIndex = this.unifiedIndex;
                const sourceEntryName = currentIndex > 1 ? `本世历程(${currentIndex})` : '本世历程';
                const sourceEntry = allEntries.find(entry => entry.comment === sourceEntryName);

                if (!sourceEntry || !sourceEntry.content) {
                    throw new Error(`未找到或内容为空的源条目: "${sourceEntryName}"`);
                }

                const journeyEvents = this.parseJourneyEntry(sourceEntry.content);
                
                // 新的切片逻辑：更稳健、更清晰
                const totalEvents = journeyEvents.length;
                let startIndex = totalEvents - segmentedCount - smallSummaryCount;
                let endIndex = totalEvents - segmentedCount;

                // 边界条件检查，确保索引不会小于0
                if (startIndex < 0) startIndex = 0;
                if (endIndex < 0) endIndex = 0;
                
                const latestEvents = smallSummaryCount === 0 ? [] : journeyEvents.slice(startIndex, endIndex);


                const formattedEvents = latestEvents.map(event => {
                    const parts = [];
                    // 格式：xxx（日期），xxx（重要信息）
                    if (event['日期'] && event['重要信息']) {
                        parts.push(`${event['日期']}，${event['重要信息']}`);
                    } else if (event['日期']) {
                        parts.push(event['日期']);
                    } else if (event['重要信息']) {
                        parts.push(event['重要信息']);
                    }

                    // 格式：暗线与伏笔|xxx
                    if (event['暗线与伏笔']) {
                        parts.push(`暗线与伏笔|${event['暗线与伏笔']}`);
                    }
                    // 格式：自动化系统|xxx
                    if (event['自动化系统']) {
                        parts.push(`自动化系统|${event['自动化系统']}`);
                    }
                    return parts.join('\n');
                }).filter(Boolean); // 过滤掉可能为空的事件字符串
                const combinedContent = formattedEvents.join('\n——\n'); // 使用新的分隔符
                
                if (!isPolling) {
                    statusEl.textContent = '正在写入“小总结”...';
                }

                const targetEntryName = currentIndex > 1 ? `小总结(${currentIndex})` : '小总结';
                const existingEntry = allEntries.find(entry => entry.comment === targetEntryName);

                if (existingEntry) {
                    if (existingEntry.content !== combinedContent) {
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: existingEntry.uid, content: combinedContent }]);
                    }
                } else {
                    await TavernHelper.createLorebookEntries(bookName, [{
                        comment: targetEntryName,
                        content: combinedContent,
                        keys: [],
                        type: 'constant',
                        enabled: true,
                    }]);
                }

                const successMsg = `小总结已更新，共聚合 ${latestEvents.length} 个最新事件。`;
                if (!isPolling) {
                    statusEl.textContent = successMsg;
                    this.showTemporaryMessage(successMsg, 'success');
                } else {
                    console.log(`[归墟-小总结] 自动更新成功，聚合 ${latestEvents.length} 个事件。`);
                }

            } catch (error) {
                console.error('生成小总结时出错:', error);
                if (!isPolling) {
                    const errorMsg = `错误: ${error.message}`;
                    statusEl.textContent = errorMsg;
                    this.showTemporaryMessage(errorMsg, 'error', 5000);
                }
            } finally {
                // 按钮状态管理已移至调用处
            }
          },

          // 新增：生成/更新大总结的核心逻辑
          async generateLargeSummary(isPolling = false) {
            const statusEl = document.getElementById('segmented-memory-status');
            const smallSummaryCountInput = document.getElementById('small-summary-count');
            const segmentedCountInput = document.getElementById('segmented-memory-count');

            try {
                if (!isPolling && statusEl) {
                    statusEl.textContent = '正在读取(大总结)...';
                }

                const smallSummaryCount = parseInt(smallSummaryCountInput.value, 10);
                const segmentedCount = parseInt(segmentedCountInput.value, 10);

                if (isNaN(smallSummaryCount) || smallSummaryCount < 0 || isNaN(segmentedCount) || segmentedCount < 0) {
                    throw new Error('获取的数值无效');
                }

                const bookName = '1归墟';
                const allEntries = await TavernHelper.getLorebookEntries(bookName);

                if (!allEntries || allEntries.length === 0) {
                    throw new Error(`世界书 "${bookName}" 中没有条目。`);
                }

                const currentIndex = this.unifiedIndex;
                const sourceEntryName = currentIndex > 1 ? `本世历程(${currentIndex})` : '本世历程';
                const sourceEntry = allEntries.find(entry => entry.comment === sourceEntryName);

                if (!sourceEntry || !sourceEntry.content) {
                    throw new Error(`未找到或内容为空的源条目: "${sourceEntryName}"`);
                }

                const journeyEvents = this.parseJourneyEntry(sourceEntry.content);
                
                // 新的切片逻辑
                const end = -(segmentedCount + smallSummaryCount);
                const largeSummaryEvents = journeyEvents.slice(0, end < 0 ? end : undefined);

                const formattedEvents = largeSummaryEvents.map(event => {
                    // 格式：xxx（日期），xxx（描述）
                    if (event['日期'] && event['描述']) {
                        return `${event['日期']}，${event['描述']}`;
                    }
                    return null; // 如果缺少任一字段，则忽略此事件
                }).filter(Boolean); // 过滤掉为null的事件
                const combinedContent = formattedEvents.join('\n——\n'); // 使用新的分隔符
                
                if (!isPolling) {
                    statusEl.textContent = '正在写入“大总结”...';
                }

                const targetEntryName = currentIndex > 1 ? `大总结(${currentIndex})` : '大总结';
                const existingEntry = allEntries.find(entry => entry.comment === targetEntryName);

                if (existingEntry) {
                    if (existingEntry.content !== combinedContent) {
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: existingEntry.uid, content: combinedContent }]);
                    }
                } else {
                    await TavernHelper.createLorebookEntries(bookName, [{
                        comment: targetEntryName,
                        content: combinedContent,
                        keys: [],
                        type: 'constant',
                        enabled: true,
                    }]);
                }

                const successMsg = `大总结已更新，共聚合 ${journeyEvents.length} 个事件。`;
                if (!isPolling) {
                    statusEl.textContent = successMsg;
                    this.showTemporaryMessage(successMsg, 'success');
                } else {
                    console.log(`[归墟-大总结] 自动更新成功，聚合 ${journeyEvents.length} 个事件。`);
                }

            } catch (error) {
                console.error('生成大总结时出错:', error);
                if (!isPolling) {
                    const errorMsg = `错误: ${error.message}`;
                    statusEl.textContent = errorMsg;
                    this.showTemporaryMessage(errorMsg, 'error', 5000);
                }
            } finally {
                // 按钮状态管理已移至调用处
            }
          },

          // --- 新增：分段记忆自动生成相关 ---
          startSegmentedMemoryPolling() {
              this.stopSegmentedMemoryPolling();
              this.segmentedMemoryIntervalId = setInterval(async () => {
                  await this.generateSegmentedMemory(true);
                  if (this.isSmallSummaryAutoOn) {
                      await this.generateSmallSummary(true);
                  }
                  if (this.isLargeSummaryAutoOn) {
                      await this.generateLargeSummary(true);
                  }
                  console.log('[归墟] 轮询更新完成。');
              }, 60000); // 每60秒检查一次
          },

          stopSegmentedMemoryPolling() {
              if (this.segmentedMemoryIntervalId) {
                  clearInterval(this.segmentedMemoryIntervalId);
                  this.segmentedMemoryIntervalId = null;
              }
          },

          saveSegmentedMemoryState() {
              try {
                  localStorage.setItem('guixu_segmented_memory_enabled', this.isSegmentedMemoryAutoGenerateEnabled);
              } catch (e) {
                  console.error('保存分段记忆状态失败:', e);
              }
          },

          loadSegmentedMemoryState() {
              try {
                  const savedState = localStorage.getItem('guixu_segmented_memory_enabled');
                  this.isSegmentedMemoryAutoGenerateEnabled = savedState === 'true';
                  if (this.isSegmentedMemoryAutoGenerateEnabled) {
                      this.startSegmentedMemoryPolling();
                  }
              } catch (e) {
                  console.error('加载分段记忆状态失败:', e);
                  this.isSegmentedMemoryAutoGenerateEnabled = false;
              }
          },

          saveSmallSummaryState() {
              try {
                  localStorage.setItem('guixu_small_summary_enabled', this.isSmallSummaryAutoOn);
              } catch (e) {
                  console.error('保存小总结状态失败:', e);
              }
          },

          loadSegmentedMemoryCounts() {
              try {
                  const segmentedCount = localStorage.getItem('guixu_segmented_memory_count');
                  const smallSummaryCount = localStorage.getItem('guixu_small_summary_count');
                  
                  const segmentedCountInput = document.getElementById('segmented-memory-count');
                  if (segmentedCountInput && segmentedCount !== null) {
                      segmentedCountInput.value = segmentedCount;
                  }

                  const smallSummaryCountInput = document.getElementById('small-summary-count');
                  if (smallSummaryCountInput && smallSummaryCount !== null) {
                      smallSummaryCountInput.value = smallSummaryCount;
                  }
              } catch (e) {
                  console.error('加载分段记忆保留数失败:', e);
              }
          },
          loadSegmentedMemoryCounts() {
              try {
                  const segmentedCount = localStorage.getItem('guixu_segmented_memory_count');
                  const smallSummaryCount = localStorage.getItem('guixu_small_summary_count');
                  
                  const segmentedCountInput = document.getElementById('segmented-memory-count');
                  if (segmentedCountInput && segmentedCount !== null) {
                      segmentedCountInput.value = segmentedCount;
                  }

                  const smallSummaryCountInput = document.getElementById('small-summary-count');
                  if (smallSummaryCountInput && smallSummaryCount !== null) {
                      smallSummaryCountInput.value = smallSummaryCount;
                  }
              } catch (e) {
                  console.error('加载分段记忆保留数失败:', e);
              }
          },

          loadSmallSummaryState() {
              try {
                  const savedState = localStorage.getItem('guixu_small_summary_enabled');
                  this.isSmallSummaryAutoOn = savedState === 'true';
              } catch (e) {
                  console.error('加载小总结状态失败:', e);
                  this.isSmallSummaryAutoOn = false;
              }
          },

          saveLargeSummaryState() {
              try {
                  localStorage.setItem('guixu_large_summary_enabled', this.isLargeSummaryAutoOn);
              } catch (e) {
                  console.error('保存大总结状态失败:', e);
              }
          },

          loadLargeSummaryState() {
              try {
                  const savedState = localStorage.getItem('guixu_large_summary_enabled');
                  this.isLargeSummaryAutoOn = savedState === 'true';
              } catch (e) {
                  console.error('加载大总结状态失败:', e);
                  this.isLargeSummaryAutoOn = false;
              }
          },
// ===分段记忆模块结束===



// ===世界书管理模块开始===
          // 显示世界书管理界面
          showWorldbookManager() {
            console.log('[世界书管理] 开始显示世界书管理界面');
            
            // 先打开模态框
            this.openModal('worldbook-manager-modal');
            
            // 检查模态框是否正确显示
            const modal = document.getElementById('worldbook-manager-modal');
            if (!modal) {
              console.error('[世界书管理] 找不到世界书管理模态框');
              this.showTemporaryMessage('世界书管理界面加载失败');
              return;
            }
            
            console.log('[世界书管理] 模态框显示状态:', modal.style.display);
            
            // 初始化界面状态
            this.worldbookManagerState = {
              allEntries: [],
              filteredEntries: [],
              currentFilter: 'all',
              currentPrefix: ''
            };
            
            // 延迟绑定事件监听器和加载数据，确保模态框已完全显示
            setTimeout(() => {
              console.log('[世界书管理] 开始绑定事件监听器');
              this.bindWorldbookManagerEvents();
              
              console.log('[世界书管理] 开始加载世界书条目');
              this.loadWorldbookEntries();
            }, 100);
          },

          // 加载世界书条目
          async loadWorldbookEntries() {
            console.log('[世界书管理] 开始加载世界书条目');
            
            const listContainer = document.getElementById('worldbook-entries-list');
            if (!listContainer) {
              console.error('[世界书管理] 找不到条目列表容器 worldbook-entries-list');
              return;
            }
            
            console.log('[世界书管理] 找到条目列表容器');
            
            try {
              listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #8b7355;"><div style="font-size: 24px; margin-bottom: 10px;">⏳</div>正在加载世界书条目...</div>';
              
              const bookName = '1归墟';
              console.log('[世界书管理] 开始调用 TavernHelper.getLorebookEntries，书名:', bookName);
              
              const entries = await TavernHelper.getLorebookEntries(bookName);
              console.log('[世界书管理] 获取到条目数量:', entries ? entries.length : 0);
              
              if (!entries || entries.length === 0) {
                console.log('[世界书管理] 没有找到世界书条目');
                listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #8b7355;"><div style="font-size: 48px; margin-bottom: 10px;">📚</div>暂无世界书条目</div>';
                this.updateWorldbookStats([], []);
                return;
              }
              
              // 保存所有条目
              this.worldbookManagerState.allEntries = entries;
              console.log('[世界书管理] 已保存条目到状态管理');
              
              // 应用当前筛选
              console.log('[世界书管理] 开始应用筛选');
              this.applyWorldbookFilter();
              
            } catch (error) {
              console.error('[世界书管理] 加载世界书条目失败:', error);
              listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #ff6b6b;"><div style="font-size: 48px; margin-bottom: 10px;">❌</div>加载失败，请重试<br><small>错误: ' + error.message + '</small></div>';
              this.updateWorldbookStats([], []);
            }
          },

          // 应用筛选条件
          applyWorldbookFilter() {
            if (!this.worldbookManagerState) return;
            
            const filterType = document.getElementById('worldbook-filter-type')?.value || 'all';
            const prefixFilter = document.getElementById('worldbook-prefix-filter')?.value.trim() || '';
            
            let filtered = [...this.worldbookManagerState.allEntries];
            
            // 按类型筛选
            switch (filterType) {
              case 'journey':
                filtered = filtered.filter(entry =>
                  entry.comment && (entry.comment.includes('本世历程') || entry.comment.includes('历程'))
                );
                break;
              case 'pastlife':
                filtered = filtered.filter(entry =>
                  entry.comment && (entry.comment.includes('往世涟漪') || entry.comment.includes('涟漪'))
                );
                break;
              case 'bracket':
                filtered = filtered.filter(entry =>
                  entry.comment && entry.comment.includes('【') && entry.comment.includes('】')
                );
                break;
              case 'enabled':
                filtered = filtered.filter(entry => entry.enabled);
                break;
              case 'disabled':
                filtered = filtered.filter(entry => !entry.enabled);
                break;
              case 'all':
              default:
                // 不筛选
                break;
            }
            
            // 按前缀筛选
            if (prefixFilter) {
              filtered = filtered.filter(entry =>
                entry.comment && entry.comment.includes(prefixFilter)
              );
            }
            
            this.worldbookManagerState.filteredEntries = filtered;
            this.worldbookManagerState.currentFilter = filterType;
            this.worldbookManagerState.currentPrefix = prefixFilter;
            
            // 渲染筛选后的条目
            this.renderWorldbookEntries(filtered);
            
            // 更新统计信息
            this.updateWorldbookStats(this.worldbookManagerState.allEntries, filtered);
          },

          // 更新统计信息
          updateWorldbookStats(allEntries, filteredEntries) {
            const totalCount = allEntries.length;
            const enabledCount = allEntries.filter(e => e.enabled).length;
            const disabledCount = totalCount - enabledCount;
            const filteredCount = filteredEntries.length;
            
            document.getElementById('stats-total').textContent = totalCount;
            document.getElementById('stats-enabled').textContent = enabledCount;
            document.getElementById('stats-disabled').textContent = disabledCount;
            document.getElementById('stats-filtered').textContent = filteredCount;
          },

          // 渲染世界书条目列表
          renderWorldbookEntries(entries) {
            const listContainer = document.getElementById('worldbook-entries-list');
            if (!listContainer) return;
            
            if (!entries || entries.length === 0) {
              listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #8b7355;"><div style="font-size: 48px; margin-bottom: 10px;">🔍</div>没有符合筛选条件的条目</div>';
              return;
            }
            
            listContainer.innerHTML = '';
            
            entries.forEach((entry, index) => {
              const entryDiv = document.createElement('div');
              entryDiv.className = 'worldbook-entry-item';
              entryDiv.style.cssText = `
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 12px;
                margin: 8px;
                background: rgba(26, 26, 46, 0.4);
                border-radius: 6px;
                border: 1px solid ${entry.enabled ? '#4a9eff' : '#8b7355'};
                transition: all 0.2s ease;
              `;
              
              // 鼠标悬浮效果
              entryDiv.addEventListener('mouseenter', () => {
                entryDiv.style.background = 'rgba(26, 26, 46, 0.6)';
                entryDiv.style.borderColor = entry.enabled ? '#5ba0ff' : '#c9aa71';
              });
              entryDiv.addEventListener('mouseleave', () => {
                entryDiv.style.background = 'rgba(26, 26, 46, 0.4)';
                entryDiv.style.borderColor = entry.enabled ? '#4a9eff' : '#8b7355';
              });
              
              // 左侧信息区域
              const infoDiv = document.createElement('div');
              infoDiv.style.cssText = 'flex: 1; min-width: 0; margin-right: 15px;';
              
              // 序号和标题
              const titleDiv = document.createElement('div');
              titleDiv.style.cssText = 'display: flex; align-items: center; margin-bottom: 4px;';
              
              const indexSpan = document.createElement('span');
              indexSpan.style.cssText = `
                display: inline-block;
                width: 30px;
                height: 20px;
                line-height: 20px;
                text-align: center;
                background: ${entry.enabled ? '#4a9eff' : '#8b7355'};
                color: white;
                font-size: 10px;
                border-radius: 10px;
                margin-right: 8px;
                font-weight: bold;
              `;
              indexSpan.textContent = (index + 1).toString();
              
              const titleSpan = document.createElement('span');
              titleSpan.style.cssText = `
                color: ${entry.enabled ? '#4a9eff' : '#c9aa71'};
                font-size: 13px;
                font-weight: bold;
                flex: 1;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
              `;
              titleSpan.textContent = entry.comment || '未命名条目';
              titleSpan.title = entry.comment || '未命名条目';
              
              titleDiv.appendChild(indexSpan);
              titleDiv.appendChild(titleSpan);
              
              // 状态和类型信息
              const metaDiv = document.createElement('div');
              metaDiv.style.cssText = 'display: flex; align-items: center; gap: 8px;';
              
              const statusSpan = document.createElement('span');
              statusSpan.style.cssText = `
                color: ${entry.enabled ? '#90ee90' : '#ff6b6b'};
                font-size: 11px;
                font-weight: bold;
              `;
              statusSpan.textContent = entry.enabled ? '✓ 已启用' : '✗ 已禁用';
              
              // 条目类型标签
              const typeSpan = document.createElement('span');
              let typeText = '普通';
              let typeColor = '#888';
              
              if (entry.comment) {
                if (entry.comment.includes('本世历程') || entry.comment.includes('历程')) {
                  typeText = '本世历程';
                  typeColor = '#007bff';
                } else if (entry.comment.includes('往世涟漪') || entry.comment.includes('涟漪')) {
                  typeText = '往世涟漪';
                  typeColor = '#9932cc';
                } else if (entry.comment.includes('【') && entry.comment.includes('】')) {
                  const match = entry.comment.match(/【([^】]+)】/);
                  if (match) {
                    typeText = `【${match[1]}】`;
                    typeColor = '#28a745';
                  }
                }
              }
              
              typeSpan.style.cssText = `
                background: rgba(${typeColor === '#007bff' ? '0, 123, 255' :
                                  typeColor === '#9932cc' ? '153, 50, 204' :
                                  typeColor === '#28a745' ? '40, 167, 69' : '136, 136, 136'}, 0.2);
                color: ${typeColor};
                font-size: 10px;
                padding: 2px 6px;
                border-radius: 10px;
                border: 1px solid ${typeColor};
              `;
              typeSpan.textContent = typeText;
              
              metaDiv.appendChild(statusSpan);
              metaDiv.appendChild(typeSpan);
              
              infoDiv.appendChild(titleDiv);
              infoDiv.appendChild(metaDiv);
              
              // 右侧操作按钮区域
              const actionsDiv = document.createElement('div');
              actionsDiv.style.cssText = 'display: flex; gap: 6px; flex-shrink: 0;';
              
              // 开启/关闭按钮
              const toggleBtn = document.createElement('button');
              toggleBtn.className = 'interaction-btn';
              toggleBtn.style.cssText = `
                padding: 4px 8px;
                font-size: 11px;
                border: 1px solid ${entry.enabled ? '#ff6b6b' : '#90ee90'};
                background: ${entry.enabled ? 'rgba(255, 107, 107, 0.2)' : 'rgba(144, 238, 144, 0.2)'};
                color: ${entry.enabled ? '#ff6b6b' : '#90ee90'};
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
              `;
              toggleBtn.textContent = entry.enabled ? '关闭' : '开启';
              toggleBtn.onclick = () => this.toggleWorldbookEntry(entry.uid, !entry.enabled);
              
              // 删除按钮
              const deleteBtn = document.createElement('button');
              deleteBtn.className = 'interaction-btn';
              deleteBtn.style.cssText = `
                padding: 4px 8px;
                font-size: 11px;
                border: 1px solid #ff6b6b;
                background: rgba(255, 107, 107, 0.2);
                color: #ff6b6b;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
              `;
              deleteBtn.textContent = '删除';
              deleteBtn.onclick = () => this.deleteWorldbookEntry(entry.uid, entry.comment);
              
              actionsDiv.appendChild(toggleBtn);
              actionsDiv.appendChild(deleteBtn);
              
              entryDiv.appendChild(infoDiv);
              entryDiv.appendChild(actionsDiv);
              
              listContainer.appendChild(entryDiv);
            });
          },

          // 批量启用筛选项
          async enableFilteredEntries() {
            if (!this.worldbookManagerState?.filteredEntries) return;
            
            const entries = this.worldbookManagerState.filteredEntries.filter(e => !e.enabled);
            if (entries.length === 0) {
              this.showTemporaryMessage('没有需要启用的条目');
              return;
            }

            this.showConfirmModal(
              '批量启用确认',
              `确定要启用 ${entries.length} 个条目吗？`,
              async () => {
                try {
                  const bookName = '1归墟';
                  const updates = entries.map(entry => ({ uid: entry.uid, enabled: true }));
                  await TavernHelper.setLorebookEntries(bookName, updates);
                  this.showTemporaryMessage(`已启用 ${entries.length} 个条目`);
                  this.loadWorldbookEntries();
                } catch (error) {
                  console.error('批量启用失败:', error);
                  this.showTemporaryMessage('批量启用失败，请重试');
                }
              }
            );
          },

          // 批量禁用筛选项
          async disableFilteredEntries() {
            if (!this.worldbookManagerState?.filteredEntries) return;
            
            const entries = this.worldbookManagerState.filteredEntries.filter(e => e.enabled);
            if (entries.length === 0) {
              this.showTemporaryMessage('没有需要禁用的条目');
              return;
            }
            
            this.showConfirmModal(
              '批量禁用确认',
              `确定要禁用 ${entries.length} 个条目吗？`,
              async () => {
                try {
                  const bookName = '1归墟';
                  const updates = entries.map(entry => ({ uid: entry.uid, enabled: false }));
                  await TavernHelper.setLorebookEntries(bookName, updates);
                  this.showTemporaryMessage(`已禁用 ${entries.length} 个条目`);
                  this.loadWorldbookEntries();
                } catch (error) {
                  console.error('批量禁用失败:', error);
                  this.showTemporaryMessage('批量禁用失败，请重试');
                }
              }
            );
          },

          // 显示删除确认模态框
          showDeleteConfirmModal(deleteType, deleteData) {
            // 存储删除相关数据
            this.deleteConfirmState = {
              type: deleteType, // 'single' 或 'batch'
              data: deleteData, // 单个条目的 {uid, comment} 或批量条目数组
              step: 1 // 当前确认步骤
            };

            // 更新模态框内容
            this.updateDeleteConfirmContent();
            
            // 显示模态框
            this.openModal('worldbook-delete-confirm-modal');
            
            // 绑定事件监听器
            setTimeout(() => {
              this.bindDeleteConfirmEvents();
            }, 100);
          },

          // 更新删除确认模态框内容
          updateDeleteConfirmContent() {
            const state = this.deleteConfirmState;
            if (!state) return;

            // 使用现有HTML结构中的元素ID
            const step1El = document.getElementById('delete-step-1');
            const step2El = document.getElementById('delete-step-2');
            const deleteItemDetailsEl = document.getElementById('delete-item-details');
            const confirmationInputEl = document.getElementById('delete-confirmation-input');

            if (!step1El || !step2El) {
              console.error('删除确认模态框元素未找到');
              return;
            }

            if (state.step === 1) {
              // 显示第一步
              step1El.style.display = 'block';
              step2El.style.display = 'none';
              
              if (deleteItemDetailsEl) {
                if (state.type === 'single') {
                  const { comment } = state.data;
                  deleteItemDetailsEl.innerHTML = `单个条目: <strong>"${comment}"</strong>`;
                } else if (state.type === 'batch') {
                  const entries = state.data;
                  deleteItemDetailsEl.innerHTML = `批量删除: <strong>${entries.length} 个条目</strong>`;
                }
              }
            } else {
              // 显示第二步
              step1El.style.display = 'none';
              step2El.style.display = 'block';
              
              // 清空输入框
              if (confirmationInputEl) {
                confirmationInputEl.value = '';
              }
            }
          },

          // 处理删除确认的下一步
          proceedDeleteConfirm() {
            if (!this.deleteConfirmState) return;

            if (this.deleteConfirmState.step === 1) {
              // 进入第二步确认
              this.deleteConfirmState.step = 2;
              this.updateDeleteConfirmContent();
            }
          },

          // 执行最终删除操作
          async executeDelete() {
            const state = this.deleteConfirmState;
            if (!state || state.step !== 2) return;

            // 临时阻止自动返回设置界面
            const originalFromSettings = this.isFromSettingsModal;
            this.isFromSettingsModal = false;

            // 验证输入 - 使用正确的元素ID
            const inputEl = document.getElementById('delete-confirmation-input');
            if (!inputEl) {
              console.error('删除确认输入框未找到');
              return;
            }
            
            const input = inputEl.value.trim();
            if (input !== '确认删除') {
              this.showTemporaryMessage('输入不正确，请输入"确认删除"');
              // 显示错误提示
              const errorEl = document.getElementById('delete-input-error');
              if (errorEl) {
                errorEl.style.display = 'block';
                setTimeout(() => {
                  errorEl.style.display = 'none';
                }, 3000);
              }
              // 恢复原始状态
              this.isFromSettingsModal = originalFromSettings;
              return;
            }

            try {
              const bookName = '1归墟';
              
              // 在删除前获取完整的条目数据用于缓存
              let entriesToCache = [];
              
              if (state.type === 'single') {
                const { uid } = state.data;
                // 从当前加载的条目中找到完整数据
                const fullEntry = this.worldbookManagerState?.allEntries?.find(entry => entry.uid === uid);
                if (fullEntry) {
                  entriesToCache = [fullEntry];
                }
                await TavernHelper.deleteLorebookEntries(bookName, [uid]);
                this.showTemporaryMessage('世界书条目已删除');
              } else if (state.type === 'batch') {
                const uids = state.data.map(entry => entry.uid);
                // 获取所有要删除条目的完整数据
                entriesToCache = state.data.slice(); // 复制数组
                await TavernHelper.deleteLorebookEntries(bookName, uids);
                this.showTemporaryMessage(`已删除 ${state.data.length} 个条目`);
              }

              // 将删除的条目添加到缓存
              if (entriesToCache.length > 0) {
                this.addToDeleteCache(entriesToCache, state.type);
              }

              // 关闭确认模态框
              this.closeModal('worldbook-delete-confirm-modal');
              this.deleteConfirmState = null;
              
              // 恢复原始的isFromSettingsModal状态
              this.isFromSettingsModal = originalFromSettings;

              // 修复：返回到世界书管理界面，而不是主界面
              this.showWorldbookManager();
              
            } catch (error) {
              console.error('删除操作失败:', error);
              this.showTemporaryMessage('删除失败，请重试');
              // 恢复原始状态
              this.isFromSettingsModal = originalFromSettings;
            }
          },

          // 取消删除操作
          cancelDelete() {
            this.closeModal('worldbook-delete-confirm-modal');
            this.deleteConfirmState = null;
            this.showTemporaryMessage('删除操作已取消');
            // 返回到世界书管理界面
            this.showWorldbookManager();
          },

          // --- 删除缓存管理功能 ---
          
          // 添加条目到删除缓存
          addToDeleteCache(entries, deleteType) {
            try {
              // 获取现有缓存
              let deleteCache = this.getDeleteCache();
              
              // 创建缓存条目
              const cacheEntry = {
                id: Date.now() + Math.random(), // 唯一ID
                timestamp: new Date().toISOString(),
                type: deleteType, // 'single' 或 'batch'
                count: entries.length,
                entries: entries.map(entry => {
                  // 保存完整的条目数据以确保无损恢复，使用正确的API字段结构
                  const savedEntry = { ...entry }; // 完整复制原始条目
                  
                  // 确保关键字段存在
                  if (!savedEntry.keys) savedEntry.keys = [];
                  if (!savedEntry.filters) savedEntry.filters = [];
                  if (typeof savedEntry.enabled !== 'boolean') savedEntry.enabled = true;
                  if (!savedEntry.type) savedEntry.type = 'selective';
                  if (!savedEntry.position) savedEntry.position = 'after_character_definition';
                  if (!savedEntry.logic) savedEntry.logic = 'and_any';
                  if (typeof savedEntry.probability !== 'number') savedEntry.probability = 100;
                  if (typeof savedEntry.order !== 'number') savedEntry.order = 0;
                  
                  // 确保扫描和匹配设置存在
                  if (savedEntry.scan_depth === undefined) savedEntry.scan_depth = 'same_as_global';
                  if (savedEntry.case_sensitive === undefined) savedEntry.case_sensitive = 'same_as_global';
                  if (savedEntry.match_whole_words === undefined) savedEntry.match_whole_words = 'same_as_global';
                  if (savedEntry.use_group_scoring === undefined) savedEntry.use_group_scoring = 'same_as_global';
                  
                  // 确保递归控制字段存在
                  if (typeof savedEntry.exclude_recursion !== 'boolean') savedEntry.exclude_recursion = false;
                  if (typeof savedEntry.prevent_recursion !== 'boolean') savedEntry.prevent_recursion = false;
                  if (savedEntry.delay_until_recursion === undefined) savedEntry.delay_until_recursion = false;
                  
                  // 确保分组和其他高级字段存在
                  if (!savedEntry.group) savedEntry.group = '';
                  if (typeof savedEntry.group_prioritized !== 'boolean') savedEntry.group_prioritized = false;
                  if (typeof savedEntry.group_weight !== 'number') savedEntry.group_weight = 100;
                  
                  // 确保可为null的字段正确处理
                  if (savedEntry.sticky === undefined) savedEntry.sticky = null;
                  if (savedEntry.cooldown === undefined) savedEntry.cooldown = null;
                  if (savedEntry.delay === undefined) savedEntry.delay = null;
                  if (savedEntry.automation_id === undefined) savedEntry.automation_id = null;
                  if (savedEntry.depth === undefined) savedEntry.depth = null;
                  
                  // 确保基础字符串字段存在
                  if (!savedEntry.comment) savedEntry.comment = '';
                  if (!savedEntry.content) savedEntry.content = '';
                  
                  console.log('[删除缓存] 保存的完整字段:', Object.keys(savedEntry));
                  console.log('[删除缓存] 字段详情:', {
                    uid: savedEntry.uid,
                    display_index: savedEntry.display_index,
                    comment: savedEntry.comment,
                    enabled: savedEntry.enabled,
                    type: savedEntry.type,
                    position: savedEntry.position,
                    depth: savedEntry.depth,
                    order: savedEntry.order,
                    probability: savedEntry.probability,
                    keys: savedEntry.keys,
                    logic: savedEntry.logic,
                    filters: savedEntry.filters,
                    scan_depth: savedEntry.scan_depth,
                    case_sensitive: savedEntry.case_sensitive,
                    match_whole_words: savedEntry.match_whole_words,
                    use_group_scoring: savedEntry.use_group_scoring,
                    automation_id: savedEntry.automation_id,
                    exclude_recursion: savedEntry.exclude_recursion,
                    prevent_recursion: savedEntry.prevent_recursion,
                    delay_until_recursion: savedEntry.delay_until_recursion,
                    content: savedEntry.content,
                    group: savedEntry.group,
                    group_prioritized: savedEntry.group_prioritized,
                    group_weight: savedEntry.group_weight,
                    sticky: savedEntry.sticky,
                    cooldown: savedEntry.cooldown,
                    delay: savedEntry.delay
                  });
                  
                  return savedEntry;
                })
              };
              
              // 添加到缓存开头
              deleteCache.unshift(cacheEntry);
              
              // 保持最多10个缓存条目
              if (deleteCache.length > 10) {
                deleteCache = deleteCache.slice(0, 10);
              }
              
              // 保存到localStorage
              localStorage.setItem('guixu_worldbook_delete_cache', JSON.stringify(deleteCache));
              
              console.log(`[删除缓存] 已缓存 ${entries.length} 个条目，缓存总数: ${deleteCache.length}`);
              
            } catch (error) {
              console.error('保存删除缓存失败:', error);
            }
          },

          // 获取删除缓存
          getDeleteCache() {
            try {
              const cache = localStorage.getItem('guixu_worldbook_delete_cache');
              return cache ? JSON.parse(cache) : [];
            } catch (error) {
              console.error('读取删除缓存失败:', error);
              return [];
            }
          },

          // 从缓存中恢复条目
          async restoreFromCache(cacheId) {
            // 临时阻止自动返回设置界面
            const originalFromSettings = this.isFromSettingsModal;
            this.isFromSettingsModal = false;
            
            try {
              const deleteCache = this.getDeleteCache();
              const cacheEntry = deleteCache.find(entry => entry.id === cacheId);
              
              if (!cacheEntry) {
                this.showTemporaryMessage('缓存条目不存在');
                // 恢复原始状态
                this.isFromSettingsModal = originalFromSettings;
                return;
              }

              const bookName = '1归墟';
              
              console.log('[恢复缓存] 开始恢复条目:', cacheEntry);
              
              // 准备要恢复的条目数据，只移除uid和display_index让系统自动生成，保留所有其他字段
              const entriesToRestore = cacheEntry.entries.map(entry => {
                const newEntry = { ...entry }; // 完整复制缓存的条目数据
                
                // 只移除这两个字段，让API自动生成
                delete newEntry.uid;
                delete newEntry.display_index;
                
                // 验证所有API要求的字段都存在，确保数据完整性
                const requiredFields = [
                  'comment', 'enabled', 'type', 'position', 'depth', 'order', 'probability',
                  'keys', 'logic', 'filters', 'scan_depth', 'case_sensitive', 'match_whole_words',
                  'use_group_scoring', 'automation_id', 'exclude_recursion', 'prevent_recursion',
                  'delay_until_recursion', 'content', 'group', 'group_prioritized', 'group_weight',
                  'sticky', 'cooldown', 'delay'
                ];
                
                // 检查是否有缺失的字段
                const missingFields = requiredFields.filter(field => !(field in newEntry));
                if (missingFields.length > 0) {
                  console.warn('[恢复缓存] 发现缺失字段:', missingFields);
                }
                
                // 验证字段类型和值的正确性
                console.log('[恢复缓存] 恢复条目的完整字段验证:', {
                  comment: typeof newEntry.comment + ' = ' + JSON.stringify(newEntry.comment),
                  enabled: typeof newEntry.enabled + ' = ' + newEntry.enabled,
                  type: typeof newEntry.type + ' = ' + newEntry.type,
                  position: typeof newEntry.position + ' = ' + newEntry.position,
                  depth: typeof newEntry.depth + ' = ' + newEntry.depth,
                  order: typeof newEntry.order + ' = ' + newEntry.order,
                  probability: typeof newEntry.probability + ' = ' + newEntry.probability,
                  keys: Array.isArray(newEntry.keys) + ' = ' + JSON.stringify(newEntry.keys),
                  logic: typeof newEntry.logic + ' = ' + newEntry.logic,
                  filters: Array.isArray(newEntry.filters) + ' = ' + JSON.stringify(newEntry.filters),
                  scan_depth: typeof newEntry.scan_depth + ' = ' + newEntry.scan_depth,
                  case_sensitive: typeof newEntry.case_sensitive + ' = ' + newEntry.case_sensitive,
                  match_whole_words: typeof newEntry.match_whole_words + ' = ' + newEntry.match_whole_words,
                  use_group_scoring: typeof newEntry.use_group_scoring + ' = ' + newEntry.use_group_scoring,
                  automation_id: typeof newEntry.automation_id + ' = ' + newEntry.automation_id,
                  exclude_recursion: typeof newEntry.exclude_recursion + ' = ' + newEntry.exclude_recursion,
                  prevent_recursion: typeof newEntry.prevent_recursion + ' = ' + newEntry.prevent_recursion,
                  delay_until_recursion: typeof newEntry.delay_until_recursion + ' = ' + newEntry.delay_until_recursion,
                  content: typeof newEntry.content + ' = ' + JSON.stringify(newEntry.content?.substring(0, 50) + '...'),
                  group: typeof newEntry.group + ' = ' + JSON.stringify(newEntry.group),
                  group_prioritized: typeof newEntry.group_prioritized + ' = ' + newEntry.group_prioritized,
                  group_weight: typeof newEntry.group_weight + ' = ' + newEntry.group_weight,
                  sticky: typeof newEntry.sticky + ' = ' + newEntry.sticky,
                  cooldown: typeof newEntry.cooldown + ' = ' + newEntry.cooldown,
                  delay: typeof newEntry.delay + ' = ' + newEntry.delay
                });
                
                console.log('[恢复缓存] 恢复条目字段总数:', Object.keys(newEntry).length);
                console.log('[恢复缓存] 恢复条目所有字段:', Object.keys(newEntry).sort());
                
                return newEntry;
              });

              console.log('[恢复缓存] 准备恢复的条目:', entriesToRestore);

              // 使用createLorebookEntries API创建新条目
              const result = await TavernHelper.createLorebookEntries(bookName, entriesToRestore);
              console.log('[恢复缓存] 恢复结果:', result);

              if (result && result.new_uids && result.new_uids.length > 0) {
                // 从缓存中移除已恢复的条目
                const updatedCache = deleteCache.filter(entry => entry.id !== cacheId);
                localStorage.setItem('guixu_worldbook_delete_cache', JSON.stringify(updatedCache));
                
                this.showTemporaryMessage(`成功恢复 ${result.new_uids.length} 个条目`);
                
                // 刷新世界书列表
                this.loadWorldbookEntries();
                
                // 如果删除历史界面是打开的，也刷新它
                if (document.getElementById('worldbook-delete-history-modal')?.style.display !== 'none') {
                  this.renderDeleteHistory();
                }
                
                // 恢复原始的isFromSettingsModal状态
                this.isFromSettingsModal = originalFromSettings;
                
              } else {
                console.error('[恢复缓存] 恢复失败，API返回结果异常:', result);
                this.showTemporaryMessage('恢复失败：API调用异常');
              }
              
            } catch (error) {
              console.error('[恢复缓存] 恢复条目失败:', error);
              this.showTemporaryMessage(`恢复失败: ${error.message}`);
            }
          },

          // 显示通用确认模态框
          showConfirmModal(title, message, onConfirm, onCancel = null) {
            const modal = document.getElementById('worldbook-confirm-modal');
            const titleEl = document.getElementById('confirm-modal-title');
            const messageEl = document.getElementById('confirm-modal-message');
            const confirmBtn = document.getElementById('confirm-modal-confirm');
            const cancelBtn = document.getElementById('confirm-modal-cancel');

            if (!modal || !titleEl || !messageEl || !confirmBtn || !cancelBtn) {
              console.error('确认模态框元素未找到');
              return;
            }

            titleEl.textContent = title;
            messageEl.innerHTML = message;

            // 清除之前的事件监听器
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            // 添加新的事件监听器
            newConfirmBtn.addEventListener('click', () => {
              this.closeModal('worldbook-confirm-modal');
              if (onConfirm) onConfirm();
            });

            newCancelBtn.addEventListener('click', () => {
              this.closeModal('worldbook-confirm-modal');
              if (onCancel) onCancel();
            });

            this.openModal('worldbook-confirm-modal');
          },

          // 显示恢复确认模态框
          showRestoreConfirmModal(message, onConfirm, onCancel = null) {
            const modal = document.getElementById('worldbook-restore-confirm-modal');
            const messageEl = document.getElementById('restore-confirm-message');
            const confirmBtn = document.getElementById('restore-confirm-confirm');
            const cancelBtn = document.getElementById('restore-confirm-cancel');

            if (!modal || !messageEl || !confirmBtn || !cancelBtn) {
              console.error('恢复确认模态框元素未找到');
              return;
            }

            messageEl.innerHTML = message;

            // 清除之前的事件监听器
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            // 添加新的事件监听器
            newConfirmBtn.addEventListener('click', () => {
              this.closeModal('worldbook-restore-confirm-modal');
              if (onConfirm) onConfirm();
              // 返回到世界书管理界面
              this.showWorldbookManager();
            });

            newCancelBtn.addEventListener('click', () => {
              this.closeModal('worldbook-restore-confirm-modal');
              if (onCancel) onCancel();
              // 返回到世界书管理界面
              this.showWorldbookManager();
            });

            this.openModal('worldbook-restore-confirm-modal');
          },

          // 显示移除历史确认模态框
          showRemoveHistoryConfirmModal(message, onConfirm, onCancel = null) {
            const modal = document.getElementById('worldbook-remove-history-confirm-modal');
            const messageEl = document.getElementById('remove-history-confirm-message');
            const confirmBtn = document.getElementById('remove-history-confirm-confirm');
            const cancelBtn = document.getElementById('remove-history-confirm-cancel');

            if (!modal || !messageEl || !confirmBtn || !cancelBtn) {
              console.error('移除历史确认模态框元素未找到');
              return;
            }

            messageEl.innerHTML = message;

            // 清除之前的事件监听器
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            // 添加新的事件监听器
            newConfirmBtn.addEventListener('click', () => {
              this.closeModal('worldbook-remove-history-confirm-modal');
              if (onConfirm) onConfirm();
              // 返回到世界书管理界面
              this.showWorldbookManager();
            });

            newCancelBtn.addEventListener('click', () => {
              this.closeModal('worldbook-remove-history-confirm-modal');
              if (onCancel) onCancel();
              // 返回到世界书管理界面
              this.showWorldbookManager();
            });

            this.openModal('worldbook-remove-history-confirm-modal');
          },

          // 清空删除缓存
          clearDeleteCache() {
            try {
              localStorage.removeItem('guixu_worldbook_delete_cache');
              this.showTemporaryMessage('删除缓存已清空');
              
              // 如果删除历史界面是打开的，刷新它
              if (document.getElementById('worldbook-delete-history-modal')?.style.display !== 'none') {
                this.renderDeleteHistory();
              }
            } catch (error) {
              console.error('清空删除缓存失败:', error);
            }
          },

          // 从缓存中移除指定条目
          removeFromCache(cacheId) {
            try {
              const deleteCache = this.getDeleteCache();
              const updatedCache = deleteCache.filter(entry => entry.id !== cacheId);
              localStorage.setItem('guixu_worldbook_delete_cache', JSON.stringify(updatedCache));
              
              // 如果删除历史界面是打开的，刷新它
              if (document.getElementById('worldbook-delete-history-modal')?.style.display !== 'none') {
                this.renderDeleteHistory();
              }
            } catch (error) {
              console.error('移除缓存条目失败:', error);
            }
          },

          // --- 删除历史管理界面功能 ---
          
          // 显示删除历史管理界面
          showDeleteHistory() {
            this.openModal('worldbook-delete-history-modal');
            this.renderDeleteHistory();
            
            // 绑定事件监听器
            setTimeout(() => {
              this.bindDeleteHistoryEvents();
            }, 100);
          },

          // 渲染删除历史列表
          renderDeleteHistory() {
            const listContainer = document.getElementById('delete-history-list');
            const countElement = document.getElementById('delete-history-count');
            
            if (!listContainer || !countElement) return;

            const deleteCache = this.getDeleteCache();
            
            // 更新统计信息
            countElement.textContent = `共有 ${deleteCache.length} 条删除记录`;

            if (deleteCache.length === 0) {
              listContainer.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #8b7355;">
                  <div style="font-size: 48px; margin-bottom: 15px;">📭</div>
                  <div style="font-size: 16px; margin-bottom: 8px;">暂无删除记录</div>
                  <div style="font-size: 12px;">删除的条目会自动保存在这里，方便您随时恢复</div>
                </div>
              `;
              return;
            }

            listContainer.innerHTML = '';

            deleteCache.forEach((cacheEntry, index) => {
              const entryDiv = document.createElement('div');
              entryDiv.className = 'delete-history-item';
              entryDiv.style.cssText = `
                background: rgba(26, 26, 46, 0.4);
                border: 1px solid #8b7355;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 12px;
                transition: all 0.3s ease;
              `;

              // 鼠标悬浮效果
              entryDiv.addEventListener('mouseenter', () => {
                entryDiv.style.background = 'rgba(26, 26, 46, 0.6)';
                entryDiv.style.borderColor = '#c9aa71';
              });
              entryDiv.addEventListener('mouseleave', () => {
                entryDiv.style.background = 'rgba(26, 26, 46, 0.4)';
                entryDiv.style.borderColor = '#8b7355';
              });

              const deleteTime = new Date(cacheEntry.timestamp);
              const timeStr = deleteTime.toLocaleString('zh-CN');
              
              entryDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                  <div style="flex: 1;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                      <span style="background: ${cacheEntry.type === 'single' ? '#007bff' : '#9932cc'}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 10px; margin-right: 10px;">
                        ${cacheEntry.type === 'single' ? '单个删除' : '批量删除'}
                      </span>
                      <span style="color: #c9aa71; font-size: 14px; font-weight: bold;">
                        ${cacheEntry.count} 个条目
                      </span>
                    </div>
                    <div style="color: #8b7355; font-size: 12px; margin-bottom: 8px;">
                      删除时间: ${timeStr}
                    </div>
                    <div style="color: #8b7355; font-size: 11px;">
                      ${cacheEntry.entries.map(entry => entry.comment || '未命名条目').slice(0, 3).join(', ')}
                      ${cacheEntry.entries.length > 3 ? ` 等${cacheEntry.entries.length}个条目` : ''}
                    </div>
                  </div>
                  <div style="display: flex; gap: 8px; flex-shrink: 0;">
                    <button class="restore-cache-btn interaction-btn" data-cache-id="${cacheEntry.id}"
                            style="background: rgba(40, 167, 69, 0.2); border-color: #28a745; color: #28a745; font-size: 11px; padding: 6px 12px;">
                      🔄 恢复
                    </button>
                    <button class="remove-cache-btn interaction-btn" data-cache-id="${cacheEntry.id}"
                            style="background: rgba(255, 107, 107, 0.2); border-color: #ff6b6b; color: #ff6b6b; font-size: 11px; padding: 6px 12px;">
                      🗑️ 移除
                    </button>
                  </div>
                </div>
                <div class="delete-history-details" style="background: rgba(0, 0, 0, 0.2); border-radius: 4px; padding: 10px; font-size: 11px; color: #8b7355; max-height: 100px; overflow-y: auto;">
                  <strong>包含条目:</strong><br>
                  ${cacheEntry.entries.map((entry, i) => `${i + 1}. ${entry.comment || '未命名条目'}`).join('<br>')}
                </div>
              `;

              listContainer.appendChild(entryDiv);
            });
          },

          // 绑定删除历史界面事件监听器
          bindDeleteHistoryEvents() {
            // 清空历史按钮
            const clearBtn = document.getElementById('clear-delete-history-btn');
            if (clearBtn) {
              clearBtn.addEventListener('click', () => {
                this.showConfirmModal(
                  '清空删除历史',
                  '确定要清空所有删除历史吗？<br><br><span style="color: #ff6b6b; font-weight: bold;">⚠️ 清空后将无法恢复这些记录</span>',
                  () => {
                    this.clearDeleteCache();
                  }
                );
              });
            }

            // 关闭按钮
            const closeBtn = document.getElementById('close-delete-history');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.closeModal('worldbook-delete-history-modal');
              });
            }

            // 模态框背景点击关闭
            const modal = document.getElementById('worldbook-delete-history-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.closeModal('worldbook-delete-history-modal');
                }
              });
            }

            // 恢复和移除按钮事件委托
            const listContainer = document.getElementById('delete-history-list');
            if (listContainer) {
              listContainer.addEventListener('click', (e) => {
                const target = e.target;
                
                if (target.classList.contains('restore-cache-btn')) {
                  const cacheId = parseFloat(target.dataset.cacheId);
                  this.showRestoreConfirmModal(
                    '确定要恢复这些删除的条目吗？',
                    () => this.restoreFromCache(cacheId)
                  );
                } else if (target.classList.contains('remove-cache-btn')) {
                  const cacheId = parseFloat(target.dataset.cacheId);
                  this.showRemoveHistoryConfirmModal(
                    '确定要从历史记录中移除这条记录吗？<br><span style="color: #ff6b6b; font-weight: bold;">移除后将无法恢复。</span>',
                    () => this.removeFromCache(cacheId)
                  );
                }
              });
            }
          },

          // 批量删除筛选项（修改为使用新的确认流程）
          async deleteFilteredEntries() {
            if (!this.worldbookManagerState?.filteredEntries) return;
            
            const entries = this.worldbookManagerState.filteredEntries;
            if (entries.length === 0) {
              this.showTemporaryMessage('没有需要删除的条目');
              return;
            }

            // 使用新的删除确认模态框
            this.showDeleteConfirmModal('batch', entries);
          },

          async toggleWorldbookEntry(uid, enabled) {
            try {
              const bookName = '1归墟';
              await TavernHelper.setLorebookEntries(bookName, [{ uid, enabled }]);
              this.showTemporaryMessage(`世界书条目已${enabled ? '启用' : '禁用'}`);
              this.loadWorldbookEntries(); // 刷新列表
            } catch (error) {
              console.error('切换世界书条目状态失败:', error);
              this.showTemporaryMessage('操作失败，请重试');
            }
          },

          // 删除单个世界书条目（简化为一次确认）
          async deleteWorldbookEntry(uid, comment) {
            // 单个条目删除只需要简单确认，不需要二次确认和输入文本
            this.showConfirmModal(
              '删除条目确认',
              `确定要删除条目 <strong>"${comment}"</strong> 吗？<br><br><span style="color: #4a9eff;">💾 删除后可以在删除历史中恢复</span>`,
              async () => {
                try {
                  const bookName = '1归墟';
                  
                  // 在删除前获取完整的条目数据用于缓存
                  const fullEntry = this.worldbookManagerState?.allEntries?.find(entry => entry.uid === uid);
                  if (fullEntry) {
                    // 添加到删除缓存
                    this.addToDeleteCache([fullEntry]);
                  }
                  
                  // 执行删除
                  await TavernHelper.deleteLorebookEntries(bookName, [uid]);
                  this.showTemporaryMessage('世界书条目已删除');
                  
                  // 刷新列表并返回世界书管理界面
                  this.showWorldbookManager();
                } catch (error) {
                  console.error('删除世界书条目失败:', error);
                  this.showTemporaryMessage('删除失败，请重试');
                }
              }
            );
          },

          // 绑定世界书管理界面事件监听器
          bindWorldbookManagerEvents() {
            // 筛选类型变化
            const filterTypeSelect = document.getElementById('worldbook-filter-type');
            if (filterTypeSelect) {
              filterTypeSelect.addEventListener('change', () => {
                this.applyWorldbookFilter();
              });
            }

            // 前缀筛选输入
            const prefixFilterInput = document.getElementById('worldbook-prefix-filter');
            if (prefixFilterInput) {
              prefixFilterInput.addEventListener('input', () => {
                this.applyWorldbookFilter();
              });
            }

            // 批量操作按钮
            const enableBtn = document.getElementById('enable-filtered-btn');
            if (enableBtn) {
              enableBtn.addEventListener('click', () => {
                this.enableFilteredEntries();
              });
            }

            const disableBtn = document.getElementById('disable-filtered-btn');
            if (disableBtn) {
              disableBtn.addEventListener('click', () => {
                this.disableFilteredEntries();
              });
            }

            // 右上角删除按钮
            const deleteHeaderBtn = document.getElementById('delete-filtered-btn-header');
            if (deleteHeaderBtn) {
              deleteHeaderBtn.addEventListener('click', () => {
                this.deleteFilteredEntries();
              });
            }

            // 删除历史按钮
            const deleteHistoryBtn = document.getElementById('show-delete-history-btn');
            if (deleteHistoryBtn) {
              deleteHistoryBtn.addEventListener('click', () => {
                this.showDeleteHistory();
              });
            }

            // 关闭按钮
            const closeBtn = document.getElementById('close-worldbook-manager');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.closeModal('worldbook-manager-modal');
              });
            }

            // 模态框背景点击关闭
            const modal = document.getElementById('worldbook-manager-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.closeModal('worldbook-manager-modal');
                }
              });
            }
          },

          // 绑定删除确认模态框事件监听器
          bindDeleteConfirmEvents() {
            // 第一步确认按钮
            const proceedBtn = document.getElementById('confirm-delete-step1-btn');
            if (proceedBtn) {
              proceedBtn.addEventListener('click', () => {
                this.proceedDeleteConfirm();
              });
            }

            // 第一步取消按钮
            const cancelStep1Btn = document.getElementById('cancel-delete-btn');
            if (cancelStep1Btn) {
              cancelStep1Btn.addEventListener('click', () => {
                this.cancelDelete();
              });
            }

            // 最终确认按钮
            const confirmBtn = document.getElementById('final-delete-btn');
            if (confirmBtn) {
              confirmBtn.addEventListener('click', () => {
                this.executeDelete();
              });
            }

            // 返回按钮
            const backBtn = document.getElementById('back-delete-step-btn');
            if (backBtn) {
              backBtn.addEventListener('click', () => {
                this.deleteConfirmState.step = 1;
                this.updateDeleteConfirmContent();
              });
            }

            // 输入框回车键确认
            const confirmInput = document.getElementById('delete-confirmation-input');
            if (confirmInput) {
              confirmInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                  this.executeDelete();
                }
              });
            }

            // 关闭按钮
            const closeBtn = document.getElementById('close-delete-confirm');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.cancelDelete();
              });
            }

            // 模态框背景点击关闭
            const modal = document.getElementById('worldbook-delete-confirm-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.cancelDelete();
                }
              });
            }
          },
// ===世界书管理模块结束===



// ===世界书预设模块开始===
          // 显示预设管理界面
          showWorldbookPresets() {
            console.log('[预设管理] 开始显示预设管理界面');
            this.openModal('worldbook-presets-modal');
            
            // 延迟加载预设列表，确保模态框已显示
            setTimeout(() => {
              this.loadWorldbookPresets();
              this.bindPresetsManagerEvents();
            }, 100);
          },

          // 加载预设列表
          loadWorldbookPresets() {
            try {
              const saved = localStorage.getItem('guixu_worldbook_presets');
              if (saved) {
                this.worldbookPresets = JSON.parse(saved);
              }
              this.renderPresetsList();
            } catch (error) {
              console.error('[预设管理] 加载预设失败:', error);
              this.worldbookPresets = {};
            }
          },

          // 渲染预设列表
          renderPresetsList() {
            const listContainer = document.getElementById('presets-list');
            if (!listContainer) return;

            const presets = Object.values(this.worldbookPresets);
            if (presets.length === 0) {
              listContainer.innerHTML = `
                <div style="text-align: center; color: #8b7355; padding: 40px 20px;">
                  <div style="font-size: 48px; margin-bottom: 15px;">📋</div>
                  <div style="font-size: 16px; margin-bottom: 8px;">暂无预设</div>
                  <div style="font-size: 12px; opacity: 0.8;">点击右上角"新建预设"按钮创建第一个预设</div>
                </div>
              `;
              return;
            }

            const html = presets.map(preset => `
              <div class="preset-item" data-preset-id="${preset.id}" style="
                padding: 12px;
                margin-bottom: 8px;
                background: rgba(26, 26, 46, 0.6);
                border: 1px solid #8b7355;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                ${this.presetManagerState.selectedPresetId === preset.id ? 'border-color: #c9aa71; background: rgba(201, 170, 113, 0.1);' : ''}
              ">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 6px;">
                  <div style="color: #c9aa71; font-weight: bold; font-size: 14px;">${preset.name}</div>
                  <div style="display: flex; gap: 4px;">
                    <span style="
                      background: ${preset.enabled ? 'rgba(40, 167, 69, 0.2)' : 'rgba(108, 117, 125, 0.2)'};
                      color: ${preset.enabled ? '#28a745' : '#6c757d'};
                      padding: 2px 6px;
                      border-radius: 3px;
                      font-size: 10px;
                    ">${preset.enabled ? '启用' : '禁用'}</span>
                    <span style="color: #8b7355; font-size: 10px; padding: 2px 6px; background: rgba(139, 115, 85, 0.2); border-radius: 3px;">
                      ${preset.entries.length} 项
                    </span>
                  </div>
                </div>
                <div style="color: #8b7355; font-size: 12px; line-height: 1.4; margin-bottom: 8px;">
                  ${preset.description || '无描述'}
                </div>
                <div style="color: #666; font-size: 10px;">
                  创建时间: ${new Date(preset.createdAt).toLocaleString()}
                </div>
              </div>
            `).join('');

            listContainer.innerHTML = html;
          },

          // 显示预设详情
          showPresetDetails(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            this.presetManagerState.selectedPresetId = presetId;
            this.renderPresetsList(); // 重新渲染以更新选中状态

            const detailsContainer = document.getElementById('preset-details');
            if (!detailsContainer) return;

            const html = `
              <div style="height: 100%; display: flex; flex-direction: column;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                  <div>
                    <h3 style="color: #c9aa71; margin: 0 0 8px 0; font-size: 18px;">${preset.name}</h3>
                    <p style="color: #8b7355; margin: 0; font-size: 13px; line-height: 1.4;">
                      ${preset.description || '无描述'}
                    </p>
                  </div>
                  <div style="display: flex; gap: 6px;">
                    <button class="interaction-btn" onclick="GuixuManager.editPreset('${preset.id}')" style="padding: 4px 8px; font-size: 11px;">编辑</button>
                    <button class="interaction-btn" onclick="GuixuManager.togglePresetStatus('${preset.id}')" style="
                      padding: 4px 8px;
                      font-size: 11px;
                      background: ${preset.enabled ? 'rgba(108, 117, 125, 0.2)' : 'rgba(40, 167, 69, 0.2)'};
                      border-color: ${preset.enabled ? '#6c757d' : '#28a745'};
                      color: ${preset.enabled ? '#6c757d' : '#28a745'};
                    ">${preset.enabled ? '禁用' : '启用'}</button>
                    <button class="interaction-btn" onclick="GuixuManager.deletePreset('${preset.id}')" style="
                      padding: 4px 8px;
                      font-size: 11px;
                      background: rgba(255, 107, 107, 0.2);
                      border-color: #ff6b6b;
                      color: #ff6b6b;
                    ">删除</button>
                  </div>
                </div>

                <div style="flex: 1; overflow-y: auto;">
                  <div style="margin-bottom: 15px;">
                    <div style="color: #c9aa71; font-size: 14px; font-weight: bold; margin-bottom: 8px;">
                      📚 包含条目 (${preset.entries.length})
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 4px; padding: 10px; max-height: 200px; overflow-y: auto;">
                      ${preset.entries.length > 0 ?
                        preset.entries.map(entryName => `
                          <div style="
                            padding: 6px 8px;
                            margin-bottom: 4px;
                            background: rgba(26, 26, 46, 0.6);
                            border-radius: 4px;
                            color: #e0dcd1;
                            font-size: 12px;
                            border-left: 3px solid #c9aa71;
                          ">${entryName}</div>
                        `).join('') :
                        '<div style="color: #8b7355; text-align: center; padding: 20px;">暂无条目</div>'
                      }
                    </div>
                  </div>

                  <div style="margin-bottom: 15px;">
                    <div style="color: #c9aa71; font-size: 14px; font-weight: bold; margin-bottom: 8px;">
                      ⚙️ 预设信息
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 4px; padding: 10px;">
                      <div style="display: grid; grid-template-columns: 80px 1fr; gap: 8px; font-size: 12px;">
                        <span style="color: #8b7355;">状态:</span>
                        <span style="color: ${preset.enabled ? '#28a745' : '#6c757d'};">
                          ${preset.enabled ? '✅ 启用中' : '❌ 已禁用'}
                        </span>
                        <span style="color: #8b7355;">条目数:</span>
                        <span style="color: #e0dcd1;">${preset.entries.length} 个</span>
                        <span style="color: #8b7355;">创建时间:</span>
                        <span style="color: #e0dcd1;">${new Date(preset.createdAt).toLocaleString()}</span>
                        <span style="color: #8b7355;">最后修改:</span>
                        <span style="color: #e0dcd1;">${preset.updatedAt ? new Date(preset.updatedAt).toLocaleString() : '未修改'}</span>
                      </div>
                    </div>
                  </div>

                  <div>
                    <div style="color: #c9aa71; font-size: 14px; font-weight: bold; margin-bottom: 8px;">
                      🎯 快速操作
                    </div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                      <button class="interaction-btn" onclick="GuixuManager.exportPreset('${preset.id}')" style="padding: 8px 12px; font-size: 12px;">导出预设</button>
                      <button class="interaction-btn" onclick="GuixuManager.duplicatePreset('${preset.id}')" style="padding: 8px 12px; font-size: 12px;">复制预设</button>
                    </div>
                  </div>
                </div>
              </div>
            `;

            detailsContainer.innerHTML = html;
          },

          // 显示创建/编辑预设界面
          showCreatePresetModal(presetId = null) {
            this.currentEditingPreset = presetId;
            this.presetManagerState.isEditing = !!presetId;
            
            const modal = document.getElementById('preset-edit-modal');
            const title = document.getElementById('preset-edit-title');
            
            // 先打开模态框
            this.openModal('preset-edit-modal');
            
            // 延迟预填充内容，确保DOM已渲染
            setTimeout(() => {
              if (presetId) {
                title.textContent = '📝 编辑预设';
                const preset = this.worldbookPresets[presetId];
                if (preset) {
                  document.getElementById('preset-name-input').value = preset.name || '';
                  document.getElementById('preset-description-input').value = preset.description || '';
                }
              } else {
                title.textContent = '📝 新建预设';
                document.getElementById('preset-name-input').value = '';
                document.getElementById('preset-description-input').value = '';
              }
              
              // 加载条目选择列表
              this.loadEntriesForPresetEdit(presetId);
              this.bindPresetEditEvents();
            }, 150);
          },

          // 加载条目选择列表
          async loadEntriesForPresetEdit(presetId = null) {
            try {
              const bookName = '1归墟';
              const entries = await TavernHelper.getLorebookEntries(bookName);
              
              if (!entries || entries.length === 0) {
                document.getElementById('preset-entries-selection').innerHTML =
                  '<div style="text-align: center; color: #8b7355; padding: 20px;">暂无可选条目</div>';
                this.updatePresetFilterStats(0, 0);
                return;
              }

              // 获取已选条目列表
              let selectedEntries = [];
              if (presetId && this.worldbookPresets[presetId]) {
                selectedEntries = [...this.worldbookPresets[presetId].entries];
                console.log('[预设编辑] 加载已选条目:', selectedEntries);
              }

              // 存储所有条目用于筛选
              this.presetEditState = {
                allEntries: entries,
                filteredEntries: entries,
                selectedEntries: selectedEntries
              };
              
              // 应用当前筛选并渲染
              this.applyPresetFilter();
              
              // 确保复选框状态正确更新
              setTimeout(() => {
                this.updateCheckboxStates();
              }, 50);
              
            } catch (error) {
              console.error('[预设管理] 加载条目失败:', error);
              document.getElementById('preset-entries-selection').innerHTML =
                '<div style="text-align: center; color: #ff6b6b; padding: 20px;">加载条目失败</div>';
              this.updatePresetFilterStats(0, 0);
            }
          },

          // 更新复选框状态
          updateCheckboxStates() {
            if (!this.presetEditState?.selectedEntries) return;
            
            const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
              const entryName = checkbox.dataset.entryName;
              const isSelected = this.presetEditState.selectedEntries.includes(entryName);
              checkbox.checked = isSelected;
              
              // 更新边框颜色
              const parentDiv = checkbox.closest('div');
              if (parentDiv) {
                parentDiv.style.borderColor = isSelected ? '#c9aa71' : '#8b7355';
              }
            });
            
            console.log('[预设编辑] 复选框状态已更新，已选条目:', this.presetEditState.selectedEntries.length);
          },

          // 应用预设条目筛选
          applyPresetFilter() {
            if (!this.presetEditState) return;

            const filterType = document.getElementById('preset-filter-type')?.value || 'all';
            const prefixFilter = document.getElementById('preset-prefix-filter')?.value.trim() || '';
            
            let filtered = [...this.presetEditState.allEntries];
            
            // 按类型筛选
            switch (filterType) {
              case 'journey':
                filtered = filtered.filter(entry =>
                  entry.comment && (entry.comment.includes('本世历程') || entry.comment.includes('历程'))
                );
                break;
              case 'pastlife':
                filtered = filtered.filter(entry =>
                  entry.comment && (entry.comment.includes('往世涟漪') || entry.comment.includes('涟漪'))
                );
                break;
              case 'bracket':
                filtered = filtered.filter(entry =>
                  entry.comment && entry.comment.includes('【') && entry.comment.includes('】')
                );
                break;
              case 'enabled':
                filtered = filtered.filter(entry => entry.enabled);
                break;
              case 'disabled':
                filtered = filtered.filter(entry => !entry.enabled);
                break;
              case 'all':
              default:
                // 不筛选
                break;
            }
            
            // 按关键词筛选
            if (prefixFilter) {
              filtered = filtered.filter(entry =>
                entry.comment && entry.comment.includes(prefixFilter)
              );
            }
            
            this.presetEditState.filteredEntries = filtered;
            this.renderPresetEntries(filtered);
            this.updatePresetFilterStats(filtered.length, this.presetEditState.allEntries.length);
          },

          // 渲染预设条目列表
          renderPresetEntries(entries) {
            const selectedEntries = this.presetEditState.selectedEntries;
            
            const html = entries.map(entry => {
              const isSelected = selectedEntries.includes(entry.comment || entry.uid);
              return `
                <div style="
                  display: flex;
                  align-items: center;
                  padding: 8px;
                  margin-bottom: 4px;
                  background: rgba(26, 26, 46, 0.4);
                  border-radius: 4px;
                  border: 1px solid ${isSelected ? '#c9aa71' : '#8b7355'};
                ">
                  <input type="checkbox"
                         id="entry-${entry.uid}"
                         data-entry-name="${entry.comment || entry.uid}"
                         ${isSelected ? 'checked' : ''}
                         style="margin-right: 10px; cursor: pointer;">
                  <label for="entry-${entry.uid}" style="
                    flex: 1;
                    cursor: pointer;
                    color: #e0dcd1;
                    font-size: 13px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                  ">
                    <span>${entry.comment || entry.uid}</span>
                    <span style="
                      color: ${entry.enabled ? '#28a745' : '#6c757d'};
                      font-size: 10px;
                      padding: 2px 6px;
                      background: ${entry.enabled ? 'rgba(40, 167, 69, 0.2)' : 'rgba(108, 117, 125, 0.2)'};
                      border-radius: 3px;
                    ">${entry.enabled ? '启用' : '禁用'}</span>
                  </label>
                </div>
              `;
            }).join('');

            document.getElementById('preset-entries-selection').innerHTML = html ||
              '<div style="text-align: center; color: #8b7355; padding: 20px;">没有符合条件的条目</div>';
          },

          // 更新预设筛选统计信息
          updatePresetFilterStats(filtered, total) {
            const statsElement = document.getElementById('preset-filter-stats');
            if (statsElement) {
              statsElement.textContent = `显示: ${filtered}/${total}`;
            }
          },

          // 保存预设
          savePreset() {
            const name = document.getElementById('preset-name-input').value.trim();
            const description = document.getElementById('preset-description-input').value.trim();
            
            if (!name) {
              this.showTemporaryMessage('请输入预设名称', 'error', 3000);
              return;
            }

            // 获取选中的条目
            const selectedEntries = [];
            const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]:checked');
            checkboxes.forEach(checkbox => {
              selectedEntries.push(checkbox.dataset.entryName);
            });

            if (selectedEntries.length === 0) {
              this.showTemporaryMessage('请至少选择一个条目', 'error', 3000);
              return;
            }

            const presetId = this.currentEditingPreset || this.generatePresetId();
            const now = new Date().toISOString();
            
            const preset = {
              id: presetId,
              name: name,
              description: description,
              entries: selectedEntries,
              enabled: this.currentEditingPreset ? this.worldbookPresets[this.currentEditingPreset].enabled : true,
              createdAt: this.currentEditingPreset ? this.worldbookPresets[this.currentEditingPreset].createdAt : now,
              updatedAt: now
            };

            this.worldbookPresets[presetId] = preset;
            this.saveWorldbookPresets();
            
            this.closeModal('preset-edit-modal');
            this.showWorldbookPresets(); // 返回预设管理界面
            this.updatePresetsInSettings();
            
            this.showTemporaryMessage(
              this.currentEditingPreset ? '预设已更新' : '预设已创建',
              'success',
              3000
            );
          },

          // 生成预设ID
          generatePresetId() {
            return 'preset_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          },

          // 保存预设到本地存储
          saveWorldbookPresets() {
            try {
              localStorage.setItem('guixu_worldbook_presets', JSON.stringify(this.worldbookPresets));
            } catch (error) {
              console.error('[预设管理] 保存预设失败:', error);
            }
          },

          // 切换预设状态
          togglePresetStatus(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            preset.enabled = !preset.enabled;
            preset.updatedAt = new Date().toISOString();
            
            this.saveWorldbookPresets();
            this.renderPresetsList();
            this.showPresetDetails(presetId);
            this.updatePresetsInSettings();
            
            this.showTemporaryMessage(
              `预设已${preset.enabled ? '启用' : '禁用'}`,
              'success'
            );
          },

          // 删除预设
          deletePreset(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            // showCustomConfirm的第一个参数是消息，第二个是确认回调，第三个是取消回调，第四个是保持当前模态框
            this.showCustomConfirm(
              `确定要删除预设"${preset.name}"吗？此操作不可撤销。`,
              () => {
                // 删除预设数据
                delete this.worldbookPresets[presetId];
                this.saveWorldbookPresets();
                
                // 更新界面
                this.renderPresetsList();
                this.updatePresetsInSettings();
                
                // 清空详情面板
                const detailsPanel = document.getElementById('preset-details');
                if (detailsPanel) {
                  detailsPanel.innerHTML = `
                    <div style="text-align: center; color: #8b7355; padding: 40px 20px;">
                      <div style="font-size: 48px; margin-bottom: 15px;">📋</div>
                      <div style="font-size: 16px; margin-bottom: 8px;">选择预设查看详情</div>
                      <div style="font-size: 12px; opacity: 0.8;">点击左侧预设项目查看和编辑详细信息</div>
                    </div>
                  `;
                }
                
                // 重置选中状态
                if (this.presetManagerState) {
                  this.presetManagerState.selectedPresetId = null;
                }
                
                this.showTemporaryMessage('预设已删除', 'success', 3000);
              },
              null, // 取消回调
              true  // keepCurrentModal - 保持预设管理模态框打开
            );
          },

          // 应用预设（批量开启/关闭条目）
          async applyPreset(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            try {
              const bookName = '1归墟';
              
              // 获取所有世界书条目
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              if (!allEntries || allEntries.length === 0) {
                this.showTemporaryMessage('未找到世界书条目', 'error');
                return;
              }

              // 找到需要更新的条目
              const entriesToUpdate = [];
              let successCount = 0;
              let failCount = 0;

              for (const entryName of preset.entries) {
                const entry = allEntries.find(e => (e.comment || e.uid.toString()) === entryName);
                if (entry) {
                  entriesToUpdate.push({
                    uid: entry.uid,
                    enabled: preset.enabled
                  });
                  successCount++;
                } else {
                  console.warn(`[预设应用] 未找到条目: ${entryName}`);
                  failCount++;
                }
              }

              // 批量更新条目
              if (entriesToUpdate.length > 0) {
                await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
              }

              const message = failCount > 0 ?
                `预设应用完成：成功 ${successCount} 个，失败 ${failCount} 个` :
                `预设应用成功：已${preset.enabled ? '启用' : '禁用'} ${successCount} 个条目`;
              
              this.showTemporaryMessage(message, failCount > 0 ? 'warning' : 'success', 3000);
            } catch (error) {
              console.error('[预设应用] 应用预设失败:', error);
              this.showTemporaryMessage('应用预设失败', 'error', 3000);
            }
          },

          // 编辑预设
          editPreset(presetId) {
            this.showCreatePresetModal(presetId);
          },

          // 复制预设
          duplicatePreset(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            const newPresetId = this.generatePresetId();
            const now = new Date().toISOString();
            
            const newPreset = {
              ...preset,
              id: newPresetId,
              name: preset.name + ' (副本)',
              createdAt: now,
              updatedAt: now
            };

            this.worldbookPresets[newPresetId] = newPreset;
            this.saveWorldbookPresets();
            this.renderPresetsList();
            this.updatePresetsInSettings();
            
            this.showTemporaryMessage('预设已复制', 'success', 3000);
          },

          // 导出预设
          exportPreset(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            const exportData = {
              version: '1.0',
              preset: preset,
              exportTime: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `归墟预设_${preset.name}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            this.showTemporaryMessage('预设已导出', 'success', 3000);
          },

          // 更新设置界面中的预设列表
          updatePresetsInSettings() {
            const container = document.getElementById('worldbook-presets-container');
            if (!container) return;

            const presets = Object.values(this.worldbookPresets);
            if (presets.length === 0) {
              container.innerHTML = `
                <div style="color: #8b7355; font-size: 12px; text-align: center; padding: 10px;">
                  暂无预设，点击上方按钮创建预设
                </div>
              `;
              return;
            }

            // 初始化折叠状态（如果不存在）
            if (!this.presetCollapseState) {
              this.presetCollapseState = {
                mainCollapsed: true, // 主面板默认折叠
                presetDetails: {} // 各个预设的详情折叠状态
              };
            }

            const mainCollapsed = this.presetCollapseState.mainCollapsed;
            const html = `
              <!-- 主标题栏 -->
              <div style="
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 8px 10px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 4px;
                cursor: pointer;
                border: 1px solid #8b7355;
              " onclick="GuixuManager.toggleMainPresetCollapse()">
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="
                    color: #c9aa71;
                    font-size: 12px;
                    font-weight: bold;
                    transform: rotate(${mainCollapsed ? '0deg' : '90deg'});
                    transition: transform 0.2s ease;
                  ">▶</span>
                  <span style="color: #c9aa71; font-size: 13px; font-weight: bold;">世界书预设</span>
                </div>
                <span style="
                  color: #8b7355;
                  font-size: 10px;
                  padding: 2px 6px;
                  background: rgba(139, 115, 85, 0.2);
                  border-radius: 2px;
                ">${presets.length} 个</span>
              </div>

              <!-- 预设列表 -->
              <div id="preset-list-content" style="
                display: ${mainCollapsed ? 'none' : 'block'};
                margin-top: 6px;
                padding-left: 8px;
              ">
                ${presets.map(preset => this.renderPresetItem(preset)).join('')}
              </div>
            `;

            container.innerHTML = html;
          },

          // 渲染单个预设项
          renderPresetItem(preset) {
            const isExpanded = this.presetCollapseState.presetDetails[preset.id] || false;
            
            return `
              <div style="margin-bottom: 8px;">
                <!-- 预设标题栏 -->
                <div style="
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  padding: 6px 8px;
                  background: rgba(26, 26, 46, 0.4);
                  border-radius: 4px;
                  border: 1px solid ${preset.enabled ? '#c9aa71' : '#8b7355'};
                ">
                  <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                    <input type="checkbox"
                           id="preset-toggle-${preset.id}"
                           ${preset.enabled ? 'checked' : ''}
                           onchange="GuixuManager.togglePresetFromSettings('${preset.id}')"
                           style="cursor: pointer;">
                    <span style="
                      color: #e0dcd1;
                      font-size: 11px;
                      cursor: pointer;
                      transform: rotate(${isExpanded ? '90deg' : '0deg'});
                      transition: transform 0.2s ease;
                    " onclick="GuixuManager.togglePresetDetails('${preset.id}')">▶</span>
                    <label for="preset-toggle-${preset.id}" style="
                      color: #e0dcd1;
                      font-size: 12px;
                      cursor: pointer;
                      flex: 1;
                    " onclick="GuixuManager.togglePresetDetails('${preset.id}')">${preset.name}</label>
                  </div>
                  <div style="display: flex; align-items: center; gap: 4px;">
                    <span style="
                      color: ${preset.enabled ? '#28a745' : '#8b7355'};
                      font-size: 9px;
                      padding: 1px 4px;
                      background: ${preset.enabled ? 'rgba(40, 167, 69, 0.2)' : 'rgba(139, 115, 85, 0.2)'};
                      border-radius: 2px;
                    ">${preset.enabled ? '启用' : '禁用'}</span>
                    <span style="
                      color: #8b7355;
                      font-size: 10px;
                      padding: 2px 4px;
                      background: rgba(139, 115, 85, 0.2);
                      border-radius: 2px;
                    ">${preset.entries.length}</span>
                  </div>
                </div>

                <!-- 预设详情 -->
                <div id="preset-details-${preset.id}" style="
                  display: ${isExpanded ? 'block' : 'none'};
                  margin-top: 4px;
                  margin-left: 16px;
                  padding: 8px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  border-left: 2px solid #c9aa71;
                ">
                  ${preset.description ? `
                    <div style="
                      color: #8b7355;
                      font-size: 11px;
                      margin-bottom: 6px;
                      line-height: 1.3;
                    ">${preset.description}</div>
                  ` : ''}
                  
                  <div style="
                    color: #8b7355;
                    font-size: 10px;
                    font-weight: bold;
                    margin-bottom: 4px;
                  ">包含条目 (${preset.entries.length}):</div>
                  
                  <div style="
                    max-height: 120px;
                    overflow-y: auto;
                    font-size: 10px;
                  ">
                    ${preset.entries.length > 0 ?
                      preset.entries.map(entryName => `
                        <div style="
                          color: #e0dcd1;
                          padding: 2px 4px;
                          margin-bottom: 2px;
                          background: rgba(26, 26, 46, 0.3);
                          border-radius: 2px;
                          border-left: 2px solid #8b7355;
                        ">• ${entryName}</div>
                      `).join('') :
                      '<div style="color: #8b7355; text-align: center; padding: 8px;">暂无条目</div>'
                    }
                  </div>
                  
                  <div style="
                    margin-top: 6px;
                    padding-top: 6px;
                    border-top: 1px solid rgba(139, 115, 85, 0.3);
                    font-size: 9px;
                    color: #666;
                  ">
                    创建: ${new Date(preset.createdAt).toLocaleString('zh-CN', {
                      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
                    })}
                    ${preset.updatedAt ? ` | 更新: ${new Date(preset.updatedAt).toLocaleString('zh-CN', {
                      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
                    })}` : ''}
                  </div>
                </div>
              </div>
            `;
          },

          // 切换主预设面板折叠状态
          toggleMainPresetCollapse() {
            if (!this.presetCollapseState) {
              this.presetCollapseState = { mainCollapsed: true, presetDetails: {} };
            }
            
            this.presetCollapseState.mainCollapsed = !this.presetCollapseState.mainCollapsed;
            this.updatePresetsInSettings();
          },

          // 切换预设详情折叠状态
          togglePresetDetails(presetId) {
            if (!this.presetCollapseState) {
              this.presetCollapseState = { mainCollapsed: false, presetDetails: {} };
            }
            
            this.presetCollapseState.presetDetails[presetId] = !this.presetCollapseState.presetDetails[presetId];
            this.updatePresetsInSettings();
          },

          // 从设置界面切换预设状态
          async togglePresetFromSettings(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            // 切换预设状态
            preset.enabled = !preset.enabled;
            preset.updatedAt = new Date().toISOString();
            
            this.saveWorldbookPresets();
            this.renderPresetsList();
            this.updatePresetsInSettings();
            
            // 自动应用预设（批量开启/关闭相关世界书条目）
            try {
              const bookName = '1归墟';
              
              // 获取所有世界书条目
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              if (!allEntries || allEntries.length === 0) {
                this.showTemporaryMessage('未找到世界书条目', 'error', 3000);
                return;
              }

              // 找到需要更新的条目
              const entriesToUpdate = [];
              let successCount = 0;
              let failCount = 0;

              for (const entryName of preset.entries) {
                const entry = allEntries.find(e => (e.comment || e.uid.toString()) === entryName);
                if (entry) {
                  entriesToUpdate.push({
                    uid: entry.uid,
                    enabled: preset.enabled
                  });
                  successCount++;
                } else {
                  console.warn(`[预设应用] 未找到条目: ${entryName}`);
                  failCount++;
                }
              }

              // 批量更新条目
              if (entriesToUpdate.length > 0) {
                await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
              }

              const message = failCount > 0 ?
                `预设"${preset.name}"已${preset.enabled ? '启用' : '禁用'}：成功 ${successCount} 个，失败 ${failCount} 个` :
                `预设"${preset.name}"已${preset.enabled ? '启用' : '禁用'}：${preset.enabled ? '启用' : '禁用'}了 ${successCount} 个条目`;
              
              this.showTemporaryMessage(message, failCount > 0 ? 'warning' : 'success', 3000);
            } catch (error) {
              console.error('[预设应用] 应用预设失败:', error);
              this.showTemporaryMessage('应用预设失败', 'error', 3000);
            }
          },

          // 绑定预设管理事件
          bindPresetsManagerEvents() {
            // 预设列表点击事件
            const listContainer = document.getElementById('presets-list');
            if (listContainer) {
              listContainer.addEventListener('click', (e) => {
                const presetItem = e.target.closest('.preset-item');
                if (presetItem) {
                  const presetId = presetItem.dataset.presetId;
                  this.showPresetDetails(presetId);
                }
              });
            }

            // 新建预设按钮
            const createBtn = document.getElementById('create-preset-btn');
            if (createBtn) {
              createBtn.addEventListener('click', () => {
                this.showCreatePresetModal();
              });
            }

            // 关闭按钮：返回到世界书管理界面
            const closeBtn = document.getElementById('close-presets-modal');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.closeModal('worldbook-presets-modal');
                // 如果是从世界书管理界面进入的，返回到世界书管理界面
                if (this.isFromWorldbookManager) {
                  this.showWorldbookManager();
                  this.isFromWorldbookManager = false; // 重置标志位
                }
              });
            }

            // 模态框背景点击关闭：返回到世界书管理界面
            const modal = document.getElementById('worldbook-presets-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.closeModal('worldbook-presets-modal');
                  // 如果是从世界书管理界面进入的，返回到世界书管理界面
                  if (this.isFromWorldbookManager) {
                    this.showWorldbookManager();
                    this.isFromWorldbookManager = false; // 重置标志位
                  }
                }
              });
            }
          },

          // 绑定预设编辑事件
          bindPresetEditEvents() {
            // 先清理旧的事件监听器，避免重复绑定
            this.cleanupPresetEditEvents();

            // 筛选类型变化
            const filterTypeSelect = document.getElementById('preset-filter-type');
            if (filterTypeSelect) {
              filterTypeSelect.addEventListener('change', () => {
                this.applyPresetFilter();
              });
            }

            // 关键词筛选输入
            const prefixFilterInput = document.getElementById('preset-prefix-filter');
            if (prefixFilterInput) {
              prefixFilterInput.addEventListener('input', () => {
                this.applyPresetFilter();
              });
            }

            // 条目复选框变化监听（使用事件委托）
            const entriesContainer = document.getElementById('preset-entries-selection');
            if (entriesContainer) {
              entriesContainer.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                  const entryName = e.target.dataset.entryName;
                  if (!this.presetEditState) this.presetEditState = { selectedEntries: [] };
                  
                  if (e.target.checked) {
                    // 添加到已选列表
                    if (!this.presetEditState.selectedEntries.includes(entryName)) {
                      this.presetEditState.selectedEntries.push(entryName);
                    }
                  } else {
                    // 从已选列表移除
                    const index = this.presetEditState.selectedEntries.indexOf(entryName);
                    if (index > -1) {
                      this.presetEditState.selectedEntries.splice(index, 1);
                    }
                  }
                  
                  // 更新边框颜色
                  const parentDiv = e.target.closest('div');
                  if (parentDiv) {
                    parentDiv.style.borderColor = e.target.checked ? '#c9aa71' : '#8b7355';
                  }
                  
                  console.log('[预设编辑] 条目选择变化:', entryName, e.target.checked);
                }
              });
            }

            // 全选按钮
            const selectAllBtn = document.getElementById('select-all-entries');
            if (selectAllBtn) {
              selectAllBtn.addEventListener('click', () => {
                const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]');
                checkboxes.forEach(cb => {
                  cb.checked = true;
                  // 触发change事件以更新selectedEntries
                  cb.dispatchEvent(new Event('change', { bubbles: true }));
                });
              });
            }

            // 全不选按钮
            const deselectAllBtn = document.getElementById('deselect-all-entries');
            if (deselectAllBtn) {
              deselectAllBtn.addEventListener('click', () => {
                const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]');
                checkboxes.forEach(cb => {
                  cb.checked = false;
                  // 触发change事件以更新selectedEntries
                  cb.dispatchEvent(new Event('change', { bubbles: true }));
                });
              });
            }

            // 选择已启用按钮
            const selectEnabledBtn = document.getElementById('select-enabled-entries');
            if (selectEnabledBtn) {
              selectEnabledBtn.addEventListener('click', () => {
                if (!this.presetEditState?.filteredEntries) return;
                
                const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                  const entryName = checkbox.dataset.entryName;
                  const entry = this.presetEditState.filteredEntries.find(e => (e.comment || e.uid) === entryName);
                  const shouldCheck = entry && entry.enabled;
                  
                  if (checkbox.checked !== shouldCheck) {
                    checkbox.checked = shouldCheck;
                    // 触发change事件以更新selectedEntries
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                  }
                });
              });
            }

            // 保存按钮 - 优化：保存后返回预设管理界面
            const saveBtn = document.getElementById('save-preset');
            if (saveBtn) {
              saveBtn.addEventListener('click', () => {
                this.savePreset();
              });
            }

            // 取消按钮 - 优化：返回预设管理界面
            const cancelBtn = document.getElementById('cancel-preset-edit');
            if (cancelBtn) {
              cancelBtn.addEventListener('click', () => {
                this.closeModal('preset-edit-modal');
                this.showWorldbookPresets(); // 返回预设管理界面
              });
            }

            // 关闭按钮 - 优化：返回预设管理界面
            const closeBtn = document.getElementById('close-preset-edit');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.closeModal('preset-edit-modal');
                this.showWorldbookPresets(); // 返回预设管理界面
              });
            }

            // 模态框背景点击关闭 - 优化：返回预设管理界面
            const modal = document.getElementById('preset-edit-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.closeModal('preset-edit-modal');
                  this.showWorldbookPresets(); // 返回预设管理界面
                }
              });
            }
          },

          // 清理预设编辑事件监听器
          cleanupPresetEditEvents() {
            const elements = [
              'preset-filter-type',
              'preset-prefix-filter',
              'select-all-entries',
              'deselect-all-entries',
              'select-enabled-entries',
              'save-preset',
              'cancel-preset-edit',
              'close-preset-edit',
              'preset-edit-modal'
            ];

            elements.forEach(id => {
              const element = document.getElementById(id);
              if (element) {
                // 通过克隆节点来移除所有事件监听器
                const newElement = element.cloneNode(true);
                element.parentNode.replaceChild(newElement, element);
              }
            });
          },
// ===世界书预设模块结束===



// === 背景图模块开始===
          // 背景图设置功能
          showBackgroundSettings() {
            this.openModal('background-settings-modal');
            this.renderBackgroundList();
            this.updateBackgroundModeUI();
            
            // 确保在模态框打开后绑定事件
            setTimeout(() => {
              this.bindBackgroundListEvents();
            }, 100);
          },

          updateBackgroundModeUI() {
            const randomRadio = document.getElementById('bg-mode-random');
            const fixedRadio = document.getElementById('bg-mode-fixed');
            if (randomRadio && fixedRadio) {
              randomRadio.checked = this.backgroundMode === 'random';
              fixedRadio.checked = this.backgroundMode === 'fixed';
            }
          },

          renderBackgroundList() {
            const listContainer = document.getElementById('background-list');
            const countSpan = document.getElementById('background-count');
            const pageInfo = document.getElementById('gallery-page-info');
            const prevBtn = document.getElementById('gallery-prev-page');
            const nextBtn = document.getElementById('gallery-next-page');
            
            if (!listContainer || !countSpan) return;

            const allImages = this.gallerySource === 'library' ? this.backgroundImages : this.outputFolderImages;
            const totalCount = allImages.length;
            const totalPages = Math.ceil(totalCount / this.galleryPageSize);
            
            // 确保当前页码有效
            if (this.galleryCurrentPage > totalPages && totalPages > 0) {
              this.galleryCurrentPage = totalPages;
            }
            if (this.galleryCurrentPage < 1) {
              this.galleryCurrentPage = 1;
            }

            countSpan.textContent = `(${totalCount}张)`;
            
            // 更新分页信息
            if (pageInfo) {
              pageInfo.textContent = totalPages > 0 ? `第 ${this.galleryCurrentPage} 页 / 共 ${totalPages} 页` : '暂无数据';
            }
            
            // 更新分页按钮状态
            if (prevBtn) {
              prevBtn.disabled = this.galleryCurrentPage <= 1;
              prevBtn.style.opacity = this.galleryCurrentPage <= 1 ? '0.5' : '1';
              prevBtn.style.cursor = this.galleryCurrentPage <= 1 ? 'not-allowed' : 'pointer';
            }
            if (nextBtn) {
              nextBtn.disabled = this.galleryCurrentPage >= totalPages;
              nextBtn.style.opacity = this.galleryCurrentPage >= totalPages ? '0.5' : '1';
              nextBtn.style.cursor = this.galleryCurrentPage >= totalPages ? 'not-allowed' : 'pointer';
            }

            listContainer.innerHTML = '';

            if (totalCount === 0) {
              const message = this.gallerySource === 'library' ? '暂无背景图' : 'Output文件夹为空或未选择';
              listContainer.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; color: #8b7355; padding: 20px;">${message}</div>`;
              return;
            }

            // 计算当前页的图片范围
            const startIndex = (this.galleryCurrentPage - 1) * this.galleryPageSize;
            const endIndex = Math.min(startIndex + this.galleryPageSize, totalCount);
            const imagesToShow = allImages.slice(startIndex, endIndex);

            imagesToShow.forEach(bg => {
              const item = document.createElement('div');
              item.className = 'background-item';
              item.dataset.bgId = bg.id;
              
              if (this.backgroundMode === 'fixed' && this.selectedBackgroundId === bg.id) {
                item.classList.add('selected');
              }

              const linkIcon = bg.isUrlImage ? '<div style="position: absolute; top: 5px; left: 5px; background: rgba(0,0,0,0.7); color: #fff; padding: 2px 6px; border-radius: 3px; font-size: 10px;">🔗</div>' : '';
              // Output图片显示"添加"按钮，其他显示"删除"按钮
              const actionBtn = bg.isOutput
                ? `<button class="background-item-btn add-to-library" data-bg-id="${bg.id}">添加到图库</button>`
                : `<button class="background-item-btn delete" data-bg-id="${bg.id}">删除</button>`;

              item.innerHTML = `
                <img src="${bg.dataUrl}" alt="${bg.name}" loading="lazy" style="width: 100%; height: 100%; object-fit: cover;">
                ${linkIcon}
                <div class="background-item-overlay">
                  <div class="background-item-actions">
                    <button class="background-item-btn preview-btn" data-bg-id="${bg.id}">预览</button>
                    <button class="background-item-btn select-btn" data-bg-id="${bg.id}">选择</button>
                    ${actionBtn}
                  </div>
                </div>
              `;

              if (this.backgroundMode === 'fixed' && this.selectedBackgroundId === bg.id) {
                const indicator = document.createElement('div');
                indicator.className = 'background-preview-indicator';
                indicator.textContent = '当前';
                item.appendChild(indicator);
              }

              listContainer.appendChild(item);
            });

            this.bindBackgroundListEvents();
          },

          bindBackgroundListEvents() {
            const listContainer = document.getElementById('background-list');
            if (!listContainer) return;

            // 移除旧的事件监听器（如果存在）
            if (this.backgroundListClickHandler) {
              listContainer.removeEventListener('click', this.backgroundListClickHandler);
            }

            // 创建新的事件处理器并保存引用
            this.backgroundListClickHandler = (e) => {
              const bgId = e.target.dataset.bgId;
              if (!bgId) return;

              if (e.target.classList.contains('preview-btn')) {
                this.previewBackground(bgId);
              } else if (e.target.classList.contains('select-btn')) {
                this.selectBackground(bgId);
              } else if (e.target.classList.contains('delete')) {
                this.deleteBackground(bgId);
              } else if (e.target.classList.contains('add-to-library')) {
                this.addOutputImageToLibrary(bgId);
              }
            };

            // 绑定新的事件监听器
            listContainer.addEventListener('click', this.backgroundListClickHandler);
          },


          
          
          /**
           * 通用图库选择器 - 模块化可复用组件
           * @param {Object} options - 配置选项
           * @param {string} options.title - 模态框标题
           * @param {string} options.mode - 模式: 'background'|'novel'|'avatar'
           * @param {Function} options.onSelect - 选择回调 (imageData) => {}
           * @param {Function} options.onClose - 关闭回调 () => {}
           * @param {boolean} options.enablePagination - 是否启用分页，默认true
           * @param {number} options.pageSize - 每页数量，默认20
           * @param {boolean} options.enableSourceSwitch - 是否显示数据源切换，默认true
           * @param {boolean} options.enableLazyLoad - 是否懒加载，默认true
           * @param {string} options.extraControlsHtml - 额外控件HTML
           * @param {Array} options.extraButtons - 额外按钮配置 [{text, callback, style}]
           * @param {boolean} options.allowEmpty - 是否允许选择"无背景"，默认false
           * @param {string} options.containerStyle - 自定义容器样式
           */
          async showUnifiedGalleryPicker(options = {}) {
            // 默认配置
            const config = {
              title: '选择图片',
              mode: 'background',
              onSelect: null,
              onClose: null,
              enablePagination: true,
              pageSize: 20,
              enableSourceSwitch: true,
              enableLazyLoad: true,
              extraControlsHtml: '',
              extraButtons: [],
              allowEmpty: false,
              containerStyle: '',
              ...options
            };

            // 确保已加载背景设置
            await this.loadBackgroundSettings();

            // 创建唯一的模态框ID
            const modalId = `unified-gallery-${config.mode}-${Date.now()}`;
            
            // 创建遮罩层
            const overlay = document.createElement('div');
            overlay.id = modalId;
            overlay.className = 'unified-gallery-overlay';
            overlay.style.cssText = `
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(0, 0, 0, 0.85);
              z-index: 10000;
              display: flex;
              justify-content: center;
              align-items: center;
              animation: fadeIn 0.3s;
            `;

            // 创建模态框内容
            const modalContent = document.createElement('div');
            modalContent.className = 'unified-gallery-content';
            modalContent.style.cssText = `
              width: 80%;
              max-width: 900px;
              height: 80vh;
              display: flex;
              flex-direction: column;
              border-radius: 8px;
              border: 1px solid #c9aa71;
              background: rgba(26, 26, 46, 0.95);
              box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
              ${config.containerStyle}
            `;

            // 生成数据源切换HTML（如果启用）
            const sourceSwitchHtml = config.enableSourceSwitch ? `
              <div style="padding: 10px; border-bottom: 1px solid rgba(201, 170, 113, 0.3);">
                <div style="display: flex; gap: 15px; justify-content: center;">
                  <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #c9aa71;">
                    <input type="radio" name="${modalId}-source" value="library" checked class="gallery-source-radio">
                    <span>📚 图库</span>
                  </label>
                  <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #c9aa71;">
                    <input type="radio" name="${modalId}-source" value="output" class="gallery-source-radio">
                    <span>📁 Output文件夹</span>
                  </label>
                </div>
              </div>
            ` : '';

            // 生成分页控件HTML（如果启用）
            const paginationHtml = config.enablePagination ? `
              <div class="unified-gallery-pagination" style="padding: 10px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(139, 115, 85, 0.3);">
                <button class="unified-prev-btn interaction-btn" style="padding: 5px 15px; font-size: 12px;">
                  <i class="fas fa-chevron-left"></i> 上一页
                </button>
                <span class="unified-page-info" style="color: #c9aa71; font-size: 12px;">第 1 页 / 共 1 页</span>
                <button class="unified-next-btn interaction-btn" style="padding: 5px 15px; font-size: 12px;">
                  下一页 <i class="fas fa-chevron-right"></i>
                </button>
              </div>
            ` : '';

            // 生成"无背景"选项HTML（如果启用）
            const emptyOptionHtml = config.allowEmpty ? `
              <div class="unified-empty-option" data-empty="true" style="
                width: 100%;
                height: 80px;
                border: 2px solid #8b7355;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                background: rgba(26, 26, 46, 0.8);
                color: #8b7355;
                font-size: 11px;
                transition: border-color 0.3s ease;
              ">无背景</div>
            ` : '';

            // 生成额外按钮HTML
            const extraButtonsHtml = config.extraButtons.map(btn => `
              <button class="unified-extra-btn" data-action="${btn.action || ''}" style="${btn.style || 'padding: 8px 16px; background: #8b7355; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;'}">
                ${btn.text}
              </button>
            `).join('');

            modalContent.innerHTML = `
              <div style="padding: 15px; border-bottom: 1px solid #8b7355; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; font-size: 1.3rem; color: #c9aa71;">${config.title}</h2>
                <span class="unified-close-btn" style="font-size: 24px; color: #888; cursor: pointer;">&times;</span>
              </div>
              ${config.extraControlsHtml}
              ${sourceSwitchHtml}
              ${paginationHtml}
              <div class="unified-gallery-grid-container" style="flex-grow: 1; overflow-y: auto; padding: 15px;">
                <div class="unified-gallery-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px;">
                  ${emptyOptionHtml}
                </div>
              </div>
              <div style="padding: 10px; border-top: 1px solid #8b7355; display: flex; gap: 10px; justify-content: center;">
                ${extraButtonsHtml}
              </div>
            `;

            overlay.appendChild(modalContent);
            document.body.appendChild(overlay);

            // 初始化状态
            const state = {
              currentPage: 1,
              pageSize: config.pageSize,
              currentSource: 'library',
              modalId: modalId
            };

            // 渲染图库函数
            const renderGallery = () => {
              const grid = modalContent.querySelector('.unified-gallery-grid');
              const pageInfo = modalContent.querySelector('.unified-page-info');
              const prevBtn = modalContent.querySelector('.unified-prev-btn');
              const nextBtn = modalContent.querySelector('.unified-next-btn');
              
              if (!grid) return;

              // 获取数据源
              const allImages = state.currentSource === 'library' ? this.backgroundImages : this.outputFolderImages;
              const totalCount = allImages.length;
              const totalPages = Math.ceil(totalCount / state.pageSize);

              // 确保当前页码有效
              if (state.currentPage > totalPages && totalPages > 0) {
                state.currentPage = totalPages;
              }
              if (state.currentPage < 1) {
                state.currentPage = 1;
              }

              // 更新分页信息
              if (pageInfo) {
                pageInfo.textContent = totalPages > 0 ? `第 ${state.currentPage} 页 / 共 ${totalPages} 页` : '暂无数据';
              }

              // 更新分页按钮状态
              if (prevBtn) {
                prevBtn.disabled = state.currentPage <= 1;
                prevBtn.style.opacity = state.currentPage <= 1 ? '0.5' : '1';
                prevBtn.style.cursor = state.currentPage <= 1 ? 'not-allowed' : 'pointer';
              }
              if (nextBtn) {
                nextBtn.disabled = state.currentPage >= totalPages;
                nextBtn.style.opacity = state.currentPage >= totalPages ? '0.5' : '1';
                nextBtn.style.cursor = state.currentPage >= totalPages ? 'not-allowed' : 'pointer';
              }

              // 清空网格（保留"无背景"选项）
              const emptyOption = grid.querySelector('[data-empty="true"]');
              grid.innerHTML = '';
              if (emptyOption && config.allowEmpty) {
                grid.appendChild(emptyOption);
              }

              // 如果没有图片
              if (totalCount === 0) {
                const message = state.currentSource === 'library' ? '暂无可用图片' : 'Output文件夹为空或未选择';
                const emptyTip = document.createElement('div');
                emptyTip.style.cssText = `
                  grid-column: 1 / -1;
                  text-align: center;
                  padding: 30px;
                  color: #8b7355;
                `;
                emptyTip.innerHTML = `
                  <i class="fas fa-image" style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;"></i>
                  <div style="color: #e8dcc6; font-size: 1rem; margin-bottom: 8px;">${message}</div>
                  <div style="font-size: 0.9rem; color: #888;">请先添加图片或选择Output文件夹</div>
                `;
                grid.appendChild(emptyTip);
                return;
              }

              // 计算当前页的图片范围
              const startIndex = (state.currentPage - 1) * state.pageSize;
              const endIndex = Math.min(startIndex + state.pageSize, totalCount);
              const imagesToShow = allImages.slice(startIndex, endIndex);

              // 渲染图片
              imagesToShow.forEach((img, index) => {
                const card = document.createElement('div');
                card.className = 'unified-gallery-card';
                card.dataset.imageId = img.id;
                card.dataset.imageUrl = img.dataUrl || img.url;
                card.style.cssText = `
                  position: relative;
                  aspect-ratio: 1;
                  border-radius: 6px;
                  overflow: hidden;
                  cursor: pointer;
                  border: 1px solid #8b7355;
                  transition: all 0.15s ease;
                  background-image: url('${img.dataUrl || img.url}');
                  background-size: cover;
                  background-position: center;
                `;

                const cardOverlay = document.createElement('div');
                cardOverlay.style.cssText = `
                  position: absolute;
                  top: 0;
                  left: 0;
                  right: 0;
                  bottom: 0;
                  background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
                  display: flex;
                  align-items: flex-end;
                  justify-content: center;
                  padding: 8px;
                  opacity: 0.8;
                  transition: opacity 0.15s ease;
                `;

                const nameTag = document.createElement('div');
                nameTag.style.cssText = `
                  font-size: 0.8rem;
                  color: #e8dcc6;
                  text-align: center;
                  white-space: nowrap;
                  overflow: hidden;
                  text-overflow: ellipsis;
                  max-width: 100%;
                `;
                nameTag.textContent = img.name || `图片 ${startIndex + index + 1}`;

                cardOverlay.appendChild(nameTag);
                card.appendChild(cardOverlay);

                // 鼠标悬停效果
                card.addEventListener('mouseenter', () => {
                  card.style.borderColor = '#c9aa71';
                  card.style.transform = 'translateY(-2px)';
                  cardOverlay.style.opacity = '1';
                });
                card.addEventListener('mouseleave', () => {
                  card.style.borderColor = '#8b7355';
                  card.style.transform = 'translateY(0)';
                  cardOverlay.style.opacity = '0.8';
                });

                // 点击选择
                card.addEventListener('click', () => {
                  if (config.onSelect) {
                    config.onSelect({
                      id: img.id,
                      name: img.name,
                      dataUrl: img.dataUrl || img.url,
                      url: img.url,
                      isOutput: img.isOutput || false,
                      source: state.currentSource
                    });
                  }
                  overlay.remove();
                });

                // 懒加载
                if (config.enableLazyLoad) {
                  const bgImg = new Image();
                  bgImg.src = img.dataUrl || img.url;
                }

                grid.appendChild(card);
              });
            };

            // 绑定事件
            
            // 关闭按钮
            modalContent.querySelector('.unified-close-btn').onclick = () => {
              if (config.onClose) config.onClose();
              overlay.remove();
            };

            // 点击遮罩层关闭
            overlay.addEventListener('click', (e) => {
              if (e.target === overlay) {
                if (config.onClose) config.onClose();
                overlay.remove();
              }
            });

            // 数据源切换事件
            if (config.enableSourceSwitch) {
              const sourceRadios = modalContent.querySelectorAll('.gallery-source-radio');
              sourceRadios.forEach(radio => {
                radio.addEventListener('change', async (e) => {
                  const newSource = e.target.value;
                  if (newSource === state.currentSource) return;
                  
                  state.currentSource = newSource;
                  state.currentPage = 1; // 切换数据源时重置页码
                  
                  // 如果切换到output但没有选择文件夹,提示用户
                  if (newSource === 'output' && (!this.outputFolderHandle || this.outputFolderImages.length === 0)) {
                    this.showTemporaryMessage('请先在背景设置中选择Output文件夹', 'warning');
                  }
                  
                  renderGallery();
                });
              });
            }

            // 分页按钮事件
            if (config.enablePagination) {
              const prevBtn = modalContent.querySelector('.unified-prev-btn');
              const nextBtn = modalContent.querySelector('.unified-next-btn');
              
              if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                  if (state.currentPage > 1) {
                    state.currentPage--;
                    renderGallery();
                    // 滚动到列表顶部
                    const gridContainer = modalContent.querySelector('.unified-gallery-grid-container');
                    if (gridContainer) gridContainer.scrollTop = 0;
                  }
                });
              }
              
              if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                  const allImages = state.currentSource === 'library' ? this.backgroundImages : this.outputFolderImages;
                  const totalPages = Math.ceil(allImages.length / state.pageSize);
                  if (state.currentPage < totalPages) {
                    state.currentPage++;
                    renderGallery();
                    // 滚动到列表顶部
                    const gridContainer = modalContent.querySelector('.unified-gallery-grid-container');
                    if (gridContainer) gridContainer.scrollTop = 0;
                  }
                });
              }
            }

            // "无背景"选项事件
            if (config.allowEmpty) {
              const emptyOption = modalContent.querySelector('.unified-empty-option');
              if (emptyOption) {
                emptyOption.addEventListener('click', () => {
                  if (config.onSelect) {
                    config.onSelect({
                      id: '',
                      name: '无背景',
                      dataUrl: '',
                      url: '',
                      isOutput: false,
                      source: 'empty'
                    });
                  }
                  overlay.remove();
                });
                
                // 悬停效果
                emptyOption.addEventListener('mouseenter', () => {
                  emptyOption.style.borderColor = '#c9aa71';
                });
                emptyOption.addEventListener('mouseleave', () => {
                  emptyOption.style.borderColor = '#8b7355';
                });
              }
            }

            // 额外按钮事件
            if (config.extraButtons && config.extraButtons.length > 0) {
              const extraBtns = modalContent.querySelectorAll('.unified-extra-btn');
              extraBtns.forEach((btn, index) => {
                const btnConfig = config.extraButtons[index];
                if (btnConfig && btnConfig.callback) {
                  btn.addEventListener('click', () => {
                    btnConfig.callback({
                      modalId: modalId,
                      state: state,
                      overlay: overlay,
                      renderGallery: renderGallery
                    });
                  });
                }
              });
            }
            
            // 初始渲染
            renderGallery();
          },

          // ===通用图库组件结束===

          // 新增：将背景设置模态框内的静态事件绑定分离出来
          bindBackgroundSettingsListeners() {
              if (this.backgroundEventsInitialized) return; // 确保只绑定一次

              // 绑定上传区域事件
              const uploadArea = document.getElementById('background-upload-area');
              const fileInput = document.getElementById('background-file-input');
              if (uploadArea && fileInput) {
                  uploadArea.addEventListener('click', () => fileInput.click());
                  fileInput.addEventListener('change', (e) => this.handleBackgroundUpload(e));
              }

              // 绑定模式切换事件
              const randomRadio = document.getElementById('bg-mode-random');
              const fixedRadio = document.getElementById('bg-mode-fixed');
              if (randomRadio && fixedRadio) {
                  randomRadio.addEventListener('change', () => {
                      if (randomRadio.checked) {
                          this.backgroundMode = 'random';
                          this.saveBackgroundSettings();
                          this.renderBackgroundList();
                      }
                  });
                  fixedRadio.addEventListener('change', () => {
                      if (fixedRadio.checked) {
                          this.backgroundMode = 'fixed';
                          this.saveBackgroundSettings();
                          this.renderBackgroundList();
                      }
                  });
              }

              // 绑定外链图床按钮事件
              const addUrlBtn = document.getElementById('add-url-image-btn');
              if (addUrlBtn) {
                  addUrlBtn.addEventListener('click', () => this.handleUrlImageAdd());
              }

              // 绑定管理外链按钮事件
              const manageUrlBtn = document.getElementById('manage-url-images-btn');
              if (manageUrlBtn) {
                  manageUrlBtn.addEventListener('click', () => this.showUrlImagesManageModal());
              }

              this.bindGallerySourceControls();
              // 标记为已初始化
              this.backgroundEventsInitialized = true;
          },

          async handleBackgroundUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) {
              console.warn('[归墟背景] 没有选择文件');
              return;
            }

            console.log(`[归墟背景] 开始处理 ${files.length} 个文件`);
            this.showTemporaryMessage('正在处理图片...', 3000);

            for (let i = 0; i < files.length; i++) {
              const file = files[i];
              console.log(`[归墟背景] 处理文件: ${file.name}, 大小: ${file.size} bytes, 类型: ${file.type}`);
              
              // 检查文件类型
              if (!file.type.startsWith('image/')) {
                console.error(`[归墟背景] 文件类型无效: ${file.type}`);
                this.showTemporaryMessage(`文件 ${file.name} 不是有效的图片格式`);
                continue;
              }

              try {
                let processedDataUrl;
                let compressionApplied = false;

                // 检查文件大小，如果超过2MB则尝试压缩
                if (file.size > 2 * 1024 * 1024) {
                  console.log(`[归墟背景] 文件过大 (${file.size} bytes)，尝试压缩...`);
                  try {
                    processedDataUrl = await this.compressImage(file, 0.8, 1920, 1080);
                    compressionApplied = true;
                    console.log(`[归墟背景] 图片压缩成功`);
                  } catch (compressionError) {
                    console.error(`[归墟背景] 图片压缩失败:`, compressionError);
                    // 如果压缩失败，尝试使用Object URL方式
                    try {
                      processedDataUrl = await this.createObjectUrlForLargeImage(file);
                      console.log(`[归墟背景] 使用Object URL处理大图片`);
                    } catch (objectUrlError) {
                      console.error(`[归墟背景] Object URL创建失败:`, objectUrlError);
                      this.showTemporaryMessage(`文件 ${file.name} 过大且处理失败，请选择小于2MB的图片`);
                      continue;
                    }
                  }
                } else {
                  // 文件大小合适，直接转换
                  processedDataUrl = await this.fileToDataUrl(file);
                  console.log(`[归墟背景] 直接转换为DataURL成功`);
                }

                const bgId = 'bg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                const newBackground = {
                  id: bgId,
                  name: file.name.replace(/\.[^/.]+$/, ""), // 移除文件扩展名
                  dataUrl: processedDataUrl,
                  uploadTime: new Date().toISOString(),
                  isPreset: false,
                  compressed: compressionApplied,
                  originalSize: file.size
                };

                // 临时添加到数组中测试存储
                const tempImages = [...this.backgroundImages, newBackground];
                const testSettings = {
                  images: tempImages,
                  mode: this.backgroundMode,
                  selectedId: this.selectedBackgroundId
                };

                // 测试是否能够成功保存到localStorage
                try {
                  const testData = JSON.stringify(testSettings);
                  console.log(`[归墟背景] 测试数据大小: ${testData.length} 字符`);
                  
                  // 检查数据大小（localStorage通常限制为5-10MB）
                  if (testData.length > 4 * 1024 * 1024) { // 4MB限制
                    throw new Error('存储空间不足');
                  }
                  
                  // 尝试保存测试数据
                  localStorage.setItem('guixu_background_test', testData);
                  localStorage.removeItem('guixu_background_test');
                  
                  // 如果测试成功，正式添加图片
                  this.backgroundImages.push(newBackground);
                  this.saveBackgroundSettings();
                  
                  console.log(`[归墟背景] 成功保存图片: ${file.name}, 当前图片数量: ${this.backgroundImages.length}`);
                  
                  // 显示成功消息，包含压缩信息
                  if (compressionApplied) {
                    this.showTemporaryMessage(`图片 ${file.name} 已压缩并保存成功`);
                  } else {
                    this.showTemporaryMessage(`图片 ${file.name} 保存成功`);
                  }
                  
                } catch (storageError) {
                  console.error('[归墟背景] localStorage存储失败:', storageError);
                  this.showTemporaryMessage(`图片 ${file.name} 保存失败：存储空间不足或图片过大`);
                  continue;
                }
                
                // 如果背景设置模态框是打开的，刷新列表
                if (document.getElementById('background-settings-modal').style.display === 'flex') {
                  this.renderBackgroundList();
                }
                
              } catch (error) {
                console.error('[归墟背景] 处理图片失败:', error);
                this.showTemporaryMessage(`处理图片 ${file.name} 失败: ${error.message}`);
              }
            }

            // 清空文件输入
            event.target.value = '';
            this.showTemporaryMessage('图片处理完成！');
          },

          fileToDataUrl(file) {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = (e) => {
                console.log(`[归墟背景] FileReader成功读取文件，DataURL长度: ${e.target.result.length}`);
                resolve(e.target.result);
              };
              reader.onerror = (error) => {
                console.error(`[归墟背景] FileReader读取失败:`, error);
                reject(error);
              };
              reader.readAsDataURL(file);
            });
          },

          // 新增：图片压缩函数
          compressImage(file, quality = 0.8, maxWidth = 1920, maxHeight = 1080) {
            return new Promise((resolve, reject) => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              const img = new Image();

              img.onload = () => {
                try {
                  // 计算压缩后的尺寸
                  let { width, height } = img;
                  
                  if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width *= ratio;
                    height *= ratio;
                  }

                  canvas.width = width;
                  canvas.height = height;

                  // 绘制压缩后的图片
                  ctx.drawImage(img, 0, 0, width, height);

                  // 转换为DataURL
                  const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                  
                  console.log(`[归墟背景] 图片压缩完成: ${img.naturalWidth}x${img.naturalHeight} -> ${width}x${height}, 质量: ${quality}`);
                  resolve(compressedDataUrl);
                } catch (error) {
                  console.error(`[归墟背景] 图片压缩过程中出错:`, error);
                  reject(error);
                }
              };

              img.onerror = (error) => {
                console.error(`[归墟背景] 图片加载失败:`, error);
                reject(new Error('图片加载失败'));
              };

              // 创建图片URL
              const url = URL.createObjectURL(file);
              img.src = url;
              
              // 清理URL - 修正onload处理
              const originalOnload = img.onload;
              img.onload = () => {
                URL.revokeObjectURL(url);
                originalOnload();
              };
            });
          },

          // 新增：为大图片创建Object URL的处理方式
          createObjectUrlForLargeImage(file) {
            return new Promise((resolve, reject) => {
              try {
                // 创建Object URL
                const objectUrl = URL.createObjectURL(file);
                
                // 验证URL是否有效
                const img = new Image();
                img.onload = () => {
                  console.log(`[归墟背景] Object URL创建成功: ${objectUrl}`);
                  resolve(objectUrl);
                };
                img.onerror = () => {
                  URL.revokeObjectURL(objectUrl);
                  reject(new Error('Object URL验证失败'));
                };
                img.src = objectUrl;
              } catch (error) {
                console.error(`[归墟背景] Object URL创建失败:`, error);
                reject(error);
              }
            });
          },



          previewBackground(bgId) {
            // 根据当前图库来源查找图片
            const allImages = this.gallerySource === 'library' ? this.backgroundImages : this.outputFolderImages;
            const bg = allImages.find(b => b.id === bgId);
            if (!bg) return;

            // 创建预览模态框
            this.showImagePreviewModal(bg);
          },

          showImagePreviewModal(bg) {
            // 创建预览模态框
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.display = 'flex';
            modal.style.zIndex = '2001'; // 确保在背景设置模态框之上
            modal.innerHTML = `
              <div class="modal-content" style="width: 90vw; height: 90vh; max-width: none; max-height: none; padding: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column;">
                <div class="modal-header" style="padding: 15px; background: rgba(26, 26, 46, 0.95); flex-shrink: 0;">
                  <h2 class="modal-title">预览：${bg.name}</h2>
                  <button class="modal-close-btn" id="preview-close-btn">&times;</button>
                </div>
                <div class="modal-body" style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 10px; overflow: hidden; min-height: 0;">
                  <img src="${bg.dataUrl}" alt="${bg.name}" style="max-width: calc(100% - 20px); max-height: calc(100% - 20px); object-fit: contain; border-radius: 4px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                </div>
              </div>
            `;

            const container = document.querySelector('.guixu-root-container');
            if (container) {
              container.appendChild(modal);

              // 绑定关闭事件
              const closeBtn = modal.querySelector('#preview-close-btn');
              const closeModal = () => {
                modal.remove();
              };

              if (closeBtn) {
                closeBtn.addEventListener('click', closeModal);
              }

              // 点击背景关闭
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  closeModal();
                }
              });

              // ESC键关闭
              const handleKeydown = (e) => {
                if (e.key === 'Escape') {
                  closeModal();
                  document.removeEventListener('keydown', handleKeydown);
                }
              };
              document.addEventListener('keydown', handleKeydown);

              this.showTemporaryMessage(`正在预览：${bg.name}`);
            }
          },

          async selectBackground(bgId) {
            // 根据当前图库来源查找图片
            const allImages = this.gallerySource === 'library' ? this.backgroundImages : this.outputFolderImages;
            const bg = allImages.find(b => b.id === bgId);
            if (!bg) return;

            // 如果是output图片，需要先将其添加到backgroundImages中
            if (bg.isOutput) {
              // 检查是否已存在（通过dataUrl比较）
              const existingBg = this.backgroundImages.find(b => b.dataUrl === bg.dataUrl);
              if (!existingBg) {
                // 自动添加到图库
                const newBg = await this.addOutputImageToLibrary(bgId, true);
                if (newBg) {
                  this.selectedBackgroundId = newBg.id;
                  this.showTemporaryMessage(`已从Output文件夹导入并选择：${bg.name}`);
                }
              } else {
                this.selectedBackgroundId = existingBg.id;
                this.showTemporaryMessage(`已选择背景：${bg.name}`);
              }
            } else {
              this.selectedBackgroundId = bgId;
              this.showTemporaryMessage(`已选择背景：${bg.name}`);
            }

            this.backgroundMode = 'fixed'; // 选择背景时自动切换到固定模式
            this.saveBackgroundSettings();
            this.updateBackgroundModeUI();
            this.renderBackgroundList();
            this.applyRandomBackground(); // 应用选中的背景
          },

          // 新增：将Output图片添加到图库
          async addOutputImageToLibrary(bgId, returnObject = false) {
            const bg = this.outputFolderImages.find(b => b.id === bgId);
            if (!bg) return null;

            // 检查是否已存在
            const existingBg = this.backgroundImages.find(b => b.dataUrl === bg.dataUrl);
            if (existingBg) {
              this.showTemporaryMessage(`图片"${bg.name}"已在图库中`, 'warning');
              return returnObject ? existingBg : null;
            }

            // 创建新的背景图对象
            const newBg = {
              id: `imported_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              name: bg.name,
              dataUrl: bg.dataUrl,
              uploadTime: Date.now(),
              isOutput: false,
              sourceFolder: bg.folder
            };

            // 添加到数组并保存
            this.backgroundImages.push(newBg);
            await this.saveBackgroundSettings();
            
            if (!returnObject) {
              this.showTemporaryMessage(`已将"${bg.name}"添加到图库`, 'success');
              // 刷新列表
              this.renderBackgroundList();
            }

            return newBg;
          },

          deleteBackground(bgId) {
            const bg = this.backgroundImages.find(b => b.id === bgId);
            if (!bg) return;

            this.showCustomConfirm(`确定要删除背景图"${bg.name}"吗？`, () => {
              this.backgroundImages = this.backgroundImages.filter(b => b.id !== bgId);
              
              // 如果删除的是当前选中的背景，清除选择
              if (this.selectedBackgroundId === bgId) {
                this.selectedBackgroundId = null;
              }
              
              this.saveBackgroundSettings();
              this.renderBackgroundList();
              this.applyRandomBackground(); // 重新应用背景
              this.showTemporaryMessage(`已删除背景图：${bg.name}`);
            }, null, true); // keepCurrentModal = true
          },

          // === IndexedDB背景图存储函数 ===
          async saveBackgroundToIndexedDB() {
            if (!this.dbAvailable || !this.db) {
              console.warn('[归墟背景] IndexedDB不可用，无法保存背景图');
              return false;
            }

            try {
              // 清空现有背景图数据
              await this.db.background_images.clear();
              
              // 批量保存所有背景图
              for (const bg of this.backgroundImages) {
                await this.db.background_images.put(bg);
              }
              
              // 保存模式和选中ID到localStorage（元数据较小）
              const metadata = {
                mode: this.backgroundMode,
                selectedId: this.selectedBackgroundId
              };
              localStorage.setItem('guixu_background_metadata', JSON.stringify(metadata));
              
              console.log(`[归墟背景] 已保存 ${this.backgroundImages.length} 张背景图到IndexedDB`);
              return true;
            } catch (error) {
              console.error('[归墟背景] 保存到IndexedDB失败:', error);
              return false;
            }
          },

          async loadBackgroundFromIndexedDB() {
            if (!this.dbAvailable || !this.db) {
              console.warn('[归墟背景] IndexedDB不可用，尝试从localStorage加载');
              return false;
            }

            try {
              // 从IndexedDB加载背景图列表
              const backgrounds = await this.db.background_images.toArray();
              
              if (backgrounds && backgrounds.length > 0) {
                this.backgroundImages = backgrounds;
                console.log(`[归墟背景] 从IndexedDB加载了 ${backgrounds.length} 张背景图`);
              } else {
                // 如果IndexedDB为空，尝试从localStorage迁移数据
                const migrated = await this.migrateBackgroundFromLocalStorage();
                if (!migrated) {
                  this.backgroundImages = [];
                }
              }
              
              // 从localStorage加载元数据
              const metadataStr = localStorage.getItem('guixu_background_metadata');
              if (metadataStr) {
                const metadata = JSON.parse(metadataStr);
                this.backgroundMode = metadata.mode || 'random';
                this.selectedBackgroundId = metadata.selectedId || null;
              } else {
                this.backgroundMode = 'random';
                this.selectedBackgroundId = null;
              }
              
              return true;
            } catch (error) {
              console.error('[归墟背景] 从IndexedDB加载失败:', error);
              this.backgroundImages = [];
              this.backgroundMode = 'random';
              this.selectedBackgroundId = null;
              return false;
            }
          },

          async migrateBackgroundFromLocalStorage() {
            try {
              const saved = localStorage.getItem('guixu_background_settings');
              if (saved) {
                const settings = JSON.parse(saved);
                if (settings.images && settings.images.length > 0) {
                  console.log(`[归墟背景] 正在从localStorage迁移 ${settings.images.length} 张背景图到IndexedDB...`);
                  
                  this.backgroundImages = settings.images;
                  this.backgroundMode = settings.mode || 'random';
                  this.selectedBackgroundId = settings.selectedId || null;
                  
                  // 保存到IndexedDB
                  const success = await this.saveBackgroundToIndexedDB();
                  
                  if (success) {
                    // 迁移成功后，清理localStorage中的旧数据（保留元数据）
                    localStorage.removeItem('guixu_background_settings');
                    console.log('[归墟背景] 数据迁移成功，已清理localStorage旧数据');
                    return true;
                  }
                }
              }
              return false;
            } catch (error) {
              console.error('[归墟背景] 数据迁移失败:', error);
              return false;
            }
          },

          async saveBackgroundSettings() {
            try {
              if (this.dbAvailable && this.db) {
                // 使用IndexedDB存储背景图
                await this.saveBackgroundToIndexedDB();
                console.log('[归墟背景] 背景图已保存到IndexedDB');
              } else {
                // 降级到localStorage
                const settings = {
                  images: this.backgroundImages,
                  mode: this.backgroundMode,
                  selectedId: this.selectedBackgroundId
                };
                localStorage.setItem('guixu_background_settings', JSON.stringify(settings));
                console.log('[归墟背景] 背景图已保存到localStorage（降级模式）');
              }
            } catch (e) {
              console.error('[归墟背景] 保存背景图设置失败:', e);
            }
          },

          async loadBackgroundSettings() {
            try {
              if (this.dbAvailable && this.db) {
                // 从IndexedDB加载
                await this.loadBackgroundFromIndexedDB();
                console.log('[归墟背景] 从IndexedDB加载背景图成功');
              } else {
                // 降级到localStorage
                const saved = localStorage.getItem('guixu_background_settings');
                if (saved) {
                  const settings = JSON.parse(saved);
                  this.backgroundImages = settings.images || [];
                  this.backgroundMode = settings.mode || 'random';
                  this.selectedBackgroundId = settings.selectedId || null;
                }
              }
            } catch (e) {
              console.error('[归墟背景] 加载背景图设置失败:', e);
              this.backgroundImages = [];
              this.backgroundMode = 'random';
              this.selectedBackgroundId = null;
            }
          },

          // --- 新增：处理外链图床添加 ---
          async handleUrlImageAdd() {
            const urlInput = document.getElementById('image-url-input');
            
            if (!urlInput) {
              this.showTemporaryMessage('找不到URL输入框');
              return;
            }
            
            const inputText = urlInput.value.trim();
            const baseName = ''; // 使用空字符串，让系统自动生成名称
            
            // 验证输入
            if (!inputText) {
              this.showTemporaryMessage('请输入图片链接');
              return;
            }
            
            // 分割多行输入，支持多个链接
            const imageUrls = inputText.split('\n')
              .map(url => url.trim())
              .filter(url => url.length > 0);
            
            if (imageUrls.length === 0) {
              this.showTemporaryMessage('请输入有效的图片链接');
              return;
            }
            
            // 验证所有链接格式
            const invalidUrls = imageUrls.filter(url => !this.isValidImageUrl(url));
            if (invalidUrls.length > 0) {
              this.showTemporaryMessage(`以下链接格式无效（需要以 https:// 开头）：\n${invalidUrls.slice(0, 3).join('\n')}${invalidUrls.length > 3 ? '\n...' : ''}`);
              return;
            }
            
            // 检查重复链接
            const existingUrls = imageUrls.filter(url =>
              this.backgroundImages.some(bg => bg.dataUrl === url)
            );
            if (existingUrls.length > 0) {
              this.showTemporaryMessage(`以下链接已存在：\n${existingUrls.slice(0, 3).join('\n')}${existingUrls.length > 3 ? '\n...' : ''}`);
              return;
            }
            
            this.showTemporaryMessage(`正在验证 ${imageUrls.length} 个图片链接...`, 5000);
            
            let successCount = 0;
            let failedUrls = [];
            
            // 批量处理图片链接
            for (let i = 0; i < imageUrls.length; i++) {
              const imageUrl = imageUrls[i];
              
              try {
                // 验证图片链接是否有效
                const isValid = await this.validateImageUrl(imageUrl);
                if (!isValid) {
                  failedUrls.push(imageUrl);
                  continue;
                }
                
                // 生成图片名称
                let finalName;
                if (baseName) {
                  finalName = imageUrls.length > 1 ? `${baseName}_${i + 1}` : baseName;
                } else {
                  finalName = this.extractNameFromUrl(imageUrl);
                }
                
                // 创建新的背景图对象
                const bgId = 'url_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const newBackground = {
                  id: bgId,
                  name: finalName,
                  dataUrl: imageUrl,
                  uploadTime: new Date().toISOString(),
                  isPreset: false,
                  isUrlImage: true, // 标记为外链图片
                  originalUrl: imageUrl
                };
                
                // 测试存储空间
                const tempImages = [...this.backgroundImages, newBackground];
                const testSettings = {
                  images: tempImages,
                  mode: this.backgroundMode,
                  selectedId: this.selectedBackgroundId
                };
                
                try {
                  const testData = JSON.stringify(testSettings);
                  if (testData.length > 4 * 1024 * 1024) {
                    throw new Error('存储空间不足');
                  }
                  
                  localStorage.setItem('guixu_background_test', testData);
                  localStorage.removeItem('guixu_background_test');
                  
                  // 保存成功
                  this.backgroundImages.push(newBackground);
                  successCount++;
                  
                  console.log(`[归墟背景] 成功添加外链图片: ${finalName}, URL: ${imageUrl}`);
                  
                } catch (storageError) {
                  console.error('[归墟背景] 存储外链图片失败:', storageError);
                  failedUrls.push(imageUrl);
                }
                
              } catch (error) {
                console.error('[归墟背景] 验证外链图片失败:', error);
                failedUrls.push(imageUrl);
              }
            }
            
            // 保存设置
            if (successCount > 0) {
              this.saveBackgroundSettings();
              
              // 清空输入框
              urlInput.value = '';
              
              // 刷新列表
              if (document.getElementById('background-settings-modal').style.display === 'flex') {
                this.renderBackgroundList();
              }
            }
            
            // 显示结果消息
            if (successCount === imageUrls.length) {
              this.showTemporaryMessage(`成功添加 ${successCount} 张外链图片！`);
            } else if (successCount > 0) {
              this.showTemporaryMessage(`成功添加 ${successCount} 张图片，${failedUrls.length} 张失败`);
            } else {
              this.showTemporaryMessage('所有图片链接都添加失败，请检查链接是否正确');
            }
          },

          // --- 新增：验证图片URL格式 ---
          isValidImageUrl(url) {
            try {
              const urlObj = new URL(url);
              // 必须是 https 协议
              if (urlObj.protocol !== 'https:') {
                return false;
              }
              // 检查是否是常见的图片扩展名或图床域名
              const pathname = urlObj.pathname.toLowerCase();
              const hostname = urlObj.hostname.toLowerCase();
              
              // 常见图片扩展名
              const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
              const hasImageExtension = imageExtensions.some(ext => pathname.endsWith(ext));
              
              // 常见图床域名
              const imagehostDomains = [
                'imgur.com', 'i.imgur.com',
                'postimg.cc', 'i.postimg.cc',
                'sm.ms', 'i.loli.net',
                'github.com', 'raw.githubusercontent.com',
                'cdn.jsdelivr.net', 'unpkg.com'
              ];
              const isImagehostDomain = imagehostDomains.some(domain =>
                hostname === domain || hostname.endsWith('.' + domain)
              );
              
              return hasImageExtension || isImagehostDomain;
            } catch (e) {
              return false;
            }
          },

          // --- 验证图片链接是否可访问 ---
          validateImageUrl(url) {
            return new Promise((resolve) => {
              const img = new Image();
              const timeout = setTimeout(() => {
                resolve(false);
              }, 10000); // 10秒超时
              
              img.onload = () => {
                clearTimeout(timeout);
                resolve(true);
              };
              
              img.onerror = () => {
                clearTimeout(timeout);
                resolve(false);
              };
              
              // 设置跨域属性以避免CORS问题
              img.crossOrigin = 'anonymous';
              img.src = url;
            });
          },

          // --- 从URL提取文件名 ---
          extractNameFromUrl(url) {
            try {
              const urlObj = new URL(url);
              const pathname = urlObj.pathname;
              const filename = pathname.split('/').pop();
              
              if (filename && filename.includes('.')) {
                // 移除扩展名
                return filename.replace(/\.[^/.]+$/, '') || '外链图片';
              }
              
              // 如果无法提取文件名，使用域名
              return urlObj.hostname.replace('www.', '') || '外链图片';
            } catch (e) {
              return '外链图片';
            }
          },

          // --- 显示图床链接管理模态框 ---
          showUrlImagesManageModal() {
            this.openModal('url-images-manage-modal');
            this.renderUrlImagesList();
          },

          // --- 新增：渲染外链图片列表 ---
          renderUrlImagesList() {
            const listContainer = document.getElementById('url-images-list');
            const countSpan = document.getElementById('url-images-count');
            if (!listContainer || !countSpan) return;

            // 筛选出外链图片
            const urlImages = this.backgroundImages.filter(bg => bg.isUrlImage);
            countSpan.textContent = `(${urlImages.length}张)`;

            if (urlImages.length === 0) {
              listContainer.innerHTML = '<div style="text-align: center; color: #8b7355; padding: 40px 20px;">暂无外链图片</div>';
              return;
            }

            listContainer.innerHTML = '';

            urlImages.forEach(bg => {
              const item = document.createElement('div');
              item.className = 'url-image-item';
              item.style.cssText = `
                display: flex; align-items: center; padding: 12px; margin-bottom: 8px;
                background: rgba(26, 26, 46, 0.6); border: 1px solid rgba(201, 170, 113, 0.2);
                border-radius: 6px; transition: all 0.2s ease;
              `;

              item.innerHTML = `
                <div style="flex-shrink: 0; width: 60px; height: 60px; margin-right: 12px; border-radius: 4px; overflow: hidden; background: rgba(0,0,0,0.3);">
                  <img src="${bg.dataUrl}" alt="${bg.name}" style="width: 100%; height: 100%; object-fit: cover;">
                </div>
                <div style="flex: 1; min-width: 0;">
                  <div style="color: #e0dcd1; font-size: 14px; font-weight: 500; margin-bottom: 4px; word-break: break-all;">
                    ${bg.name}
                  </div>
                  <div style="color: #8b7355; font-size: 11px; word-break: break-all; line-height: 1.3;">
                    ${bg.originalUrl}
                  </div>
                  <div style="color: #8b7355; font-size: 10px; margin-top: 2px;">
                    添加时间: ${new Date(bg.uploadTime).toLocaleString('zh-CN')}
                  </div>
                </div>
                <div style="flex-shrink: 0; display: flex; gap: 6px; margin-left: 12px;">
                  <button class="url-image-btn edit-name-btn" data-bg-id="${bg.id}" 
                          style="padding: 4px 8px; font-size: 11px; background: rgba(201, 170, 113, 0.2); 
                                 border: 1px solid rgba(201, 170, 113, 0.3); border-radius: 3px; 
                                 color: #c9aa71; cursor: pointer; transition: all 0.2s ease;">
                    重命名
                  </button>
                  <button class="url-image-btn preview-btn" data-bg-id="${bg.id}"
                          style="padding: 4px 8px; font-size: 11px; background: rgba(76, 175, 80, 0.2); 
                                 border: 1px solid rgba(76, 175, 80, 0.3); border-radius: 3px; 
                                 color: #4caf50; cursor: pointer; transition: all 0.2s ease;">
                    预览
                  </button>
                  <button class="url-image-btn delete-btn" data-bg-id="${bg.id}"
                          style="padding: 4px 8px; font-size: 11px; background: rgba(244, 67, 54, 0.2); 
                                 border: 1px solid rgba(244, 67, 54, 0.3); border-radius: 3px; 
                                 color: #f44336; cursor: pointer; transition: all 0.2s ease;">
                    删除
                  </button>
                </div>
              `;

              // 添加悬停效果
              item.addEventListener('mouseenter', () => {
                item.style.background = 'rgba(26, 26, 46, 0.8)';
                item.style.borderColor = 'rgba(201, 170, 113, 0.4)';
              });

              item.addEventListener('mouseleave', () => {
                item.style.background = 'rgba(26, 26, 46, 0.6)';
                item.style.borderColor = 'rgba(201, 170, 113, 0.2)';
              });

              listContainer.appendChild(item);
            });

            // 绑定按钮事件
            this.bindUrlImageListEvents();
          },

          // --- 新增：绑定外链图片列表事件 ---
          bindUrlImageListEvents() {
            const listContainer = document.getElementById('url-images-list');
            if (!listContainer) return;

            // 移除旧的事件监听器
            if (this.urlImageListClickHandler) {
              listContainer.removeEventListener('click', this.urlImageListClickHandler);
            }

            // 创建新的事件处理器
            this.urlImageListClickHandler = (e) => {
              const bgId = e.target.dataset.bgId;
              if (!bgId) return;

              if (e.target.classList.contains('edit-name-btn')) {
                this.showEditImageNameModal(bgId);
              } else if (e.target.classList.contains('preview-btn')) {
                this.previewBackground(bgId);
              } else if (e.target.classList.contains('delete-btn')) {
                this.deleteUrlImage(bgId);
              }
            };

            // 绑定新的事件监听器
            listContainer.addEventListener('click', this.urlImageListClickHandler);
          },

          // 显示编辑图片名称模态框
          showEditImageNameModal(bgId) {
            const bg = this.backgroundImages.find(b => b.id === bgId);
            if (!bg) return;

            const input = document.getElementById('edit-image-name-input');
            const saveBtn = document.getElementById('save-image-name-btn');
            
            if (!input || !saveBtn) return;

            // 设置当前名称
            input.value = bg.name;
            
            // 移除旧的事件监听器
            if (this.saveImageNameHandler) {
              saveBtn.removeEventListener('click', this.saveImageNameHandler);
            }

            // 创建新的保存事件处理器
            this.saveImageNameHandler = () => {
              const newName = input.value.trim();
              if (!newName) {
                this.showTemporaryMessage('图片名称不能为空');
                return;
              }

              // 更新图片名称
              bg.name = newName;
              this.saveBackgroundSettings();
              
              // 刷新列表
              this.renderUrlImagesList();
              
              // 如果背景设置模态框也是打开的，也刷新那个列表
              if (document.getElementById('background-settings-modal').style.display === 'flex') {
                this.renderBackgroundList();
              }
              
              // 刷新UI界面的背景图列表
              this.renderBackgroundList();

              this.closeModal('edit-image-name-modal');
              this.showTemporaryMessage(`图片名称已更新为：${newName}`);
            };

            // 绑定保存事件
            saveBtn.addEventListener('click', this.saveImageNameHandler);

            // 绑定回车键保存
            const handleEnterKey = (e) => {
              if (e.key === 'Enter') {
                this.saveImageNameHandler();
                input.removeEventListener('keypress', handleEnterKey);
              }
            };
            input.addEventListener('keypress', handleEnterKey);

            // 打开模态框并聚焦输入框
            this.openModal('edit-image-name-modal');
            setTimeout(() => {
              input.focus();
              input.select();
            }, 100);
          },

          // --- 新增：删除外链图片 ---
          deleteUrlImage(bgId) {
            const bg = this.backgroundImages.find(b => b.id === bgId);
            if (!bg) return;

            this.showCustomConfirm(`确定要删除外链图片"${bg.name}"吗？`, () => {
              this.backgroundImages = this.backgroundImages.filter(b => b.id !== bgId);
              
              // 如果删除的是当前选中的背景，清除选择
              if (this.selectedBackgroundId === bgId) {
                this.selectedBackgroundId = null;
              }
              
              this.saveBackgroundSettings();
              this.renderUrlImagesList();
              
              // 如果背景设置模态框也是打开的，也刷新那个列表
              if (document.getElementById('background-settings-modal').style.display === 'flex') {
                this.renderBackgroundList();
              }
              
              this.applyRandomBackground(); // 重新应用背景
              this.showTemporaryMessage(`已删除外链图片：${bg.name}`);
            }, null, true); // keepCurrentModal = true
          },

          bindGallerySourceControls() {
            const libraryRadio = document.getElementById('gallery-source-library');
            const outputRadio = document.getElementById('gallery-source-output');
            const outputFolderControls = document.getElementById('output-folder-controls');
            const selectOutputFolderBtn = document.getElementById('select-output-folder-btn');
            const refreshOutputFolderBtn = document.getElementById('refresh-output-folder-btn');

            const toggleOutputControls = (show) => {
                outputFolderControls.style.display = show ? 'block' : 'none';
            };

            libraryRadio.addEventListener('change', () => {
                if (libraryRadio.checked) {
                    this.gallerySource = 'library';
                    toggleOutputControls(false);
                    this.galleryCurrentPage = 1; // 切换图库时重置页码
                    this.renderBackgroundList();
                    this.saveGallerySource();
                }
            });

            outputRadio.addEventListener('change', () => {
                if (outputRadio.checked) {
                    this.gallerySource = 'output';
                    toggleOutputControls(true);
                    this.galleryCurrentPage = 1; // 切换图库时重置页码
                    this.renderBackgroundList();
                    this.saveGallerySource();
                }
            });

            selectOutputFolderBtn.addEventListener('click', async () => {
                await this.selectOutputFolder();
            });

            refreshOutputFolderBtn.addEventListener('click', async () => {
                await this.loadOutputFolderImages();
            });

            // 绑定分页按钮事件
            const prevPageBtn = document.getElementById('gallery-prev-page');
            const nextPageBtn = document.getElementById('gallery-next-page');

            if (prevPageBtn) {
                prevPageBtn.addEventListener('click', () => {
                    if (this.galleryCurrentPage > 1) {
                        this.galleryCurrentPage--;
                        this.renderBackgroundList();
                        // 滚动到列表顶部
                        const listContainer = document.getElementById('background-list');
                        if (listContainer) {
                            listContainer.scrollTop = 0;
                        }
                    }
                });
            }

            if (nextPageBtn) {
                nextPageBtn.addEventListener('click', () => {
                    const allImages = this.gallerySource === 'library' ? this.backgroundImages : this.outputFolderImages;
                    const totalPages = Math.ceil(allImages.length / this.galleryPageSize);
                    if (this.galleryCurrentPage < totalPages) {
                        this.galleryCurrentPage++;
                        this.renderBackgroundList();
                        // 滚动到列表顶部
                        const listContainer = document.getElementById('background-list');
                        if (listContainer) {
                            listContainer.scrollTop = 0;
                        }
                    }
                });
            }
          },

          async selectOutputFolder() {
              try {
                  this.outputFolderHandle = await window.showDirectoryPicker();
                  await this.saveOutputFolderHandle();
                  await this.loadOutputFolderImages();
                  this.updateOutputFolderStatus();
              } catch (error) {
                  console.error('选择文件夹时出错:', error);
                  this.showTemporaryMessage('未能选择文件夹', 'error');
              }
          },

          async loadOutputFolderImages() {
              if (!this.outputFolderHandle) {
                  this.showTemporaryMessage('请先选择一个文件夹', 'warning');
                  return;
              }

              try {
                  const permission = await this.verifyPermission(this.outputFolderHandle, true);
                  if (!permission) {
                      this.showTemporaryMessage('需要文件夹读取权限', 'error');
                      return;
                  }

                  // 清空之前的数据
                  this.outputFolderImages = [];
                  await this.recursiveLoadImages(this.outputFolderHandle, '');
                  // 按修改时间排序（新的在前），只排序一次
                  this.outputFolderImages.sort((a, b) => b.lastModified - a.lastModified);
                  
                  // 重置到第一页
                  this.galleryCurrentPage = 1;
                  
                  // 只在gallerySource为output时才渲染
                  if (this.gallerySource === 'output') {
                      this.renderBackgroundList();
                  }
                  
                  this.showTemporaryMessage(`从文件夹加载了 ${this.outputFolderImages.length} 张图片`, 'success');
                  
                  // 启动自动刷新监听
                  this.startOutputFolderMonitoring();
              } catch (error) {
                  console.error('从文件夹读取图片时出错:', error);
                  this.showTemporaryMessage('读取图片失败', 'error');
              }
          },

          async recursiveLoadImages(dirHandle, path) {
              const imageExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.bmp'];
              
              for await (const entry of dirHandle.values()) {
                  const fullPath = path ? `${path}/${entry.name}` : entry.name;
                  
                  if (entry.kind === 'file') {
                      // 检查是否是图片文件
                      const isImage = imageExtensions.some(ext => entry.name.toLowerCase().endsWith(ext));
                      if (isImage) {
                          try {
                              const file = await entry.getFile();
                              this.outputFolderImages.push({
                                  id: `output_${fullPath.replace(/[\/\\]/g, '_')}`,
                                  name: entry.name,
                                  folder: path || '根目录',
                                  fullPath: fullPath,
                                  dataUrl: URL.createObjectURL(file),
                                  isOutput: true,
                                  lastModified: file.lastModified,
                              });
                          } catch (error) {
                              console.warn(`无法读取文件 ${fullPath}:`, error);
                          }
                      }
                  } else if (entry.kind === 'directory') {
                      // 递归读取子文件夹
                      try {
                          await this.recursiveLoadImages(entry, fullPath);
                      } catch (error) {
                          console.warn(`无法访问子文件夹 ${fullPath}:`, error);
                      }
                  }
              }
          },

          startOutputFolderMonitoring() {
              // 停止之前的监听
              if (this.outputFolderMonitoringInterval) {
                  clearInterval(this.outputFolderMonitoringInterval);
              }

              // 每30秒检查一次文件夹变化
              this.outputFolderMonitoringInterval = setInterval(async () => {
                  if (this.outputFolderHandle && this.gallerySource === 'output') {
                      await this.checkAndRefreshOutputFolder();
                  }
              }, 30000); // 30秒刷新一次

              console.log('[归墟背景] Output文件夹监听已启动');
          },

          stopOutputFolderMonitoring() {
              if (this.outputFolderMonitoringInterval) {
                  clearInterval(this.outputFolderMonitoringInterval);
                  this.outputFolderMonitoringInterval = null;
                  console.log('[归墟背景] Output文件夹监听已停止');
              }
          },

          async checkAndRefreshOutputFolder() {
              try {
                  const oldCount = this.outputFolderImages.length;
                  const oldImages = new Set(this.outputFolderImages.map(img => img.fullPath));
                  
                  // 重新加载文件夹内容
                  this.outputFolderImages = [];
                  await this.recursiveLoadImages(this.outputFolderHandle, '');
                  // 按修改时间排序（新的在前）
                  this.outputFolderImages.sort((a, b) => b.lastModified - a.lastModified);
                  
                  const newCount = this.outputFolderImages.length;
                  const newImages = new Set(this.outputFolderImages.map(img => img.fullPath));
                  
                  // 检查是否有变化
                  const hasChanges = oldCount !== newCount ||
                                    ![...oldImages].every(img => newImages.has(img)) ||
                                    ![...newImages].every(img => oldImages.has(img));
                  
                  if (hasChanges) {
                      this.renderBackgroundList();
                      const diff = newCount - oldCount;
                      const message = diff > 0
                          ? `检测到新增 ${diff} 张图片`
                          : diff < 0
                          ? `检测到移除 ${Math.abs(diff)} 张图片`
                          : '检测到文件夹内容变化';
                      this.showTemporaryMessage(message, 'info');
                      console.log(`[归墟背景] ${message}，当前共 ${newCount} 张图片`);
                  }
              } catch (error) {
                  console.error('[归墟背景] 检查文件夹更新时出错:', error);
              }
          },
          
          updateOutputFolderStatus() {
              const statusDiv = document.getElementById('output-folder-status');
              const refreshBtn = document.getElementById('refresh-output-folder-btn');
              if (this.outputFolderHandle) {
                  statusDiv.textContent = `已选择: ${this.outputFolderHandle.name}`;
                  refreshBtn.style.display = 'block';
              } else {
                  statusDiv.textContent = '未选择文件夹';
                  refreshBtn.style.display = 'none';
              }
          },

          async saveOutputFolderHandle() {
              if (this.dbAvailable && this.outputFolderHandle) {
                  await this.db.setItem('outputFolderHandle', this.outputFolderHandle);
              }
          },

          async loadOutputFolderHandle() {
              if (!this.dbAvailable) {
                  console.warn('[归墟背景] IndexedDB不可用，无法加载文件夹句柄');
                  return;
              }

              try {
                  this.outputFolderHandle = await this.db.getItem('outputFolderHandle');
                  
                  if (this.outputFolderHandle) {
                      // 验证句柄是否仍然有效
                      try {
                          const permission = await this.verifyPermission(this.outputFolderHandle, false);
                          
                          if (permission) {
                              console.log(`[归墟背景] 已加载output文件夹: ${this.outputFolderHandle.name}`);
                              this.updateOutputFolderStatus();
                              await this.loadOutputFolderImages();
                          } else {
                              console.warn('[归墟背景] 文件夹权限已失效，需要重新选择');
                              this.outputFolderHandle = null;
                              this.updateOutputFolderStatus();
                          }
                      } catch (error) {
                          console.warn('[归墟背景] 文件夹句柄无效，可能已被删除或移动:', error);
                          this.outputFolderHandle = null;
                          await this.db.setItem('outputFolderHandle', null);
                          this.updateOutputFolderStatus();
                      }
                  } else {
                      console.log('[归墟背景] 未找到保存的output文件夹');
                  }
              } catch (error) {
                  console.error('[归墟背景] 加载文件夹句柄时出错:', error);
                  this.outputFolderHandle = null;
                  this.updateOutputFolderStatus();
              }
          },

          async verifyPermission(fileHandle, readWrite) {
              const options = {};
              if (readWrite) {
                  options.mode = 'readwrite';
              }
              if ((await fileHandle.queryPermission(options)) === 'granted') {
                  return true;
              }
              if ((await fileHandle.requestPermission(options)) === 'granted') {
                  return true;
              }
              return false;
          },

          saveGallerySource() {
              localStorage.setItem('guixu_gallery_source', this.gallerySource);
          },

          loadGallerySource() {
              const source = localStorage.getItem('guixu_gallery_source');
              if (source) {
                  this.gallerySource = source;
                  document.getElementById(source === 'library' ? 'gallery-source-library' : 'gallery-source-output').checked = true;
                  document.getElementById('output-folder-controls').style.display = source === 'output' ? 'block' : 'none';
              }
          },

// === 背景图模块结束===


// ===快捷键模块开始===
          // 新增：绑定键盘快捷键
          bindKeyboardShortcuts() {
            this.boundHandleKeydown = (e) => {
              // 检查快捷键是否已启用
              if (!this.isKeyboardShortcutsEnabled) {
                return; // 快捷键已禁用
              }

              // 检查是否在输入框中，如果是则不处理快捷键
              const activeElement = document.activeElement;
              const isInputField = activeElement && (
                activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.contentEditable === 'true' ||
                activeElement.isContentEditable
              );

              if (isInputField) {
                return; // 在输入框中时不处理快捷键
              }

              // 处理带修饰键的快捷键
              if (e.ctrlKey && !e.altKey && !e.metaKey) {
                switch (e.key.toLowerCase()) {
                  case 'a':
                    e.preventDefault();
                    this.toggleLeftPanel();
                    console.log('[归墟快捷键] Ctrl+A - 切换左侧面板');
                    break;
                  case 'd':
                    e.preventDefault();
                    this.toggleRightPanel();
                    console.log('[归墟快捷键] Ctrl+D - 切换右侧面板');
                    break;
                }
                return; // 处理完修饰键快捷键后返回
              }

              // 防止其他修饰键组合干扰
              const isModifierPressed = e.ctrlKey || e.altKey || e.metaKey;
              if (isModifierPressed) {
                return; // 有其他修饰键时不处理
              }

              switch (e.key.toLowerCase()) {
                case 'e':
                  e.preventDefault();
                  this.toggleModal('inventory-modal', () => this.showInventory());
                  console.log('[归墟快捷键] E键 - 切换物品栏');
                  break;
                case 'r':
                  e.preventDefault();
                  this.toggleModal('relationships-modal', () => this.showRelationships());
                  console.log('[归墟快捷键] R键 - 切换人物关系');
                  break;
                case 'c':
                  e.preventDefault();
                  this.toggleModal('save-load-modal', () => this.showNewSaveLoadManager());
                  console.log('[归墟快捷键] C键 - 切换存档管理器');
                  break;
                case 't':
                  e.preventDefault();
                  this.toggleModal('settings-modal', () => this.showSettings());
                  console.log('[归墟快捷键] T键 - 切换设置界面');
                  break;
                // --- 新增快捷键 ---
                case 'y': // 自动阅读
                    e.preventDefault();
                    document.getElementById('auto-read-checkbox')?.click();
                    console.log('[归墟快捷键] Y键 - 切换自动阅读');
                    break;
                case 'f': // 分段记忆
                    e.preventDefault();
                    this.toggleModal('segmented-memory-modal', () => this.showSegmentedMemoryModal());
                    console.log('[归墟快捷键] F键 - 切换分段记忆');
                    break;
                case '1': // 回顶
                    e.preventDefault();
                    document.getElementById('scroll-to-top-btn')?.click();
                    console.log('[归墟快捷键] 1键 - 回顶');
                    break;
                case '2': // 本章
                    e.preventDefault();
                    document.getElementById('scroll-to-bottom-btn')?.click();
                    console.log('[归墟快捷键] 2键 - 本章');
                    break;
                case '3': // 回底
                    e.preventDefault();
                    document.getElementById('scroll-to-real-bottom-btn')?.click();
                    console.log('[归墟快捷键] 3键 - 回底');
                    break;
                case '5': // 上一章
                    e.preventDefault();
                    document.getElementById('prev-chapter-btn')?.click();
                    console.log('[归墟快捷键] 5键 - 上一章');
                    break;
                case '6': // 下一章
                    e.preventDefault();
                    document.getElementById('next-chapter-btn')?.click();
                    console.log('[归墟快捷键] 6键 - 下一章');
                    break;
                case 'g': // 归墟系统
                    e.preventDefault();
                    this.toggleModal('guixu-system-modal', () => this.showGuixuSystem());
                    console.log('[归墟快捷键] G键 - 切换归墟系统');
                    break;
                case 'b': // 背景图设置
                    e.preventDefault();
                    this.toggleModal('background-settings-modal', () => this.showBackgroundSettings());
                    console.log('[归墟快捷键] B键 - 切换背景图设置');
                    break;
                case '4': // 变量编辑器
                    e.preventDefault();
                    this.toggleModal('variable-editor-modal', () => this.showVariableEditor());
                    console.log('[归墟快捷键] 4键 - 切换变量编辑器');
                    break;
                case 'z': // 指令中心
                    e.preventDefault();
                    this.toggleModal('command-center-modal', () => this.showCommandCenter());
                    console.log('[归墟快捷键] Z键 - 切换指令中心');
                    break;
                case 'l': // 查看提取内容
                    e.preventDefault();
                    this.toggleModal('extracted-content-modal', () => this.showExtractedContent());
                    console.log('[归墟快捷键] L键 - 切换查看提取内容');
                    break;
                case 'x': // 小说模式
                    e.preventDefault();
                    this.toggleModal('novel-mode-modal', () => this.showNovelMode());
                    console.log('[归墟快捷键] X键 - 切换小说模式');
                    break;
       }
            };
            document.addEventListener('keydown', this.boundHandleKeydown);

            console.log('[归墟快捷键] 键盘快捷键绑定完成');
            console.log('[归墟快捷键] Y-自动阅读, F-分段记忆, G-归墟系统, B-背景设置, 4-变量编辑, Z-指令中心, L-查看提取, X-小说模式');
            console.log('[归墟快捷键] 1-回顶, 2-本章, 3-回底, 5-上一章, 6-下一章');
            console.log('[归墟快捷键] E-背包, R-人物关系, C-存档读档, T-设置, Ctrl+A/D-面板折叠');
          },

          // 新增：模态框切换函数
          toggleModal(modalId, showFunction) {
            const modal = document.getElementById(modalId);
            if (modal && modal.style.display === 'flex') {
              // 如果模态框已经打开，则关闭它
              this.closeModal(modalId);
            } else {
              // 如果模态框未打开，则打开它
              showFunction();
            }
          },

          // 新增：键盘快捷键详情折叠/展开函数
          toggleKeyboardShortcutsDetails() {
            const details = document.getElementById('keyboard-shortcuts-details');
            const toggleButton = document.getElementById('keyboard-shortcuts-toggle');
            
            if (details && toggleButton) {
              if (details.style.display === 'none' || details.style.display === '') {
                details.style.display = 'block';
                toggleButton.textContent = '▲';
                toggleButton.style.transform = 'rotate(180deg)';
              } else {
                details.style.display = 'none';
                toggleButton.textContent = '▼';
                toggleButton.style.transform = 'rotate(0deg)';
              }
            }
          },
// ===快捷键模块结束===



// ===输入法适配模块开始===
          setupInputKeyboardHandling() {
            const inputField = document.getElementById('quick-send-input');
            if (!inputField) {
              return;
            }
            if (this.isMobileInputAdaptEnabled) {
              this.setupFloatingInput();
            } else {
              this.setupViewportAdjustment();
            }
          },
          reinitializeInputKeyboardHandling() {
            const inputField = document.getElementById('quick-send-input');
            this.cleanupInputKeyboardHandling();
            this.setupInputKeyboardHandling();
          },
          cleanupInputKeyboardHandling() {
            const inputField = document.getElementById('quick-send-input');
            if (!inputField) return;
            const newInputField = inputField.cloneNode(true);
            inputField.parentNode.replaceChild(newInputField, inputField);
          },
          setupFloatingInput() {
            const inputField = document.getElementById('quick-send-input');
            const sendButton = document.getElementById('btn-quick-send');
            const bottomBar = document.querySelector('.bottom-status-bar');
            this.originalParent = inputField.parentElement;
            this.originalNextSibling = inputField.nextSibling;
            this.moveInputToTop = () => {              
              const container = this.createFloatingContainer();
              const inputValue = inputField.value;
              container.appendChild(inputField);
              inputField.style.cssText = `
                background: rgba(0, 0, 0, 0.5) !important;
                border: 1px solid #8b7355 !important;
                border-radius: 4px !important;
                color: #e0dcd1 !important;
                padding: 5px 10px !important;
                font-size: 12px !important;
                width: 100% !important;
                flex-grow: 1 !important;
                max-width: 500px !important;
                height: 32px !important;
                resize: none !important;
                line-height: 1.5 !important;
                font-family: inherit !important;
                margin: 0 !important;
              `;
              inputField.onfocus = null;
              inputField.onblur = null;
              inputField.value = inputValue;
              if (sendButton && sendButton.parentElement !== container) {
                const sendBtnClone = document.createElement('button');
                sendBtnClone.textContent = '发送';
                sendBtnClone.style.cssText = `
                  padding: 6px 4px !important;
                  background: linear-gradient(45deg, #1a1a2e, #2d1b3d) !important;
                  border: 1px solid #c9aa71 !important;
                  border-radius: 5px !important;
                  color: #c9aa71 !important;
                  font-size: 10px !important;
                  cursor: pointer !important;
                  text-align: center !important;
                  transition: all 0.3s ease !important;
                  white-space: nowrap !important;
                `;
                sendBtnClone.onmouseover = () => {
                  sendBtnClone.style.background = 'linear-gradient(45deg, #2d1b3d, #3d2b4d)';
                };
                sendBtnClone.onmouseout = () => {
                  sendBtnClone.style.background = 'linear-gradient(45deg, #1a1a2e, #2d1b3d)';
                };
                sendBtnClone.onclick = () => {
                  sendButton.click();
                };
                container.appendChild(sendBtnClone);
              }
              setTimeout(() => {
                container.style.top = '0px';
                container.style.opacity = '1';
              }, 10);
              setTimeout(() => {
                inputField.focus();
              }, 100);
            };
            inputField.addEventListener('focus', (e) => {
              if (this.isMobileInputAdaptEnabled) {
                if (!this.floatingInputContainer || !this.floatingInputContainer.parentElement) {
                  this.moveInputToTop();
                } 
              } 
            });
            inputField.addEventListener('blur', (e) => {
              if (this.isMobileInputAdaptEnabled && this.floatingInputContainer) {
                setTimeout(() => {
                  const activeElement = document.activeElement;
                  const isInFloatingContainer = this.floatingInputContainer &&
                    (this.floatingInputContainer.contains(activeElement) || activeElement === inputField);                  
                  if (!isInFloatingContainer) {
                    this.resetInputPosition();
                  }
                }, 200);
              }
            });
          },
          createFloatingContainer() {
            if (this.floatingInputContainer && this.floatingInputContainer.parentElement) {
              return this.floatingInputContainer;
            }            
            this.floatingInputContainer = document.createElement('div');
            this.floatingInputContainer.className = 'floating-input-container';
            this.floatingInputContainer.style.cssText = `
              position: fixed !important;
              top: -60px !important;
              left: 0 !important;
              right: 0 !important;
              width: 100% !important;
              z-index: 999999 !important;
              background: transparent !important;
              padding: 10px 15px !important;
              display: flex !important;
              gap: 8px !important;
              align-items: center !important;
              opacity: 0 !important;
              visibility: visible !important;
              pointer-events: auto !important;
              transform: translateY(0) !important;
              transition: all 0.3s ease !important;
            `;
            const isFullscreen = document.fullscreenElement !== null;
            const rootContainer = document.querySelector('.guixu-root-container');            
            if (isFullscreen && rootContainer) {
              rootContainer.appendChild(this.floatingInputContainer);
            } else {
              document.body.appendChild(this.floatingInputContainer);
            }
            this.floatingInputContainer.offsetHeight;    
            return this.floatingInputContainer;
          },
          resetInputPosition() {            
            const inputField = document.getElementById('quick-send-input');
            if (!this.floatingInputContainer || !inputField) return;  
            this.floatingInputContainer.style.opacity = '0';
            this.floatingInputContainer.style.visibility = 'hidden';
            setTimeout(() => {
              const inputValue = inputField.value;
              if (this.originalNextSibling) {
                this.originalParent.insertBefore(inputField, this.originalNextSibling);
              } else {
                this.originalParent.appendChild(inputField);
              }
              inputField.style.cssText = '';
              inputField.className = 'quick-send-input';
              inputField.value = inputValue;
              const clonedButton = this.floatingInputContainer.querySelector('button:not(.close-floating-input)');
              if (clonedButton) {
                clonedButton.remove();
              }
              if (this.floatingInputContainer && this.floatingInputContainer.parentElement) {
                this.floatingInputContainer.remove();
              }
              this.floatingInputContainer = null;
            }, 300);
          },
          setupViewportAdjustment() {
            const inputField = document.getElementById('quick-send-input');
            let isKeyboardOpen = false;
            let originalHeight = window.innerHeight;
            let lastScrollPosition = 0;
            const getViewportHeight = () => {
              if (window.visualViewport) {
                return window.visualViewport.height;
              }
              return window.innerHeight;
            };
            const handleKeyboardToggle = () => {
              const currentHeight = getViewportHeight();
              const heightDiff = originalHeight - currentHeight;
              if (heightDiff > 100 && !isKeyboardOpen) {
                isKeyboardOpen = true;
                this.adjustForKeyboard(true, heightDiff);
              }
              else if (heightDiff < 50 && isKeyboardOpen) {
                isKeyboardOpen = false;
                this.adjustForKeyboard(false, 0);
              }
            };
            inputField.addEventListener('focus', () => {
              lastScrollPosition = window.scrollY;
              setTimeout(() => {
                handleKeyboardToggle();
                this.ensureInputVisible();
              }, 300);
            });

            inputField.addEventListener('blur', () => {
              // 延迟处理键盘收起
              setTimeout(() => {
                if (document.activeElement !== inputField) {
                  isKeyboardOpen = false;
                  this.adjustForKeyboard(false, 0);
                  // 恢复滚动位置
                  window.scrollTo(0, lastScrollPosition);
                }
              }, 300);
            });

            // 监听视口变化
            if (window.visualViewport) {
              window.visualViewport.addEventListener('resize', handleKeyboardToggle);
              window.visualViewport.addEventListener('scroll', () => {
                if (isKeyboardOpen) {
                  this.ensureInputVisible();
                }
              });
            } else {
              window.addEventListener('resize', handleKeyboardToggle);
            }
            window.addEventListener('orientationchange', () => {
              setTimeout(() => {
                originalHeight = window.innerHeight;
                handleKeyboardToggle();
              }, 500);
            });
          },
          adjustForKeyboard(keyboardOpen, keyboardHeight) {
            const bottomBar = document.querySelector('.bottom-status-bar');
            const chatContainer = document.querySelector('.chat-container');
            const rootContainer = document.querySelector('.guixu-root-container');  
            if (keyboardOpen && keyboardHeight > 0) {
              if (rootContainer && rootContainer.classList.contains('mobile-view')) {
                if (bottomBar) {
                  bottomBar.style.position = 'fixed';
                  bottomBar.style.bottom = `${keyboardHeight}px`;
                  bottomBar.style.left = '0';
                  bottomBar.style.right = '0';
                  bottomBar.style.zIndex = '10000';
                  bottomBar.style.transition = 'bottom 0.3s ease';
                }
                if (chatContainer) {
                  const bottomBarHeight = bottomBar ? bottomBar.offsetHeight : 0;
                  chatContainer.style.paddingBottom = `${keyboardHeight + bottomBarHeight + 10}px`;
                  chatContainer.style.transition = 'padding-bottom 0.3s ease';
                }
              } else {
                if (bottomBar) {
                  bottomBar.style.position = 'fixed';
                  bottomBar.style.bottom = '0';
                  bottomBar.style.zIndex = '10000';
                }
                if (chatContainer) {
                  chatContainer.style.paddingBottom = '150px';
                }
              }
            } else {
              if (bottomBar) {
                bottomBar.style.position = '';
                bottomBar.style.bottom = '';
                bottomBar.style.left = '';
                bottomBar.style.right = '';
                bottomBar.style.zIndex = '';
                bottomBar.style.transition = '';
              }
              if (chatContainer) {
                chatContainer.style.paddingBottom = '';
                chatContainer.style.transition = '';
              }
            }
          },
          ensureInputVisible() {
            const inputField = document.getElementById('quick-send-input');
            const bottomBar = document.querySelector('.bottom-status-bar');
            if (inputField && bottomBar) {
              const inputRect = inputField.getBoundingClientRect();
              const viewportHeight = this.getViewportHeight();
              if (inputRect.bottom > viewportHeight || inputRect.top < 0) {
                const scrollTarget = window.scrollY + inputRect.top - (viewportHeight / 2);
                window.scrollTo({
                  top: scrollTarget,
                  behavior: 'smooth'
                });
              }
            }
          },
          getViewportHeight() {
            if (window.visualViewport) {
              return window.visualViewport.height;
            }
            return window.innerHeight;
          },
// ===输入法适配模块结束===



// ===衍梦尘/抽卡/Gacha系统开始===
          showGachaSystem() {
              this.isFromGuixuSystem = true;
              this.openModal('gacha-modal', true); 
              this.renderSummonTab(); 
          },

          loadGachaState() {
              const defaultState = {
                  pitySSR_char: 0, pitySR_char: 0,
                  pitySSR_item: 0, pitySR_item: 0, pitySSR_talent: 0, pitySR_talent: 0,
                  redeemedCodes: [],
                  activeCompanions: [],
                  activatedItems: [],
              };
              const savedState = AppStorage.loadData('gacha_state', defaultState);
              this.gachaState = Object.assign({}, defaultState, savedState);
              if (this.gachaState.mengChen) {
                  delete this.gachaState.mengChen;
              }
              this.gachaCollection = AppStorage.loadData('gacha_collection', {});
              this.gachaHistory = AppStorage.loadData('gacha_history', []);
          },

          saveGachaState() {
              AppStorage.saveData('gacha_state', this.gachaState);
              AppStorage.saveData('gacha_collection', this.gachaCollection);
              AppStorage.saveData('gacha_history', this.gachaHistory);
          },
          _updateGachaBackground(bgUrl) {
              const modalContent = document.getElementById('gacha-modal-content');
              if (modalContent && bgUrl) {
                  const img = new Image();
                  img.onload = () => {
                      modalContent.style.backgroundImage = `url('${bgUrl}')`;
                  };
                  img.src = bgUrl;
              }
          },
          _renderGachaPool(poolType) {
              this.currentGachaPoolType = poolType;
              const displayContainer = document.getElementById('gacha-pool-display');
              if (!displayContainer) return;

              const poolData = {
                  character: { title: '镜花水月 (角色池)', cost: 320, pitySSR: this.gachaState.pitySSR_char, pitySR: this.gachaState.pitySR_char, bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
                  item: { title: '万象奇珍 (道具池)', cost: 160, pitySSR: this.gachaState.pitySSR_item, pitySR: this.gachaState.pitySR_item, bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
                  talent: { title: '天命灵根 (天赋池)', cost: 160, pitySSR: this.gachaState.pitySSR_talent, pitySR: this.gachaState.pitySR_talent, bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
              };
              const currentPool = poolData[poolType];

              this._updateGachaBackground(currentPool.bg);

              displayContainer.innerHTML = `
                  <div class="summon-container">
                      <div class="summon-header-info"></div> 
                      <div class="summon-main-controls">
                          <h3 class="pool-title">${currentPool.title}</h3>
                          <p style="font-size:12px; color:#a09c91;">SSR保底: ${currentPool.pitySSR}/90 | SR保底: ${currentPool.pitySR}/10</p>
                          <div class="summon-buttons">
                              <button id="gacha-pull-1" class="interaction-btn">召唤1次 (${currentPool.cost} 梦尘)</button>
                              <button id="gacha-pull-10" class="interaction-btn primary-btn">召唤10次 (${currentPool.cost * 10} 梦尘)</button>
                          </div>
                      </div>
                  </div>
              `;

              document.getElementById('gacha-pull-1').addEventListener('click', () => this.handlePull(1, poolType));
              document.getElementById('gacha-pull-10').addEventListener('click', () => this.handlePull(10, poolType));

              document.querySelectorAll('.pool-switch-btn').forEach(btn => {
                  btn.classList.toggle('active', btn.dataset.pool === poolType);
              });
              const galleryBtn = document.getElementById('btn-gacha-gallery-new');
              if (galleryBtn) {
                  const newBtn = galleryBtn.cloneNode(true); 
                  galleryBtn.parentNode.replaceChild(newBtn, galleryBtn);
                  newBtn.addEventListener('click', () => this.showGachaGalleryPopup(poolType));
              }
          },

     // 显示图鉴弹窗
          showGachaGalleryPopup(poolType) { 
              if (!poolType) {
                  console.error('showGachaGalleryPopup 调用时缺少 poolType');
                  poolType = this.currentGachaPoolType; 
              }
              this.openModal('gacha-gallery-popup', true);
               // const poolType = this.currentGachaPoolType; // 不再从全局状态读取
              const poolData = {
                  character: { title: '镜花水月', bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
                  item: { title: '万象奇珍', bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
                  talent: { title: '天命灵根', bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
              };
              const currentPool = poolData[poolType];

              document.getElementById('gacha-gallery-title').textContent = `${currentPool.title} 图鉴`;

              const previewContainer = document.getElementById('gallery-pool-preview');
              previewContainer.innerHTML = `<div class="summon-container" style="background-image: url('${currentPool.bg}');"><h3 class="pool-title">${currentPool.title}</h3></div>`;

              const gridContainer = document.getElementById('gallery-obtained-grid');
              const allItems = [...(this.gachaPools[poolType]?.ssr || []), ...(this.gachaPools[poolType]?.sr || []), ...(this.gachaPools[poolType]?.r || [])];

              const renderContent = (isObtainedOnly) => {
                  const itemsToRender = isObtainedOnly ? allItems.filter(item => this.gachaCollection[item.id]) : allItems;

                  if (itemsToRender.length === 0) {
                      gridContainer.innerHTML = `<p style='text-align:center; color:#8b7355; padding-top: 40px;'>${isObtainedOnly ? '此卡池暂无已获得的项目' : '此卡池内容为空'}</p>`;
                      return;
                  }

                  let gridHtml = '';
                  if (poolType === 'character') {
                      itemsToRender.forEach(item => {
                          const isUnlocked = this.gachaCollection[item.id];
                          const isActive = this.gachaState.activeCompanions.some(c => c.id === item.id);
                          const isQueued = this.pendingActions.some(a => a.itemName === item.名称);
                          let buttonHtml = '';
                          if (isUnlocked) {
                              if (isActive) buttonHtml = `<button class="gallery-join-world-btn" disabled>已加入</button>`;
                              else if (isQueued) buttonHtml = `<button class="gallery-join-world-btn" disabled>指令队列中</button>`;
                              else buttonHtml = `<button class="gallery-join-world-btn" data-item-id="${item.id}">加入世界</button>`;
                          }
                          const bgImageStyle = item.图片 ? `background-image: url('${item.图片}');` : '';
                          gridHtml += `
                              <div class="gallery-card rarity-${item.稀有度} ${isUnlocked ? 'unlocked' : 'gallery-card-locked'}" data-item-id="${item.id}">
                                  <div class="gallery-card-name">${item.名称}</div>
                                  ${buttonHtml}
                              </div>
                          `;
                      });
                      gridContainer.innerHTML = `<div class="gallery-grid">${gridHtml}</div>`;
                  } else {
                      itemsToRender.forEach(item => {
                          const isUnlocked = this.gachaCollection[item.id];
                          const isActive = this.gachaState.activatedItems.includes(item.id);
                          const isQueued = this.pendingActions.some(a => a.itemName === item.名称);
                          let buttonHtml = '';
                          if (isUnlocked) {
                              if (isActive) buttonHtml = `<button class="gallery-join-world-btn" disabled>已激活</button>`;
                              else if (isQueued) buttonHtml = `<button class="gallery-join-world-btn" disabled>指令队列中</button>`;
                              else buttonHtml = `<button class="gallery-join-world-btn" data-item-id="${item.id}" style="position: static; transform: none; opacity: 1; background: rgba(139,115,85,0.4);">加入指令</button>`;
                          }

                          gridHtml += `
                              <div class="gallery-text-item ${isUnlocked ? '' : 'gallery-text-item-locked'}" data-item-id="${item.id}">
                                  <div class="gallery-text-item-header">
                                      <span class="gallery-text-item-name rarity-${item.稀有度}">${item.名称} ${item.类型 ? `(${item.类型})` : ''}</span>
                                      <span class="gallery-text-item-rarity rarity-${item.稀有度}">${item.稀有度}</span>
                                  </div>
                                  <p class="gallery-text-item-desc">${item.描述}</p>
                                  ${isUnlocked ? `<div style="text-align: right; margin-top: 8px;">${buttonHtml}</div>` : ''}
                              </div>
                          `;
                      });
                      gridContainer.innerHTML = `<div class="gallery-text-grid">${gridHtml}</div>`;
                  }

                  gridContainer.querySelectorAll('.gallery-join-world-btn[data-item-id]').forEach(btn => {
                      btn.addEventListener('click', (e) => {
                          e.stopPropagation();
                          const itemId = e.target.dataset.itemId;
                          const itemData = allItems.find(i => i.id === itemId);
                          if(itemData) this.handleJoinWorld(itemData, poolType);
                      });
                  });
              };

              const container = document.querySelector('.gallery-obtained-container');
              const oldTabs = container.querySelector('.gallery-tab-nav');
              if (oldTabs) oldTabs.remove();
              const tabsHtml = `
                  <div class="gallery-tab-nav">
                      <button class="gallery-tab-btn" data-view="overview">卡池总览</button>
                      <button class="gallery-tab-btn" data-view="collection">我的收藏</button>
                  </div>
              `;
              container.insertAdjacentHTML('afterbegin', tabsHtml);

              const tabButtons = container.querySelectorAll('.gallery-tab-btn');
              tabButtons.forEach(btn => {
                  btn.addEventListener('click', () => {
                      tabButtons.forEach(b => b.classList.remove('active'));
                      btn.classList.add('active');
                      renderContent(btn.dataset.view === 'collection');
                  });
              });

              container.querySelector('.gallery-tab-btn[data-view="overview"]').click();
          },

          // 衍梦尘设置面板
          showGachaSettingsPopup() {
              this.openModal('gacha-settings-popup', true);
              const container = document.querySelector('#gacha-settings-popup .modal-body');
              if (!container) return;
              const archiveTab = container.querySelector('.gacha-settings-tab[data-tab="archives"]');
              if (archiveTab) archiveTab.textContent = '卡池档案';
              container.querySelectorAll('.gacha-settings-tab').forEach(tab => {
                  tab.addEventListener('click', () => {
                      container.querySelectorAll('.gacha-settings-tab').forEach(t => t.classList.remove('active'));
                      tab.classList.add('active');
                      this._renderGachaSettingsTab(tab.dataset.tab);
                  });
              });
              this._renderGachaSettingsTab('command_center');
          },

          _renderGachaSettingsTab(tabName) {
              const contentContainer = document.getElementById('gacha-settings-content-container');
              if (!contentContainer) return;
              contentContainer.innerHTML = '<p style="color: #a09c91; padding: 20px;">正在加载...</p>';

              switch (tabName) {
                  case 'command_center':
                      this._renderSettingsCommandCenter(contentContainer);
                      break;
                  case 'archives':
                      this._renderSettingsArchives(contentContainer);
                      break;
                  case 'redeem':
                      this._renderSettingsRedeem(contentContainer);
                      break;
                  case 'pool_editor':
                      this._renderSettingsPoolEditor(contentContainer);
                      break;
              }
          },

          _renderSettingsCommandCenter(container) {
              let contentHtml = '<h3 class="settings-section-title">待处理指令</h3>';
              if (this.pendingActions.length === 0) {
                  contentHtml += '<p style="color: #a09c91; font-size: 13px;">当前没有待处理的指令。</p>';
              } else {
                  contentHtml += '<ul class="command-center-list">';
                  this.pendingActions.forEach(cmd => {
                      const actionText = this._formatActionText(cmd); 
                      if(actionText) contentHtml += `<li>${actionText}</li>`;
                  });
                  contentHtml += '</ul>';
                  contentHtml += '<button id="gacha-clear-pending" class="interaction-btn btn-danger" style="margin-top: 15px;">清空指令</button>';
              }
              container.innerHTML = contentHtml;

              const clearBtn = document.getElementById('gacha-clear-pending');
              if(clearBtn) {
                  clearBtn.addEventListener('click', () => {
                      this.pendingActions = [];
                      this.savePendingActions();
                      this._renderGachaSettingsTab('command_center'); 
                      this.showTemporaryMessage('指令中心已清空');
                  });
              }
          },
          _renderSettingsArchives(container) {
              container.innerHTML = '<p style="color: #a09c91;">正在加载卡池项目...</p>';
              
              const allPoolItems = [
                  ...Object.values(this.gachaPools.character || {}).flat(),
                  ...Object.values(this.gachaPools.item || {}).flat(),
                  ...Object.values(this.gachaPools.talent || {}).flat()
              ].filter(Boolean);

              if (allPoolItems.length === 0) {
                  container.innerHTML = '<p style="color: #a09c91; font-size: 13px;">“【归墟扩展】衍梦尘卡池”为空或未加载，请先在世界书中定义卡池内容。</p>';
                  return;
              }
              
              let contentHtml = '<h3 class="settings-section-title">卡池项目预览</h3>';
              contentHtml += '<p style="font-size: 12px; color: #a09c91; margin-top: -5px; margin-bottom: 15px;">此处列出所有在“【归墟扩展】衍梦尘卡池”世界书中定义的项目。</p>';

              for (const item of allPoolItems) {
                  contentHtml += `
                      <div class="character-archive-item">
                          <div class="archive-header">
                              <span class="archive-char-name" style="color: ${item.稀有度 === 'SSR' ? '#FFD700' : item.稀有度 === 'SR' ? '#C0C0C0' : '#CD7F32'};">${item.名称}</span>
                              <span style="font-size: 12px; color: #a09c91;">${item.类型} - ${item.稀有度}</span>
                          </div>
                          <div style="padding: 10px 15px; font-size: 13px; color: #d4d2c8;">${item.描述}</div>
                      </div>
                  `;
              }
              container.innerHTML = contentHtml;
          },

          // 卡池编辑器UI渲染函数
          _renderSettingsPoolEditor(container) {
              let contentHtml = `
                  <div class="pool-editor-container">
                      <h3 class="settings-section-title">卡池编辑器</h3>
                      <p style="font-size: 12px; color: #a09c91; margin-top: -5px; margin-bottom: 15px;">在此管理“【归墟扩展】衍梦尘卡池”世界书的内容。</p>
                      <div class="pool-editor-controls">
                          <select id="pool-editor-select" class="quick-send-input">
                              <option value="character">[角色池]</option>
                              <option value="item">[道具池]</option>
                              <option value="talent">[天赋池]</option>
                          </select>
                          <button id="pool-editor-add-btn" class="interaction-btn primary-btn">添加新项目</button>
                      </div>
                      <div id="pool-editor-list-container" class="pool-editor-list">
                          <!-- 项目列表将在这里动态生成 -->
                      </div>
                  </div>
              `;
              container.innerHTML = contentHtml;
              const selectEl = document.getElementById('pool-editor-select');
              const addBtn = document.getElementById('pool-editor-add-btn');

              if (selectEl) {
                  selectEl.addEventListener('change', () => {
                      this._loadPoolEditorList(selectEl.value);
                  });
              }

              if (addBtn) {
                  addBtn.addEventListener('click', () => {
                      const poolType = selectEl ? selectEl.value : 'character';
                      this._addNewItemToEditor(poolType);
                  });
              }
              // 初始加载默认卡池
              this._loadPoolEditorList(selectEl ? selectEl.value : 'character');
          },

          // 加载并渲染指定卡池的编辑器列表
          async _loadPoolEditorList(poolType) {
              const listContainer = document.getElementById('pool-editor-list-container');
              if (!listContainer) return;

              listContainer.innerHTML = '<p style="color: #a09c91;">正在从世界书加载项目...</p>';
              
              const poolCommentMapping = {
                  character: '[角色池]',
                  item: '[道具池]',
                  talent: '[天赋池]'
              };
              const targetComment = poolCommentMapping[poolType];
              
              try {
                  const bookName = '【归墟扩展】衍梦尘卡池';
                  const allEntries = await TavernHelper.getLorebookEntries(bookName);
                  const targetEntry = allEntries.find(e => e.comment === targetComment && e.enabled === false);

                  if (!targetEntry || !targetEntry.content) {
                      listContainer.innerHTML = '<p style-style="color: #8b7355;">未找到或卡池为空。您可以点击“添加新项目”来创建第一个条目。</p>';
                      return;
                  }

                  const itemBlocks = targetEntry.content.split(/\n*\s*名称:/).filter(block => block.trim() !== '');
                  if (itemBlocks.length === 0) {
                       listContainer.innerHTML = '<p style-style="color: #8b7355;">卡池为空。您可以点击“添加新项目”来创建第一个条目。</p>';
                      return;
                  }

                  listContainer.innerHTML = ''; // 清空
                  itemBlocks.forEach(block => {
                      const item = this._parseGachaPoolEntry('名称:' + block);
                      if (item) {
                          const itemElement = this._createEditorItemElement(item, poolType);
                          listContainer.appendChild(itemElement);
                      }
                  });

              } catch (e) {
                  console.error(`加载卡池 [${targetComment}] 失败:`, e);
                  listContainer.innerHTML = `<p style="color: #ff6b6b;">加载失败: ${e.message}</p>`;
              }
          },

          // 从世界书中删除卡池项目
          async _deletePoolItem(itemName, poolType) {
              this.showTemporaryMessage(`正在删除“${itemName}”...`, 'info');
              const poolCommentMapping = {
                  character: '[角色池]',
                  item: '[道具池]',
                  talent: '[天赋池]'
              };
              const targetComment = poolCommentMapping[poolType];

              try {
                  const bookName = '【归墟扩展】衍梦尘卡池';
                  const allEntries = await TavernHelper.getLorebookEntries(bookName);
                  const targetEntry = allEntries.find(e => e.comment === targetComment && e.enabled === false);

                  if (!targetEntry) {
                      throw new Error('未找到对应的卡池条目。');
                  }

                  const itemBlocks = targetEntry.content.split(/\n*\s*名称:/).filter(block => block.trim() !== '');
                  const newBlocks = itemBlocks.filter(block => !('名称:' + block).trim().startsWith(`名称: ${itemName}`));
                  
                  if (newBlocks.length === itemBlocks.length) {
                      throw new Error('在卡池内容中未找到要删除的项目。');
                  }

                  const newContent = newBlocks.map(b => '名称: ' + b.trim()).join('\n\n');
                  
                  await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: newContent }]);
                  
                  this.showTemporaryMessage('删除成功！', 'success');
                  this._loadPoolEditorList(poolType);
                  this.loadCharacterPoolFromLorebook();

              } catch (e) {
                  console.error('删除卡池项目失败:', e);
                  this.showTemporaryMessage(`删除失败: ${e.message}`, 'error');
              }
          },
          _addNewItemToEditor(poolType) {
              const listContainer = document.getElementById('pool-editor-list-container');
              if (!listContainer) return;

              if (document.getElementById('new-item-editor')) {
                  this.showTemporaryMessage('请先保存或取消当前正在创建的项目。', 'warning');
                  return;
              }

              const newItemElement = this._createEditorItemElement(null, poolType);
              newItemElement.id = 'new-item-editor';
              listContainer.prepend(newItemElement);
              newItemElement.querySelector('details').open = true; 
          },
          
          _createEditorItemElement(item, poolType) {
              const isNew = !item;
              const originalName = isNew ? '' : item.名称;
              const element = document.createElement('div');
              element.className = 'pool-editor-item';

              const rarityColor = `var(--tier-${(isNew ? 'R' : item.稀有度).toLowerCase()}, '#CD7F32')`;

              element.innerHTML = `
                  <details class="pool-editor-card" ${isNew ? 'open' : ''}>
                      <summary class="card-summary-header">
                          <div class="summary-info">
                            <span class="item-name-display">${isNew ? '【新项目】' : _.escape(item.名称)}</span>
                            <p class="item-description-display-summary">${isNew ? '点击此处折叠' : _.escape(item.描述)}</p>
                          </div>
                          <span class="item-rarity-display" style="color: ${rarityColor};">${isNew ? 'R' : _.escape(item.稀有度)}</span>
                      </summary>
                      <div class="card-editor-form">
                          <form class="pool-editor-form-inline">
                              <input type="hidden" name="originalName" value="${_.escape(originalName)}">
                              <input type="hidden" name="poolType" value="${poolType}">
                              <label><span>名称:</span> <input type="text" name="名称" class="stylish-input" value="${isNew ? '' : _.escape(item.名称)}" required></label>
                              <label><span>稀有度:</span>
                                  <div class="stylish-select-wrapper">
                                      <select name="稀有度" class="stylish-select" required>
                                          <option value="SSR" ${!isNew && item.稀有度 === 'SSR' ? 'selected' : ''}>SSR</option>
                                          <option value="SR" ${!isNew && item.稀有度 === 'SR' ? 'selected' : ''}>SR</option>
                                          <option value="R" ${!isNew && item.稀有度 === 'R' ? 'selected' : ''}>R</option>
                                      </select>
                                      <i class="arrow down"></i>
                                  </div>
                              </label>
                              <label><span>类型:</span> <input type="text" name="类型" class="stylish-input" value="${isNew ? '' : _.escape(item.类型)}" required></label>
                              <label><span>描述:</span> <textarea name="描述" class="stylish-input" rows="2" required>${isNew ? '' : _.escape(item.描述)}</textarea></label>
                              <label><span>详细信息 (世界书内容):</span> <textarea name="worldbookContent" class="stylish-input" rows="4">${isNew ? '' : _.escape(item.worldbookContent || '')}</textarea></label>
                              <div class="pool-editor-item-actions">
                                  ${!isNew ? `<button type="button" class="stylish-btn danger-btn btn-delete-item" data-name="${_.escape(item.名称)}">删除</button>` : ''}
                                  <button type="submit" class="stylish-btn primary-btn btn-save-item">保存</button>
                              </div>
                          </form>
                      </div>
                  </details>
              `;

              const details = element.querySelector('details');
              const form = element.querySelector('form');

              details.addEventListener('toggle', (event) => {
                  if (isNew && !details.open) {
                      element.remove();
                  }
              });

              form.addEventListener('submit', async (e) => {
                  e.preventDefault();
                  const formData = new FormData(form);
                  const saveData = Object.fromEntries(formData.entries());
                  const success = await this._savePoolItem(saveData);
                  if (success && !isNew) {
                      // 更新成功后，同步UI和表单内的原始名称
                      const summaryView = element.querySelector('.card-summary-header');
                      summaryView.querySelector('.item-name-display').textContent = saveData.名称;
                      summaryView.querySelector('.item-description-display-summary').textContent = saveData.描述;
                      summaryView.querySelector('.item-rarity-display').textContent = saveData.稀有度;
                      
                      const newRarityColor = `var(--tier-${saveData.稀有度.toLowerCase()}, '#CD7F32')`;
                      summaryView.querySelector('.item-rarity-display').style.color = newRarityColor;

                      // 核心修复：更新隐藏的originalName字段，以便下次编辑
                      form.querySelector('input[name="originalName"]').value = saveData.名称;
                      
                      details.open = false;
                  } else if (success && isNew) {
                      // 如果是新建项目且成功，列表会被刷新，这里不需要额外操作
                  }
              });

              const deleteBtn = element.querySelector('.btn-delete-item');
              if (deleteBtn) {
                  deleteBtn.addEventListener('click', (e) => {
                      e.preventDefault();
                      const itemName = deleteBtn.dataset.name;
                      if (confirm(`您确定要从 [${poolType}] 池中删除“${itemName}”吗？此操作不可撤销。`)) {
                          this._deletePoolItem(itemName, poolType);
                      }
                  });
              }
              return element;
          },

          // 保存卡池项目到世界书
          async _savePoolItem(saveData) {
              this.showTemporaryMessage('正在保存到世界书...', 'info');
              const poolCommentMapping = {
                  character: '[角色池]',
                  item: '[道具池]',
                  talent: '[天赋池]'
              };
              const targetComment = poolCommentMapping[saveData.poolType];
              if (!targetComment) {
                  this.showTemporaryMessage('错误：无效的卡池类型！', 'error');
                  return false;
              }

              try {
                  const bookName = '【归墟扩展】衍梦尘卡池';
                  const allEntries = await TavernHelper.getLorebookEntries(bookName);
                  let targetEntry = allEntries.find(e => e.comment === targetComment && e.enabled === false);
                  
                  if (targetEntry && saveData.名称 !== saveData.originalName) {
                      const existingNames = (targetEntry.content.match(/名称:\s*(.*)/g) || []).map(line => line.substring(line.indexOf(':') + 1).trim());
                      if (existingNames.includes(saveData.名称)) {
                          const overwrite = await this.showCustomConfirm(`已存在名为“${saveData.名称}”的项目。您想要覆盖它吗？`);
                          if (!overwrite) {
                              this.showTemporaryMessage('操作已取消', 'info');
                              return false;
                          }
                      }
                  }
                  let newContent = '';
                  const newItemBlock = `名称: ${saveData.名称}\n稀有度: ${saveData.稀有度}\n类型: ${saveData.类型}\n描述: ${saveData.描述}\n<详细信息>\n${saveData.worldbookContent}\n</详细信息>`;

                  if (targetEntry) {
                      const itemBlocks = targetEntry.content.split(/\n*\s*名称:/).filter(block => block.trim() !== '');
                      let itemFound = false;
                      const filteredBlocks = itemBlocks.filter(block => {
                          const currentName = ('名称:' + block).trim().match(/名称:\s*(.*?)\n/)[1];
                          return currentName !== saveData.名称 && currentName !== saveData.originalName;
                      });

                      const finalBlocks = filteredBlocks.map(b => '名称: ' + b.trim());
                      finalBlocks.push(newItemBlock);
                      newContent = finalBlocks.join('\n\n');
                      
                      await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: newContent }]);
                  } else {
                      newContent = newItemBlock;
                      await TavernHelper.createLorebookEntries(bookName, [{ comment: targetComment, content: newContent, enabled: false }]);
                  }
                  
                  this.showTemporaryMessage('保存成功！', 'success');
                  this._loadPoolEditorList(saveData.poolType);
                  this.loadCharacterPoolFromLorebook();
                  return true;

              } catch (e) {
                  console.error('保存卡池项目失败:', e);
                  this.showTemporaryMessage(`保存失败: ${e.message}`, 'error');
                  return false;
              }
          },

          _renderSettingsRedeem(container) {
              container.innerHTML = `
                  <div class="redeem-container">
                      <h3 class="settings-section-title" style="text-align:center;">天道馈赠</h3>
                      <p style="color: #a09c91; font-size: 13px; max-width: 400px; margin: 15px auto;">在此输入神秘的真言以换取天道的馈赠。</p>
                      <div style="display: flex; gap: 10px; align-items: center; justify-content: center;">
                          <input type="text" id="redeem-code-input-settings" placeholder="输入兑换码" class="quick-send-input" style="width: 300px; height: 40px; text-align: center; font-size: 14px;">
                          <button id="btn-redeem-code-settings" class="interaction-btn primary-btn" style="padding: 10px 20px;">兑换</button>
                      </div>

                      
                      <div style="margin-top: 40px; padding-top: 20px; border-top: 1px dashed rgba(201, 170, 113, 0.3);">
                          <label style="display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; color: #ff6b6b;">
                              <input type="checkbox" id="gacha-cheat-mode-toggle" ${this.isGachaCheatMode ? 'checked' : ''}>
                              <strong>开启内测作弊模式 (无限梦尘)</strong>
                          </label>
                      </div>
                  </div>
              `;
              
              const redeemBtn = document.getElementById('btn-redeem-code-settings');
              const redeemInput = document.getElementById('redeem-code-input-settings');
              const cheatToggle = document.getElementById('gacha-cheat-mode-toggle'); 

              redeemBtn.addEventListener('click', () => {
                  this.handleRedeemCode(redeemInput.value, () => {
                      redeemInput.value = ''; 
                      // 成功兑换后，刷新整个召唤界面的UI以显示最新的归墟点
                      this.renderSummonTab(this.currentGachaPoolType);
                  });
              });
              redeemInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') redeemBtn.click(); });
              if (cheatToggle) {
                  cheatToggle.addEventListener('change', (e) => {
                      this.isGachaCheatMode = e.target.checked;
                      this.saveGachaCheatState(); 
                      this.showTemporaryMessage(`作弊模式已${this.isGachaCheatMode ? '开启' : '关闭'}`);
                  });
              }
          },
         // 主函数 (第三步)
          renderSummonTab(activePool = 'character') {
              if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                  console.error('[衍梦尘] 无法渲染召唤界面：主游戏状态 (MVU) 未加载。');
                  const container = document.getElementById('gacha-main-container');
                  if (container) {
                      container.innerHTML = '<p style="text-align:center; color:#8b7355; padding: 50px;">无法加载角色数据，请先开始游戏或发送一条消息以初始化状态。</p>';
                  }
                  const switcher = document.getElementById('gacha-pool-switcher-header');
                  const currency = document.getElementById('gacha-currency-header');
                  if(switcher) switcher.style.display = 'none';
                  if(currency) currency.style.display = 'none';
              }
              const switcher = document.getElementById('gacha-pool-switcher-header');
              const currency = document.getElementById('gacha-currency-header');
              if(switcher) switcher.style.display = 'flex';
              if(currency) currency.style.display = 'block';

              const mainContainer = document.getElementById('gacha-main-container');
              const switcherContainer = document.getElementById('gacha-pool-switcher-header');
              const currencyContainer = document.getElementById('gacha-currency-header');
              if (!mainContainer || !switcherContainer || !currencyContainer) return;

              const poolInfo = {
                  character: { title: '镜花水月', bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
                  item: { title: '万象奇珍', bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
                  talent: { title: '天命灵根', bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
              };

              let switcherHtml = '';
              for (const [poolType, data] of Object.entries(poolInfo)) {
                  switcherHtml += `<button class="pool-switch-btn" data-pool="${poolType}" data-title="${data.title}" style="background-image: url('${data.bg}');"></button>`;
              }
              switcherContainer.innerHTML = switcherHtml;

              const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, '归墟点', 0);
              currencyContainer.innerHTML = `归墟点: <strong>${guixuPoints}</strong>`;

              mainContainer.innerHTML = `
                  <div id="gacha-pool-display" style="flex-grow: 1; display: flex;"></div>
                  <button id="btn-gacha-settings-new" class="gacha-corner-btn" title="设置">⚙️</button>
                  <button id="btn-gacha-gallery-new" class="gacha-corner-btn" title="图鉴">🖼️</button>
              `;

              switcherContainer.querySelectorAll('.pool-switch-btn').forEach(btn => {
                  btn.addEventListener('click', () => {
                      this._renderGachaPool(btn.dataset.pool);
                  });
              });

              document.getElementById('btn-gacha-settings-new').addEventListener('click', () => this.showGachaSettingsPopup());
              document.getElementById('btn-gacha-gallery-new').addEventListener('click', () => this.showGachaGalleryPopup(this.currentGachaPoolType));
              
              this._renderGachaPool(activePool);
          },
          _renderTextBasedGrid(poolType) {
              const allItems = [...(this.gachaPools[poolType]?.ssr || []), ...(this.gachaPools[poolType]?.sr || []), ...(this.gachaPools[poolType]?.r || [])];
              if(allItems.length === 0) return '<p style="color: #a09c91; text-align: center; margin-top: 20px;">此图鉴暂无内容</p>';
              
              allItems.sort((a,b) => (b.稀有度 === 'SSR' ? 3 : b.稀有度 === 'SR' ? 2 : 1) - (a.稀有度 === 'SSR' ? 3 : a.稀有度 === 'SR' ? 2 : 1));
              
              let gridHtml = '';
              allItems.forEach(item => {
                  const isUnlocked = this.gachaCollection[item.id];
                  const rarity = item.稀有度 || 'R';
                  const name = item.名称 || '未知';
                  const desc = item.描述 || '暂无描述';
                  const type = item.类型 || '';

                  if (isUnlocked) {
                      gridHtml += `
                          <div class="gallery-text-item" data-item-id="${item.id}" data-pool-type="${poolType}">
                              <div class="gallery-text-item-header">
                                  <span class="gallery-text-item-name rarity-${rarity}">${name} ${type ? `(${type})` : ''}</span>
                                  <span class="gallery-text-item-rarity rarity-${rarity}">${rarity}</span>
                              </div>
                              <p class="gallery-text-item-desc">${desc}</p>
                          </div>
                      `;
                  } else {
                      gridHtml += `
                          <div class="gallery-text-item gallery-text-item-locked">
                              <div class="gallery-text-item-header">
                                  <span class="gallery-text-item-name">？？？</span>
                                  <span class="gallery-text-item-rarity rarity-${rarity}">${rarity}</span>
                              </div>
                              <p class="gallery-text-item-desc">尚未获得</p>
                          </div>
                      `;
                  }
              });
              return `<div class="gallery-text-grid">${gridHtml}</div>`;
          },

          renderGalleryTab() {
              const container = document.getElementById('gacha-tab-gallery');
              if(!container) return;
              const renderGrid = (poolType) => {
                  const allItems = [...(this.gachaPools[poolType]?.ssr || []), ...(this.gachaPools[poolType]?.sr || []), ...(this.gachaPools[poolType]?.r || [])];
                  if(allItems.length === 0) return '<p style="color: #a09c91; text-align: center; margin-top: 20px;">此图鉴暂无内容</p>';
                  allItems.sort((a,b) => (a.稀有度 === 'SSR' ? 3 : a.稀有度 === 'SR' ? 2 : 1) - (b.稀有度 === 'SSR' ? 3 : b.稀有度 === 'SR' ? 2 : 1));
                  let gridHtml = '';
                  allItems.forEach(item => {
                      const isUnlocked = this.gachaCollection[item.id];
                      const cardClass = `gallery-card rarity-${item.稀有度} ${isUnlocked ? 'unlocked' : 'gallery-card-locked'}`;
                      const bgImageStyle = isUnlocked && item.图片 ? `background-image: url('${item.图片}');` : '';
                      gridHtml += `<div class="${cardClass}" title="${item.名称}" data-item-id="${item.id}" data-pool-type="${poolType}" style="${bgImageStyle}">${isUnlocked ? `<div class="gallery-card-name">${item.名称}</div>` : ''}</div>`;
                  });
                  return `<div class="gallery-grid">${gridHtml}</div>`;
              }
              container.innerHTML = `
                  <details class="gallery-section" open><summary class="section-title">角色图鉴</summary>${renderGrid('character')}</details>
                  <details class="gallery-section" open><summary class=\"section-title\">道具图鉴</summary>${this._renderTextBasedGrid('item')}</details>
                  <details class=\"gallery-section\" open><summary class=\"section-title\">天赋图鉴</summary>${this._renderTextBasedGrid('talent')}</details>
              `;
             
              container.querySelectorAll('.gallery-grid, .gallery-text-grid').forEach(grid => {
                  grid.addEventListener('click', e => {
                      const card = e.target.closest('.gallery-card.unlocked, .gallery-text-item:not(.gallery-text-item-locked)');
                      if (!card) return;
                      const itemId = card.dataset.itemId;
                      const poolType = card.dataset.poolType;
                      const allItems = [...this.gachaPools[poolType].ssr, ...this.gachaPools[poolType].sr, ...this.gachaPools[poolType].r];
                      const itemData = allItems.find(i => i.id === itemId);
                      if (itemData) this.showGachaItemDetails(itemData, poolType);
                  });
              });
          },

          renderShopTab() {
              const container = document.getElementById('gacha-tab-shop');
              if (!container) return;
              container.innerHTML = `
                  <div class="shop-container" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; gap: 25px; padding: 20px; text-align: center;">
                      <h3 class="pool-title">天道馈赠</h3>
                      <p style="color: #a09c91; font-size: 13px; max-width: 400px;">在此输入神秘的真言以换取天道的馈赠。某些真言或许低语着大能的名讳，蕴含着莫大的机缘。</p>
                      <div style="display: flex; gap: 10px; align-items: center;">
                          <input type="text" id="redeem-code-input" placeholder="输入兑换码" class="quick-send-input" style="width: 300px; height: 40px; text-align: center; font-size: 14px;">
                          <button id="btn-redeem-code" class="interaction-btn primary-btn" style="padding: 10px 20px;">兑换</button>
                      </div>
                      
                  <div class="gacha-currency">当前梦尘: <strong>${this.gachaState.mengChen}</strong></div>
                  <div style="margin-top: 20px; padding-top: 20px; border-top: 1px dashed rgba(201, 170, 113, 0.3);">
                      <label style="display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; color: #ff6b6b;">
                          <input type="checkbox" id="gacha-cheat-mode-toggle" ${this.isGachaCheatMode ? 'checked' : ''}>
                          <strong>开启内测作弊模式 (无限梦尘)</strong>
                      </label>
                  </div>
              </div>
              `;
              document.getElementById('btn-redeem-code').addEventListener('click', () => this.handleRedeemCode());
              document.getElementById('redeem-code-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') { document.getElementById('btn-redeem-code').click(); } });
 
              document.getElementById('gacha-cheat-mode-toggle').addEventListener('change', (e) => {
                  this.isGachaCheatMode = e.target.checked;
                  this.saveGachaCheatState();
                  this.showTemporaryMessage(`作弊模式已${this.isGachaCheatMode ? '开启' : '关闭'}`);
              });
         },

          async handlePull(count, poolType) {
              if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                  this.showTemporaryMessage('错误：角色数据未加载，无法进行召唤。');
                  return;
              }

              const costs = { character: 320, item: 160, talent: 160 };
              const cost = count * costs[poolType];
              const initialPoints = parseInt(Mvu.getMvuVariable(this.currentMvuState, '归墟点', { default_value: 0 }), 10);

              if (!this.isGachaCheatMode && initialPoints < cost) {
                  this.showTemporaryMessage('归墟点不足！');
                  return;
              }

              // --- 抽卡逻辑 ---
              const results = [];
              let gotSR_or_above = false;
              for (let i = 0; i < count; i++) {
                  const result = this.getGachaRoll(poolType);
                  results.push(result);
                  if (result.rarity === 'SR' || result.rarity === 'SSR') gotSR_or_above = true;
              }
              if (count === 10 && !gotSR_or_above) {
                  results[Math.floor(Math.random() * 10)] = this.getRandomItemFromPool(poolType, ['sr']);
              }
              // --- 抽卡逻辑结束 ---

              // --- 归墟点计算与同步 ---
              let totalReward = 0;
              if (!this.isGachaCheatMode) {
                  results.forEach(res => {
                      const isDuplicate = !!this.gachaCollection[res.id];
                      if (isDuplicate) {
                          totalReward += res.稀有度 === 'SSR' ? 80 : res.稀有度 === 'SR' ? 20 : 5;
                      }
                  });

                  const netChange = totalReward - cost;
                  const mvuData = this.currentMvuState;
                  const path = '归墟点';
                  const currentPoints = parseInt(Mvu.getMvuVariable(mvuData, path, { default_value: 0 }), 10);
                  
                  await Mvu.setMvuVariable(mvuData, path, currentPoints + netChange, { reason: `衍梦尘召唤, 消耗${cost}, 补偿${totalReward}` });
                  await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                  this.showTemporaryMessage(`召唤完成！消耗${cost}, 补偿${totalReward}归墟点。`);
              }
              // --- 归墟点计算与同步结束 ---
              
              this.processPullResults(results, poolType); // 现在只负责处理物品和UI
              this.saveGachaState();
              this.renderSummonTab(poolType); // 刷新UI以显示最新的归墟点
          },

          getGachaRoll(poolType) {
              const pitySRKey = `pitySR_${poolType}`;
              const pitySSRKey = `pitySSR_${poolType}`;
              this.gachaState[pitySRKey]++;
              this.gachaState[pitySSRKey]++;
              if (this.gachaState[pitySSRKey] >= 90) return this.getSSRItem(poolType);
              if (this.gachaState[pitySRKey] >= 10) return this.getSRItem(poolType);
              const rand = Math.random();
              let softPityRate = this.gachaState[pitySSRKey] >= 74 ? (this.gachaState[pitySSRKey] - 73) * 0.06 : 0;
              if (rand < 0.006 + softPityRate) return this.getSSRItem(poolType);
              if (rand < 0.006 + softPityRate + 0.051) return this.getSRItem(poolType);
              return this.getRandomItemFromPool(poolType, ['r']);
          },

          getSSRItem(poolType) {
              this.gachaState[`pitySSR_${poolType}`] = 0;
              this.gachaState[`pitySR_${poolType}`] = 0;
              return this.getRandomItemFromPool(poolType, ['ssr']);
          },

          getSRItem(poolType) {
              this.gachaState[`pitySR_${poolType}`] = 0;
              return this.getRandomItemFromPool(poolType, ['sr']);
          },

          getRandomItemFromPool(poolType, rarities) {
              const pool = rarities.flatMap(r => this.gachaPools[poolType][r.toLowerCase()] || []);
              if (pool.length === 0) {
                  console.error(`[衍梦尘] 警告: 卡池 (${poolType} - ${rarities.join(', ')}) 为空。`);
                  return { id: 'fallback', 名称: '虚无之影', 稀有度: 'R', 类型: '错误' }; 
              }
              return pool[Math.floor(Math.random() * pool.length)];
          },

          processPullResults(results, poolType) {
              this.openModal('gacha-results-modal', true);
              const gridContainer = document.getElementById('gacha-results-grid');
              if (!gridContainer) return;
              gridContainer.innerHTML = '';
              gridContainer.className = results.length === 1 ? 'gacha-results-grid single-pull' : 'gacha-results-grid';
              results.forEach((res) => {
                  const isDuplicate = !!this.gachaCollection[res.id];
                  if (!isDuplicate) {
                      this.gachaCollection[res.id] = { acquired: new Date().toISOString() };
                  }
                  
                  // 归墟点逻辑已移至 handlePull, 这里只处理非重复物品的指令添加
                  if (!isDuplicate) {
                      // 将非重复获得的物品信息，构造成一个格式化的<user>消息，并添加到指令中心
                      const loreContent = Object.entries(res)
                          .filter(([key, value]) => !['id', '$meta'].includes(key) && value)
                          .map(([key, value]) => `${key}: ${value}`)
                          .join('\n');
                      const command = `<user>通过衍梦尘获得了新的[${res.类型 || '物品'}]：${res.名称}\n${loreContent}`;
                      this.addCommand(command);
                      this.showTemporaryMessage(`[${res.名称}] (新)，获得指令已入队`);
                  }

                  const card = document.createElement('div');
                  
                  if (poolType === 'character') {
                      card.className = `gacha-results-card rarity-${res.稀有度.toUpperCase()}`;
                      if (res.图片) card.style.backgroundImage = `url('${res.图片}')`;
                      
                      const infoContainer = document.createElement('div');
                      infoContainer.className = 'gacha-results-card-info';
                      infoContainer.innerHTML = `<div class="item-name">${res.名称}</div><div class="item-rarity">${res.稀有度}</div>`;
                      if (isDuplicate) {
                          infoContainer.innerHTML += `<div class="gacha-results-duplicate-tag">重复</div>`;
                      }
                      card.appendChild(infoContainer);

                      if (!isDuplicate) {
                          const newTag = document.createElement('div');
                          newTag.className = 'gacha-results-new-tag';
                          newTag.textContent = 'NEW';
                          card.appendChild(newTag);
                      }
                  } else {
                      card.className = `gacha-results-card-text rarity-${res.稀有度.toUpperCase()}`;
                      let cardContentHtml = `<div class="item-name">${res.名称}</div>`;
                      cardContentHtml += `<div class="item-rarity">${res.稀有度}</div>`;
                      if (res.类型) {
                          cardContentHtml += `<div class="item-type">${res.类型}</div>`;
                      }
                      if (isDuplicate) {
                          cardContentHtml += `<div class="gacha-results-duplicate-tag" style="margin-top: 10px;">重复</div>`;
                      }
                      card.innerHTML = cardContentHtml;

                      if (!isDuplicate) {
                          const newTag = document.createElement('div');
                          newTag.className = 'gacha-results-new-tag';
                          newTag.textContent = 'NEW';
                          card.appendChild(newTag);
                      }
                  }
                  gridContainer.appendChild(card);
              });
              this.gachaHistory.unshift({ timestamp: new Date().toISOString(), results: results, poolType: poolType });
              if (this.gachaHistory.length > 200) this.gachaHistory.pop();
              this.saveGachaState();
          },

          showGachaHistory(page = 1) {
              this.openModal('gacha-history-modal', true);
              const listContainer = document.getElementById('gacha-history-list');
              const indicatorEl = document.getElementById('gacha-history-page-indicator');
              const prevBtn = document.getElementById('gacha-history-prev-btn');
              const nextBtn = document.getElementById('gacha-history-next-btn');

              if (!listContainer || !indicatorEl || !prevBtn || !nextBtn) {
                  console.error('衍梦尘历史记录界面UI元素缺失!');
                  return;
              }

              const itemsPerPage = 5;
              const totalPages = Math.ceil(this.gachaHistory.length / itemsPerPage);
              const currentPage = Math.max(1, Math.min(page, totalPages || 1));
              const pageItems = this.gachaHistory.slice((currentPage - 1) * itemsPerPage, currentPage * itemsPerPage);
              let html = pageItems.length > 0 ? '' : '<p style=\"color:#a09c91; text-align:center; padding: 40px 0;\">暂无召唤记录</p>';
              pageItems.forEach(entry => {
                  // 安全检查 (1): 如果记录条目或其结果数组不存在，则跳过此条记录，避免程序崩溃
                  if (!entry || !entry.results) { 
                      console.warn('发现并跳过一条损坏的召唤历史记录:', entry);
                      return; 
                  }
                  const poolType = entry.poolType || 'character';
                  const poolNames = { character: '镜花水月', item: '万象奇珍', talent: '天命灵根' };
                  const poolName = poolNames[poolType] || '未知卡池';

                  const resultsHtml = entry.results.map(res => {
                      // 安全检查 (2): 如果结果数组中的某个物品不存在，也跳过它
                      if (!res) return '';
                      const rarity = res.稀有度 || 'R';
                      const name = res.名称 || '未知物品';
                      return `<div class=\"gacha-history-item-card rarity-${rarity.toUpperCase()}\" title=\"${name}\">${name}</div>`;
                  }).join('');
                  html += `
                      <div class=\"gacha-history-entry\">
                          <div class=\"gacha-history-header\">
                              <span class=\"gacha-history-timestamp\">${new Date(entry.timestamp).toLocaleString('zh-CN')}</span>
                              <span class=\"gacha-history-pool\">${poolName}</span>
                          </div>
                          <div class=\"gacha-history-results-grid\">
                              ${resultsHtml}
                          </div>
                      </div>
                  `;
              });

              listContainer.className = 'gacha-history-list';
              listContainer.innerHTML = html;

              indicatorEl.textContent = `第 ${currentPage} / ${totalPages || 1} 页`;

              const newPrevBtn = prevBtn.cloneNode(true);
              prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
              const newNextBtn = nextBtn.cloneNode(true);
              nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
              
              newPrevBtn.disabled = currentPage <= 1;
              newNextBtn.disabled = currentPage >= totalPages;

              if (!newPrevBtn.disabled) newPrevBtn.onclick = () => this.showGachaHistory(currentPage - 1);
              if (!newNextBtn.disabled) newNextBtn.onclick = () => this.showGachaHistory(currentPage + 1);
          },          
          showGachaItemDetails(itemData, poolType) {
              const titleEl = document.getElementById('gacha-details-title');
              const bodyEl = document.getElementById('gacha-details-body');
              const footerEl = document.getElementById('gacha-details-footer');
              if (!titleEl || !bodyEl || !footerEl) return;

              titleEl.textContent = itemData.名称;
              let imageHtml = poolType === 'character' ? `<div class="gacha-details-image-large" style="background-image: url('${itemData.图片 || ''}');"></div>` : '';
              let infoHtml = `<div class="gacha-details-info">
                  <p><strong>稀有度:</strong> ${itemData.稀有度 || '未知'}</p>
                  <p><strong>类型:</strong> ${itemData.类型 || itemData.系列 || '未知'}</p>
                  <p><strong>描述:</strong> ${itemData.描述 || '暂无详细描述'}</p>
              </div>`;
              bodyEl.innerHTML = imageHtml + infoHtml;

              const companions = this.gachaState.activeCompanions || [];
              const isAlreadyActive = companions.some(c => c.id === itemData.id);
              const isAlreadyQueued = this.pendingActions.some(command => command.includes(`[角色加入] ${itemData.名称}`));

              let joinButtonHtml = '';
              if (isAlreadyActive) {
                  joinButtonHtml = `<button class="interaction-btn primary-btn" disabled>已在世界中</button>`;
              } else if (isAlreadyQueued) {
                  joinButtonHtml = `<button class="interaction-btn primary-btn" disabled>已在指令队列</button>`;
              } else {
                  let isDisabled = false;
                  let disabledReason = '';
                  if (poolType === 'character') {
                      const totalLimitReached = companions.length >= 3;
                      const ssrLimitReached = companions.filter(c => c.rarity === 'SSR').length >= 1;
                      const isCharSSR = itemData.稀有度 === 'SSR';

                      if (totalLimitReached) { isDisabled = true; disabledReason = `伙伴已满 (${companions.length}/3)`; }
                      else if (isCharSSR && ssrLimitReached) { isDisabled = true; disabledReason = `SSR伙伴已满 (1/1)`; }
                  }
                  
                  if (isDisabled) {
                      joinButtonHtml = `<button class="interaction-btn primary-btn" disabled>${disabledReason}</button>`;
                  } else {
                      joinButtonHtml = `<button id="btn-gacha-join-world" class="interaction-btn primary-btn">加入当前世界</button>`;
                  }
              }

              footerEl.innerHTML = `
                  <button onclick="GuixuManager.closeModal('gacha-details-modal')" class="interaction-btn">关闭</button>
                  ${joinButtonHtml}
              `;

              const joinButton = document.getElementById('btn-gacha-join-world');
              if (joinButton) {
                  joinButton.onclick = () => this.handleJoinWorld(itemData, poolType);
              }

              this.openModal('gacha-details-modal', true);
          },

          _parseLorebookCharacter(contentBlock, poolType) {
              const item = {};
              const lines = contentBlock.split('\n');
              lines.forEach(line => {
                  const parts = line.split(':');
                  if (parts.length < 2) return;
                  const key = parts[0].trim();
                  const value = parts.slice(1).join(':').trim();
                  switch (key) {
                      case '名称': item.名称 = value; break;
                      case '系列': item.系列 = value; break;
                      case '图片': item.图片 = value; break;
                      case '稀有度': item.稀有度 = value.toUpperCase(); break;
                      case '类型': item.类型 = value; break;
                      case '描述': item.描述 = value; break;
                  }
              });
              if (item.名称 && item.稀有度) return item;
              return null;
          },

          async loadCharacterPoolFromLorebook() {
              const bookName = '【归墟扩展】衍梦尘卡池';
              const newPools = { character: { ssr: [], sr: [], r: [] }, item: { ssr: [], sr: [], r: [] }, talent: { ssr: [], sr: [], r: [] } };
              try {
                  const entries = await TavernHelper.getLorebookEntries(bookName);
                  if (!entries || entries.length === 0) { this.showTemporaryMessage(`警告：未找到或“${bookName}”世界书为空。`, 3000); return; }
                  let count = 0;
                  const poolMapping = { '[角色池]': 'character', '[道具池]': 'item', '[天赋池]': 'talent' };
                  for (const entry of entries) {
                      const poolType = poolMapping[entry.comment];
                      if (poolType && entry.enabled === false) {
                          const itemBlocks = entry.content.split(/\n*\s*名称:/).filter(block => block.trim() !== '');
                          for (const block of itemBlocks) {
                              const fullBlock = '名称:' + block;
                              const item = this._parseGachaPoolEntry(fullBlock);
                              if (item) {
                                  item.id = `${poolType}_${item.名称}`.replace(/\s/g, '_');
                                  const rarityKey = item.稀有度.toLowerCase();
                                  if (newPools[poolType][rarityKey]) {
                                      newPools[poolType][rarityKey].push(item);
                                      count++;
                                  }
                              }
                          }
                      }
                  }
                  this.gachaPools = newPools;
                  console.log(`[衍梦尘] 成功从世界书加载 ${count} 个项目。`);
                  if (count === 0) this.showTemporaryMessage('未在禁用的条目中找到任何格式正确的卡池项目。', 4000);
              } catch (e) {
                  console.error('加载衍梦尘卡池失败:', e);
                  this.showTemporaryMessage('错误：加载卡池失败，请检查世界书。', 3000);
              }
          },

          _parseGachaPoolEntry(blockText) {
              const item = {};
              const lines = blockText.trim().split('\n');
              let worldbookContent = '';
              let isDetailSection = false;

              for (const line of lines) {
                  if (line.trim() === '<详细信息>') {
                      isDetailSection = true;
                      continue;
                  }
                  if (line.trim() === '</详细信息>') {
                      isDetailSection = false;
                      continue;
                  }

                  if (isDetailSection) {
                      worldbookContent += line + '\n';
                  } else {
                      const match = line.match(/^([^:]+):\s*(.*)$/);
                      if (match) {
                          const key = match[1].trim();
                          const value = match[2].trim();
                          item[key] = value;
                      }
                  }
              }

              item.worldbookContent = worldbookContent.trim();

              if (item.名称 && item.稀有度 && item.类型 && item.描述) {
                  return item;
              }
              return null;
          },

          async handleRedeemCode(code, onSuccessCallback) {
              if (!code || !code.trim()) {
                  this.showTemporaryMessage('请输入兑换码。');
                  return;
              }
              const upperCaseCode = code.trim().toUpperCase();
              
              const manualCodeDB = {
                  'GUIXU666': { reward: 1600, type: 'mengChen' },
                  'MENGXING888': { reward: 3200, type: 'mengChen' }
              };
              const manualEntry = manualCodeDB[upperCaseCode];
              
              if (manualEntry) {
                  if (this.gachaState.redeemedCodes.includes(upperCaseCode)) {
                      this.showTemporaryMessage('您已经兑换过这个礼包了。');
                      if (onSuccessCallback) onSuccessCallback();
                      return;
                  }
                  // 1. 获取状态
                  const mvuData = this.currentMvuState;
                  if (!mvuData) {
                      this.showTemporaryMessage('发生内部错误，兑换失败', 'error');
                      return;
                  }
                  
                  // 2. 原子化修改
                  const path = '归墟点';
                  const currentPoints = parseInt(Mvu.getMvuVariable(mvuData, path, { default_value: 0 }), 10);
                  await Mvu.setMvuVariable(mvuData, path, currentPoints + manualEntry.reward, { reason: `兑换码 ${upperCaseCode}` });

                  // 3. 同步回后端
                  await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });
                  // --- MVU API 重构结束 ---

                  this.gachaState.redeemedCodes.push(upperCaseCode);
                  this.saveGachaState(); // 只保存兑换码使用记录
                  this.showTemporaryMessage(`兑换成功！获得 ${manualEntry.reward} 归墟点！`, 3000);
                  
                  // 4. 刷新UI
                  this.renderSummonTab(this.currentGachaPoolType);
                  if (onSuccessCallback) onSuccessCallback();
                  return;
              }
               this.showTemporaryMessage('无效的兑换码。');
          },
     

          saveGachaCheatState() {
              AppStorage.saveData('gacha_cheat_mode', this.isGachaCheatMode);
          },

          loadGachaCheatState() {
              this.isGachaCheatMode = AppStorage.loadData('gacha_cheat_mode', false);
          },

          _loadGachaDataFromSave(saveData) {
              if (saveData && saveData.gacha_data) {
                  this.gachaState = saveData.gacha_data.state;
                  this.gachaCollection = saveData.gacha_data.collection;
                  this.gachaHistory = saveData.gacha_data.history;
                  console.log('[衍梦尘] 已成功从存档文件加载Gacha数据。');
              } else {
                  // 如果是旧存档或新游戏，则重置为初始状态
                  this.gachaState = { mengChen: 1600, pitySSR_char: 0, pitySR_char: 0, pitySSR_item: 0, pitySR_item: 0, pitySSR_talent: 0, pitySR_talent: 0, redeemedCodes: [] };
                  this.gachaCollection = {};
                  this.gachaHistory = [];
                  console.log('[衍梦尘] 未在存档中找到Gacha数据，已重置为初始状态。');
              }
              // 将从存档加载的状态，立刻保存为当前的实时状态，以便刷新后能正确保留
              this.saveGachaState();
          },
          async handleJoinWorld(itemData, poolType) {
              const isAlreadyQueued = this.pendingActions.some(action => action.itemName === itemData.名称);
              if (isAlreadyQueued) {
                  this.showTemporaryMessage(`[${itemData.名称}] 已在指令队列中。`, 'info');
                  return;
              }
              const isAlreadyActive = poolType === 'character' ?
                  this.gachaState.activeCompanions.some(c => c.id === itemData.id) :
                  this.gachaState.activatedItems.includes(itemData.id);
              if (isAlreadyActive) {
                  this.showTemporaryMessage(`[${itemData.名称}] 已加入或已激活。`, 'info');
                  return;
              }
              if (!itemData.worldbookContent || itemData.worldbookContent.trim() === '') {
                  this.showTemporaryMessage(`“${itemData.名称}”没有详细信息，无法写入世界书。`, 'warning');
              } else {
                  this.showTemporaryMessage(`正在为“${itemData.名称}”写入世界书...`, 'info');
                  try {
                      const bookName = '1归墟';
                      const allEntries = await TavernHelper.getLorebookEntries(bookName);
                      const existingEntry = allEntries.find(entry => entry.comment === itemData.名称);

                      if (existingEntry) {
                          await TavernHelper.setLorebookEntries(bookName, [{
                              uid: existingEntry.uid,
                              content: itemData.worldbookContent,
                              enabled: true
                          }]);
                          this.showTemporaryMessage(`已成功覆盖“${itemData.名称}”的世界书条目！`, 'success');
                      } else {
                          await TavernHelper.createLorebookEntries(bookName, [{
                              comment: itemData.名称,
                              content: itemData.worldbookContent,
                              enabled: true
                          }]);
                          this.showTemporaryMessage(`已为“${itemData.名称}”创建新的世界书条目！`, 'success');
                      }
                  } catch (e) {
                      console.error('写入世界书条目失败:', e);
                      this.showTemporaryMessage('写入世界书条目失败', 'error');
                      return; // 写入失败则中止
                  }
              }
              if (poolType === 'character') {
                  this.gachaState.activeCompanions.push({ id: itemData.id, name: itemData.名称, rarity: itemData.稀有度 });
              } else {
                  this.gachaState.activatedItems.push(itemData.id);
              }
              this.saveGachaState();
              const type = itemData.类型 || '角色';
              const description = itemData.描述 || '无简介';
              const commandText = `[系统提示] "我"通过衍梦尘获得了名为【${itemData.名称}】的${type}。描述：${description}`;
              this.addCommand(commandText);
              if (document.getElementById('gacha-gallery-popup').style.display === 'flex') {
                  this.showGachaGalleryPopup(poolType);
              }
              this.closeModal('gacha-details-modal');
          },
       applyPanelWidths() {
           const gameContainer = document.querySelector('.game-container');
           if (gameContainer) {
               const leftWidth = this.leftPanelCollapsed ? '0px' : `${this.leftPanelWidth}%`;
               const rightWidth = this.rightPanelCollapsed ? '0px' : `${this.rightPanelWidth}%`;
               gameContainer.style.gridTemplateColumns = `${leftWidth} 1fr ${rightWidth}`;
           }
       },

       savePanelWidths() {
           try {
               localStorage.setItem('guixu_leftPanelWidth', this.leftPanelWidth);
               localStorage.setItem('guixu_rightPanelWidth', this.rightPanelWidth);
           } catch (e) {
               console.error('Failed to save panel widths to localStorage', e);
           }
       },

       loadPanelWidths() {
           try {
               const left = localStorage.getItem('guixu_leftPanelWidth');
               const right = localStorage.getItem('guixu_rightPanelWidth');
               if (left !== null) this.leftPanelWidth = parseInt(left, 10);
               if (right !== null) this.rightPanelWidth = parseInt(right, 10);
               
               this.applyPanelWidths();
           } catch (e) {
               console.error('Failed to load panel widths from localStorage', e);
           }
       },

       initPanelWidthSliders() {
           const leftSlider = document.getElementById('left-panel-width-slider');
           const leftValue = document.getElementById('left-panel-width-value');
           const rightSlider = document.getElementById('right-panel-width-slider');
           const rightValue = document.getElementById('right-panel-width-value');

           if (leftSlider && leftValue) {
               leftSlider.value = this.leftPanelWidth;
               leftValue.textContent = `${this.leftPanelWidth}%`;
               leftSlider.addEventListener('input', (e) => {
                   this.leftPanelWidth = e.target.value;
                   leftValue.textContent = `${e.target.value}%`;
                   this.applyPanelWidths();
                   this.savePanelWidths();
               });
           }

           if (rightSlider && rightValue) {
               rightSlider.value = this.rightPanelWidth;
               rightValue.textContent = `${this.rightPanelWidth}%`;
               rightSlider.addEventListener('input', (e) => {
                   this.rightPanelWidth = e.target.value;
                   rightValue.textContent = `${e.target.value}%`;
                   this.applyPanelWidths();
                   this.savePanelWidths();
               });
           }
       },
     };
// ===衍梦尘/抽卡/Gacha系统结束===



// ===避免内存泄漏与GuixuManager全局暴露===
          if (window.GuixuManager && typeof window.GuixuManager.destroy === 'function') {
          window.GuixuManager.destroy();
        }
        window.GuixuManager = GuixuManager;
          eventOn(tavern_events.APP_READY, () => {
            GuixuManager.init();
// ===避免内存泄漏与GuixuManager全局暴露===    

        
// ===过滤无关的控制台错误，避免干扰调试===
            const originalConsoleError = console.error;
            console.error = function(...args) {
              const message = args.join(' ');
              if (message.includes('ui-icons') ||
                  message.includes('MIME type') ||
                  message.includes('stylesheet MIME type') ||
                  message.includes('404 (Not Found)')) {
                return; // 静默处理这些错误
              }
              originalConsoleError.apply(console, args);
            };
          });
// ===过滤无关的控制台错误，避免干扰调试==


// ===设置界面模块开始===
          // --- 设置界面面板切换功能 ---
          function initSettingsPanelSwitcher() {
            setTimeout(() => {
              // 获取所有导航按钮和面板
              const navButtons = document.querySelectorAll('.sidebar-nav-btn');
              const panels = document.querySelectorAll('.settings-panel');                      
              if (navButtons.length === 0 || panels.length === 0) {
                return;
              }
              // 切换面板的函数
              function switchPanel(targetCategory) {            
                panels.forEach(panel => {
                  panel.classList.remove('active');
                });                
                navButtons.forEach(btn => {
                  btn.classList.remove('active');
                });
                const targetPanel = document.getElementById(targetCategory + '-panel');
                if (targetPanel) {
                  targetPanel.classList.add('active');
                } else {
                }                
                const targetButton = document.querySelector(`[data-category="${targetCategory}"]`);
                if (targetButton) {
                  targetButton.classList.add('active');
                }              
                if (targetCategory === 'interface') {
                  setTimeout(() => {
                    const widthSlider = document.getElementById('width-slider');
                    const heightSlider = document.getElementById('height-slider');
                    const resetSizeBtn = document.getElementById('reset-size-btn');
                    
                    if (widthSlider && !widthSlider.hasAttribute('data-bound')) {
                      widthSlider.addEventListener('input', (e) => {
                        if (window.GuixuManager) {
                          window.GuixuManager.updateWidthDisplay(e.target.value);
                        }
                      });
                      widthSlider.setAttribute('data-bound', 'true');
                    }
                    
                    if (heightSlider && !heightSlider.hasAttribute('data-bound')) {
                      heightSlider.addEventListener('input', (e) => {
                        if (window.GuixuManager) {
                          window.GuixuManager.updateHeightDisplay(e.target.value);
                        }
                      });
                      heightSlider.setAttribute('data-bound', 'true');
                    }
                    
                    if (resetSizeBtn && !resetSizeBtn.hasAttribute('data-bound')) {
                      resetSizeBtn.addEventListener('click', () => {
                        if (window.GuixuManager) {
                          window.GuixuManager.resetWindowSize();
                        }
                      });
                      resetSizeBtn.setAttribute('data-bound', 'true');
                    }                    
                    const modalWidthSlider = document.getElementById('modal-width-slider');
                    const modalHeightSlider = document.getElementById('modal-height-slider');
                    const resetModalSizeBtn = document.getElementById('reset-modal-size-btn');
                    
                    if (modalWidthSlider && !modalWidthSlider.hasAttribute('data-bound')) {
                      modalWidthSlider.addEventListener('input', (e) => {
                        if (window.GuixuManager) {
                          window.GuixuManager.updateModalWidthDisplay(e.target.value);
                        }
                      });
                      modalWidthSlider.setAttribute('data-bound', 'true');
                    }
                    
                    if (modalHeightSlider && !modalHeightSlider.hasAttribute('data-bound')) {
                      modalHeightSlider.addEventListener('input', (e) => {
                        if (window.GuixuManager) {
                          window.GuixuManager.updateModalHeightDisplay(e.target.value);
                        }
                      });
                      modalHeightSlider.setAttribute('data-bound', 'true');
                    }
                    
                    if (resetModalSizeBtn && !resetModalSizeBtn.hasAttribute('data-bound')) {
                      resetModalSizeBtn.addEventListener('click', () => {
                        if (window.GuixuManager) {
                          window.GuixuManager.resetModalSize();
                        }
                      });
                      resetModalSizeBtn.setAttribute('data-bound', 'true');
                    }
                  }, 100);
                }
              }
              navButtons.forEach(button => {
                button.addEventListener('click', function() {
                  const category = this.getAttribute('data-category');
                  if (category) {
                    switchPanel(category);
                  }
                });
              });
              switchPanel('interface');
            }, 100);
          }
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initSettingsPanelSwitcher);
          } else {
            initSettingsPanelSwitcher();
          }
// ===设置界面模块结束===



      })();
    </script>
  </body>
</html>

```

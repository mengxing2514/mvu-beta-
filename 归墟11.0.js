
    // ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«
    // --- SillyTavern Global API ---
    // These are provided by the SillyTavern environment at runtime.
      // We will check for their existence before using them.
      /* global TavernHelper, eventOn, tavern_events, getChatMessages, getCurrentMessageId, _ */
      // --- Main Application Logic ---
      (function () {
    // ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«
    const AppStorage = (() => {
    const STORAGE_NAMESPACE = 'GUIXU_GACHA_';
    const getNamespacedKey = (key) => `${STORAGE_NAMESPACE}${key}`;
    const getCircularReplacer = () => {
        const seen = new WeakSet();
        return (key, value) => {
            if (typeof value === 'undefined') return null;
            if (typeof value === 'object' && value !== null) {
                if (seen.has(value)) return;
                seen.add(value);
            }
            return value;
        };
    };
    const saveData = (key, value) => {
        if (typeof key !== 'string') return;
        try {
            const namespacedKey = getNamespacedKey(key);
            const stringifiedValue = JSON.stringify(value, getCircularReplacer());
            localStorage.setItem(namespacedKey, stringifiedValue);
        } catch (error) {
            console.error(`AppStorage Error: Failed to save data for key \"${key}\".`, error);
        }
    };
    const loadData = (key, defaultValue = null) => {
        if (typeof key !== 'string') return defaultValue;
        try {
            const namespacedKey = getNamespacedKey(key);
            const stringifiedValue = localStorage.getItem(namespacedKey);
            if (stringifiedValue === null) return defaultValue;
            return JSON.parse(stringifiedValue);
        } catch (error) {
            console.error(`AppStorage Error: Failed to load data for key \"${key}\".`, error);
            return defaultValue;
        }
    };
    return { saveData, loadData };
})();



        // ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«
        const GuixuManager = {
              isInitialized: false, // åˆå§‹åŒ–çŠ¶æ€æ ‡å¿—
// ===æ¸…ç†æ¨¡å—å¼€å§‹===
    destroy() {
            // æ¸…ç†é€»è¾‘å°†åœ¨è¿™é‡Œé€æ­¥æ·»åŠ 
            console.log('[å½’å¢Ÿ] GuixuManager.destroy() è¢«è°ƒç”¨');

            // 1. ç§»é™¤é”®ç›˜å¿«æ·é”®ç›‘å¬å™¨
            if (this.boundHandleKeydown) {
              document.removeEventListener('keydown', this.boundHandleKeydown);
              this.boundHandleKeydown = null;
            }

            // 2. æ¸…é™¤è‡ªåŠ¨ä¿å­˜å®šæ—¶å™¨
            if (this.autoSaveInterval) {
              clearInterval(this.autoSaveInterval);
              this.autoSaveInterval = null;
            }
            if (this.periodicAutoSaveIntervalId) {
              clearInterval(this.periodicAutoSaveIntervalId);
              this.periodicAutoSaveIntervalId = null;
            }

            // 3. ç§»é™¤åŠ¨æ€æ·»åŠ çš„DOMå…ƒç´ 
            const rootContainer = document.querySelector('.guixu-root-container');
            if (rootContainer) {
              rootContainer.remove();
            }
            const modals = document.querySelectorAll('.modal-overlay');
            modals.forEach(modal => modal.remove());

            // 4. é‡ç½®æ‰€æœ‰çŠ¶æ€
            this.isInitialized = false;
            this.currentMvuState = null;
            this.db = null;
            this.dbPromise = null;
            this.pendingActions = [];
            this.guixuStoreItems = [];
            this.baseAttributes = {};
            this.calculatedMaxAttributes = {};
            this.lastExtractedJourney = null;
            this.lastExtractedPastLives = null;
            this.gachaState = {};
            this.gachaCollection = {};
            this.gachaHistory = [];
            this.gachaPools = { character: { ssr: [], sr: [], r: [] }, item: { ssr: [], sr: [], r: [] }, talent: { ssr: [], sr: [], r: [] } };
          },
 
          // --- è¡æ¢¦å°˜ Gachaç³»ç»ŸçŠ¶æ€å˜é‡ ---
          isFromGuixuSystem: false,
          currentGachaPoolType: 'character', // æ–°å¢ï¼šè·Ÿè¸ªå½“å‰æ˜¾ç¤ºçš„å¡æ± ç±»å‹
          gachaState: {
              mengChen: 1600, // åˆå§‹èµ é€
              pitySSR_char: 0,
              pitySR_char: 0,
              pitySSR_item: 0,
              pitySR_item: 0,
              pitySSR_talent: 0,
              pitySR_talent: 0,
              redeemedCodes: [],
                  activeCompanions: [],
          },
          gachaCollection: {},
          gachaHistory: [],
          gachaPools: { // ä¿®æ”¹ä¸ºä¸‰å¡æ± ç»“æ„
              character: { ssr: [], sr: [], r: [] },
              item:      { ssr: [], sr: [], r: [] },
              talent:    { ssr: [], sr: [], r: [] }
          },
   
          isGachaCheatMode: false, // æ–°å¢ï¼šä½œå¼Šæ¨¡å¼å¼€å…³   
          pendingCompanionJoin: null, // æ–°å¢ï¼šç­‰å¾…åŠ å…¥ä¸–ç•Œçš„ä¼™ä¼´ä¿¡æ¯
          pendingCharacterCardGeneration: null, // æ–°å¢ï¼šç­‰å¾…AIç”Ÿæˆè§’è‰²å¡çš„ä»»åŠ¡
          listenersBound: false, // æ–°å¢ï¼šé˜²æ­¢äº‹ä»¶ç›‘å¬å™¨é‡å¤ç»‘å®šçš„æ ‡å¿—
          isSegmentedMemoryAutoOn: false, // æ–°å¢ï¼šåˆ†æ®µè®°å¿†è‡ªåŠ¨ç”Ÿæˆå¼€å…³
          segmentedMemoryPollTimer: null, // æ–°å¢ï¼šåˆ†æ®µè®°å¿†è½®è¯¢å®šæ—¶å™¨ID
          isSmallSummaryAutoOn: false, // æ–°å¢ï¼šå°æ€»ç»“è‡ªåŠ¨ç”Ÿæˆå¼€å…³
          smallSummaryPollTimer: null, // æ–°å¢ï¼šå°æ€»ç»“è½®è¯¢å®šæ—¶å™¨ID
          isLargeSummaryAutoOn: false, // æ–°å¢ï¼šå¤§æ€»ç»“è‡ªåŠ¨ç”Ÿæˆå¼€å…³
          largeSummaryPollTimer: null, // æ–°å¢ï¼šå¤§æ€»ç»“è½®è¯¢å®šæ—¶å™¨ID
          isFromSettingsModal: false,
          worldEventsViewMode: 'timeline', // æ–°å¢ï¼šä¸–ç•Œå¤§äº‹è§†å›¾æ¨¡å¼,
          mainOpacity: 100, // é»˜è®¤100%ä¸é€æ˜
          leftPanelWidth: 20, // æ–°å¢ï¼šå·¦ä¾§é¢æ¿å®½åº¦
          rightPanelWidth: 20, // æ–°å¢ï¼šå³ä¾§é¢æ¿å®½åº¦
          intimateCharacters: new Set(), // æ–°å¢ï¼šç”¨äºå­˜å‚¨äº²å¯†è§’è‰²çš„Setæ€
          leftPanelCollapsed: false,

          // --- IndexedDB æ•°æ®åº“å®ä¾‹ç¼“å­˜ ---
          db: null,
          dbPromise: null,
          dbAvailable: false, // æ ‡è®°æ•°æ®åº“æ˜¯å¦å¯ç”¨
          rightPanelCollapsed: false,

          // --- è‡ªåŠ¨é˜…è¯» ---
          isAutoReading: false,
          autoReadSpeed: 3,
          autoReadInterval: null,
          
          // è¿½è¸ªå·²è£…å¤‡ç‰©å“çš„çŠ¶æ€
          //equippedItems ç°åœ¨å­˜å‚¨å®Œæ•´çš„ç‰©å“å¯¹è±¡ï¼Œè€Œä¸ä»…ä»…æ˜¯ID
          equippedItems: {
            wuqi: null,
            fangju: null,
            shipin: null,
            fabao1: null,
            zhuxiuGongfa: null,
            fuxiuXinfa: null,
          },
          currentMvuState: null, // æ–°å¢ï¼šç”¨äºç¼“å­˜å½“å‰æœ€æ–°çš„mvuçŠ¶æ€
          currentSeries: '', // å½“å‰é€‰ä¸­çš„ç³»åˆ—ID(ç©ºå­—ç¬¦ä¸²ä»£è¡¨"æ— ç³»åˆ—")
          activeSeries: '', // å­˜æ¡£ç•Œé¢ä¸­å½“å‰æ¿€æ´»æ˜¾ç¤ºçš„ç³»åˆ—
          pendingActions: [], // æŒ‡ä»¤é˜Ÿåˆ— - å­˜å‚¨çº¯æ–‡æœ¬æŒ‡ä»¤
          guixuStoreItems: [], // å½’å¢Ÿç©ºé—´å•†å“ç¼“å­˜
          baseAttributes: {}, // å­˜å‚¨ä»mvuåŠ è½½çš„åŸå§‹å±æ€§
          calculatedMaxAttributes: {}, // æ–°å¢ï¼šç”¨äºç¼“å­˜è®¡ç®—åçš„å±æ€§ä¸Šé™
          lastExtractedJourney: null,
          lastExtractedPastLives: null,
          lastExtractedNovelText: null, // æ–°å¢ï¼šç”¨äºå­˜å‚¨æå–çš„åŸå§‹æ­£æ–‡
          lastExtractedCharacterCard: null, // æ–°å¢ï¼šç”¨äºå­˜å‚¨æå–çš„è§’è‰²å¡
          lastExtractedThinking: null, // æ–°å¢ï¼šç”¨äºå­˜å‚¨æå–çš„æ€ç»´è¿‡ç¨‹
          lastExtractedVariables: null, // æ–°å¢ï¼šç”¨äºå­˜å‚¨å˜é‡æ”¹å˜
          lastSentPrompt: null, // æ–°å¢ï¼šç”¨äºå­˜å‚¨å‘é€ç»™AIçš„å®Œæ•´æç¤º
          isNovelModeEnabled: false, // æ–°å¢ï¼šå°è¯´æ¨¡å¼å¼€å…³çŠ¶æ€
          isAutoWriteEnabled: true, // é»˜è®¤å¼€å¯è‡ªåŠ¨å†™å…¥
          autoWriteIntervalId: null, // ç”¨äºå­˜å‚¨è½®è¯¢è®¡æ—¶å™¨ID
          
          // æ–°å¢ï¼šä¸–ç•Œä¹¦é¢„è®¾ç®¡ç†çŠ¶æ€
          worldbookPresets: {}, // å­˜å‚¨æ‰€æœ‰é¢„è®¾
          currentEditingPreset: null, // å½“å‰æ­£åœ¨ç¼–è¾‘çš„é¢„è®¾
          presetManagerState: {
            selectedPresetId: null,
            isEditing: false
          },
          isFromWorldbookManager: false, // æ–°å¢ï¼šè·Ÿè¸ªæ˜¯å¦ä»ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢è¿›å…¥é¢„è®¾ç®¡ç†
          novelModeAutoWriteIntervalId: null, // æ–°å¢ï¼šå°è¯´æ¨¡å¼çš„è‡ªåŠ¨å†™å…¥è½®è¯¢ID
          isMobileView: false, // æ–°å¢ï¼šè¿½è¸ªç§»åŠ¨è§†å›¾çŠ¶æ€
          isCharacterPanelVisible: false, // æ–°å¢ï¼šè¿½è¸ªè§’è‰²é¢æ¿çš„æ˜¾ç¤ºçŠ¶æ€
          relationshipSortType: 'default', // æ–°å¢: äººç‰©å…³ç³»æ’åºç±»å‹
          isInteractionPanelVisible: false, // æ–°å¢ï¼šè¿½è¸ªäº¤äº’é¢æ¿çš„æ˜¾ç¤ºçŠ¶æ€
          currentRelationshipTab: 'attributes', // æ–°å¢ï¼šè®°å½•å½“å‰æ¿€æ´»çš„tab
          lastSelectedCharacter: null, // æ–°å¢ï¼šè®°å½•ä¸Šæ¬¡é€‰æ‹©çš„äººç‰©
          unifiedIndex: 1, // æ–°å¢ï¼šç»Ÿä¸€çš„è¯»å†™åºå·
          novelModeIndex: 1, // ä¿ç•™ï¼šç”¨äºå‘åå…¼å®¹ï¼Œä½†å°è¯´æ¨¡å¼ç°åœ¨ä½¿ç”¨unifiedIndex
          isAutoToggleLorebookEnabled: false, // æ–°å¢ï¼šè‡ªåŠ¨å¼€å…³ä¸–ç•Œä¹¦çŠ¶æ€
          autoToggleIntervalId: null, // æ–°å¢ï¼šè½®è¯¢è®¡æ—¶å™¨ID
          periodicAutoSaveIntervalId: null, // æ–°å¢ï¼šè½®è¯¢è‡ªåŠ¨å­˜æ¡£è®¡æ—¶å™¨ID
          isAutoSaveEnabled: true, // æ–°å¢ï¼šè‡ªåŠ¨å­˜æ¡£å¼€å…³çŠ¶æ€
          isActionOptionsEnabled: true, // æ–°å¢ï¼šè¡ŒåŠ¨é€‰é¡¹å¼€å…³çŠ¶æ€
          isActionAutoSend: true, // æ–°å¢ï¼šè¡ŒåŠ¨é€‰é¡¹è‡ªåŠ¨å‘é€å¼€å…³çŠ¶æ€
          isAutoTrimEnabled: false, // æ–°å¢ï¼šè‡ªåŠ¨ä¿®å‰ªå¼€å…³çŠ¶æ€
          isStreamingGametxt: false, // æ–°å¢ï¼šè·Ÿè¸ª<gametxt>æµå¼çŠ¶æ€
          auxModelSettings: null, // ç¬¬äºŒAPIè®¾ç½®ç¼“å­˜
          mvuUpdateMode: 'éšAIè¾“å‡º', // MVUæ›´æ–°æ–¹å¼ï¼š'éšAIè¾“å‡º' æˆ– 'åˆ†æ­¥å˜é‡æ›´æ–°'
          generationMode: 'once', // ç”Ÿæˆæ¨¡å¼ï¼š'once' ä¸€æ¬¡æ€§ æˆ– 'stepwise' æ­¥è¿›å¼
          stepwiseConfig: null, // åˆ†æ­¥å˜é‡æ›´æ–°é…ç½® {modelSource, worldbookFilterMode}
          isStreamingEnabled: true, // æ–°å¢ï¼šæµå¼å¼€å…³çŠ¶æ€
          isStepwiseAppendMode: false, // æ–°å¢ï¼šæ­¥è¿›å¼è¿½åŠ æ¨¡å¼æ ‡å¿—
          stepwiseDisplayedMainContent: '', // æ–°å¢ï¼šæ­¥è¿›å¼å·²æ˜¾ç¤ºçš„ä¸»å†…å®¹
          isStepwiseFirstStep: false, // æ–°å¢ï¼šæ ‡è®°æ˜¯å¦å¤„äºæ­¥è¿›å¼ç¬¬ä¸€æ­¥
          isStepwiseSecondStep: false, // æ–°å¢ï¼šæ ‡è®°æ˜¯å¦å¤„äºæ­¥è¿›å¼ç¬¬äºŒæ­¥
          cachedFirstStepText: null, // æ–°å¢ï¼šç¼“å­˜ç¬¬ä¸€æ­¥çš„å®Œæ•´åŸå§‹æ–‡æœ¬ï¼ˆä¸æå–æ ‡ç­¾ï¼‰
          cachedStepwiseWorldbookEntries: null, // æ–°å¢ï¼šç¼“å­˜ç¬¬äºŒæ­¥ç­›é€‰åçš„ä¸–ç•Œä¹¦æ¡ç›®
          isFormatValidationEnabled: true, // æ–°å¢ï¼šæ ¼å¼å®¡æŸ¥å¼€å…³çŠ¶æ€
          isEnterSendEnabled: true, // æ–°å¢ï¼šå›è½¦å‘é€å¼€å…³çŠ¶æ€
          isKeyboardShortcutsEnabled: true, // æ–°å¢ï¼šé”®ç›˜å¿«æ·é”®å¼€å…³çŠ¶æ€
          isMobileInputAdaptEnabled: false, // æ–°å¢ï¼šæ‰‹æœºè¾“å…¥æ¡†é€‚é…å¼€å…³çŠ¶æ€
          lastValidGametxtHTML: '', // æ–°å¢ï¼šç”¨äºå¤‡ä»½ä¸Šä¸€æ¬¡æœ‰æ•ˆçš„æ­£æ–‡HTML
          floatingInputContainer: null, // æ–°å¢ï¼šæµ®åŠ¨è¾“å…¥æ¡†å®¹å™¨
          historicalTextCount: 3, // æ–°å¢ï¼šå†å²æ­£æ–‡æ˜¾ç¤ºæ•°é‡ï¼ˆ0=ä¸æ˜¾ç¤ºï¼Œ-1=å…¨éƒ¨ï¼Œå…¶ä»–æ­£æ•°=æ˜¾ç¤ºæ•°é‡ï¼‰
          
          // --- æ–°å¢ï¼šæ–‡å­—è®¾ç½®çŠ¶æ€ ---
          textSettings: {
            colors: {
              normal: '#e8dcc6',        // æ­£æ–‡é¢œè‰²
              dialogue: '#ff1493',      // å¯¹è¯é¢œè‰²
              psychology: '#808080',    // å¿ƒç†æ´»åŠ¨é¢œè‰²ï¼šç°è‰²
              scenery: '#98fb98',      // æ™¯ç‰©æå†™é¢œè‰²
              character: '#87CEFA'     // äººç‰©åç§°é¢œè‰²ï¼šæ·¡è“è‰²
            },
            fontSizes: {               // å•ç‹¬å­—ä½“å¤§å°è®¾ç½®
              normal: 14,             // æ­£æ–‡å­—ä½“å¤§å°
              dialogue: 14,           // å¯¹è¯å­—ä½“å¤§å°
              psychology: 13,         // å¿ƒç†æ´»åŠ¨å­—ä½“å¤§å°
              scenery: 15,            // æ™¯ç‰©æå†™å­—ä½“å¤§å°
              character: 14           // äººç‰©åç§°å­—ä½“å¤§å°
            },
            fontFamily: "'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif", // å­—ä½“æ—
            customFonts: []            // ç”¨æˆ·ä¸Šä¼ çš„è‡ªå®šä¹‰å­—ä½“
          },
          backgroundImages: [], // å­˜å‚¨ç”¨æˆ·ä¸Šä¼ çš„èƒŒæ™¯å›¾
          backgroundMode: 'random', // 'random' æˆ– 'fixed'
          selectedBackgroundId: null, // å›ºå®šæ¨¡å¼ä¸‹é€‰ä¸­çš„èƒŒæ™¯å›¾ID
          gallerySource: 'library', // 'library' æˆ– 'output'
          outputFolderHandle: null, // ç”¨äºå­˜å‚¨ output æ–‡ä»¶å¤¹çš„å¥æŸ„
          outputFolderImages: [], // å­˜å‚¨ä» output æ–‡ä»¶å¤¹åŠ è½½çš„å›¾ç‰‡
          outputFolderMonitoringInterval: null, // å­˜å‚¨æ–‡ä»¶å¤¹ç›‘å¬å®šæ—¶å™¨ID
          // å›¾åº“åˆ†é¡µç›¸å…³
          galleryCurrentPage: 1, // å½“å‰é¡µç 
          galleryPageSize: 20, // æ¯é¡µæ˜¾ç¤ºæ•°é‡ï¼ˆæ”¹ä¸º20å¼ ï¼‰
          // --- æ–°å¢ï¼šå¤„ç†æ‰€æœ‰åŠ¨ä½œçš„æ ¸å¿ƒå‡½æ•° ---
          waitingMessages: [
            'å‘œå‘œå‘œå‘œä¼Ÿå¤§çš„æ¢¦æ˜Ÿå¤§äººå•Šï¼Œè¯·ç»™ä½ è™”è¯šçš„ä¿¡å¾’<user>å›å¤å§......',
            'æ¢¦æ˜Ÿå¤§äººï¼Œæˆ‘ä»¬æ•¬çˆ±ä½ å£ç‰™ï¼ï¼è¯·ç»™æˆ‘å›å¤å§ï¼ï¼',
            'æ¢¦æ˜Ÿå¤§äººæ­£åœ¨å›åº”ä½ çš„è¯·æ±‚ï¼Œä¸ƒä¸ªå·¥ä½œæ—¥ç»™ä½ å›å¤',
            'æ­£åœ¨å‘ä¼Ÿå¤§æ¢¦æ˜Ÿç¥ˆç¥·......å‘œå‘œå‘œä½ å¿«ä¸€ç‚¹å¥½ä¸å¥½'
          ],
// ===æ¸…ç†æ¨¡å—ç»“æŸ===



// ===ç­‰å¾…ä¿¡æ¯å¤„ç†æ¨¡å—å¼€å§‹===



          showWaitingMessage() {
            this.hideWaitingMessage(); 
            const message = this.waitingMessages[Math.floor(Math.random() * this.waitingMessages.length)];
            const msgElement = document.createElement('div');
            msgElement.id = 'waiting-popup';
            msgElement.className = 'waiting-popup';
            msgElement.innerHTML = `
              <div class="waiting-spinner"></div>
              <span>${message}</span>
            `;
            const container = document.querySelector('.guixu-root-container');
            if (container) {
                container.appendChild(msgElement);
            }
          },

          hideWaitingMessage() {
              const existingMsg = document.getElementById('waiting-popup');
              if (existingMsg) {
                  existingMsg.remove();
              }
          },

          updateWaitingMessage(text) {
             const popup = document.getElementById('waiting-popup');
             if (popup) {
                 const span = popup.querySelector('span');
                 if (span) {
                     span.textContent = text;
                 }
             }
          },



// ===ç­‰å¾…ä¿¡æ¯å¤„ç†æ¨¡å—ç»“æŸ===



// ===æ‰‹æœº/ç”µè„‘ç•Œé¢åˆ‡æ¢æ¨¡å—å¼€å§‹===
          toggleViewMode() {
            this.isMobileView = !this.isMobileView;
            const container = document.querySelector('.guixu-root-container');
            const btn = document.getElementById('view-toggle-btn');
            if (container && btn) {
              if (this.isMobileView) {
                container.classList.add('mobile-view');
                btn.textContent = 'ğŸ’»'; // åˆ‡æ¢åˆ°æ¡Œé¢å›¾æ ‡
                btn.title = 'åˆ‡æ¢åˆ°æ¡Œé¢è§†å›¾';
              } else {
                container.classList.remove('mobile-view');
                btn.textContent = 'ğŸ“±'; // åˆ‡æ¢åˆ°æ‰‹æœºå›¾æ ‡
                btn.title = 'åˆ‡æ¢åˆ°ç§»åŠ¨è§†å›¾';
              }
            }
            this.saveViewMode();
          },

          saveViewMode() {
            try {
              localStorage.setItem('guixu_view_mode', this.isMobileView ? 'mobile' : 'desktop');
            } catch (e) {
              console.error('ä¿å­˜è§†å›¾æ¨¡å¼å¤±è´¥:', e);
            }
          },

          loadViewMode() {
            try {
              const savedMode = localStorage.getItem('guixu_view_mode');
              // ä»…å½“ä¿å­˜çš„æ¨¡å¼ä¸º 'mobile' æ—¶ï¼Œæ‰åœ¨åŠ è½½æ—¶åˆ‡æ¢åˆ°ç§»åŠ¨è§†å›¾
              if (savedMode === 'mobile') {
                this.isMobileView = true; // è®¾ç½®åˆå§‹çŠ¶æ€
                const container = document.querySelector('.guixu-root-container');
                const btn = document.getElementById('view-toggle-btn');
                if (container && btn) {
                  container.classList.add('mobile-view');
                  btn.textContent = 'ğŸ’»';
                  btn.title = 'åˆ‡æ¢åˆ°æ¡Œé¢è§†å›¾';
                }
              } else {
                this.isMobileView = false; // ç¡®ä¿é»˜è®¤æ˜¯æ¡Œé¢è§†å›¾
              }
            } catch (e) {
              console.error('åŠ è½½è§†å›¾æ¨¡å¼å¤±è´¥:', e);
            }
          },



// ===æ‰‹æœº/ç”µè„‘ç•Œé¢åˆ‡æ¢æ¨¡å—å¼€å§‹===




// ===detailæ ‡ç­¾å¤„ç†æ¨¡å—===
  convertDetailTagsToHTML(text) {
    if (!text) return text;
    let counter = 0;
    return text.replace(/<detail>([\s\S]*?)<\/detail>/g, (match, content) => {
      const id = `detail-${Date.now()}-${counter++}`;
      const onclickAction = `const wrapper=document.getElementById('${id}'); if(wrapper) { wrapper.classList.toggle('expanded'); const icon=wrapper.querySelector('.detail-icon'); if(icon) { icon.classList.toggle('collapsed'); icon.textContent = wrapper.classList.contains('expanded') ? 'â–¼' : 'â–¶'; } }`;
      return `<span class="detail-wrapper" id="${id}"><span class="detail-trigger" onclick="${onclickAction}"><span class="detail-icon">â–¶</span><span>æŸ¥çœ‹è¯¦æƒ…</span></span><div class="detail-content-wrapper"><div class="detail-content">${content.trim()}</div></div></span>`;
    });
  },

// ===æ­£æ–‡æŸ“è‰²æ¨¡å—å¼€å§‹===
  formatMessageContent(text) {
            if (!text) return '';

            // é¢„å¤„ç†detailæ ‡ç­¾ï¼šè½¬æ¢ä¸ºå¯æŠ˜å çš„HTMLç»“æ„
            text = this.convertDetailTagsToHTML(text);

            // é¢„å¤„ç†ï¼šä»…å¤„ç†ç« èŠ‚æ ‡é¢˜å’Œæ¢è¡Œ
            let processedText = text.replace(/\\n/g, '<br />');
            processedText = processedText.replace(/(^\s*ç¬¬.*?ç« .*$)/gm, (match) => `<h3 class="novel-chapter-title">${match}</h3>`);

            // åŸºäºASTçš„è§£æå™¨
            const parseAndStyle = (str) => {
                // 1. åˆ†è¯
                // å°†å­—ç¬¦ä¸²åˆ†è§£ä¸ºæ ‡è®°ç¬¦å·å’Œçº¯æ–‡æœ¬å—
                const tokens = str.match(/(\*\*|\*|ã€ã€|ã€‘ã€‘|ã€|ã€‘|ã€Š|ã€‹|ã€Œ|ã€|ã€|ã€|â€œ|â€|"[^"]*"|'[^']*')|([^ã€ã€‘\*ã€Šã€‹ã€Œã€ã€ã€â€œâ€'"]+)/g) || [];

                // 2. å®šä¹‰è§„åˆ™
                const tokenRules = {
                    '**': { type: 'psychology', symmetric: true },
                    '*': { type: 'psychology', symmetric: true },
                    'ã€ã€': { type: 'scenery-double', open: 'ã€ã€', close: 'ã€‘ã€‘' },
                    'ã€‘ã€‘': { type: 'scenery-double', open: 'ã€ã€', close: 'ã€‘ã€‘' },
                    'ã€': { type: 'scenery', open: 'ã€', close: 'ã€‘' },
                    'ã€‘': { type: 'scenery', open: 'ã€', close: 'ã€‘' },
                    'ã€Š': { type: 'language', open: 'ã€Š', close: 'ã€‹' },
                    'ã€‹': { type: 'language', open: 'ã€Š', close: 'ã€‹' },
                    'ã€Œ': { type: 'language', open: 'ã€Œ', close: 'ã€' },
                    'ã€': { type: 'language', open: 'ã€Œ', close: 'ã€' },
                    'ã€': { type: 'language', open: 'ã€', close: 'ã€' },
                    'ã€': { type: 'language', open: 'ã€', close: 'ã€' },
                    'â€œ': { type: 'language', open: 'â€œ', close: 'â€' },
                    'â€': { type: 'language', open: 'â€œ', close: 'â€' },
                    '"': { type: 'language', symmetric: true },
                    "'": { type: 'language', symmetric: true }
                };
                const classMap = { psychology: 'text-psychology', scenery: 'text-scenery', 'scenery-double': 'text-scenery', language: 'text-language' };

                // 3. è§£æ-> æ„å»ºæŠ½è±¡è¯­æ³•æ ‘ (AST)
                let root = { type: 'root', children: [] };
                let stack = [root]; // èŠ‚ç‚¹æ ˆ

                for (const token of tokens) {
                    const rule = tokenRules[token];
                    let currentNode = stack[stack.length - 1];

                    if (rule) {
                        if (rule.symmetric) {
                            if (currentNode.type === rule.type && currentNode.token === token) {
                                stack.pop(); // é—­åˆå¯¹ç§°æ ‡ç­¾
                            } else {
                                const newNode = { type: rule.type, token: token, children: [] };
                                currentNode.children.push(newNode);
                                stack.push(newNode); // å¼€å¯å¯¹ç§°æ ‡ç­¾
                            }
                        } else if (token === rule.open) { // å¼€å¯éå¯¹ç§°æ ‡ç­¾
                            const newNode = { type: rule.type, children: [] };
                            currentNode.children.push(newNode);
                            stack.push(newNode);
                        } else if (token === rule.close) { // é—­åˆéå¯¹ç§°æ ‡ç­¾
                            if (currentNode.type === rule.type) {
                                stack.pop();
                            } else { // å®¹é”™ï¼šå¦‚æœæ ‡ç­¾ä¸åŒ¹é…ï¼Œåˆ™ä½œä¸ºçº¯æ–‡æœ¬å¤„ç†
                                currentNode.children.push(token);
                            }
                        }
                    } else { // çº¯æ–‡æœ¬
                        currentNode.children.push(token);
                    }
                }

                // 4. ä»£ç ç”Ÿæˆ 
                const generateHTML = (node) => {
                    if (typeof node === 'string') {
                        // åœ¨æœ€ç»ˆç”Ÿæˆæ—¶æ‰è¿›è¡ŒHTMLå®ä½“è½¬ä¹‰
                        return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    const childrenHTML = node.children.map(generateHTML).join('');
                    if (node.type === 'root') {
                        return childrenHTML;
                    }
                    // åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†æ ‡è®°ç¬¦å·æœ¬èº«ä¹ŸåŒ…å«åœ¨spanå†…éƒ¨ï¼Œä»¥å®ç°å¯¹ç¬¦å·çš„æŸ“è‰²
                    const openToken = node.token || Object.keys(tokenRules).find(k => tokenRules[k].type === node.type && tokenRules[k].open === k) || '';
                    const closeToken = node.token || Object.keys(tokenRules).find(k => tokenRules[k].type === node.type && tokenRules[k].close === k) || '';
                    
                    return `<span class="${classMap[node.type]}">${openToken}${childrenHTML}${closeToken}</span>`;
                };
                
                // åœ¨ç”ŸæˆHTMLæ—¶ï¼Œæˆ‘ä»¬åº”è¯¥åªåŒ…è£¹å†…å®¹ï¼Œè€Œä¸æ˜¯å†æ¬¡æ·»åŠ æ ‡è®°
                const generateCorrectHTML = (node) => {
                     if (typeof node === 'string') {
                        return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    const childrenHTML = node.children.map(generateCorrectHTML).join('');
                    if (node.type === 'root') {
                        return childrenHTML;
                    }
                    // åªåŒ…è£¹å†…å®¹
                    return `<span class="${classMap[node.type]}">${childrenHTML}</span>`;
                }
                const generateFinalHTML = (node, parent) => {
                    if (typeof node === 'string') {
                         return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    const childrenHTML = node.children.map(child => generateFinalHTML(child, node)).join('');
                    if (node.type === 'root') return childrenHTML;

                    const open = node.token || Object.keys(tokenRules).find(k => tokenRules[k].type === node.type && tokenRules[k].open) || '';
                    const close = node.token || Object.keys(tokenRules).find(k => tokenRules[k].type === node.type && tokenRules[k].close) || '';

                    return `<span class="${classMap[node.type]}">${open}${childrenHTML}${close}</span>`;
                };
                
                // æœ€ç»ˆç‰ˆç”Ÿæˆå™¨
                const finalGenerator = (node) => {
                    if (typeof node === 'string') {
                        return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    
                    const childrenHtml = node.children.map(finalGenerator).join('');
                    
                    if (node.type === 'root') {
                        return childrenHtml;
                    }
                    
                    return `<span class="${classMap[node.type]}">${childrenHtml}</span>`;
                };

                // å°†æ ‡è®°ä¹Ÿä½œä¸ºèŠ‚ç‚¹
                let new_root = { type: 'root', children: [] };
                let new_stack = [new_root];

                for (const token of tokens) {
                    const rule = tokenRules[token];
                    let currentNode = new_stack[new_stack.length - 1];

                    if (rule) {
                        if (rule.symmetric) {
                            if (currentNode.type === rule.type && currentNode.token === token) {
                                new_stack.pop();
                            } else {
                                const newNode = { type: rule.type, token: token, children: [] };
                                currentNode.children.push(newNode);
                                new_stack.push(newNode);
                            }
                        } else if (rule.open === token) {
                            const newNode = { type: rule.type, open: token, close: rule.close, children: [] };
                            currentNode.children.push(newNode);
                            new_stack.push(newNode);
                        } else if (rule.close === token) {
                            if (currentNode.type === rule.type && currentNode.close === token) {
                                new_stack.pop();
                            } else {
                                currentNode.children.push(token); // Mismatch, treat as text
                            }
                        }
                    } else {
                        currentNode.children.push(token);
                    }
                }
                
                const finalHtmlGenerator = (node) => {
                    if (typeof node === 'string') {
                        return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    const childrenHtml = node.children.map(finalHtmlGenerator).join('');
                    if (node.type === 'root') {
                        return childrenHtml;
                    }

                    // æ ¹æ®ç±»å‹å†³å®šæ˜¯å¦ä¿ç•™æ ‡è®°ç¬¦å·
                    if (node.type === 'language') {
                        // å¯¹è¯ç±»å‹ï¼Œä¿ç•™ç¬¦å·
                        return `<span class="${classMap[node.type]}">${node.open || node.token || ''}${childrenHtml}${node.close || node.token || ''}</span>`;
                    } else if (node.type === 'scenery-double') {
                        // åŒå±‚æ‹¬å·æ™¯ç‰©ï¼Œä¿ç•™å¤–å±‚æ‹¬å·å¹¶æŸ“è‰²
                        return `<span class="${classMap[node.type]}">ã€${childrenHtml}ã€‘</span>`;
                    }
                    else {
                        // æ™¯ç‰©å’Œå¿ƒç†ç±»å‹ï¼Œç§»é™¤ç¬¦å·
                        return `<span class="${classMap[node.type]}">${childrenHtml}</span>`;
                    }
                };

                return finalHtmlGenerator(new_root);
            };

            let finalHtml = parseAndStyle(processedText);
            
            // æ–°å¢ï¼šåœ¨HTMLç”Ÿæˆåè¿›è¡Œäººç‰©åç§°æ£€ç´¢å’Œé“¾æ¥åŒ–
            finalHtml = this.highlightCharacterNames(finalHtml);
            
            return finalHtml;
          },
          // æ–°å¢ï¼šäººç‰©åç§°é«˜äº®å’Œé“¾æ¥åŒ–å‡½æ•°
          highlightCharacterNames(html) {
            if (!html || !this.currentMvuState) return html;
            
            try {
              // è·å–äººç‰©å…³ç³»åˆ—è¡¨
              const relationships = this.SafeGetValue(this.currentMvuState.stat_data, 'äººç‰©å…³ç³»åˆ—è¡¨', {});
              
              // æå–æ‰€æœ‰äººç‰©åç§°ï¼ˆåªæ£€ç´¢é”®åï¼‰
              const characterNames = Object.keys(relationships).filter(name => name !== '$meta');
              
              if (characterNames.length === 0) return html;
              
              // æŒ‰åç§°é•¿åº¦é™åºæ’åˆ—ï¼Œä¼˜å…ˆåŒ¹é…è¾ƒé•¿çš„åç§°
              characterNames.sort((a, b) => b.length - a.length);
              
              let result = html;
              
              // å¯¹æ¯ä¸ªäººç‰©åç§°è¿›è¡Œæ›¿æ¢
              characterNames.forEach(name => {
                // åˆ›å»ºæ­£åˆ™è¡¨è¾¾å¼ï¼ŒåŒ¹é…äººç‰©åç§°ä½†é¿å…åœ¨HTMLæ ‡ç­¾å†…åŒ¹é…
                // ä½¿ç”¨åˆ†å‰²å’Œé‡ç»„çš„æ–¹å¼ï¼Œåªæ›¿æ¢>å’Œ<ä¹‹é—´çš„çº¯æ–‡æœ¬ä¸­çš„äººç‰©åç§°
                const parts = result.split(/(>[^<]*<)/);
                result = parts.map((part, index) => {
                  // åªå¤„ç†å¥‡æ•°ç´¢å¼•çš„éƒ¨åˆ†ï¼ˆçº¯æ–‡æœ¬å†…å®¹ï¼‰
                  if (index % 2 === 1) {
                    // æ›¿æ¢äººç‰©åç§°ä¸ºå¸¦æ ·å¼çš„span
                    return part.replace(new RegExp(name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
                      `<span class="character-link" data-character="${name}">${name}</span>`);
                  }
                  return part;
                }).join('');
              });
              
              return result;
              
            } catch (error) {
              // é™é»˜å¤„ç†é”™è¯¯ï¼Œä¸å½±å“æ­£æ–‡æ˜¾ç¤º
              return html;
            }
          },


// ===æ­£æ–‡æŸ“è‰²æ¨¡å—ç»“æŸ===



// ===æ­£æ–‡å­—æ•°è·å–æ¨¡å—å¼€å§‹===
          updateLiveWordCount() {
            const gameTextDisplay = document.getElementById('game-text-display');
            const wordCountEl = document.getElementById('game-text-word-count');
            if (gameTextDisplay && wordCountEl) {
              // ä½¿ç”¨ textContent æ¥è·å–çº¯æ–‡æœ¬ï¼Œè‡ªåŠ¨å¿½ç•¥HTMLæ ‡ç­¾
              const wordCount = gameTextDisplay.textContent ? gameTextDisplay.textContent.trim().length : 0;
              wordCountEl.textContent = `æ­£æ–‡ï¼š${wordCount}å­—`;
            }
          },
// ===æ­£æ–‡å­—æ•°è·å–æ¨¡å—ç»“æŸ===


// ===åˆå§‹åŒ–ï¼ˆinitï¼‰æ¨¡å—å¼€å§‹===
          async init() {


// ===åˆå§‹åŒ–ä¹‹å‰===ï¼ˆæ•°æ®åº“åˆå§‹åŒ–ï¼‰

// æ•°æ®åº“åˆå§‹åŒ–

            try {
              await this.initializeDatabase();
              console.log('[å½’å¢ŸPlus] Dexie æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ');
            } catch (error) {
              console.error('[å½’å¢ŸPlus] æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error);
            }
        if (this.isInitialized) {
              console.log('[å½’å¢Ÿ]åˆå§‹åŒ–å®Œæˆ');
              return;
            }

// ===åˆå§‹åŒ–ä¹‹å‰===

            this.isInitialized = true;
            this.loadPanelWidths(); // åŠ è½½é¢æ¿å®½åº¦è®¾ç½®
            this.bindStaticListeners();
            this.loadWindowSizeState(); // åŠ è½½çª—å£å¤§å°çŠ¶æ€
            this.loadModalSizeState(); // åŠ è½½æ¨¡æ€æ¡†å¤§å°çŠ¶æ€
            this.initBackgroundSystem(); // åˆå§‹åŒ–èƒŒæ™¯å›¾ç³»ç»Ÿ
            this.loadWorldbookPresets(); // åŠ è½½ä¸–ç•Œä¹¦é¢„è®¾
            this.loadGallerySource(); // åŠ è½½å›¾åº“æ¥æºè®¾ç½®
            this.loadOutputFolderHandle(); // åŠ è½½outputæ–‡ä»¶å¤¹å¥æŸ„
            this.loadGallerySource(); // åŠ è½½å›¾åº“æ¥æºè®¾ç½®
            this.loadOutputFolderHandle(); // åŠ è½½outputæ–‡ä»¶å¤¹å¥æŸ„        
            this.initAutoRead(); // åˆå§‹åŒ–è‡ªåŠ¨é˜…è¯»åŠŸèƒ½
                 await this.updateDynamicData(); // åˆå§‹åŒ–å˜é‡æ•°æ®
            this.loadAutoWriteState(); // åŠ è½½è‡ªåŠ¨å†™å…¥çŠ¶æ€
            this.loadNovelModeState(); // åŠ è½½å°è¯´æ¨¡å¼çŠ¶æ€
            this.loadPendingActions(); // åŠ è½½å¾…å¤„ç†æŒ‡ä»¤
            this.loadViewMode(); // æ–°å¢ï¼šåŠ è½½ç”¨æˆ·ä¿å­˜çš„è§†å›¾æ¨¡å¼
            this.loadUnifiedIndex(); // æ–°å¢ï¼šåŠ è½½ç»Ÿä¸€çš„è¯»å†™åºå·
            this.loadAutoToggleState(); // æ–°å¢ï¼šåŠ è½½è‡ªåŠ¨å¼€å…³çŠ¶æ€
            this.loadWorldbookSettings(); // æ–°å¢ï¼šåŠ è½½ä¸–ç•Œä¹¦é«˜çº§è®¾ç½®
            this.loadAutoSaveState(); // æ–°å¢ï¼šåŠ è½½è‡ªåŠ¨å­˜æ¡£çŠ¶æ€
            this.loadSegmentedMemoryState(); // åŠ è½½ç»Ÿä¸€çš„å¼€å…³çŠ¶æ€
            this.loadSegmentedMemoryCounts(); // æ–°å¢ï¼šåŠ è½½åˆ†æ®µè®°å¿†ä¿ç•™æ•°
            this.loadSmallSummaryState();
            this.loadLargeSummaryState();
            this.loadActionOptionsState(); // æ–°å¢ï¼šåŠ è½½è¡ŒåŠ¨é€‰é¡¹å¼€å…³çŠ¶æ€
            this.loadActionAutoSendState(); // æ–°å¢ï¼šåŠ è½½è¡ŒåŠ¨é€‰é¡¹è‡ªåŠ¨å‘é€çŠ¶æ€
            this.loadHistoricalTextSettings(); // æ–°å¢ï¼šåŠ è½½å†å²æ­£æ–‡è®¾ç½®
            this.loadPanelStates(); // æ–°å¢ï¼šåŠ è½½é¢æ¿æŠ˜å çŠ¶æ€
            this.loadStreamingState(); // æ–°å¢ï¼šåŠ è½½æµå¼å¼€å…³çŠ¶æ€
            this.loadFormatValidationState(); // æ–°å¢ï¼šåŠ è½½æ ¼å¼å®¡æŸ¥çŠ¶æ€
            this.loadEnterSendState(); // æ–°å¢ï¼šåŠ è½½å›è½¦å‘é€çŠ¶æ€
            this.loadKeyboardShortcutsState(); // æ–°å¢ï¼šåŠ è½½é”®ç›˜å¿«æ·é”®çŠ¶æ€
            this.loadMobileInputAdaptState(); // æ–°å¢ï¼šåŠ è½½æ‰‹æœºè¾“å…¥æ¡†é€‚é…çŠ¶æ€
            this.loadRelationshipSettings(); // æ–°å¢ï¼šåŠ è½½äººç‰©å…³ç³»è®¾ç½®
            this.loadLastThinking(); // æ–°å¢ï¼šåŠ è½½ä¸Šæ¬¡çš„æ€ç»´è¿‡ç¨‹
            this.loadTrimFieldsState(); // æ–°å¢ï¼šåŠ è½½ä¿®å‰ªå­—æ®µçŠ¶æ€
            this.loadTextSettings(); // æ–°å¢ï¼šåŠ è½½æ–‡å­—è®¾ç½®
            this.loadGachaState(); // æ–°å¢ï¼šåŠ è½½Gacha/è¡æ¢¦å°˜æ•°æ®
            this.loadAuxModelSettings(); // æ–°å¢ï¼šåŠ è½½ç¬¬äºŒAPIè®¾ç½®
            this.loadMvuUpdateMode(); // æ–°å¢ï¼šåŠ è½½MVUæ›´æ–°æ–¹å¼
            this.loadGachaCheatState(); // æ–°å¢ï¼šåŠ è½½Gachaä½œå¼Šæ¨¡å¼çŠ¶æ€
                 await this.loadCharacterPoolFromLorebook(); // æ–°å¢ï¼šåŠ è½½å¡æ± 
            this.updateThinkingButtonVisibility(); // æ–°å¢ï¼šæ ¹æ®åŠ è½½çš„æ•°æ®æ›´æ–°æŒ‰é’®
            this.updateCurrentLifeButtonVisibility(); // æ–°å¢:æ›´æ–°æœ¬ä¸–å†ç¨‹æŒ‰é’®æ˜¾ç¤º
            this.updatePastLivesButtonVisibility(); // æ–°å¢:æ›´æ–°å¾€ä¸–æ¶Ÿæ¼ªæŒ‰é’®æ˜¾ç¤º
            this.setupInputKeyboardHandling();
            this.initQuestSystem(); // åˆå§‹åŒ–ä»»åŠ¡ç³»ç»Ÿ
            //this.startPeriodicAutoSave(); // å¯åŠ¨è½®è¯¢è‡ªåŠ¨å­˜æ¡£


// ===åˆå§‹åŒ–æœ«å°¾===ï¼ˆå…¶ä»–é€»è¾‘ã€äº‹ä»¶æ³¨å†Œç­‰å†…å®¹ï¼‰


           eventOn(iframe_events.STREAM_TOKEN_RECEIVED_FULLY, (text) => this.handleStreamUpdate(text));
           eventOn(iframe_events.GENERATION_ENDED, (text) => this.handleStreamEnd(text));
           eventOn('worldinfo_entries_loaded', (lores) => this.handleWorldbookFilter(lores));

            // å°†è‡ªåŠ¨é˜…è¯»æ‚¬æµ®çª—ç§»åŠ¨åˆ°bodyæœ«å°¾(å¿…é¡»åœ¨initAutoReadä¹‹å‰)
            const autoReadFloat = document.getElementById('auto-read-float');
            if (autoReadFloat) {
              document.body.appendChild(autoReadFloat);
            }

            //åœ¨åˆå§‹åŒ–æœ€åï¼Œæ‰‹åŠ¨æ›´æ–°ä¸€æ¬¡ç« èŠ‚å¯¼èˆªæŒ‰é’®çš„å¯è§æ€§ï¼Œç¡®ä¿æŒ‰é’®çŠ¶æ€æ­£ç¡®
           if (typeof this.updateChapterNavigation === 'function') {
             this.updateChapterNavigation();
           }

            // é¦–æ¬¡åŠ è½½å®Œæˆåè‡ªåŠ¨è·³è½¬åˆ°æ ‡é¢˜/æ€ç»´é“¾ä½ç½®
            setTimeout(() => {
              const mainContent = document.getElementById('main-content');
              const titleContainer = document.getElementById('current-chapter-title');
              const thinkingContainer = document.getElementById('thinking-process-container');
              const gameTextDisplay = document.getElementById('game-text-display');
             
              if (mainContent) {
                let targetElement = gameTextDisplay; // é»˜è®¤ç›®æ ‡
                if (titleContainer && titleContainer.style.display !== 'none') {
                 targetElement = titleContainer; // ä¼˜å…ˆæ»šåŠ¨åˆ°æ ‡é¢˜
                } else if (thinkingContainer && thinkingContainer.style.display !== 'none') {
                 targetElement = thinkingContainer; // å…¶æ¬¡æ»šåŠ¨åˆ°æ€ç»´é“¾
               }
               
               const rect = targetElement.getBoundingClientRect();
               const containerRect = mainContent.getBoundingClientRect();
               const targetPosition = mainContent.scrollTop + rect.top - containerRect.top;
               console.log('[å½’å¢Ÿ] é¦–æ¬¡åŠ è½½,æ»šåŠ¨åˆ°:', targetElement.id, 'ä½ç½®:', targetPosition);
               mainContent.scrollTo({ top: targetPosition, behavior: 'smooth' });
             }
            }, 500); // å»¶è¿Ÿ500msç¡®ä¿æ‰€æœ‰åˆå§‹åŒ–å®Œæˆ
           // ã€åŠ¨æ€æ³¨å…¥å½’å¢Ÿç©ºé—´å®šåˆ¶åŒ–CSSã€‘
            const customStyles = `
                /* å½’å¢Ÿç©ºé—´ç¡®è®¤æ¡†å®šåˆ¶æ ·å¼ */
                #custom-confirm-modal.guixu-confirm-modal .modal-content {
                    background: var(--bg-secondary, rgba(15, 15, 35, 0.85));
                    border: 1px solid var(--border-color, #444);
                    border-radius: 8px;
                    box-shadow: var(--shadow-glow, 0 0 12px rgba(201, 170, 113, 0.3)), var(--shadow-elevation-medium, 0 4px 6px rgba(0, 0, 0, 0.2));
                    width: 400px !important; /* è°ƒæ•´å®½åº¦å¹¶å¼ºåˆ¶è¦†ç›– */
                    max-width: 80vw;
                    height: auto;
                    min-height: 180px; /* è°ƒæ•´æœ€å°é«˜åº¦ */
                    padding: 24px;
                    display: flex;
                    flex-direction: column;
                    justify-content: center; /* å‚ç›´å±…ä¸­ */
                    align-items: center; /* æ°´å¹³å±…ä¸­ */
                    gap: 20px; /* å…ƒç´ é—´è· */
                }
                #custom-confirm-modal.guixu-confirm-modal .modal-header {
                    padding: 0;
                    border-bottom: none;
                    position: absolute; /* å°†å…³é—­æŒ‰é’®å®šä½åˆ°å³ä¸Šè§’ */
                    top: 10px;
                    right: 10px;
                }
                #custom-confirm-modal.guixu-confirm-modal .modal-title {
                    display: none; /* éšè—é»˜è®¤æ ‡é¢˜ */
                }
                #custom-confirm-modal.guixu-confirm-modal .confirm-modal-message {
                    color: var(--text-primary, #e0e0e0);
                    font-size: 16px;
                    text-align: center;
                    line-height: 1.6;
                }
                #custom-confirm-modal.guixu-confirm-modal .confirm-modal-buttons {
                    display: flex;
                    gap: 15px;
                    padding: 0;
                }
                #custom-confirm-modal.guixu-confirm-modal .interaction-btn {
                    min-width: 100px;
                }
                #custom-confirm-modal.guixu-confirm-modal #custom-confirm-btn-ok {
                    background-color: var(--primary-gold, #c9aa71);
                    color: var(--text-on-primary, #1a1a1a);
                    border: none;
                }
                #custom-confirm-modal.guixu-confirm-modal #custom-confirm-btn-ok:hover {
                    background-color: var(--secondary-gold, #daa520);
                }
                #custom-confirm-modal.guixu-confirm-modal #custom-confirm-btn-cancel {
                    background-color: transparent;
                    border: 1px solid var(--border-color-light, #666);
                    color: var(--text-secondary, #b0b0b0);
                }
                #custom-confirm-modal.guixu-confirm-modal #custom-confirm-btn-cancel:hover {
                    background-color: var(--bg-hover, rgba(255, 255, 255, 0.1));
                    border-color: var(--border-color-hover, #888);
                }
            `;
            const styleElement = document.createElement('style');
            styleElement.textContent = customStyles;
            document.head.appendChild(styleElement);
// ===åˆå§‹åŒ–æœ«å°¾===


          },



// ===åˆå§‹åŒ–ï¼ˆinitï¼‰æ¨¡å—ç»“æŸ===

        
          // ä¸–ç•Œä¹¦ç­›é€‰å‡½æ•°ï¼ˆç”¨äºæ­¥è¿›å¼æ¨¡å¼ï¼‰
          handleWorldbookFilter(lores) {
              
              const only_plot_regex = /ã€onlyå‰§æƒ…ã€‘/;
              const only_variable_regex = /ã€onlyå˜é‡ã€‘/;
              
              // å¦‚æœæ˜¯ç¬¬äºŒæ­¥ï¼Œåœ¨ç­›é€‰å‰å…ˆç¼“å­˜æ‰€æœ‰ä¸–ç•Œä¹¦å†…å®¹ï¼ˆç”¨äºä¸Šä¸‹æ–‡æŸ¥çœ‹ï¼‰
              if (this.isStepwiseSecondStep) {
                  this.cachedStepwiseWorldbookEntries = {
                      original: {
                          globalLore: lores.globalLore ? [...lores.globalLore] : [],
                          characterLore: lores.characterLore ? [...lores.characterLore] : [],
                          chatLore: lores.chatLore ? [...lores.chatLore] : [],
                          personaLore: lores.personaLore ? [...lores.personaLore] : []
                      },
                      filtered: null  // ç¨åå¡«å……
                  };
              }
              
              const filterLoreArray = (loreArray, arrayName) => {
                  if (!loreArray || loreArray.length === 0) return;
                  
                  const originalCount = loreArray.length;
                  
                  const removed = _.remove(loreArray, entry => {
                      const entryName = entry.name || entry.comment || '';
                      const hasPlotPrefix = entryName.match(only_plot_regex);
                      const hasVariablePrefix = entryName.match(only_variable_regex);
                      
                      if (this.isStepwiseFirstStep) {
                          // ç¬¬ä¸€æ­¥ï¼šç§»é™¤ã€onlyå˜é‡ã€‘æ ‡è®°çš„æ¡ç›®
                          return hasVariablePrefix && !hasPlotPrefix;
                      } else if (this.isStepwiseSecondStep) {
                          // ç¬¬äºŒæ­¥ï¼šç§»é™¤ã€onlyå‰§æƒ…ã€‘æ ‡è®°çš„æ¡ç›®
                          return hasPlotPrefix && !hasVariablePrefix;
                      }
                      return false;
                  });
                  
                  if (removed.length > 0) {
                      console.log(`[å½’å¢Ÿ-ä¸–ç•Œä¹¦ç­›é€‰] ${arrayName}: ç§»é™¤äº† ${removed.length} ä¸ªæ¡ç›®`);
                      removed.forEach(entry => {
                          const entryName = entry.name || entry.comment || 'unnamed';
                          console.log(`  - ç§»é™¤: ${entryName}`);
                      });
                  }
                  
                  console.log(`[å½’å¢Ÿ-ä¸–ç•Œä¹¦ç­›é€‰] ${arrayName}: ${originalCount} â†’ ${loreArray.length} ä¸ªæ¡ç›®`);
              };
              
              // å¯¹æ‰€æœ‰ç±»å‹çš„ä¸–ç•Œä¹¦è¿›è¡Œç­›é€‰
              if (lores.globalLore) filterLoreArray(lores.globalLore, 'å…¨å±€ä¸–ç•Œä¹¦');
              if (lores.characterLore) filterLoreArray(lores.characterLore, 'è§’è‰²ä¸–ç•Œä¹¦');
              if (lores.chatLore) filterLoreArray(lores.chatLore, 'èŠå¤©ä¸–ç•Œä¹¦');
              if (lores.personaLore) filterLoreArray(lores.personaLore, 'äººè®¾ä¸–ç•Œä¹¦');
              
              // âœ… å¦‚æœæ˜¯ç¬¬äºŒæ­¥ï¼Œç¼“å­˜ç­›é€‰åçš„ç»“æœï¼ˆç”¨äºä¸Šä¸‹æ–‡æŸ¥çœ‹ï¼‰
              if (this.isStepwiseSecondStep && this.cachedStepwiseWorldbookEntries) {
                  this.cachedStepwiseWorldbookEntries.filtered = {
                      globalLore: lores.globalLore || [],
                      characterLore: lores.characterLore || [],
                      chatLore: lores.chatLore || [],
                      personaLore: lores.personaLore || []
                  };
                  console.log('[å½’å¢Ÿ-ä¸–ç•Œä¹¦ç­›é€‰] å·²ç¼“å­˜ç¬¬äºŒæ­¥ç­›é€‰åçš„ä¸–ç•Œä¹¦å†…å®¹');
              }
          },

// ===æµå¼å¤„ç†æ¨¡å—å¼€å§‹===

          startPeriodicAutoSave() {
            if (this.periodicAutoSaveIntervalId) {
              clearInterval(this.periodicAutoSaveIntervalId);
            }
            this.periodicAutoSaveIntervalId = setInterval(() => {
              this.saveGame(true); // è°ƒç”¨ç°æœ‰çš„å­˜æ¡£å‡½æ•°ï¼ŒisAutoSave=true
            }, 60000); // 60ç§’
          },

          handleStreamUpdate(text) {
            if (!this.isStreamingGametxt && text.includes('<gametxt>')) {
                this.isStreamingGametxt = true;
                this.updateWaitingMessage('æ¢¦æ˜Ÿå¤§äººæ­£åœ¨ç»™ä½ æµå¼ç”Ÿæˆæ­£æ–‡ï¼Œèµç¾æ¢¦æ˜Ÿå¤§äººï¼ï¼ï¼');
                this.hideVariableChangesReminder();
            }
            
            const gameTextDisplay = document.getElementById('game-text-display');
            if (gameTextDisplay) {
              // æ­¥è¿›å¼ç¬¬äºŒæ­¥ä¸æ˜¾ç¤ºæµå¼æ›´æ–°ï¼Œç­‰å¾…å®Œæˆåå†åˆå¹¶æ˜¾ç¤º
              if (this.isStepwiseAppendMode) {
                return;
              }
              
              // æ­£å¸¸æ¨¡å¼æˆ–æ­¥è¿›å¼ç¬¬ä¸€æ­¥ï¼šæ˜¾ç¤ºgametxtå†…å®¹
              const displayText = this._getDisplayText(text);
              gameTextDisplay.innerHTML = this.formatMessageContent(displayText);
              this.updateLiveWordCount();
            }
          },
// ===æµå¼å¤„ç†æ¨¡å—ç»“æŸ==



// ===æ ¼å¼å®¡æŸ¥æ¨¡å—å¼€å§‹===



          // éªŒè¯æ­¥è¿›å¼ç¬¬äºŒæ­¥çš„å“åº”æ ¼å¼ï¼ˆåªæ£€æŸ¥UpdateVariableæ ‡ç­¾ï¼‰
          validateStep2Response(text) {
            const tagConfig = {
              // ç¬¬äºŒæ­¥åªéœ€è¦UpdateVariableæ ‡ç­¾
              required: ['UpdateVariable'],
              optional: []
            };
            const errors = [];
            // æ™ºèƒ½è¿‡æ»¤æ‰<thinking>...</thinking>æ ‡ç­¾å†…å®¹
            const thinkingRegex = /<thinking>[\s\S]*?<\/thinking>/gi;
            let cleanedText = text.replace(thinkingRegex, '');
            
            // æ£€æŸ¥æ‰€æœ‰æ ‡ç­¾
            const allTags = [...tagConfig.required, ...tagConfig.optional];
            for (const tag of allTags) {
              const openTagCount = (cleanedText.match(new RegExp(`<${tag}>`, 'gi')) || []).length;
              const closeTagCount = (cleanedText.match(new RegExp(`</${tag}>`, 'gi')) || []).length;
              const isRequired = tagConfig.required.includes(tag);
              
              console.log(`[æ ¼å¼éªŒè¯-æ­¥éª¤2] æ ‡ç­¾ ${tag} (${isRequired ? 'å¿…éœ€' : 'å¯é€‰'}): å¼€å§‹=${openTagCount}, ç»“æŸ=${closeTagCount}`);
              
              // æ£€æŸ¥å¿…éœ€æ ‡ç­¾æ˜¯å¦å®Œå…¨ç¼ºå¤±
              if (isRequired && openTagCount === 0 && closeTagCount === 0) {
                errors.push({
                  tag: tag,
                  type: 'missing',
                  message: `&lt;${tag}&gt;æ²¡æœ‰`
                });
              }
              // æ£€æŸ¥æ ‡ç­¾é—­åˆæƒ…å†µ
              else if (openTagCount > 0 && closeTagCount === 0) {
                errors.push({
                  tag: tag,
                  type: 'unclosed',
                  message: `&lt;${tag}&gt;æ ‡ç­¾æ²¡é—­åˆ`
                });
              }
              else if (openTagCount === 0 && closeTagCount > 0) {
                errors.push({
                  tag: tag,
                  type: 'incomplete',
                  message: `&lt;${tag}&gt;æ ‡ç­¾ç¼ºå¤±å¼€å§‹æ ‡ç­¾`
                });
              }
              else if (openTagCount > 0 && closeTagCount > 0 && openTagCount !== closeTagCount) {
                errors.push({
                  tag: tag,
                  type: 'mismatch',
                  message: `&lt;${tag}&gt;æ ‡ç­¾æ²¡é—­åˆ`
                });
              }
            }
            
            return {
              isValid: errors.length === 0,
              errors: errors,
              summary: {
                total: errors.length,
                missing: errors.filter(e => e.type === 'missing').length,
                unclosed: errors.filter(e => e.type === 'unclosed').length,
                incomplete: errors.filter(e => e.type === 'incomplete').length,
                mismatch: errors.filter(e => e.type === 'mismatch').length
              }
            };
          },

          validateResponseFormat(text) {
            // å®šä¹‰æ ‡ç­¾æ£€æŸ¥é…ç½®
            const tagConfig = {
              // å¿…éœ€æ ‡ç­¾ï¼šå¿…é¡»å­˜åœ¨ä¸”æ­£ç¡®é—­åˆ
              required: ['gametxt', 'æœ¬ä¸–å†ç¨‹'],
              // å¯é€‰æ ‡ç­¾ï¼šå¦‚æœå­˜åœ¨åˆ™å¿…é¡»æ­£ç¡®é—­åˆ
              optional: ['UpdateVariable', 'thinking', 'action']
            };
            const errors = [];
            // æ™ºèƒ½è¿‡æ»¤æ‰<thinking>...</thinking>æ ‡ç­¾å†…å®¹ï¼Œé¿å…å…¶ä¸­çš„å†…å®¹å¹²æ‰°æ ¼å¼éªŒè¯
            const thinkingRegex = /<thinking>[\s\S]*?<\/thinking>/gi;
            let cleanedText = text.replace(thinkingRegex, '');
            // æ£€æŸ¥æ‰€æœ‰æ ‡ç­¾ï¼ˆå¿…éœ€ + å¯é€‰ï¼‰
            const allTags = [...tagConfig.required, ...tagConfig.optional];        
            for (const tag of allTags) {
              const openTagCount = (cleanedText.match(new RegExp(`<${tag}>`, 'gi')) || []).length;
              const closeTagCount = (cleanedText.match(new RegExp(`</${tag}>`, 'gi')) || []).length;
              const isRequired = tagConfig.required.includes(tag);              
              console.log(`[æ ¼å¼éªŒè¯] æ ‡ç­¾ ${tag} (${isRequired ? 'å¿…éœ€' : 'å¯é€‰'}): å¼€å§‹=${openTagCount}, ç»“æŸ=${closeTagCount}`);              
              // 1. æ£€æŸ¥å¿…éœ€æ ‡ç­¾æ˜¯å¦å®Œå…¨ç¼ºå¤±
              if (isRequired && openTagCount === 0 && closeTagCount === 0) {
                const errorMsg = `&lt;${tag}&gt;æ²¡æœ‰`;
                console.log(`[æ ¼å¼éªŒè¯] æ·»åŠ é”™è¯¯: ${errorMsg}`);
                errors.push({
                  tag: tag,
                  type: 'missing',
                  message: errorMsg
                });
              }
              // 2. æ£€æŸ¥æ ‡ç­¾é—­åˆæƒ…å†µï¼ˆå¯¹æ‰€æœ‰å­˜åœ¨çš„æ ‡ç­¾ï¼‰
              else if (openTagCount > 0 && closeTagCount === 0) {
                const errorMsg = `&lt;${tag}&gt;æ ‡ç­¾æ²¡é—­åˆ`;
                console.log(`[æ ¼å¼éªŒè¯] æ·»åŠ é”™è¯¯: ${errorMsg}`);
                errors.push({
                  tag: tag,
                  type: 'unclosed',
                  message: errorMsg
                });
              }
              // 3. æ£€æŸ¥åªæœ‰ç»“æŸæ ‡ç­¾çš„æƒ…å†µ
              else if (openTagCount === 0 && closeTagCount > 0) {
                const errorMsg = `&lt;${tag}&gt;æ ‡ç­¾ç¼ºå¤±å¼€å§‹æ ‡ç­¾`;
                console.log(`[æ ¼å¼éªŒè¯] æ·»åŠ é”™è¯¯: ${errorMsg}`);
                errors.push({
                  tag: tag,
                  type: 'incomplete',
                  message: errorMsg
                });
              }
              // 4. æ£€æŸ¥æ ‡ç­¾æ•°é‡ä¸åŒ¹é…çš„æƒ…å†µ
              else if (openTagCount > 0 && closeTagCount > 0 && openTagCount !== closeTagCount) {
                const errorMsg = `&lt;${tag}&gt;æ ‡ç­¾æ²¡é—­åˆ`;
                console.log(`[æ ¼å¼éªŒè¯] æ·»åŠ é”™è¯¯: ${errorMsg}`);
                errors.push({
                  tag: tag,
                  type: 'mismatch',
                  message: errorMsg
                });
              }
            }
            
            return {
              isValid: errors.length === 0,
              errors: errors,
              summary: {
                total: errors.length,
                missing: errors.filter(e => e.type === 'missing').length,
                unclosed: errors.filter(e => e.type === 'unclosed').length,
                incomplete: errors.filter(e => e.type === 'incomplete').length,
                mismatch: errors.filter(e => e.type === 'mismatch').length
              }
            };
          },


          // æ˜¾ç¤ºæ ¼å¼å®¡æŸ¥è¯¦æƒ…ç•Œé¢ï¼ˆå¢å¼ºç‰ˆï¼šæ”¯æŒæ–‡æœ¬æ˜¾ç¤ºå’Œç¼–è¾‘ï¼‰
          showFormatValidationDetails(errors, finalText, options = {}) {
            const modal = document.getElementById('format-validation-modal');
            const errorsList = document.getElementById('format-errors-list');
            const rollbackBtn = document.getElementById('format-validation-rollback');
            const continueBtn = document.getElementById('format-validation-continue');
            
            if (!modal || !errorsList || !rollbackBtn || !continueBtn) return;
            
            // å­˜å‚¨å½“å‰æ–‡æœ¬å’Œé€‰é¡¹åˆ°å®ä¾‹å˜é‡ï¼Œä¾›ç¼–è¾‘åŠŸèƒ½ä½¿ç”¨
            this.currentValidationText = finalText;
            this.currentValidationOptions = options;
            
            // æ¸…ç©ºå¹¶å¡«å……é”™è¯¯åˆ—è¡¨
            errorsList.innerHTML = '';
            
            // æŒ‰é”™è¯¯ç±»å‹åˆ†ç»„æ˜¾ç¤º
            const errorsByType = {
              missing: errors.filter(e => e.type === 'missing'),
              unclosed: errors.filter(e => e.type === 'unclosed'),
              incomplete: errors.filter(e => e.type === 'incomplete'),
              mismatch: errors.filter(e => e.type === 'mismatch')
            };
            
            // å®šä¹‰é”™è¯¯ç±»å‹çš„æ˜¾ç¤ºä¿¡æ¯
            const typeInfo = {
              missing: { icon: 'âŒ', title: 'ç¼ºå¤±å¿…éœ€æ ‡ç­¾', priority: 1 },
              unclosed: { icon: 'âš ï¸', title: 'æ ‡ç­¾æœªé—­åˆ', priority: 2 },
              incomplete: { icon: 'ğŸ”§', title: 'æ ‡ç­¾ä¸å®Œæ•´', priority: 3 },
              mismatch: { icon: 'ğŸ”„', title: 'æ ‡ç­¾æ•°é‡ä¸åŒ¹é…', priority: 4 }
            };
            
            // æŒ‰ä¼˜å…ˆçº§æ˜¾ç¤ºé”™è¯¯
            Object.keys(typeInfo)
              .sort((a, b) => typeInfo[a].priority - typeInfo[b].priority)
              .forEach(type => {
                const typeErrors = errorsByType[type];
                if (typeErrors.length > 0) {
                  // åˆ›å»ºé”™è¯¯ç±»å‹æ ‡é¢˜
                  const typeHeader = document.createElement('div');
                  typeHeader.className = 'format-error-type-header';
                  typeHeader.innerHTML = `
                    <span class="error-type-icon">${typeInfo[type].icon}</span>
                    <span class="error-type-title">${typeInfo[type].title} (${typeErrors.length})</span>
                  `;
                  errorsList.appendChild(typeHeader);
                  
                  // æ˜¾ç¤ºè¯¥ç±»å‹çš„æ‰€æœ‰é”™è¯¯
                  typeErrors.forEach(error => {
                    console.log(`[æ ¼å¼éªŒè¯æ˜¾ç¤º] é”™è¯¯å¯¹è±¡:`, error);
                    console.log(`[æ ¼å¼éªŒè¯æ˜¾ç¤º] é”™è¯¯ä¿¡æ¯: "${error.message}"`);
                    const errorItem = document.createElement('div');
                    errorItem.className = 'format-error-item';
                    
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'format-error-message';
                    // ä½¿ç”¨textContentè€Œä¸æ˜¯innerHTMLï¼Œé¿å…HTMLè§£æ
                    messageDiv.textContent = error.message.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                    
                    errorItem.appendChild(messageDiv);
                    console.log(`[æ ¼å¼éªŒè¯æ˜¾ç¤º] ç”Ÿæˆçš„HTML: ${errorItem.innerHTML}`);
                    errorsList.appendChild(errorItem);
                  });
                }
              });
            
            // å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œæ˜¾ç¤ºå ä½ä¿¡æ¯
            if (errors.length === 0) {
              errorsList.innerHTML = '<div class="format-no-errors">âœ… æ‰€æœ‰æ ‡ç­¾æ ¼å¼æ­£ç¡®</div>';
            }
            // æ›´æ–°æ¨¡æ€æ¡†æ ‡é¢˜ä»¥æ˜¾ç¤ºé”™è¯¯ç»Ÿè®¡å’Œæ­¥éª¤ä¿¡æ¯
            const modalTitle = modal.querySelector('.modal-title');
            if (modalTitle) {
              const summary = [];
              if (errorsByType.missing.length > 0) summary.push(`${errorsByType.missing.length}ä¸ªç¼ºå¤±`);
              if (errorsByType.unclosed.length > 0) summary.push(`${errorsByType.unclosed.length}ä¸ªæœªé—­åˆ`);
              if (errorsByType.incomplete.length > 0) summary.push(`${errorsByType.incomplete.length}ä¸ªä¸å®Œæ•´`);
              if (errorsByType.mismatch.length > 0) summary.push(`${errorsByType.mismatch.length}ä¸ªä¸åŒ¹é…`);
              
              const summaryText = summary.length > 0 ? ` (${summary.join(', ')})` : '';
              const stepInfo = options.stepInfo ? ` - ${options.stepInfo}` : '';
              modalTitle.textContent = `ğŸ” æ ¼å¼å®¡æŸ¥è¯¦æƒ…${stepInfo} - å‘ç° ${errors.length} ä¸ªé—®é¢˜${summaryText}`;
            }
            
            // åˆå§‹åŒ–æ–‡æœ¬æ˜¾ç¤ºå’Œç¼–è¾‘åŠŸèƒ½
            this.initFormatTextEditor(finalText);
            
            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            // 1.ç‚¹å‡»å›é€€
            rollbackBtn.onclick = () => {
              const gameTextDisplay = document.getElementById('game-text-display');
              if (gameTextDisplay && this.lastValidGametxtHTML) {

// ã€æ¢å¤åˆ°ä¸Šä¸€æ¬¡æœ‰æ•ˆçš„å†…å®¹å’Œç›¸å…³åç»­æ•°æ®é€»è¾‘å¤„ç†ã€‘

                gameTextDisplay.innerHTML = this.lastValidGametxtHTML;
                this.updateLiveWordCount(); // 1.è°ƒç”¨å­—æ•°ç»Ÿè®¡å‡½æ•°
                this.showTemporaryMessage('å†…å®¹å·²å›é€€ã€‚');
                this.lastExtractedThinking = this._extractLastTagContent('thinking', this.lastValidGametxtHTML, true);// æ¢å¤æ€ç»´é“¾
                this.saveLastThinking(); // 2.æŒä¹…åŒ–æ¢å¤çš„æ€ç»´å†…å®¹
                const thinkingProcessContainer = document.getElementById('thinking-process-container');
                const thinkingProcessContent = document.getElementById('thinking-process-content');
                if (this.lastExtractedThinking && this.lastExtractedThinking.trim() !== '') {
                    if (thinkingProcessContainer) {
                        thinkingProcessContainer.style.display = 'block'; // å¼ºåˆ¶æ˜¾ç¤ºå®¹å™¨
                    }
                    if (thinkingProcessContent) {
                        try {
                            if (typeof formatAsDisplayedMessage === 'function') {
                                const cleanedContent = this.lastExtractedThinking
                                    .replace(/<thinking>/g, '')
                                    .replace(/<\/thinking>/g, '');
                                thinkingProcessContent.innerHTML = formatAsDisplayedMessage(cleanedContent);
                            } else {
                                thinkingProcessContent.innerHTML = this.simpleMarkdownParse(this.lastExtractedThinking);
                            }
                        } catch (error) {
                            console.error('Error formatting thinking content on rollback:', error);
                            thinkingProcessContent.textContent = this.lastExtractedThinking;
                        }
                        thinkingProcessContent.classList.add('expanded'); // é»˜è®¤å±•å¼€
                        const thinkingProcessIcon = document.getElementById('thinking-process-icon');
                        if (thinkingProcessIcon) {
                            thinkingProcessIcon.classList.remove('collapsed');
                            thinkingProcessIcon.textContent = 'â–¼';
                        }
                    }
                } else {
                    if (thinkingProcessContainer) {
                        thinkingProcessContainer.style.display = 'none'; // å¦‚æœæ²¡æœ‰å†…å®¹åˆ™éšè—
                    }
                }

                // 3.æ¢å¤å˜é‡æ”¹å˜æé†’
                this.updateVariableChangesReminder();

                // 4.æ¢å¤è¡ŒåŠ¨é€‰é¡¹
                this.isActionOptionsEnabled = true; // å¼ºåˆ¶å¼€å¯è¡ŒåŠ¨é€‰é¡¹æ˜¾ç¤º
                const actionOptionsContainer = document.getElementById('action-options-container');
                if (actionOptionsContainer) {
                    actionOptionsContainer.style.display = 'flex'; // ç¡®ä¿å®¹å™¨å¯è§
                }
                const lastActionOptions = this._extractLastTagContent('è¡ŒåŠ¨é€‰é¡¹', this.lastValidGametxtHTML) || this._extractLastTagContent('action', this.lastValidGametxtHTML);
                this.renderActionOptions(lastActionOptions);
              }
              this.closeModal('format-validation-modal'); 
              this.hideWaitingMessage();// 5.å…³é—­ç­‰å¾…æ¶ˆæ¯
            };

            // 2.ç‚¹å‡»ç»§ç»­
            continueBtn.onclick = () => {
              // è·å–å¯èƒ½è¢«ç¼–è¾‘è¿‡çš„æ–‡æœ¬
              const finalTextToProcess = this.currentValidationText || finalText;
              
              this.closeModal('format-validation-modal');
              
              // æ›´æ–°ç¼“å­˜ï¼Œä»¥ä¾¿ä¸‹æ¬¡å‡ºé”™æ—¶å›é€€åˆ°è¿™ä¸ªç‰ˆæœ¬
              const gameTextDisplay = document.getElementById('game-text-display');
              if (gameTextDisplay) {
                this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
              }
              
              // å¦‚æœæ˜¯æ­¥è¿›å¼æ¨¡å¼ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
              if (options.isStepwise) {
                if (options.step === 1) {
                  // ç¬¬ä¸€æ­¥ï¼šæ›´æ–°ç¼“å­˜å¹¶ç»§ç»­ç¬¬äºŒæ­¥ï¼Œä¿æŒç­‰å¾…æ¶ˆæ¯æ˜¾ç¤º
                  this.updateWaitingMessage('åˆ†æ­¥å˜é‡æ›´æ–°ing');
                  this.cachedFirstStepText = finalTextToProcess;
                  this.generateVariablesStep(finalTextToProcess);
                } else if (options.step === 2) {
                  // ç¬¬äºŒæ­¥ï¼šåˆå¹¶æ–‡æœ¬å¹¶ç»§ç»­å¤„ç†ï¼Œå…³é—­ç­‰å¾…æ¶ˆæ¯
                  this.hideWaitingMessage();
                  this.showTemporaryMessage('å·²ä¿ç•™å†…å®¹ï¼Œå°†ç»§ç»­è¿›è¡Œæ•°æ®å¤„ç†ã€‚');
                  const processedSecondStepText = this._processSecondStepResponse(finalTextToProcess);
                  const fusedFinalText = this._mergeStepwiseTexts(this.cachedFirstStepText, processedSecondStepText);
                  this.continueProcessingWithAutoFix(fusedFinalText);
                }
              } else {
                // æ™®é€šæ¨¡å¼ï¼šå…³é—­ç­‰å¾…æ¶ˆæ¯å¹¶ç»§ç»­å¤„ç†
                this.hideWaitingMessage();
                this.continueProcessingWithAutoFix(finalTextToProcess);
              }
            };
            
            this.openModal('format-validation-modal');
          },

          // åˆå§‹åŒ–æ ¼å¼å®¡æŸ¥æ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆæ–°å¢ï¼šæ¨¡å—åŒ–ã€å¯å¤ç”¨ç»„ä»¶ï¼‰
          initFormatTextEditor(text) {
            const textDisplay = document.getElementById('format-text-display');
            const textEditor = document.getElementById('format-text-editor');
            const editToggle = document.getElementById('format-text-edit-toggle');
            const editIcon = document.getElementById('format-text-edit-icon');
            const editHint = document.getElementById('format-edit-hint');
            
            if (!textDisplay || !textEditor || !editToggle) return;
            
            // åˆå§‹åŒ–æ˜¾ç¤ºæ–‡æœ¬
            textDisplay.textContent = text;
            textEditor.value = text;
            
            // é‡ç½®ä¸ºæ˜¾ç¤ºæ¨¡å¼
            textDisplay.style.display = 'block';
            textEditor.style.display = 'none';
            if (editHint) editHint.style.display = 'none';
            editIcon.textContent = 'âœï¸ ç¼–è¾‘';
            
            let isEditMode = false;
            
            // ç¼–è¾‘/ä¿å­˜åˆ‡æ¢
            editToggle.onclick = () => {
              isEditMode = !isEditMode;
              
              if (isEditMode) {
                // åˆ‡æ¢åˆ°ç¼–è¾‘æ¨¡å¼
                textDisplay.style.display = 'none';
                textEditor.style.display = 'block';
                if (editHint) editHint.style.display = 'block';
                editIcon.textContent = 'ğŸ’¾ ä¿å­˜';
                textEditor.focus();
              } else {
                // åˆ‡æ¢åˆ°æ˜¾ç¤ºæ¨¡å¼ï¼Œä¿å­˜ç¼–è¾‘
                const editedText = textEditor.value;
                textDisplay.textContent = editedText;
                textDisplay.style.display = 'block';
                textEditor.style.display = 'none';
                if (editHint) editHint.style.display = 'none';
                editIcon.textContent = 'âœï¸ ç¼–è¾‘';
                
                // æ›´æ–°å½“å‰éªŒè¯æ–‡æœ¬
                this.currentValidationText = editedText;
                
                // é‡æ–°éªŒè¯æ ¼å¼
                const validationResult = this.validateResponseFormat(editedText);
                const errorsList = document.getElementById('format-errors-list');
                const modalTitle = document.querySelector('#format-validation-modal .modal-title');
                
                if (validationResult.isValid) {
                  errorsList.innerHTML = '<div class="format-no-errors">âœ… æ‰€æœ‰æ ‡ç­¾æ ¼å¼æ­£ç¡®</div>';
                  if (modalTitle) {
                    const stepInfo = this.currentValidationOptions?.stepInfo ? ` - ${this.currentValidationOptions.stepInfo}` : '';
                    modalTitle.textContent = `ğŸ” æ ¼å¼å®¡æŸ¥è¯¦æƒ…${stepInfo} - æ ¼å¼æ­£ç¡®`;
                  }
                  this.showTemporaryMessage('æ–‡æœ¬å·²ä¿å­˜ï¼Œæ ¼å¼éªŒè¯é€šè¿‡ï¼', 2000);
                } else {
                  // é‡æ–°æ¸²æŸ“é”™è¯¯åˆ—è¡¨
                  this.renderFormatErrors(validationResult.errors, errorsList);
                  if (modalTitle) {
                    const summary = [];
                    const errorsByType = {
                      missing: validationResult.errors.filter(e => e.type === 'missing'),
                      unclosed: validationResult.errors.filter(e => e.type === 'unclosed'),
                      incomplete: validationResult.errors.filter(e => e.type === 'incomplete'),
                      mismatch: validationResult.errors.filter(e => e.type === 'mismatch')
                    };
                    if (errorsByType.missing.length > 0) summary.push(`${errorsByType.missing.length}ä¸ªç¼ºå¤±`);
                    if (errorsByType.unclosed.length > 0) summary.push(`${errorsByType.unclosed.length}ä¸ªæœªé—­åˆ`);
                    if (errorsByType.incomplete.length > 0) summary.push(`${errorsByType.incomplete.length}ä¸ªä¸å®Œæ•´`);
                    if (errorsByType.mismatch.length > 0) summary.push(`${errorsByType.mismatch.length}ä¸ªä¸åŒ¹é…`);
                    const summaryText = summary.length > 0 ? ` (${summary.join(', ')})` : '';
                    const stepInfo = this.currentValidationOptions?.stepInfo ? ` - ${this.currentValidationOptions.stepInfo}` : '';
                    modalTitle.textContent = `ğŸ” æ ¼å¼å®¡æŸ¥è¯¦æƒ…${stepInfo} - å‘ç° ${validationResult.errors.length} ä¸ªé—®é¢˜${summaryText}`;
                  }
                  this.showTemporaryMessage('æ–‡æœ¬å·²ä¿å­˜ï¼Œä½†ä»æœ‰æ ¼å¼é—®é¢˜', 2000);
                }
              }
            };
          },

          // æ¸²æŸ“æ ¼å¼é”™è¯¯åˆ—è¡¨ï¼ˆæå–ä¸ºç‹¬ç«‹æ–¹æ³•ï¼Œä¾¿äºå¤ç”¨ï¼‰
          renderFormatErrors(errors, errorsList) {
            errorsList.innerHTML = '';
            
            const errorsByType = {
              missing: errors.filter(e => e.type === 'missing'),
              unclosed: errors.filter(e => e.type === 'unclosed'),
              incomplete: errors.filter(e => e.type === 'incomplete'),
              mismatch: errors.filter(e => e.type === 'mismatch')
            };
            
            const typeInfo = {
              missing: { icon: 'âŒ', title: 'ç¼ºå¤±å¿…éœ€æ ‡ç­¾', priority: 1 },
              unclosed: { icon: 'âš ï¸', title: 'æ ‡ç­¾æœªé—­åˆ', priority: 2 },
              incomplete: { icon: 'ğŸ”§', title: 'æ ‡ç­¾ä¸å®Œæ•´', priority: 3 },
              mismatch: { icon: 'ğŸ”„', title: 'æ ‡ç­¾æ•°é‡ä¸åŒ¹é…', priority: 4 }
            };
            
            Object.keys(typeInfo)
              .sort((a, b) => typeInfo[a].priority - typeInfo[b].priority)
              .forEach(type => {
                const typeErrors = errorsByType[type];
                if (typeErrors.length > 0) {
                  const typeHeader = document.createElement('div');
                  typeHeader.className = 'format-error-type-header';
                  typeHeader.innerHTML = `
                    <span class="error-type-icon">${typeInfo[type].icon}</span>
                    <span class="error-type-title">${typeInfo[type].title} (${typeErrors.length})</span>
                  `;
                  errorsList.appendChild(typeHeader);
                  
                  typeErrors.forEach(error => {
                    const errorItem = document.createElement('div');
                    errorItem.className = 'format-error-item';
                    
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'format-error-message';
                    messageDiv.textContent = error.message.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                    
                    errorItem.appendChild(messageDiv);
                    errorsList.appendChild(errorItem);
                  });
                }
              });
            
            if (errors.length === 0) {
              errorsList.innerHTML = '<div class="format-no-errors">âœ… æ‰€æœ‰æ ‡ç­¾æ ¼å¼æ­£ç¡®</div>';
            }
          },

          // --- æ–°å¢ï¼šå¸¦è‡ªåŠ¨ä¿®å¤çš„ç»§ç»­å¤„ç†å‡½æ•° ---
          async continueProcessingWithAutoFix(textToProcess) {
            if (!textToProcess || textToProcess.trim() === '') {
              console.error('[å½’å¢Ÿ] continueProcessingWithAutoFix æ¥æ”¶åˆ°ç©ºæ–‡æœ¬ï¼Œåœæ­¢å¤„ç†');
              this.hideWaitingMessage();
              this.showTemporaryMessage('é”™è¯¯ï¼šæ¥æ”¶åˆ°ç©ºå†…å®¹ï¼Œæ— æ³•ç»§ç»­å¤„ç†ã€‚');
              return;
            }
            
            // æ£€æŸ¥å¹¶è‡ªåŠ¨è¡¥å…¨UpdateVariableæ ‡ç­¾
            let fixedText = this.autoFixUpdateVariable(textToProcess);
            
            // è°ƒç”¨åŸæœ‰çš„å¤„ç†é€»è¾‘
            await this.continueProcessing(fixedText);
          },



// ===æ ¼å¼å®¡æŸ¥æ¨¡å—ç»“æŸ===



// ===æ ‡ç­¾è‡ªåŠ¨è¡¥å…¨æ¨¡å—å¼€å§‹===



          autoFixUpdateVariable(text) {
            // åªæ£€æŸ¥æ˜¯å¦å­˜åœ¨</UpdateVariable>ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™åœ¨æœ«å°¾æ·»åŠ ä¸€ä¸ª
            if (text.includes('<UpdateVariable>') && text.indexOf('</UpdateVariable>') === -1) {
              console.log('[å½’å¢Ÿ] æœªæ‰¾åˆ° </UpdateVariable> æ ‡ç­¾ï¼Œè‡ªåŠ¨åœ¨æœ«å°¾æ·»åŠ ã€‚');
              this.showTemporaryMessage('å·²è‡ªåŠ¨è¡¥å…¨UpdateVariableç»“æŸæ ‡ç­¾', 3000);
              return text + '</UpdateVariable>';
            }
            return text;
          },


          /**
           * æ ‡ç­¾è¡¥å…¨å‡½æ•°ï¼šåœ¨æ ¼å¼å®¡æŸ¥å‰å¯¹æ–‡æœ¬è¿›è¡Œæ ‡ç­¾è¡¥å…¨
           * @param {string} text - åŸå§‹æ–‡æœ¬
           * @param {boolean} isSecondStep - æ˜¯å¦æ˜¯ç¬¬äºŒæ­¥(å˜é‡ç”Ÿæˆæ­¥éª¤)
           * @returns {string} - è¡¥å…¨åçš„æ–‡æœ¬
           */
          autoFixTags(text, isSecondStep = false) {
            if (!text || text.trim() === '') {
              return text;
            }

            let fixedText = text;

            // ç¬¬äºŒæ­¥ï¼šåªå¤„ç†UpdateVariableæ ‡ç­¾è¡¥å…¨
            if (isSecondStep) {
              // å¦‚æœåªæœ‰<UpdateVariable>è€Œæ²¡æœ‰</UpdateVariable>ï¼Œåœ¨ç»“å°¾æ·»åŠ 
              if (fixedText.includes('<UpdateVariable>') && fixedText.indexOf('</UpdateVariable>') === -1) {
                console.log('[æ ‡ç­¾è¡¥å…¨] ç¬¬äºŒæ­¥ï¼šè¡¥å…¨</UpdateVariable>æ ‡ç­¾');
                fixedText = fixedText + '</UpdateVariable>';
              }
              return fixedText;
            }

            // ç¬¬ä¸€æ­¥ï¼šå¤„ç†thinkingå’Œgametxtæ ‡ç­¾

            // 1. è¡¥å…¨<thinking>å¼€å§‹æ ‡ç­¾
            const hasClosingThinking = /<\/thinking>/i.test(fixedText);
            const hasOpeningThinking = /<thinking>/i.test(fixedText);

            if (hasClosingThinking && !hasOpeningThinking) {
              console.log('[æ ‡ç­¾è¡¥å…¨] ç¬¬ä¸€æ­¥ï¼šåœ¨å¼€å¤´è¡¥å…¨<thinking>æ ‡ç­¾');
              fixedText = '<thinking>' + fixedText;
            }

            // 2. æ¸…ç†æœ€åä¸€ä¸ªé—­åˆçš„<gametxt>ä¹‹å‰çš„éæ³•æ ‡ç­¾
            // åˆ†æˆ<gametxt>ä¹‹å‰å’Œä¹‹åä¸¤éƒ¨åˆ†ï¼Œæ¸…ç†ä¹‹å‰çš„å…¨éƒ¨æ ‡ç­¾ï¼Œé™¤äº†<thinking>å’Œ</thinking>
            
            const lastClosingGametxtRegex = /<\/gametxt>/gi;
            let lastClosingGametxtIndex = -1;
            let match;
            while ((match = lastClosingGametxtRegex.exec(fixedText)) !== null) {
              lastClosingGametxtIndex = match.index;
            }

            if (lastClosingGametxtIndex !== -1) {
              const textBeforeClosing = fixedText.substring(0, lastClosingGametxtIndex);
              const openingGametxtRegex = /<gametxt>/gi;
              let lastOpeningGametxtIndex = -1;
              let openMatch;
              while ((openMatch = openingGametxtRegex.exec(textBeforeClosing)) !== null) {
                lastOpeningGametxtIndex = openMatch.index;
              }

              if (lastOpeningGametxtIndex !== -1) {
                // åˆ†æˆä¸¤éƒ¨åˆ†ï¼š<gametxt>ä¹‹å‰ å’Œ <gametxt>ä¹‹å
                const beforeGametxt = fixedText.substring(0, lastOpeningGametxtIndex);
                const afterGametxt = fixedText.substring(lastOpeningGametxtIndex);

                // æ¸…ç†beforeGametxtä¸­é™¤äº†<thinking>å’Œ</thinking>ä¹‹å¤–çš„æ‰€æœ‰æ ‡ç­¾
                // ä½¿ç”¨æ­£åˆ™æ›¿æ¢ï¼Œæ’é™¤<thinking>å’Œ</thinking>
                const cleaned = beforeGametxt.replace(/<(?!\/?thinking>)[^>]+>/gi, 'ã€fwå“ˆåŸºç±³åˆåœ¨æ­£æ–‡æ€è€ƒåŠ å…¥æ ‡ç­¾ã€‘');
                fixedText = cleaned + afterGametxt;
              }
            }

            return fixedText;
          },

// ===æ ‡ç­¾è‡ªåŠ¨è¡¥å…¨æ¨¡å—ç»“æŸ===



// ===å½’å¢Ÿæ•´ä½“å…³é”®æ•°æ®æµç¨‹å¤„ç†å’Œ0å±‚æ¸¸ç©é€»è¾‘ç›¸å…³æ¨¡å—å¼€å§‹===



          // ä¸“é—¨ç”¨äºæ ¼å¼éªŒè¯åç»§ç»­å¤„ç†çš„å‡½æ•°
          async continueProcessing(textToProcess) {
            console.log('[å½’å¢Ÿ] continueProcessing è¢«è°ƒç”¨ï¼Œæ–‡æœ¬é•¿åº¦:', textToProcess ? textToProcess.length : 0);
            // åœ¨å¤„ç†ä¸»è¦é€»è¾‘å‰ï¼Œå…ˆå‡†å¤‡å¥½æ¸…ç†è¿‡çš„æ–‡æœ¬ï¼Œç”¨äºåç»­è®¡ç®—
            const thinkingRegex = /<thinking>[\s\S]*?<\/thinking>/gi;
            const cleanedText = textToProcess.replace(thinkingRegex, '');

            // 1. æå–æ‰€æœ‰æ•°æ®
            this.lastExtractedNovelText = this._extractLastTagContent('gametxt', textToProcess);
            this.lastExtractedJourney = this._extractLastTagContent('æœ¬ä¸–å†ç¨‹', textToProcess);
            this.lastExtractedPastLives = this._extractLastTagContent('å¾€ä¸–æ¶Ÿæ¼ª', textToProcess);
            this.lastExtractedThinking = this._extractLastTagContent('thinking', textToProcess, true);
            this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', textToProcess, true);
            this.lastExtractedCharacterCard = this._extractLastTagContent('è§’è‰²æå–', textToProcess);

            this.saveLastThinking();
            this.updateThinkingButtonVisibility();
            this.updateCurrentLifeButtonVisibility(); // æ–°å¢:æ›´æ–°æœ¬ä¸–å†ç¨‹æŒ‰é’®æ˜¾ç¤º
            this.updatePastLivesButtonVisibility(); // æ–°å¢:æ›´æ–°å¾€ä¸–æ¶Ÿæ¼ªæŒ‰é’®æ˜¾ç¤º
            this.updateVariableChangesReminder();
            await this.updateHistoricalText(); // æ›´æ–°å†å²æ­£æ–‡
            
            // AIå›å¤åè‡ªåŠ¨è·³è½¬åˆ°å½“å‰æ­£æ–‡å¼€å¤´,é€šè¿‡æ¨¡æ‹Ÿç‚¹å‡»â€œæœ¬ç« â€æŒ‰é’®å®ç°
            setTimeout(() => {
              const scrollToBottomBtn = document.getElementById('scroll-to-bottom-btn');
              if (scrollToBottomBtn) {
                console.log('[å½’å¢Ÿ] AIå›å¤å®Œæˆ,è§¦å‘â€œæœ¬ç« â€æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶è¿›è¡Œè·³è½¬ã€‚');
                scrollToBottomBtn.click();
             } else {
                console.error('[å½’å¢Ÿ] æœªæ‰¾åˆ°â€œæœ¬ç« â€æŒ‰é’®(scroll-to-bottom-btn),æ— æ³•æ‰§è¡Œè‡ªåŠ¨è·³è½¬ã€‚');
              }
              
              // æ›´æ–°ç« èŠ‚å¯¼èˆªæŒ‰é’®çŠ¶æ€
              if (typeof this.updateChapterNavigation === 'function') {
                this.updateChapterNavigation();
              }
            }, 100); // å»¶è¿Ÿ100msç¡®ä¿DOMå·²æ›´æ–°

            // 2. æ›´æ–°å˜é‡
            const updateScript = textToProcess;
            if (updateScript && this.currentMvuState) {
                const inputData = { old_variables: this.currentMvuState };
                let mvuSucceeded = false;
                try {
                    const mvuPromise = eventEmit('mag_invoke_mvu', updateScript, inputData);
                    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('MVU event timeout')), 3000));
                    await Promise.race([mvuPromise, timeoutPromise]);

                    if (inputData.new_variables) {
                      this.currentMvuState = this._safeLoadMvuData(inputData.new_variables);
                      this.renderUI(this.currentMvuState.stat_data);
                        mvuSucceeded = true;
                    } else {
                        console.log('[å½’å¢Ÿ] mvu æœªè¿”å›æ–°çŠ¶æ€ï¼Œå°è¯•å‰ç«¯å¤‡ç”¨æ–¹æ¡ˆã€‚');
                    }
                } catch (eventError) {
                    console.error('[å½’å¢Ÿ] è°ƒç”¨ mag_invoke_mvu äº‹ä»¶æ—¶å‘ç”Ÿé”™è¯¯æˆ–è¶…æ—¶ï¼Œå°è¯•å‰ç«¯å¤‡ç”¨æ–¹æ¡ˆ:', eventError);
                }

                if (!mvuSucceeded) {
                    console.log('[å½’å¢Ÿ] å°è¯•ä½¿ç”¨ Mvu API ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ');
                    try {
                        // ä½¿ç”¨ Mvu API ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
                        const mvu_data = Mvu.getMvuData({ type: 'message', message_id: 'latest' });
                        const updatedMvuData = await Mvu.parseMessage(updateScript, mvu_data);
                        
                        if (updatedMvuData) {
                            await Mvu.replaceMvuData(updatedMvuData, { type: 'message', message_id: 'latest' });
                            this.currentMvuState = updatedMvuData;
                            this.renderUI(this.currentMvuState.stat_data);
                            console.log('[å½’å¢Ÿ] Mvu API å¤‡ç”¨æ–¹æ¡ˆæ‰§è¡ŒæˆåŠŸ');
                        }
                    } catch (mvuApiError) {
                        console.warn('[å½’å¢Ÿ] Mvu API å¤‡ç”¨æ–¹æ¡ˆä¹Ÿå¤±è´¥ï¼Œä½¿ç”¨å‰ç«¯è§£æå™¨:', mvuApiError);
                        // æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨å‰ç«¯è§£æå™¨
                        const modifiedState = this._applyUpdateFallback(updateScript, this.currentMvuState);
                        if (modifiedState) {
                            this.currentMvuState = modifiedState;
                            this.renderUI(this.currentMvuState.stat_data);
                        }
                    }
                }
            }

            // 3. æ›´æ–°è¡ŒåŠ¨é€‰é¡¹
            let actionOptionsContent = this._extractLastTagContent('è¡ŒåŠ¨é€‰é¡¹', textToProcess);
            if (!actionOptionsContent) {
               actionOptionsContent = this._extractLastTagContent('action', textToProcess);
            }
            this.renderActionOptions(actionOptionsContent);

            // 4. é™é»˜ä¿å­˜åˆ°ç¬¬0å±‚
            const messages = await getChatMessages('0');
            if (messages && messages.length > 0) {
                const messageZero = messages[0];
                messageZero.message = textToProcess;
                messageZero.data = this.currentMvuState;
                await TavernHelper.setChatMessages([messageZero], { refresh: 'none' });
            }

            // 5. æ¸…ç†å·¥ä½œ
            const input = document.getElementById('quick-send-input');
            if (input) input.value = '';
            this.pendingActions = [];
            this.savePendingActions();
            // this.showTemporaryMessage('ä¼Ÿå¤§æ¢¦æ˜Ÿå·²å›åº”ã€‚');

            // 6. è‡ªåŠ¨å­˜æ¡£
            if (this.isAutoSaveEnabled) {
                await this.performAutoSave();     
                        this.lastUserMessage = '';  
                        this.showTemporaryMessage('è‡ªåŠ¨å­˜æ¡£æˆåŠŸäº†ï¼ï¼ï¼å¥½æ¬¸ï¼ï¼ï¼','success');
       }

            // 7.æ¸²æŸ“ä¸»ç•Œé¢çš„æ­£æ–‡å†…å®¹
            const gameTextDisplay = document.getElementById('game-text-display');
            if (gameTextDisplay && this.lastExtractedNovelText) {
                gameTextDisplay.innerHTML = this.formatMessageContent(this.lastExtractedNovelText);
                this.updateLiveWordCount();
            }

            // 8. æœ€ç»ˆåˆ·æ–°UI
            await this.updateDynamicData();
            
            // 9. å¦‚æœæ˜¯éšæœºæ¨¡å¼ï¼Œåˆ‡æ¢èƒŒæ™¯å›¾
            if (this.backgroundMode === 'random') {
              this.applyRandomBackground();
            }
            
            this.hideWaitingMessage();
          },

          async handleStreamEnd(finalText) {
            if (typeof TavernHelper.stopGeneration === 'function') {
              TavernHelper.stopGeneration();
              console.log('[å½’å¢Ÿ] å·²è°ƒç”¨ TavernHelper.stopGeneration()');
            }

            this.isStreamingGametxt = false; // é‡ç½®æµå¼çŠ¶æ€

            // ====== æ­¥è¿›å¼ç”Ÿæˆæ¨¡å¼ä¼˜å…ˆå¤„ç† ======
            // å¿…é¡»åœ¨æ‰€æœ‰å…¶ä»–é€»è¾‘ä¹‹å‰æ£€æŸ¥å’Œå¤„ç†æ­¥è¿›å¼æ¨¡å¼
            
            // æ­¥è¿›å¼ç¬¬ä¸€æ­¥å®Œæˆ
            if (this.generationStep === 1) {
                this.cachedFirstStepText = finalText;
                if (!this.cachedFirstStepText || this.cachedFirstStepText.trim() === '') {
                    console.error('[å½’å¢Ÿ] âŒ æ­¥è¿›å¼ç”Ÿæˆï¼šç¬¬ä¸€æ­¥è¿”å›ç©ºæ–‡æœ¬ï¼');
                    this.showTemporaryMessage('é”™è¯¯ï¼šç¬¬ä¸€æ­¥è¿”å›ç©ºå†…å®¹', 3000);
                    this.generationStep = 0;
                    this.isStepwiseFirstStep = false;
                    this.hideWaitingMessage();
                    return;
                }
                const gameTextDisplay = document.getElementById('game-text-display');
                if (gameTextDisplay) {
                    this.stepwiseDisplayedMainContent = gameTextDisplay.innerHTML;
                }

                // æ–°å¢ï¼šç¬¬ä¸€æ­¥æ ¼å¼å®¡æŸ¥å‰å…ˆè¿›è¡Œæ ‡ç­¾è¡¥å…¨
                let processedText = finalText;
                if (this.isFormatValidationEnabled) {
                    // åœ¨æ ¼å¼å®¡æŸ¥å‰å…ˆè¿›è¡Œæ ‡ç­¾è¡¥å…¨ï¼ˆç¬¬ä¸€æ­¥ï¼‰
                    processedText = this.autoFixTags(finalText, false);
                    const validationResult = this.validateResponseFormat(processedText);
                    if (!validationResult.isValid) {
                        console.log('[å½’å¢Ÿ] æ­¥è¿›å¼ç¬¬ä¸€æ­¥ï¼šæ ¼å¼éªŒè¯å¤±è´¥ï¼Œæ˜¾ç¤ºå®¡æŸ¥ç•Œé¢');
                        this.showFormatValidationDetails(validationResult.errors, processedText, {
                            isStepwise: true,
                            step: 1,
                            stepInfo: 'æ­¥è¿›å¼ç¬¬ä¸€æ­¥ï¼ˆä¸»å†…å®¹ç”Ÿæˆï¼‰'
                        });
                        return; // ç­‰å¾…ç”¨æˆ·æ“ä½œ
                    }
                }

                // å…³é”®ï¼šåœ¨è°ƒç”¨ç¬¬äºŒæ­¥ä¹‹å‰è®¾ç½®æ ‡å¿—
                this.isStepwiseFirstStep = false;
                this.isStepwiseSecondStep = true;
                
                // è§¦å‘ç¬¬äºŒæ­¥ï¼šç”Ÿæˆå˜é‡ï¼ˆä½¿ç”¨å¤„ç†åçš„æ–‡æœ¬ï¼‰
                this.cachedFirstStepText = processedText;
                await this.generateVariablesStep(processedText);
                return; // å…³é”®ï¼šç›´æ¥è¿”å›ï¼Œä¸æ‰§è¡Œåç»­ä»»ä½•é€»è¾‘
            }
            
            // æ­¥è¿›å¼ç¬¬äºŒæ­¥å®Œæˆ
            if (this.generationStep === 2) {
                console.log('==================== ç¬¬äºŒæ­¥ç”Ÿæˆå†…å®¹å¼€å§‹ ====================');
                console.log(finalText);
                console.log('==================== ç¬¬äºŒæ­¥ç”Ÿæˆå†…å®¹ç»“æŸ ====================');
                
                // æ–°å¢ï¼šç¬¬äºŒæ­¥æ ¼å¼å®¡æŸ¥å‰å…ˆè¿›è¡Œæ ‡ç­¾è¡¥å…¨
                let processedStep2Text = finalText;
                if (this.isFormatValidationEnabled) {
                    // åœ¨æ ¼å¼å®¡æŸ¥å‰å…ˆè¿›è¡Œæ ‡ç­¾è¡¥å…¨ï¼ˆç¬¬äºŒæ­¥ï¼‰
                    processedStep2Text = this.autoFixTags(finalText, true);
                    // ä¸ºç¬¬äºŒæ­¥åˆ›å»ºç‰¹æ®Šçš„éªŒè¯é…ç½®ï¼ˆåªæ£€æŸ¥UpdateVariableï¼‰
                    const step2ValidationResult = this.validateStep2Response(processedStep2Text);
                    if (!step2ValidationResult.isValid) {
                        console.log('[å½’å¢Ÿ] æ­¥è¿›å¼ç¬¬äºŒæ­¥ï¼šæ ¼å¼éªŒè¯å¤±è´¥ï¼Œæ˜¾ç¤ºå®¡æŸ¥ç•Œé¢');
                        this.showFormatValidationDetails(step2ValidationResult.errors, processedStep2Text, {
                            isStepwise: true,
                            step: 2,
                            stepInfo: 'æ­¥è¿›å¼ç¬¬äºŒæ­¥ï¼ˆå˜é‡ç”Ÿæˆï¼‰'
                        });
                        return; // ç­‰å¾…ç”¨æˆ·æ“ä½œ
                    }
                }
                
                const processedSecondStepText = this._processSecondStepResponse(processedStep2Text);
                console.log('[å½’å¢Ÿ] ğŸ“„ å¤„ç†åçš„ç¬¬äºŒæ­¥å†…å®¹:');
                console.log(processedSecondStepText);
                // åˆå¹¶ç¬¬ä¸€æ­¥å’Œç¬¬äºŒæ­¥çš„æ–‡æœ¬
                const fusedFinalText = this._mergeStepwiseTexts(this.cachedFirstStepText, processedSecondStepText);
                this.generationStep = 0;
                this.cachedFirstStepText = null;
                this.isStepwiseAppendMode = false;
                this.stepwiseDisplayedMainContent = '';
                this.isStepwiseFirstStep = false;
                this.isStepwiseSecondStep = false;
                finalText = fusedFinalText;
            }
            
            // ====== æ­¥è¿›å¼æ¨¡å¼å¤„ç†ç»“æŸ ======

            // 10.å¤„ç†AIç”Ÿæˆçš„è§’è‰²å¡ï¼ˆè¡æ¢¦å°˜ï¼‰
            if (this.pendingCharacterCardGeneration) {
                const charName = this.pendingCharacterCardGeneration;
                const tagName = 'CharacterCard';
                const cardContent = this._extractLastTagContent(tagName, finalText);

                if (cardContent) {
                    try {
                        const bookName = '1å½’å¢Ÿ';
                        const allEntries = await TavernHelper.getLorebookEntries(bookName);
                        const targetEntry = allEntries.find(entry => entry.comment === charName);
                        if (targetEntry) {
                            await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: cardContent }]);
                            this.showTemporaryMessage(`å·²æˆåŠŸä¸ºâ€œ${charName}â€ç”Ÿæˆå¹¶å†™å…¥è§’è‰²å¡ï¼`, 3000);
                        } else {
                            throw new Error(`æœªæ‰¾åˆ°åä¸ºâ€œ${charName}â€çš„ä¸–ç•Œä¹¦æ¡ç›®ã€‚`);
                        }
                    } catch (error) {
                        console.error('å†™å…¥ç”Ÿæˆçš„è§’è‰²å¡å¤±è´¥:', error);
                        this.showTemporaryMessage(`é”™è¯¯ï¼šå†™å…¥â€œ${charName}â€çš„è§’è‰²å¡å¤±è´¥ï¼`, 4000);
                    }
                } else {
                    this.showTemporaryMessage(`è­¦å‘Šï¼šAIå›å¤ä¸­æœªæ‰¾åˆ°â€œ${charName}â€çš„è§’è‰²å¡æ ‡ç­¾ï¼Œè¯·æ‰‹åŠ¨æ£€æŸ¥å¹¶å¡«å…¥ä¸–ç•Œä¹¦ã€‚`, 5000);
                }
                this.pendingCharacterCardGeneration = null; // å¤„ç†å®Œæ¯•ï¼Œé‡ç½®è¿½è¸ªå˜é‡
            }


            // 11.æ ¼å¼éªŒè¯é€»è¾‘ï¼ˆåœ¨æ ¼å¼å®¡æŸ¥å‰å…ˆè¿›è¡Œæ ‡ç­¾è¡¥å…¨ï¼‰
            let processedFinalText = finalText;
            if (this.isFormatValidationEnabled) {
                // åœ¨æ ¼å¼å®¡æŸ¥å‰å…ˆè¿›è¡Œæ ‡ç­¾è¡¥å…¨ï¼ˆä¸€æ¬¡æ€§ç”Ÿæˆï¼‰
                processedFinalText = this.autoFixTags(finalText, false);
                const validationResult = this.validateResponseFormat(processedFinalText);
                if (!validationResult.isValid) {
                    // æ˜¾ç¤ºè¯¦ç»†çš„æ ¼å¼å®¡æŸ¥ç•Œé¢ï¼Œè®©ç”¨æˆ·å†³å®šå¦‚ä½•æ“ä½œ
                    this.showFormatValidationDetails(validationResult.errors, processedFinalText);
                } else {
                    // æ ¼å¼æ­£ç¡®ï¼Œç¼“å­˜æœ‰æ•ˆHTMLï¼Œç„¶åç»§ç»­å¤„ç†
                    const gameTextDisplay = document.getElementById('game-text-display');
                    if (gameTextDisplay) {
                        this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
                    }
                    // ç›´æ¥è°ƒç”¨å¸¦æœ‰è‡ªåŠ¨ä¿®å¤åŠŸèƒ½çš„å¤„ç†å‡½æ•°ï¼ˆä½¿ç”¨å¤„ç†åçš„æ–‡æœ¬ï¼‰
                    await this.continueProcessingWithAutoFix(processedFinalText);
                }
            } else {
                // ç¦ç”¨å®¡æŸ¥æ—¶ä¹Ÿè¿›è¡Œæ ‡ç­¾è¡¥å…¨
                processedFinalText = this.autoFixTags(finalText, false);
                const gameTextDisplay = document.getElementById('game-text-display');
                if (gameTextDisplay) {
                    this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
                }
                // ç›´æ¥è°ƒç”¨å¸¦æœ‰è‡ªåŠ¨ä¿®å¤åŠŸèƒ½çš„å¤„ç†å‡½æ•°ï¼ˆä½¿ç”¨å¤„ç†åçš„æ–‡æœ¬ï¼‰
                await this.continueProcessingWithAutoFix(processedFinalText);
            }

            // 12.AIç”Ÿæˆç»“æŸåï¼Œè§¦å‘ä¸€æ¬¡åˆ†æ®µè®°å¿†æ›´æ–°
            if (this.isSegmentedMemoryAutoGenerateEnabled) {
                console.log('[å½’å¢Ÿ] åˆ†æ®µè®°å¿†æ›´æ–°ing...');
                await this.generateSegmentedMemory(false);
            }
            if (this.isSmallSummaryAutoOn) {
                await this.generateSmallSummary(false);
            }
            if (this.isLargeSummaryAutoOn) {
                await this.generateLargeSummary(false);
            }
          },


// ===å½’å¢Ÿæ•´ä½“å…³é”®æ•°æ®æµç¨‹å¤„ç†å’Œ0å±‚æ¸¸ç©é€»è¾‘ç›¸å…³æ¨¡å—ç»“æŸ===




// ===å…¨å±æ¨¡å—å¼€å§‹===



          toggleFullScreen() {
            const elem = document.querySelector('.guixu-root-container');
            if (!document.fullscreenElement) {
              elem.requestFullscreen().catch(err => {
                alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
              });
            } else {
              document.exitFullscreen();
            }
          },

          exitFullScreen() {
              if (document.fullscreenElement) {
                  document.exitFullscreen();
              }
          },



// ===å…¨å±æ¨¡å—ç»“æŸ===




// ===é¢æ¿æŠ˜å æ¨¡å—å¼€å§‹===



          toggleLeftPanel() {
            this.leftPanelCollapsed = !this.leftPanelCollapsed;
            this.updatePanelStates();
            this.savePanelStates();
          },

          toggleRightPanel() {
            this.rightPanelCollapsed = !this.rightPanelCollapsed;
            this.updatePanelStates();
            this.savePanelStates();
          },

          updatePanelStates() {
            this.applyPanelWidths(); // æ–°å¢ï¼šåº”ç”¨é¢æ¿å®½åº¦
            const gameContainer = document.querySelector('.game-container');
            const leftPanel = document.querySelector('.character-panel');
            const rightPanel = document.querySelector('.interaction-panel');
            
            if (!gameContainer || !leftPanel || !rightPanel) return;

            // æ›´æ–°game-containerçš„CSSç±»
            gameContainer.classList.toggle('left-panel-collapsed', this.leftPanelCollapsed);
            gameContainer.classList.toggle('right-panel-collapsed', this.rightPanelCollapsed);
            gameContainer.classList.toggle('both-panels-collapsed', this.leftPanelCollapsed && this.rightPanelCollapsed);

            // æ›´æ–°é¢æ¿çš„æŠ˜å çŠ¶æ€
            leftPanel.classList.toggle('collapsed', this.leftPanelCollapsed);
            rightPanel.classList.toggle('collapsed', this.rightPanelCollapsed);

            // æ›´æ–°ç®­å¤´æ–¹å‘ - éšè—/æ˜¾ç¤ºæ¨¡å¼
            const leftArrow = document.querySelector('.left-panel-toggle .toggle-arrow');
            const rightArrow = document.querySelector('.right-panel-toggle .toggle-arrow');
            
            if (leftArrow) {
              leftArrow.textContent = this.leftPanelCollapsed ? 'â–¶' : 'â—€';
            }
            if (rightArrow) {
              rightArrow.textContent = this.rightPanelCollapsed ? 'â—€' : 'â–¶';
            }
          },

          loadPanelStates() {
            try {
              const savedStates = localStorage.getItem('guixu_panel_states');
              if (savedStates) {
                const states = JSON.parse(savedStates);
                this.leftPanelCollapsed = states.leftPanelCollapsed || false;
                this.rightPanelCollapsed = states.rightPanelCollapsed || false;
                this.updatePanelStates();
              }
            } catch (e) {
              console.error('åŠ è½½é¢æ¿çŠ¶æ€å¤±è´¥:', e);
            }
          },

          savePanelStates() {
            try {
              const states = {
                leftPanelCollapsed: this.leftPanelCollapsed,
                rightPanelCollapsed: this.rightPanelCollapsed
              };
              localStorage.setItem('guixu_panel_states', JSON.stringify(states));
            } catch (e) {
              console.error('ä¿å­˜é¢æ¿çŠ¶æ€å¤±è´¥:', e);
            }
          },

          toggleCharacterPanel() {
              this.isCharacterPanelVisible = !this.isCharacterPanelVisible;
              const container = document.querySelector('.guixu-root-container');
              const floatingBtn = document.getElementById('floating-character-btn');

              if (container) {
                  container.classList.toggle('character-panel-visible', this.isCharacterPanelVisible);
              }

              if (floatingBtn) {
                  floatingBtn.classList.toggle('active', this.isCharacterPanelVisible);
                  floatingBtn.textContent = this.isCharacterPanelVisible ? 'æ”¶èµ·' : 'è§’è‰²';
              }
          },

          toggleInteractionPanel() {
              this.isInteractionPanelVisible = !this.isInteractionPanelVisible;
              const container = document.querySelector('.guixu-root-container');
              const floatingBtn = document.getElementById('floating-interaction-btn');

              if (container) {
                  container.classList.toggle('interaction-panel-visible', this.isInteractionPanelVisible);
              }

              if (floatingBtn) {
                  floatingBtn.classList.toggle('active', this.isInteractionPanelVisible);
                  floatingBtn.textContent = this.isInteractionPanelVisible ? 'æ”¶èµ·' : 'åŠŸèƒ½';
              }
          },



// ===é¢æ¿æŠ˜å æ¨¡å—ç»“æŸ===



// ===é‡æ–°å¤„ç†å˜é‡æ¨¡å—å¼€å§‹===



          async reprocessVariables() {
            this.showWaitingMessage('æ­£åœ¨é‡æ–°å¤„ç†å˜é‡...');
            try {
              const messages = await getChatMessages(getCurrentMessageId());
              if (messages && messages.length > 0) {
                const lastMessageContent = messages[0].message;
                await this.continueProcessingWithAutoFix(lastMessageContent);
                // this.showTemporaryMessage('å˜é‡å·²é‡æ–°å¤„ç†ã€‚');
              } else {
                this.showTemporaryMessage('é”™è¯¯ï¼šæ‰¾ä¸åˆ°å½“å‰æ¶ˆæ¯ä»¥é‡æ–°å¤„ç†ã€‚', 5000, true);
              }
            } catch (error) {
              console.error('é‡æ–°å¤„ç†å˜é‡æ—¶å‡ºé”™:', error);
              this.showTemporaryMessage('é‡æ–°å¤„ç†å˜é‡æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°ã€‚', 5000, true);
            } finally {
              this.hideWaitingMessage();
            }
          },



// ===é‡æ–°å¤„ç†å˜é‡æ¨¡å—ç»“æŸ===



// ===æŒ‰é’®å¯æ‹–åŠ¨åŠŸèƒ½æ¨¡å—å¼€å§‹===



          initDraggableButtons() {
              const characterBtn = document.getElementById('floating-character-btn');
              const interactionBtn = document.getElementById('floating-interaction-btn');

              if (characterBtn) {
                  this.makeDraggable(characterBtn, () => this.toggleCharacterPanel());
              }
              if (interactionBtn) {
                  this.makeDraggable(interactionBtn, () => this.toggleInteractionPanel());
              }
          },
          makeDraggable(element, clickCallback) {
              let isDragging = false;
              let startX, startY, startLeft, startTop;
              let hasMoved = false;


              element.addEventListener('mousedown', (e) => {
                  isDragging = true;
                  hasMoved = false;
                  startX = e.clientX;
                  startY = e.clientY;
                  startLeft = parseInt(window.getComputedStyle(element).left, 10);
                  startTop = parseInt(window.getComputedStyle(element).top, 10);
                  element.classList.add('dragging');
                  e.preventDefault();
              });

              document.addEventListener('mousemove', (e) => {
                  if (!isDragging) return;
                  
                  const deltaX = e.clientX - startX;
                  const deltaY = e.clientY - startY;
                  
                  if (Math.abs(deltaX) > 0 || Math.abs(deltaY) > 0) {
                      hasMoved = true;
                  }

                  const newLeft = startLeft + deltaX;
                  const newTop = startTop + deltaY;

                  const maxLeft = window.innerWidth - element.offsetWidth;
                  const maxTop = window.innerHeight - element.offsetHeight;

                  element.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                  element.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
              });

              document.addEventListener('mouseup', () => {
                  if (isDragging) {
                      isDragging = false;
                      element.classList.remove('dragging');
                      
                      if (!hasMoved) {
                          clickCallback();
                      }
                  }
              });

              element.addEventListener('touchstart', (e) => {
                  isDragging = true;
                  hasMoved = false;
                  const touch = e.touches[0];
                  startX = touch.clientX;
                  startY = touch.clientY;
                  startLeft = parseInt(window.getComputedStyle(element).left, 10);
                  startTop = parseInt(window.getComputedStyle(element).top, 10);
                  element.classList.add('dragging');
                  e.preventDefault();
              });

              element.addEventListener('touchmove', (e) => {
                  if (!isDragging) return;
                  
                  const touch = e.touches[0];
                  const deltaX = touch.clientX - startX;
                  const deltaY = touch.clientY - startY;
                  
                  if (Math.abs(deltaX) > 0 || Math.abs(deltaY) > 0) {
                      hasMoved = true;
                  }

                  const newLeft = startLeft + deltaX;
                  const newTop = startTop + deltaY;

                  const maxLeft = window.innerWidth - element.offsetWidth;
                  const maxTop = window.innerHeight - element.offsetHeight;

                  element.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                  element.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
                  e.preventDefault();
              });

              element.addEventListener('touchend', () => {
                  if (isDragging) {
                      isDragging = false;
                      element.classList.remove('dragging');
                      
                      if (!hasMoved) {
                          clickCallback();
                      }
                  }
              });
          },



// ===æŒ‰é’®å¯æ‹–åŠ¨åŠŸèƒ½æ¨¡å—å¼€å§‹===




// ===çª—å£å¤§å°è‡ªå®šä¹‰æ¨¡å—å¼€å§‹===



          // ä¸»ç•Œé¢ï¼ˆä¸€çº§çª—å£ï¼‰å¤§å°è‡ªå®šä¹‰åŠŸèƒ½
          toggleWindowSizePanel() {
              const panel = document.getElementById('window-size-panel');
              if (panel) {
                  const isVisible = panel.style.display === 'block';
                  panel.style.display = isVisible ? 'none' : 'block';
                  if (!isVisible) {
                      this.loadCurrentWindowSize();
                  }
              }
          },

          hideWindowSizePanel() {
              const panel = document.getElementById('window-size-panel');
              if (panel) {
                  panel.style.display = 'none';
              }
          },
          
          loadCurrentWindowSize() {
              const container = document.querySelector('.guixu-root-container');
              const gameContainer = document.querySelector('.game-container');
              if (container && gameContainer) {
                  const currentWidth = parseInt(container.style.maxWidth) || 900;
                  const currentHeight = parseInt(gameContainer.style.height) || 600;
                  
                  const widthSlider = document.getElementById('width-slider');
                  const heightSlider = document.getElementById('height-slider');
                  const widthDisplay = document.getElementById('width-display');
                  const heightDisplay = document.getElementById('height-display');
                  
                  if (widthSlider) widthSlider.value = currentWidth;
                  if (heightSlider) heightSlider.value = currentHeight;
                  if (widthDisplay) widthDisplay.textContent = `${currentWidth}px`;
                  if (heightDisplay) heightDisplay.textContent = `${currentHeight}px`;
              }
              
              // åŒæ—¶åŠ è½½æ¨¡æ€æ¡†å½“å‰å¤§å°
              this.loadCurrentModalSize();
          },

          loadCurrentModalSize() {
              // ä»localStorageåŠ è½½æˆ–ä½¿ç”¨é»˜è®¤å€¼
              const savedState = localStorage.getItem('guixu_modal_size');
              let modalWidth = 800;
              let modalHeight = 600;
              
              if (savedState) {
                  try {
                      const { width, height } = JSON.parse(savedState);
                      modalWidth = width || 800;
                      modalHeight = height || 600;
                  } catch (e) {
                      console.error('è§£ææ¨¡æ€æ¡†å¤§å°çŠ¶æ€å¤±è´¥:', e);
                  }
              }
              
              const modalWidthSlider = document.getElementById('modal-width-slider');
              const modalHeightSlider = document.getElementById('modal-height-slider');
              const modalWidthDisplay = document.getElementById('modal-width-display');
              const modalHeightDisplay = document.getElementById('modal-height-display');
              
              if (modalWidthSlider) modalWidthSlider.value = modalWidth;
              if (modalHeightSlider) modalHeightSlider.value = modalHeight;
              if (modalWidthDisplay) modalWidthDisplay.textContent = `${modalWidth}px`;
              if (modalHeightDisplay) modalHeightDisplay.textContent = `${modalHeight}px`;
          },

          updateWidthDisplay(value) {
              const widthDisplay = document.getElementById('width-display');
              if (widthDisplay) {
                  widthDisplay.textContent = `${value}px`;
              }
              this.applyWindowSize(value, null);
          },

          updateHeightDisplay(value) {
              const heightDisplay = document.getElementById('height-display');
              if (heightDisplay) {
                  heightDisplay.textContent = `${value}px`;
              }
              this.applyWindowSize(null, value);
          },
          
          applyWindowSize(newWidth, newHeight) {
               const container = document.querySelector('.guixu-root-container');
               const gameContainer = document.querySelector('.game-container');

               if (container && gameContainer) {
                   if (newWidth !== null) {
                       container.style.maxWidth = `${newWidth}px`;
                   }
                   if (newHeight !== null) {
                       gameContainer.style.height = `${newHeight}px`;
                   }
               }
               // å®æ—¶ä¿å­˜ï¼Œå¯èƒ½ä¼šæœ‰æ€§èƒ½é—®é¢˜ï¼Œä½†æŒ‰æŒ‡ç¤ºå¿½ç•¥lodash
               this.saveWindowSizeState();
          },
          
          resetWindowSize() {
              const defaultWidth = 900;
              const defaultHeight = 600;
              
              const widthSlider = document.getElementById('width-slider');
              const heightSlider = document.getElementById('height-slider');
              
              if (widthSlider) widthSlider.value = defaultWidth;
              if (heightSlider) heightSlider.value = defaultHeight;

              this.updateWidthDisplay(defaultWidth);
              this.updateHeightDisplay(defaultHeight);

              this.showTemporaryMessage('å·²é‡ç½®ä¸ºé»˜è®¤å¤§å°');
          },

          saveWindowSizeState() {
              try {
                  const container = document.querySelector('.guixu-root-container');
                  const gameContainer = document.querySelector('.game-container');
                  
                  if (container && gameContainer) {
                      // ä»å®é™…çš„DOMæ ·å¼ä¸­è·å–å½“å‰å°ºå¯¸
                      const currentWidth = parseInt(container.style.maxWidth) || 900;
                      const currentHeight = parseInt(gameContainer.style.height) || 600;
                      
                      const sizeState = {
                          width: currentWidth,
                          height: currentHeight
                      };
                      
                      localStorage.setItem('guixu_window_size', JSON.stringify(sizeState));
                  }
              } catch (e) {
                  console.error('ä¿å­˜çª—å£å¤§å°çŠ¶æ€å¤±è´¥:', e);
              }
          },
          
          loadWindowSizeState() {
              try {
                  const savedState = localStorage.getItem('guixu_window_size');
                  if (savedState) {
                      const { width, height } = JSON.parse(savedState);
                      if (width && height) {
                          // ç›´æ¥åº”ç”¨åˆ°DOMï¼Œé¿å…å¾ªç¯è°ƒç”¨saveWindowSizeState
                          const container = document.querySelector('.guixu-root-container');
                          const gameContainer = document.querySelector('.game-container');
                          
                          if (container && gameContainer) {
                              container.style.maxWidth = `${width}px`;
                              gameContainer.style.height = `${height}px`;
                              
                              // æ›´æ–°æ»‘å—æ˜¾ç¤ºå€¼
                              const widthSlider = document.getElementById('width-slider');
                              const heightSlider = document.getElementById('height-slider');
                              const widthDisplay = document.getElementById('width-display');
                              const heightDisplay = document.getElementById('height-display');
                              
                              if (widthSlider) widthSlider.value = width;
                              if (heightSlider) heightSlider.value = height;
                              if (widthDisplay) widthDisplay.textContent = `${width}px`;
                              if (heightDisplay) heightDisplay.textContent = `${height}px`;
                              
                          }
                      }
                  }
              } catch (e) {
                  console.error('åŠ è½½çª—å£å¤§å°çŠ¶æ€å¤±è´¥:', e);
              }
          },

          // æ¨¡æ€æ¡†ï¼ˆäºŒçº§çª—å£ï¼‰å¤§å°è‡ªå®šä¹‰åŠŸèƒ½
          updateModalWidthDisplay(value) {
              const modalWidthDisplay = document.getElementById('modal-width-display');
              if (modalWidthDisplay) {
                  modalWidthDisplay.textContent = `${value}px`;
              }
              this.applyModalSize(value, null);
          },

          updateModalHeightDisplay(value) {
              const modalHeightDisplay = document.getElementById('modal-height-display');
              if (modalHeightDisplay) {
                  modalHeightDisplay.textContent = `${value}px`;
              }
              this.applyModalSize(null, value);
          },

          applyModalSize(newWidth, newHeight) {
              // åº”ç”¨åˆ°æ‰€æœ‰æ¨¡æ€æ¡†çš„ .modal-content
              const modalContents = document.querySelectorAll('.modal-content');
              modalContents.forEach(modalContent => {

                  // è±å…äººç‰©å…³ç³»æ¨¡æ€æ¡†ã€å®—é—¨æ¨¡æ€æ¡†å’Œå½’å¢Ÿç³»ç»Ÿæ¨¡æ€æ¡†ï¼Œå®ƒä»¬çš„å°ºå¯¸ç”±å…¶å†…éƒ¨CSSæ§åˆ¶
                  if (modalContent.closest('#relationships-modal') || modalContent.closest('#sects-modal') || modalContent.closest('#guixu-system-modal')) {
                      return;
                  }
                  if (newWidth !== null) {
                      modalContent.style.maxWidth = `${newWidth}px`;
                      modalContent.style.width = `${Math.min(newWidth, window.innerWidth * 0.9)}px`;
                  }
                  if (newHeight !== null) {
                      modalContent.style.height = `${Math.min(newHeight, window.innerHeight * 0.9)}px`;
                      modalContent.style.maxHeight = `${Math.min(newHeight, window.innerHeight * 0.9)}px`;
                      // ç¡®ä¿å†…å®¹åŒºåŸŸä¹Ÿèƒ½æ­£ç¡®æ˜¾ç¤º
                      modalContent.style.overflow = 'auto';
                  }
              });
              
              // å®æ—¶ä¿å­˜æ¨¡æ€æ¡†å¤§å°çŠ¶æ€
              this.saveModalSizeState();
          },

          resetModalSize() {
              const defaultWidth = 800;
              const defaultHeight = 600;
              
              const modalWidthSlider = document.getElementById('modal-width-slider');
              const modalHeightSlider = document.getElementById('modal-height-slider');
              
              if (modalWidthSlider) modalWidthSlider.value = defaultWidth;
              if (modalHeightSlider) modalHeightSlider.value = defaultHeight;

              this.updateModalWidthDisplay(defaultWidth);
              this.updateModalHeightDisplay(defaultHeight);

              this.showTemporaryMessage('æ¨¡æ€æ¡†å¤§å°å·²é‡ç½®ä¸ºé»˜è®¤');
          },

          resetPanelWidth() {
              const defaultLeftWidth = 20;
              const defaultRightWidth = 20;
              
              const leftSlider = document.getElementById('left-panel-width-slider');
              const rightSlider = document.getElementById('right-panel-width-slider');
              
              if (leftSlider) leftSlider.value = defaultLeftWidth;
              if (rightSlider) rightSlider.value = defaultRightWidth;

              // æ›´æ–°æ˜¾ç¤ºå€¼
              const leftValue = document.getElementById('left-panel-width-value');
              const rightValue = document.getElementById('right-panel-width-value');
              if (leftValue) leftValue.textContent = defaultLeftWidth + '%';
              if (rightValue) rightValue.textContent = defaultRightWidth + '%';

              // åº”ç”¨å®é™…æ ·å¼
              const leftPanel = document.getElementById('left-panel');
              const rightPanel = document.getElementById('right-panel');
              if (leftPanel) leftPanel.style.flex = `0 0 ${defaultLeftWidth}%`;
              if (rightPanel) rightPanel.style.flex = `0 0 ${defaultRightWidth}%`;

              // ä¿å­˜çŠ¶æ€
              localStorage.setItem('guixu_left_panel_width', defaultLeftWidth);
              localStorage.setItem('guixu_right_panel_width', defaultRightWidth);

              this.showTemporaryMessage('é¢æ¿å®½åº¦å·²é‡ç½®ä¸ºé»˜è®¤');
          },

          saveModalSizeState() {
              try {
                  const modalWidthSlider = document.getElementById('modal-width-slider');
                  const modalHeightSlider = document.getElementById('modal-height-slider');
                  
                  if (modalWidthSlider && modalHeightSlider) {
                      const currentWidth = parseInt(modalWidthSlider.value) || 800;
                      const currentHeight = parseInt(modalHeightSlider.value) || 600;
                      
                      const modalSizeState = {
                          width: currentWidth,
                          height: currentHeight
                      };
                      
                      localStorage.setItem('guixu_modal_size', JSON.stringify(modalSizeState));
                  }
              } catch (e) {
                  console.error('ä¿å­˜æ¨¡æ€æ¡†å¤§å°çŠ¶æ€å¤±è´¥:', e);
              }
          },

          loadModalSizeState() {
              try {
                  const savedState = localStorage.getItem('guixu_modal_size');
                  if (savedState) {
                      const { width, height } = JSON.parse(savedState);
                      if (width && height) {
                          // æ›´æ–°æ»‘å—æ˜¾ç¤ºå€¼
                          const modalWidthSlider = document.getElementById('modal-width-slider');
                          const modalHeightSlider = document.getElementById('modal-height-slider');
                          const modalWidthDisplay = document.getElementById('modal-width-display');
                          const modalHeightDisplay = document.getElementById('modal-height-display');
                          
                          if (modalWidthSlider) modalWidthSlider.value = width;
                          if (modalHeightSlider) modalHeightSlider.value = height;
                          if (modalWidthDisplay) modalWidthDisplay.textContent = `${width}px`;
                          if (modalHeightDisplay) modalHeightDisplay.textContent = `${height}px`;
                          
                          // åº”ç”¨åˆ°ç°æœ‰çš„æ¨¡æ€æ¡†
                          this.applyModalSize(width, height);
                          
                      }
                  }
              } catch (e) {
                  console.error('åŠ è½½æ¨¡æ€æ¡†å¤§å°çŠ¶æ€å¤±è´¥:', e);
              }
          },



// ===çª—å£å¤§å°è‡ªå®šä¹‰æ¨¡å—ç»“æŸ===



// ===å½“å‰çŠ¶æ€æ¨¡å—å¼€å§‹===



         toggleStatusPopup() {
           const popup = document.getElementById('status-effects-popup');
           if (popup) {
             const isVisible = popup.style.display === 'flex';
             popup.style.display = isVisible ? 'none' : 'flex';
           }
         },



// ===å½“å‰çŠ¶æ€æ¨¡å—ç»“æŸ===




// ===æ ¸å¿ƒmvuå˜é‡è·å–ã€è¯»å–ã€è§£æç›¸å…³æ¨¡å—å¼€å§‹===

          SafeGetValue(obj, path, defaultValue = 'N/A') {
            let keys = Array.isArray(path) ? path : path.split('.');
            let current = obj;
            for (let i = 0; i < keys.length; i++) {
              if (
                current === undefined ||
                current === null ||
                typeof current !== 'object' ||
                !current.hasOwnProperty(keys[i])
              ) {
                return defaultValue;
              }
              current = current[keys[i]];
            }
            if (current === undefined || current === null) {
              return defaultValue;
            }
            // å¦‚æœæ˜¯å¯¹è±¡ï¼ˆä½†ä¸æ˜¯æ•°ç»„ï¼‰ï¼Œç›´æ¥è¿”å›
            if (typeof current === 'object' && !Array.isArray(current)) {
               return current;
           }
            if (Array.isArray(current)) {
              if (current.length > 0) {
                const actualValue = current[0];
                if (typeof actualValue === 'boolean') return actualValue;
                // å¦‚æœæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¯¹è±¡ï¼Œç›´æ¥è¿”å›è¯¥å¯¹è±¡
                if (typeof actualValue === 'object' && actualValue !== null) {
                   return actualValue;
                }
                return String(actualValue);
              } else {
                return defaultValue;
              }
            }
            if (typeof current === 'boolean') return current;
            return String(current);
          },

          // å®‰å…¨è®¾ç½®å€¼å‡½æ•°ï¼šå¯¹åº” SafeGetValue çš„è®¾ç½®ç‰ˆæœ¬
          SafeSetValue(obj, path, value) {
              if (!obj || typeof obj !== 'object') {
                  console.warn('[SafeSetValue] ç›®æ ‡å¯¹è±¡æ— æ•ˆ:', obj);
                  return false;
              }

              const keys = Array.isArray(path) ? path : path.split('.');
              let current = obj;

              // éå†åˆ°å€’æ•°ç¬¬äºŒå±‚ï¼Œç¡®ä¿è·¯å¾„ä¸Šçš„æ‰€æœ‰å¯¹è±¡éƒ½å­˜åœ¨
              for (let i = 0; i < keys.length - 1; i++) {
                  const key = keys[i];
                  
                  if (!current.hasOwnProperty(key) ||
                      current[key] === null ||
                      current[key] === undefined ||
                      typeof current[key] !== 'object') {
                      // åˆ›å»ºæ–°çš„å¯¹è±¡
                      current[key] = {};
                  }
                  current = current[key];
              }

              // è®¾ç½®æœ€åä¸€ä¸ªé”®çš„å€¼
              const lastKey = keys[keys.length - 1];
              current[lastKey] = value;
              
              console.log(`[SafeSetValue] æˆåŠŸè®¾ç½®: ${path} = ${JSON.stringify(value)}`);
              return true;
          },

          // æ”¹è¿›çš„ SafeGetValue å‡½æ•°
          SafeGetValue(obj, path, defaultValue = 'N/A') {
            let keys = Array.isArray(path) ? path : path.split('.');
            let current = obj;
            for (let i = 0; i < keys.length; i++) {
              if (
                current === undefined ||
                current === null ||
                typeof current !== 'object' ||
                !current.hasOwnProperty(keys[i])
              ) {
                return defaultValue;
              }
              current = current[keys[i]];
            }
            if (current === undefined || current === null) {
              return defaultValue;
            }
            // å¦‚æœæ˜¯å¯¹è±¡ï¼ˆä½†ä¸æ˜¯æ•°ç»„ï¼‰ï¼Œç›´æ¥è¿”å›
            if (typeof current === 'object' && !Array.isArray(current)) {
               return current;
           }
            if (Array.isArray(current)) {
              if (current.length > 0) {
                const actualValue = current[0];
                if (typeof actualValue === 'boolean') return actualValue;
                // å¦‚æœæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¯¹è±¡ï¼Œç›´æ¥è¿”å›è¯¥å¯¹è±¡
                if (typeof actualValue === 'object' && actualValue !== null) {
                   return actualValue;
                }
                return String(actualValue);
              } else {
                return defaultValue;
              }
            }
            if (typeof current === 'boolean') return current;
            return String(current);
          },

          
          async updateDynamicData() {
            try {
              // åŠ è½½æ ¸å¿ƒmvuæ•°æ®
              const messages = await getChatMessages(getCurrentMessageId());
              if (messages && messages.length > 0 && messages[0].data) {
                const rawData = messages[0].data;
                this.currentMvuState = this._safeLoadMvuData(rawData);
                this.renderUI(this.currentMvuState.stat_data);
              } else {
                console.warn('æ— æ³•ä»å½“å‰æ¶ˆæ¯ä¸­åŠ è½½ mvu dataã€‚');
              }
              await this.loadAndDisplayCurrentScene();
            } catch (error) {
              console.error('æ›´æ–°å½’å¢ŸåŠ¨æ€æ•°æ®æ—¶å‡ºé”™:', error);
            }
          },

// ===ç»Ÿä¸€çš„UIæ¸²æŸ“å‡½æ•°ï¼ˆæä¸ºé‡è¦ï¼‰===



          renderUI(data) {
            if (!data) {
              console.warn('RenderUI è°ƒç”¨å¤±è´¥ï¼šæ²¡æœ‰æä¾›æ•°æ®ã€‚');
              return;
            }
            const updateText = (id, value, style = '') => {
              const el = document.getElementById(id);
              if (el) {
                el.innerText = value;
                if (style) {
                  el.setAttribute('style', style);
                }
              }
            };
            const jingjieValue = this.SafeGetValue(data, 'å½“å‰å¢ƒç•Œ', '...');
            const match = jingjieValue.match(/^(\S{2})/);
            const jingjieTier = match ? match[1] : '';
            const jingjieStyle = this.getJingJieStyle(jingjieTier);
            updateText('val-jingjie', jingjieValue, jingjieStyle);
            updateText('val-jinian', this.SafeGetValue(data, 'å½“å‰æ—¶é—´çºªå¹´'));
            const currentWorld = this.SafeGetValue(data, 'å½“å‰ç¬¬xä¸–', '1');
            updateText('val-current-world', `ç¬¬${currentWorld}ä¸–`);
            const charge = this.SafeGetValue(data, 'å½’çœŸæ•°', '0');
            updateText('val-guixu-charge-text', `${charge}`);
            const chargeBar = document.getElementById('bar-guixu-charge');
            if (chargeBar) chargeBar.style.setProperty('--guixu-charge', `${charge}`);
            
            this.updateTalentAndLinggen(data);
            this.loadEquipmentFromMVU(data);
            this.updateDisplayedAttributes(data); // æ ¸å¿ƒæ¸²æŸ“å‡½æ•°
            const summaryTextEl = document.getElementById('status-summary-text');
            const popupListEl = document.getElementById('status-effects-popup-list');
            if (summaryTextEl && popupListEl) {
              const statuses = this.SafeGetValue(data, 'å½“å‰çŠ¶æ€', {});
              const statusEntries = Object.entries(statuses).filter(([key]) => key !== '$meta');

              if (statusEntries.length > 0) {
                summaryTextEl.textContent = `å½“å‰æœ‰ ${statusEntries.length} ä¸ªçŠ¶æ€æ•ˆæœ`;
                
                popupListEl.innerHTML = statusEntries.map(([name, description]) => {
                  return `
                    <div class="status-effect-item">
                      <strong>${name}:</strong> ${description}
                    </div>
                  `;
                }).join('');
              } else {
                summaryTextEl.textContent = 'å½“å‰æ— çŠ¶æ€æ•ˆæœ';
                popupListEl.innerHTML = '<div class="status-effect-item">æš‚æ— </div>';
              }
            }

            // å¦‚æœå½“å‰æ˜¯ä»»åŠ¡Tabï¼Œåˆ·æ–°ä»»åŠ¡åˆ—è¡¨
            const activeTab = document.querySelector('.guixu-tab-btn.active');
            if (activeTab && activeTab.getAttribute('data-tab') === 'quest') {
                const activeStatus = document.querySelector('.quest-status-tabs .panel-tab-btn.active');
                const statusFilter = activeStatus ? activeStatus.getAttribute('data-status') : 'unfinished';
                this.renderQuestList(statusFilter);
            }
          },

// ===æ ¸å¿ƒmvuå˜é‡è·å–ã€è¯»å–ã€è§£æç›¸å…³æ¨¡å—ç»“æŸ===



// ===æŒ‰é’®ç»Ÿä¸€ç›‘å¬ç»‘å®šæ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰å¼€å§‹===
          bindStaticListeners() {
            if (this.listenersBound) return; // å¦‚æœå·²ç»ç»‘å®šè¿‡ï¼Œåˆ™ç›´æ¥è¿”å›

            // ä¸ºä¸–ç•Œä¹¦é«˜çº§è®¾ç½®ä¸­çš„ä½ç½®é€‰æ‹©æ¡†æ·»åŠ å®æ—¶äº¤äº’
            try {
                ['journey', 'past-lives', 'novel', 'segmented', 'large-summary', 'small-summary'].forEach(type => {
                    const positionSelect = document.getElementById(`${type}-position`);
                    const depthContainer = document.getElementById(`${type}-depth-container`);

                    if (positionSelect && depthContainer) {
                        positionSelect.addEventListener('change', (event) => {
                            depthContainer.style.display = event.target.value.startsWith('at_depth') ? 'contents' : 'none';
                            // ä¿å­˜è®¾ç½®ä»¥æŒä¹…åŒ–
                            this.saveWorldbookSettings();
                        });
                    }
                });
            } catch(e) {
                console.error("ç»‘å®šä¸–ç•Œä¹¦é«˜çº§è®¾ç½®äº¤äº’äº‹ä»¶å¤±è´¥:", e);
            }

            // ä¸ºè§†å›¾åˆ‡æ¢æŒ‰é’®ç»‘å®šç›‘å¬å™¨
            document.getElementById('view-toggle-btn')?.addEventListener('click', () => this.toggleViewMode());
            document.getElementById('fullscreen-btn')?.addEventListener('click', () => this.toggleFullScreen());
            document.getElementById('exit-fullscreen-btn')?.addEventListener('click', () => this.exitFullScreen());

            // ä¸ºé¡¶éƒ¨å…¨å±æŒ‰é’®ç»‘å®šç›‘å¬å™¨
            document.getElementById('top-fullscreen-btn')?.addEventListener('click', () => this.toggleFullScreen());
            document.getElementById('top-exit-fullscreen-btn')?.addEventListener('click', () => this.exitFullScreen());

            // ä¸ºå˜é‡æ”¹å˜æé†’ç»‘å®šç›‘å¬å™¨
            document.getElementById('variable-changes-header')?.addEventListener('click', () => this.toggleVariableChanges());

            // ä¸ºé¢æ¿æŠ˜å æŒ‰é’®ç»‘å®šç›‘å¬å™¨
            document.getElementById('left-panel-toggle')?.addEventListener('click', () => this.toggleLeftPanel());
            document.getElementById('right-panel-toggle')?.addEventListener('click', () => this.toggleRightPanel());

            document.addEventListener('fullscreenchange', () => {
                // å³ä¾§é¢æ¿çš„å…¨å±æŒ‰é’®
                const fullscreenBtn = document.getElementById('fullscreen-btn');
                const exitFullscreenBtn = document.getElementById('exit-fullscreen-btn');
                // é¡¶éƒ¨çŠ¶æ€æ çš„å…¨å±æŒ‰é’®
                const topFullscreenBtn = document.getElementById('top-fullscreen-btn');
                const topExitFullscreenBtn = document.getElementById('top-exit-fullscreen-btn');
                
                if (document.fullscreenElement) {
                    // è¿›å…¥å…¨å±æ¨¡å¼
                    if (fullscreenBtn) fullscreenBtn.style.display = 'none';
                    if (exitFullscreenBtn) exitFullscreenBtn.style.display = 'flex';
                    if (topFullscreenBtn) topFullscreenBtn.style.display = 'none';
                    if (topExitFullscreenBtn) topExitFullscreenBtn.style.display = 'flex';
                } else {
                    // é€€å‡ºå…¨å±æ¨¡å¼
                    if (fullscreenBtn) fullscreenBtn.style.display = 'flex';
                    if (exitFullscreenBtn) exitFullscreenBtn.style.display = 'none';
                    if (topFullscreenBtn) topFullscreenBtn.style.display = 'flex';
                    if (topExitFullscreenBtn) topExitFullscreenBtn.style.display = 'none';
                }
            });
            // æµ®åŠ¨æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨å’Œæ‹–åŠ¨åŠŸèƒ½
            this.initDraggableButtons();
            
            // ä¸ºçª—å£å¤§å°è°ƒæ•´æ»‘åŠ¨æ¡ç»‘å®šäº‹ä»¶ç›‘å¬å™¨ï¼ˆç°åœ¨ç›´æ¥åœ¨è®¾ç½®é¢æ¿ä¸­ï¼‰
            document.getElementById('width-slider')?.addEventListener('input', (e) => this.updateWidthDisplay(e.target.value));
            document.getElementById('height-slider')?.addEventListener('input', (e) => this.updateHeightDisplay(e.target.value));
            document.getElementById('reset-size-btn')?.addEventListener('click', () => this.resetWindowSize());
            
            // ä¸ºäºŒçº§çª—å£(æ¨¡æ€æ¡†)å¤§å°è°ƒæ•´ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
            document.getElementById('modal-width-slider')?.addEventListener('input', (e) => this.updateModalWidthDisplay(e.target.value));
            document.getElementById('modal-height-slider')?.addEventListener('input', (e) => this.updateModalHeightDisplay(e.target.value));
            document.getElementById('reset-modal-size-btn')?.addEventListener('click', () => this.resetModalSize());
            
            // ä¸ºé¢æ¿å®½åº¦é‡ç½®æŒ‰é’®ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
            document.getElementById('reset-panel-width-btn')?.addEventListener('click', () => this.resetPanelWidth());
            
            // ä¸ºçŠ¶æ€æ•ˆæœå¼¹å‡ºçª—å£ç»‘å®šäº‹ä»¶ ---
            document.getElementById('status-summary-button')?.addEventListener('click', () => this.toggleStatusPopup());
            document.getElementById('status-effects-popup-close')?.addEventListener('click', () => this.toggleStatusPopup());
            
            // ä¸ºä¸–ç•Œä¹¦åºå·è¾“å…¥æ¡†ç»‘å®šç›‘å¬
            // ä¸ºç»Ÿä¸€çš„åºå·è¾“å…¥æ¡†ç»‘å®šç›‘å¬
            document.getElementById('unified-index-input')?.addEventListener('change', (e) => {
                const newIndex = parseInt(e.target.value, 10);
                if (!isNaN(newIndex) && newIndex > 0) {
                    this.unifiedIndex = newIndex;
                    this.saveUnifiedIndex();
                    this.showTemporaryMessage(`ä¸–ç•Œä¹¦è¯»å†™åºå·å·²æ›´æ–°ä¸º ${newIndex}`);
                    // å¦‚æœè‡ªåŠ¨å¼€å…³æ˜¯å¼€å¯çš„ï¼Œç«‹å³æ›´æ–°å¯ç”¨çš„æ¡ç›®
                    if (this.isAutoToggleLorebookEnabled) {
                        this.startAutoTogglePolling();
                    }
                } else {
                    e.target.value = this.unifiedIndex; // å¦‚æœè¾“å…¥æ— æ•ˆï¼Œåˆ™æ¢å¤
                }
            });

           // å°è¯´æ¨¡å¼åºå·è¾“å…¥æ¡†ä½¿ç”¨ç»Ÿä¸€åºå·
           document.getElementById('novel-mode-index-input')?.addEventListener('change', (e) => {
               const newIndex = parseInt(e.target.value, 10);
               if (!isNaN(newIndex) && newIndex > 0) {
                   this.unifiedIndex = newIndex; // ä½¿ç”¨ç»Ÿä¸€åºå·
                   this.saveUnifiedIndex();
                   this.showTemporaryMessage(`ä¸–ç•Œä¹¦è¯»å†™åºå·å·²æ›´æ–°ä¸º ${newIndex}`);
                   // ç«‹å³åˆ·æ–°æ¨¡æ€æ¡†å†…å®¹
                   if (document.getElementById('novel-mode-modal').style.display === 'flex') {
                     this.showNovelMode();
                   }
                   // å¦‚æœè‡ªåŠ¨å¼€å…³æ˜¯å¼€å¯çš„ï¼Œç«‹å³æ›´æ–°å¯ç”¨çš„æ¡ç›®
                   if (this.isAutoToggleLorebookEnabled) {
                       this.startAutoTogglePolling();
                   }
               } else {
                   e.target.value = this.unifiedIndex;
               }
           });

           // è¾…åŠ©æ¨¡å‹è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
           document.getElementById('toggle-aux-model-enabled')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.isEnabled = e.target.checked;
               
               // æ˜¾ç¤º/éšè—é…ç½®åŒºåŸŸ
               const configSection = document.getElementById('aux-model-config-section');
               if (configSection) {
                   configSection.style.display = e.target.checked ? 'block' : 'none';
               }
               
               this.saveAuxModelSettings();
               this.showTemporaryMessage(`è¾…åŠ©æ¨¡å‹å·²${e.target.checked ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
           });

           document.getElementById('aux-model-source')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.source = e.target.value;
               this.saveAuxModelSettings();
           });

           document.getElementById('toggle-aux-model-use-preset')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.usePreset = e.target.checked;
               this.saveAuxModelSettings();
               this.showTemporaryMessage(`${e.target.checked ? 'å·²å¯ç”¨' : 'å·²ç¦ç”¨'}ä½¿ç”¨é¢„è®¾`);
           });

           document.getElementById('toggle-aux-model-streaming')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.isStreaming = e.target.checked;
               this.saveAuxModelSettings();
           });

           // è¾“å…¥æ¡†å®æ—¶ä¿å­˜
           document.getElementById('aux-model-api-url')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.apiUrl = e.target.value;
               this.saveAuxModelSettings();
           });

           document.getElementById('aux-model-api-key')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.apiKey = e.target.value;
               this.saveAuxModelSettings();
           });

           document.getElementById('aux-model-name')?.addEventListener('change', (e) => {
               if (!this.auxModelSettings) this.auxModelSettings = {};
               this.auxModelSettings.modelName = e.target.value;
               this.saveAuxModelSettings();
               console.log('[å½’å¢Ÿ] å·²é€‰æ‹©æ¨¡å‹:', e.target.value);
           });

           // è¿æ¥æŒ‰é’®ï¼ˆè·å–æ¨¡å‹åˆ—è¡¨ï¼‰
           document.getElementById('btn-connect-aux-model')?.addEventListener('click', async () => {
               await this.connectAndFetchModels();
           });

           // æµ‹è¯•æŒ‰é’®
           document.getElementById('btn-test-aux-model')?.addEventListener('click', async () => {
               await this.testAuxModel();
           });

           // MVUæ›´æ–°æ–¹å¼åˆ‡æ¢äº‹ä»¶ç›‘å¬å™¨
           document.getElementById('mvu-mode-with-ai')?.addEventListener('change', (e) => {
               if (e.target.checked) {
                   this.mvuUpdateMode = 'éšAIè¾“å‡º';
                   this.generationMode = 'once'; // åŒæ­¥æ›´æ–°ç”Ÿæˆæ¨¡å¼
                   this.saveMvuUpdateMode();
                   this.showTemporaryMessage('å·²åˆ‡æ¢åˆ°ï¼šéšAIè¾“å‡ºæ¨¡å¼');
                   // éšè—åˆ†æ­¥å˜é‡æ›´æ–°é…ç½®
                   const configSection = document.getElementById('stepwise-config-section');
                   if (configSection) configSection.style.display = 'none';
               }
           });

           document.getElementById('mvu-mode-stepwise')?.addEventListener('change', (e) => {
               if (e.target.checked) {
                   this.mvuUpdateMode = 'åˆ†æ­¥å˜é‡æ›´æ–°';
                   this.generationMode = 'stepwise'; // åŒæ­¥æ›´æ–°ç”Ÿæˆæ¨¡å¼
                   this.saveMvuUpdateMode();
                   this.showTemporaryMessage('å·²åˆ‡æ¢åˆ°ï¼šåˆ†æ­¥å˜é‡æ›´æ–°æ¨¡å¼');
                   // æ˜¾ç¤ºåˆ†æ­¥å˜é‡æ›´æ–°é…ç½®
                   const configSection = document.getElementById('stepwise-config-section');
                   if (configSection) configSection.style.display = 'block';
               }
           });

           document.getElementById('mvu-mode-with-ai')?.addEventListener('change', (e) => {
                if (e.target.checked) {
                    this.mvuUpdateMode = 'éšAIè¾“å‡º';
                    this.generationMode = 'once';
                    this.saveMvuUpdateMode();
                    this.showTemporaryMessage('å·²åˆ‡æ¢åˆ°ï¼šå•æ¬¡ç”Ÿæˆæ¨¡å¼');
                    const configSection = document.getElementById('stepwise-config-section');
                    if (configSection) configSection.style.display = 'none';
                }
            });

            document.getElementById('mvu-mode-stepwise')?.addEventListener('change', (e) => {
                if (e.target.checked) {
                    this.mvuUpdateMode = 'åˆ†æ­¥å˜é‡æ›´æ–°';
                    this.generationMode = 'stepwise';
                    this.saveMvuUpdateMode();
                    this.showTemporaryMessage('å·²åˆ‡æ¢åˆ°ï¼šåˆ†æ­¥å˜é‡æ›´æ–°æ¨¡å¼');
                    const configSection = document.getElementById('stepwise-config-section');
                    if (configSection) configSection.style.display = 'block';
                }
            });

           // åˆ†æ­¥å˜é‡æ›´æ–°é…ç½®äº‹ä»¶ç›‘å¬å™¨
           document.getElementById('stepwise-source-same')?.addEventListener('change', (e) => {
               if (e.target.checked) {
                   if (!this.stepwiseConfig) this.stepwiseConfig = {};
                   this.stepwiseConfig.modelSource = 'ä¸æ’å¤´ç›¸åŒ';
                   this.saveMvuUpdateMode();
                   this.showTemporaryMessage('å˜é‡ç”Ÿæˆå°†ä½¿ç”¨ä¸æ’å¤´ç›¸åŒçš„API');
               }
           });

           document.getElementById('stepwise-source-custom')?.addEventListener('change', (e) => {
               if (e.target.checked) {
                   if (!this.stepwiseConfig) this.stepwiseConfig = {};
                   this.stepwiseConfig.modelSource = 'è‡ªå®šä¹‰';
                   this.saveMvuUpdateMode();
                   this.showTemporaryMessage('å˜é‡ç”Ÿæˆå°†ä½¿ç”¨ç¬¬äºŒAPIé…ç½®');
               }
           });

            // ä¸ºè‡ªåŠ¨å¼€å…³ä¸–ç•Œä¹¦å¤é€‰æ¡†ç»‘å®šç›‘å¬
            document.getElementById('auto-toggle-lorebook-checkbox')?.addEventListener('change', (e) => {
                this.isAutoToggleLorebookEnabled = e.target.checked;
                this.saveAutoToggleState();
                this.showTemporaryMessage(`è‡ªåŠ¨å¼€å…³ä¸–ç•Œä¹¦å·²${this.isAutoToggleLorebookEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
                if (this.isAutoToggleLorebookEnabled) {
                  this.startAutoTogglePolling();
                } else {
                  this.stopAutoTogglePolling();
                }
            });

            // ä¸–ç•Œä¹¦é«˜çº§è®¾ç½®ç›¸å…³äº‹ä»¶
            document.getElementById('toggle-worldbook-advanced')?.addEventListener('click', (e) => {
                e.preventDefault();
                const advancedSection = document.getElementById('worldbook-advanced-settings');
                const arrow = document.getElementById('worldbook-advanced-arrow');
                
                if (advancedSection.style.display === 'none') {
                    advancedSection.style.display = 'block';
                    arrow.textContent = 'â–¼';
                } else {
                    advancedSection.style.display = 'none';
                    arrow.textContent = 'â–¶';
                }
            });

            // ä½ç½®é€‰æ‹©æ”¹å˜æ—¶å¯ç”¨/ç¦ç”¨æ·±åº¦è¾“å…¥
            const positionSelects = ['journey-position', 'past-lives-position', 'novel-position'];
            positionSelects.forEach(id => {
                document.getElementById(id)?.addEventListener('change', (e) => {
                    const depthInput = document.getElementById(id.replace('-position', '-depth'));
                    if (depthInput) {
                        if (e.target.value.startsWith('at_depth')) {
                            depthInput.disabled = false;
                        } else {
                            depthInput.disabled = true;
                        }
                    }
                });
            });

            // ä¿å­˜ä¸–ç•Œä¹¦è®¾ç½®
            document.getElementById('save-worldbook-settings')?.addEventListener('click', () => {
                this.saveWorldbookSettings();
                this.showTemporaryMessage('ä¸–ç•Œä¹¦è®¾ç½®å·²ä¿å­˜');
            });

            // æ¢å¤é»˜è®¤è®¾ç½®
            document.getElementById('reset-worldbook-settings')?.addEventListener('click', () => {
                this.resetWorldbookSettings();
                this.loadWorldbookSettings(); // é‡æ–°åŠ è½½UI
                this.showTemporaryMessage('å·²æ¢å¤é»˜è®¤ä¸–ç•Œä¹¦è®¾ç½®');
            });

            document.getElementById('btn-inventory')?.addEventListener('click', () => this.showInventory());
            document.getElementById('btn-relationships')?.addEventListener('click', () => this.showRelationships());
            document.getElementById('btn-sects')?.addEventListener('click', () => this.showSects());
            // document.getElementById('btn-world-events')?.addEventListener('click', () => this.showWorldEvents());
            // document.getElementById('btn-variable-editor')?.addEventListener('click', () => this.showVariableEditor());
            document.getElementById('btn-guixu-system')?.addEventListener('click', () => this.showGuixuSystem());
            document.getElementById('btn-guixu-space')?.addEventListener('click', () => this.showGuixuSpace());
            // æ€ç»´è¿‡ç¨‹å®¹å™¨çš„ç‚¹å‡»äº‹ä»¶
            document.getElementById('thinking-process-header')?.addEventListener('click', () => this.toggleThinkingDisplay());

            // æœ¬ä¸–å†ç¨‹å®¹å™¨çš„ç‚¹å‡»äº‹ä»¶
            document.getElementById('current-life-header')?.addEventListener('click', () => this.toggleCurrentLifeDisplay());

            // å¾€ä¸–æ¶Ÿæ¼ªå®¹å™¨çš„ç‚¹å‡»äº‹ä»¶
            document.getElementById('past-lives-header')?.addEventListener('click', () => this.togglePastLivesDisplay());
            
            // å†å²æ­£æ–‡è®¾ç½®å®æ—¶ç›‘å¬
            document.getElementById('historical-text-count')?.addEventListener('change', (e) => {
              const count = parseInt(e.target.value);
              if (!isNaN(count) && count >= -1) {
                this.historicalTextCount = count;
                this.saveHistoricalTextSettings();
                this.updateHistoricalText();
              }
            });

            // æ»šåŠ¨å¯¼èˆªæŒ‰é’®äº‹ä»¶
            const mainContent = document.getElementById('main-content');
            const toTopBtn = document.getElementById('scroll-to-top-btn');
            const toBottomBtn = document.getElementById('scroll-to-bottom-btn');
            const toRealBottomBtn = document.getElementById('scroll-to-real-bottom-btn');
            const prevChapterBtn = document.getElementById('prev-chapter-btn');
            const nextChapterBtn = document.getElementById('next-chapter-btn');
            const historicalTextContainer = document.getElementById('historical-text-container');
            const gameTextDisplay = document.getElementById('game-text-display');

            if (mainContent && toTopBtn && toBottomBtn && toRealBottomBtn && historicalTextContainer && gameTextDisplay) {
              let lastTopClickTime = 0;
              let lastScrollTop = 0;
              
              toTopBtn.addEventListener('click', () => {
                const now = Date.now();
                const currentScrollTop = mainContent.scrollTop;
                if (now - lastTopClickTime < 1000 && Math.abs(currentScrollTop - lastScrollTop) < 50) {
                  mainContent.scrollTo({ top: 0, behavior: 'smooth' });
                } else {
                  const rect = historicalTextContainer.getBoundingClientRect();
                  const containerRect = mainContent.getBoundingClientRect();
                  const targetPosition = mainContent.scrollTop + rect.top - containerRect.top;
                  mainContent.scrollTo({ top: targetPosition, behavior: 'smooth' });
                }
                
                lastTopClickTime = now;
                lastScrollTop = currentScrollTop;
              });

              toBottomBtn.addEventListener('click', () => {
                const titleContainer = document.getElementById('current-chapter-title');
                const thinkingContainer = document.getElementById('thinking-process-container');
                
                let targetElement = gameTextDisplay; // é»˜è®¤ç›®æ ‡
                if (titleContainer && titleContainer.style.display !== 'none') {
                  targetElement = titleContainer; // ä¼˜å…ˆæ»šåŠ¨åˆ°æ ‡é¢˜
                } else if (thinkingContainer && thinkingContainer.style.display !== 'none') {
                  targetElement = thinkingContainer; // å…¶æ¬¡æ»šåŠ¨åˆ°æ€ç»´é“¾
                }
                
                const rect = targetElement.getBoundingClientRect();
                const containerRect = mainContent.getBoundingClientRect();
                const targetPosition = mainContent.scrollTop + rect.top - containerRect.top;
                mainContent.scrollTo({ top: targetPosition, behavior: 'smooth' });
              });

              toRealBottomBtn.addEventListener('click', () => {
                mainContent.scrollTo({ top: mainContent.scrollHeight, behavior: 'smooth' });
              });

              // ç« èŠ‚å¯¼èˆªåŠŸèƒ½
              let currentChapterIndex = -1;
              let chapterElements = [];

              const updateChapterNavigation = () => {
                // è·å–å†å²æ­£æ–‡ä¸­çš„æ‰€æœ‰ç« èŠ‚æ ‡é¢˜
                chapterElements = Array.from(historicalTextContainer.querySelectorAll('.novel-chapter-title'));
                
                if (chapterElements.length > 0) {
                  prevChapterBtn.style.display = 'block';
                  nextChapterBtn.style.display = 'block';
                } else {
                  prevChapterBtn.style.display = 'none';
                  nextChapterBtn.style.display = 'none';
                }
              };

              prevChapterBtn.addEventListener('click', () => {
                if (chapterElements.length === 0) return;
                
                const scrollTop = mainContent.scrollTop;
                const containerRect = mainContent.getBoundingClientRect();
                let targetIndex = -1;
                
                for (let i = chapterElements.length - 1; i >= 0; i--) {
                  const rect = chapterElements[i].getBoundingClientRect();
                  const relativeTop = mainContent.scrollTop + rect.top - containerRect.top;
                  if (relativeTop < scrollTop - 50) {
                    targetIndex = i;
                    break;
                  }
                }
                
                if (targetIndex > 0) {
                  const rect = chapterElements[targetIndex - 1].getBoundingClientRect();
                  const targetPosition = mainContent.scrollTop + rect.top - containerRect.top;
                  mainContent.scrollTo({ top: targetPosition, behavior: 'smooth' });
                } else if (targetIndex === 0 || targetIndex === -1) {
                  mainContent.scrollTo({ top: 0, behavior: 'smooth' });
                }
              });

              nextChapterBtn.addEventListener('click', () => {
                if (chapterElements.length === 0) return;
                
                const scrollTop = mainContent.scrollTop;
                const containerRect = mainContent.getBoundingClientRect();
                let targetIndex = -1;
                
                for (let i = 0; i < chapterElements.length; i++) {
                  const rect = chapterElements[i].getBoundingClientRect();
                  const relativeTop = mainContent.scrollTop + rect.top - containerRect.top;
                  if (relativeTop > scrollTop + 50) {
                    targetIndex = i;
                    break;
                  }
                }
                
                if (targetIndex !== -1) {
                  const rect = chapterElements[targetIndex].getBoundingClientRect();
                  const targetPosition = mainContent.scrollTop + rect.top - containerRect.top;
                  mainContent.scrollTo({ top: targetPosition, behavior: 'smooth' });
                } else {
                  const titleContainer = document.getElementById('current-chapter-title');
                  const thinkingContainer = document.getElementById('thinking-process-container');
                  
                  let targetElement = gameTextDisplay; // é»˜è®¤ç›®æ ‡
                  if (titleContainer && titleContainer.style.display !== 'none') {
                    targetElement = titleContainer; // ä¼˜å…ˆæ»šåŠ¨åˆ°æ ‡é¢˜
                  } else if (thinkingContainer && thinkingContainer.style.display !== 'none') {
                    targetElement = thinkingContainer; // å…¶æ¬¡æ»šåŠ¨åˆ°æ€ç»´é“¾
                  }
                  
                  const rect = targetElement.getBoundingClientRect();
                  const targetPosition = mainContent.scrollTop + rect.top - containerRect.top;
                  mainContent.scrollTo({ top: targetPosition, behavior: 'smooth' });
                }
              });
              toTopBtn.style.display = 'block';
              toBottomBtn.style.display = 'block';

              // æš´éœ²æ›´æ–°ç« èŠ‚å¯¼èˆªçš„æ–¹æ³•ä¾›å¤–éƒ¨è°ƒç”¨
              this.updateChapterNavigation = updateChapterNavigation;
            } 
            document.getElementById('btn-settings')?.addEventListener('click', () => this.showSettings());
            document.getElementById('btn-reprocess-variables')?.addEventListener('click', () => this.reprocessVariables());
      
            document.getElementById('btn-gacha-system')?.addEventListener('click', () => this.showGachaSystem());
  
            // è®¾ç½®æ¨¡æ€æ¡†å†…çš„æŒ‰é’®äº‹ä»¶
            document.getElementById('btn-command-center-from-settings')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // è®¾ç½®æ ‡å¿—ä½
              this.showCommandCenter();
            });
            document.getElementById('btn-show-extracted-from-settings')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // è®¾ç½®æ ‡å¿—ä½
              this.showExtractedContent();
            });
            document.getElementById('btn-map-from-settings')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // è®¾ç½®æ ‡å¿—ä½
              this.showMap();
            });

            // ä»è®¾ç½®ä¸­æ‰“å¼€ä¸–ç•Œå¤§äº‹
            document.getElementById('world-events-btn-from-settings')?.addEventListener('click', () => {
                this.isFromSettingsModal = true;
                this.showWorldEvents();
            });
            // ä»è®¾ç½®ä¸­æ‰“å¼€å˜é‡ç¼–è¾‘å™¨
            document.getElementById('variable-editor-btn-from-settings')?.addEventListener('click', () => {
                this.isFromSettingsModal = true;
                this.showVariableEditor();
            });
            // ä»è®¾ç½®ä¸­æ‰“å¼€å°è¯´æ¨¡å¼
            document.getElementById('novel-mode-btn-from-settings')?.addEventListener('click', () => {
                this.isFromSettingsModal = true;
                this.showNovelMode();
            });

            document.getElementById('background-settings-btn')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // è®¾ç½®æ ‡å¿—ä½
              this.showBackgroundSettings();
            });
            
            // åŠŸèƒ½å…¥å£çš„ä¸–ç•Œä¹¦ç®¡ç†æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('btn-worldbook-manager-from-settings')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // è®¾ç½®æ ‡å¿—ä½
              this.showWorldbookManager();
            });

            // åˆ†æ®µè®°å¿†æŒ‰é’®äº‹ä»¶
            document.getElementById('btn-segmented-memory-from-settings')?.addEventListener('click', () => {
                this.isFromSettingsModal = true; // è®¾ç½®æ ‡å¿—ä½
                this.showSegmentedMemoryModal();
            });

            // é¢„è®¾ç®¡ç†æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('btn-presets-manager')?.addEventListener('click', () => {
              this.showWorldbookPresets();
            });

            // ä¸ºåˆ†æ®µè®°å¿†é¢„è§ˆçš„æ¡ç›®æ·»åŠ ç‚¹å‡»æŠ˜å /å±•å¼€äº‹ä»¶
            document.getElementById('segmented-memory-modal')?.addEventListener('click', (e) => {
                const header = e.target.closest('.summary-header');
                if (header) {
                    const details = header.nextElementSibling;
                    const arrow = header.querySelector('.summary-arrow');
                    if (details && details.classList.contains('summary-details')) {
                        if (details.style.display === 'none') {
                            details.style.display = 'block';
                            if(arrow) arrow.textContent = 'â–¼';
                        } else {
                            details.style.display = 'none';
                            if(arrow) arrow.textContent = 'â–¶';
                        }
                    }
                }
            });

            // ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢çš„é¢„è®¾æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('worldbook-presets-btn')?.addEventListener('click', () => {
              this.isFromWorldbookManager = true; 
              this.showWorldbookPresets();
            });

            // æ–‡å­—è®¾ç½®ç›¸å…³äº‹ä»¶ç›‘å¬å™¨
            // æ–‡å­—é¢œè‰²è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('text-color-normal')?.addEventListener('change', (e) => {
              this.textSettings.colors.normal = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('text-color-dialogue')?.addEventListener('change', (e) => {
              this.textSettings.colors.dialogue = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('text-color-psychology')?.addEventListener('change', (e) => {
              this.textSettings.colors.psychology = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('text-color-scenery')?.addEventListener('change', (e) => {
              this.textSettings.colors.scenery = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('text-color-character')?.addEventListener('change', (e) => {
              this.textSettings.colors.character = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });

            // å•ç‹¬å­—ä½“å¤§å°è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('font-size-normal')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.normal = parseInt(e.target.value);
              document.getElementById('font-size-normal-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('font-size-dialogue')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.dialogue = parseInt(e.target.value);
              document.getElementById('font-size-dialogue-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('font-size-psychology')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.psychology = parseInt(e.target.value);
              document.getElementById('font-size-psychology-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('font-size-scenery')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.scenery = parseInt(e.target.value);
              document.getElementById('font-size-scenery-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('font-size-character')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.character = parseInt(e.target.value);
              document.getElementById('font-size-character-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });

            // å…¨å±€å­—ä½“å¤§å°è®¾ç½®äº‹ä»¶ç›‘å¬å™¨å·²ç§»é™¤
            document.getElementById('font-family-select')?.addEventListener('change', (e) => {
              if (e.target.value === 'upload_new') {
                // è§¦å‘æ–‡ä»¶é€‰æ‹©
                document.getElementById('font-file-input').click();
                // é‡ç½®é€‰æ‹©æ¡†åˆ°ä¹‹å‰çš„å€¼
                setTimeout(() => {
                  e.target.value = this.textSettings.fontFamily;
                }, 100);
              } else {
                // åº”ç”¨é€‰æ‹©çš„å­—ä½“
                this.textSettings.fontFamily = e.target.value;
                // ç¡®ä¿è‡ªå®šä¹‰å­—ä½“æ ·å¼å·²åŠ è½½
                this.ensureCustomFontLoaded(e.target.value).then(() => {
                  this.applyTextSettings();
                  this.saveTextSettings();
                });
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªå®šä¹‰å­—ä½“
                const isCustomFont = this.textSettings.customFonts.some(font => font.family === e.target.value);
                const fontName = isCustomFont ?
                  this.textSettings.customFonts.find(font => font.family === e.target.value).name :
                  e.target.options[e.target.selectedIndex].text;
                
                this.showTemporaryMessage(`å·²åº”ç”¨å­—ä½“: ${fontName}`);
              }
            });
            document.getElementById('font-file-input')?.addEventListener('change', (e) => {
              this.handleFontUpload(e);
            });
            document.getElementById('reset-text-settings-btn')?.addEventListener('click', () => {
              this.resetTextSettings();
            });
            document.getElementById('preview-text-settings-btn')?.addEventListener('click', () => {
              this.previewTextSettings();
            });
            document.getElementById('font-compress-help-btn')?.addEventListener('click', () => {
              this.showFontCompressHelp();
            });
            // ä¸»ç•Œé¢çš„ä¸–ç•Œçº¿å›é¡¾æŒ‰é’®
            document.getElementById('btn-view-journey-main')?.addEventListener('click', () => this.showJourney());
            document.getElementById('btn-view-past-lives-main')?.addEventListener('click', () => this.showPastLives());
            document.getElementById('btn-save-load-manager')?.addEventListener('click', () => this.showNewSaveLoadManager());
            // document.getElementById('btn-novel-mode')?.addEventListener('click', () => this.showNovelMode());
            document.getElementById('btn-novel-mode-from-settings')?.addEventListener('click', () => this.showNovelMode());
            document.getElementById('btn-clear-all-saves')?.addEventListener('click', () => this.clearAllSaves());

            // å°è¯´æ¨¡å¼ç›¸å…³äº‹ä»¶ç»‘å®š
            // èƒŒæ™¯è®¾ç½®æŒ‰é’®
            document.getElementById('novel-background-btn')?.addEventListener('click', () => this.showNovelBackgroundSettings());
            // ç« èŠ‚é€‰æ‹©ä¸‹æ‹‰æ¡†
            document.getElementById('chapter-select')?.addEventListener('change', (e) => {
              const chapterIndex = parseInt(e.target.value, 10);
              if (!isNaN(chapterIndex) && chapterIndex >= 0) {
                this.showNovelChapter(chapterIndex);
              }
            });
            // ä¸Šä¸€ç« /ä¸‹ä¸€ç« æŒ‰é’®
            document.getElementById('prev-chapter-btn')?.addEventListener('click', () => this.prevChapter());
            document.getElementById('next-chapter-btn')?.addEventListener('click', () => this.nextChapter());
            // ä¹¦ç­¾åŠŸèƒ½æŒ‰é’®
            document.getElementById('add-bookmark-btn')?.addEventListener('click', () => this.addNovelBookmark());
            document.getElementById('goto-bookmark-btn')?.addEventListener('click', () => this.gotoBookmark());
            document.getElementById('delete-bookmark-btn')?.addEventListener('click', () => this.deleteBookmark());

            // æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢äº‹ä»¶ç›‘å¬å™¨
            document.addEventListener('change', (e) => {
              if (e.target.name === 'novel-display-mode') {
                this.switchNovelDisplayMode(e.target.value);
              }
            });
            // å¯¼å…¥å­˜æ¡£äº‹ä»¶å·²åœ¨äº‹ä»¶å§”æ‰˜ä¸­å¤„ç†ï¼Œé¿å…é‡å¤ç»‘å®š
            document.getElementById('import-file-input')?.addEventListener('change', (e) => this.handleFileImport(e));

              // ä¸ºå†™å…¥ä¸–ç•Œä¹¦æŒ‰é’®ç»‘å®šç›‘å¬å™¨
             document
              .getElementById('btn-write-journey')
              ?.addEventListener('click', () => this.writeJourneyToLorebook());
            document
              .getElementById('btn-write-past-lives')
              ?.addEventListener('click', () => this.writePastLivesToLorebook());
            document
              .getElementById('btn-write-novel-mode')
              ?.addEventListener('click', () => this.writeNovelModeToLorebook());

            document
              .getElementById('btn-write-character-card')
              ?.addEventListener('click', () => this.writeCharacterCardToLorebook());
            // ä¸ºè‡ªåŠ¨å†™å…¥å¤é€‰æ¡†ç»‘å®šç›‘å¬å™¨ï¼Œå¹¶å¢åŠ çŠ¶æ€ä¿å­˜
            const autoWriteCheckbox = document.getElementById('auto-write-checkbox');
            if (autoWriteCheckbox) {
              autoWriteCheckbox.addEventListener('change', e => {
                this.isAutoWriteEnabled = e.target.checked;
                this.saveAutoWriteState(this.isAutoWriteEnabled);
                this.showTemporaryMessage(`è‡ªåŠ¨å†™å…¥å†ç¨‹/æ¶Ÿæ¼ªå·²${this.isAutoWriteEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
                if (this.isAutoWriteEnabled) {
                  this.startAutoWritePolling();
                } else {
                  this.stopAutoWritePolling();
                }
              });
            }


            // æŒ‡ä»¤ä¸­å¿ƒæŒ‰é’®
            document
              .getElementById('btn-execute-commands')
              ?.addEventListener('click', () => this.executePendingActions());
            document.getElementById('btn-clear-commands')?.addEventListener('click', () => this.clearPendingActions());
            document.getElementById('btn-refresh-storage')?.addEventListener('click', () => this.refreshLocalStorage());
            document.getElementById('action-options-enabled-checkbox')?.addEventListener('change', (e) => {
                this.isActionOptionsEnabled = e.target.checked;
                this.saveActionOptionsState();
                this.showTemporaryMessage(`è¡ŒåŠ¨é€‰é¡¹æ˜¾ç¤ºå·²${this.isActionOptionsEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
                // é‡æ–°æ¸²æŸ“è¡ŒåŠ¨é€‰é¡¹ä»¥ç«‹å³åæ˜ å˜åŒ–
                this.renderActionOptions(this._extractLastTagContent('è¡ŒåŠ¨é€‰é¡¹', this.lastExtractedVariables || ''));
            });

            document.getElementById('auto-send-action-checkbox')?.addEventListener('change', (e) => {
               this.isActionAutoSend = e.target.checked;
               this.saveActionAutoSendState();
               this.showTemporaryMessage(`è¡ŒåŠ¨é€‰é¡¹ç‚¹å‡»å³å‘é€å·²${this.isActionAutoSend ? 'å¼€å¯' : 'å…³é—­'}`);
            });

            document.getElementById('streaming-enabled-checkbox')?.addEventListener('change', (e) => {
                this.isStreamingEnabled = e.target.checked;
                this.saveStreamingState();
                this.showTemporaryMessage(`æµå¼å“åº”å·²${this.isStreamingEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
            });

            document.getElementById('format-validation-enabled-checkbox')?.addEventListener('change', (e) => {
                this.isFormatValidationEnabled = e.target.checked;
                this.saveFormatValidationState();
                this.showTemporaryMessage(`æ ¼å¼å®¡æŸ¥å·²${this.isFormatValidationEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
            });

            // æ–°å¢ï¼šä¸ºå›è½¦å‘é€å¤é€‰æ¡†ç»‘å®šäº‹ä»¶
            document.getElementById('enter-send-checkbox')?.addEventListener('change', (e) => {
                this.isEnterSendEnabled = e.target.checked;
                this.saveEnterSendState();
                this.showTemporaryMessage(`å›è½¦å‘é€å·²${this.isEnterSendEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
            });

            // æ–°å¢ï¼šä¸ºé”®ç›˜å¿«æ·é”®å¤é€‰æ¡†ç»‘å®šäº‹ä»¶
            document.getElementById('keyboard-shortcuts-checkbox')?.addEventListener('change', (e) => {
                this.isKeyboardShortcutsEnabled = e.target.checked;
                this.saveKeyboardShortcutsState();
                this.showTemporaryMessage(`é”®ç›˜å¿«æ·é”®å·²${this.isKeyboardShortcutsEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
            });

            // æ–°å¢ï¼šä¸ºæ‰‹æœºè¾“å…¥æ¡†é€‚é…å¤é€‰æ¡†ç»‘å®šäº‹ä»¶
            document.getElementById('mobile-input-adapt-checkbox')?.addEventListener('change', (e) => {
                this.isMobileInputAdaptEnabled = e.target.checked;
                this.saveMobileInputAdaptState();
                this.showTemporaryMessage(`æ‰‹æœºè¾“å…¥æ¡†é€‚é…å·²${this.isMobileInputAdaptEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
                
                // å¦‚æœå…³é—­äº†é€‚é…ï¼Œéœ€è¦é‡ç½®è¾“å…¥æ¡†ä½ç½®
                if (!this.isMobileInputAdaptEnabled && this.floatingInputContainer) {
                    this.resetInputPosition();
                }
                
                // é‡æ–°åˆå§‹åŒ–é”®ç›˜å¤„ç†é€»è¾‘
                this.reinitializeInputKeyboardHandling();
            });

            // æ–°å¢ï¼šä¸ºé”®ç›˜å¿«æ·é”®ä¸‰è§’æŒ‰é’®ç»‘å®šç‚¹å‡»äº‹ä»¶
            document.getElementById('keyboard-shortcuts-toggle')?.addEventListener('click', () => {
                this.toggleKeyboardShortcutsDetails();
            });

            // æ–°å¢ï¼šä¸ºå¿«é€Ÿå‘é€è¾“å…¥æ¡†ç»‘å®šå›è½¦é”®äº‹ä»¶
            document.getElementById('quick-send-input')?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey && this.isEnterSendEnabled) {
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„æ¢è¡Œè¡Œä¸º
                    this.executeQuickSend();
                }
            });

             document
                .querySelectorAll('.modal-close-btn')
                .forEach(btn => btn.addEventListener('click', (e) => this.handleModalClose(e)));
  
              // æ–°å¢ï¼šä¸ºäººç‰©å…³ç³»é¢æ¿çš„è‡ªå®šä¹‰å…³é—­æŒ‰é’®æ·»åŠ å§”æ‰˜äº‹ä»¶
              // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç¡®ä¿åŠ¨æ€æ·»åŠ çš„æŒ‰é’®ä¹Ÿèƒ½è¢«ç›‘å¬åˆ°
              document.body.addEventListener('click', (e) => {
                if (e.target.matches('.relationships-close-btn') && e.target.closest('#relationships-modal')) {
                    window.GuixuManager.closeModal('relationships-modal');
                }
                
                if (e.target.matches('.sects-close-btn') && e.target.closest('#sects-modal')) {
                    window.GuixuManager.closeModal('sects-modal');
                }
                
                // æ–°å¢ï¼šå¤„ç†æ­£æ–‡ä¸­äººç‰©åç§°é“¾æ¥çš„ç‚¹å‡»äº‹ä»¶
                if (e.target.matches('.character-link')) {
                    e.preventDefault();
                    const characterName = e.target.getAttribute('data-character');
                    if (characterName) {
                        // æ‰“å¼€äººç‰©å…³ç³»ç•Œé¢
                        window.GuixuManager.showRelationships();
                        // ç­‰å¾…ç•Œé¢æ¸²æŸ“å®Œæˆåï¼Œè·³è½¬åˆ°å¯¹åº”äººç‰©
                        setTimeout(() => {
                            window.GuixuManager.renderCharacterDetails(characterName);
                        }, 100);
                    }
                }
              });

              // æ–°å¢ï¼šä¸ºè¾“å…¥ç¼“å­˜æ¨¡æ€æ¡†çš„å†…å®¹åˆ—è¡¨æ·»åŠ äº‹ä»¶å§”æ‰˜
              document.getElementById('input-cache-modal')?.addEventListener('click', e => {
                  if (e.target && e.target.closest('.input-cache-item')) {
                      const item = e.target.closest('.input-cache-item');
                      const content = item.dataset.content;
                      if (content) {
                          this.applyInputFromHistory(content);
                      }
                  }
              });
            document.querySelectorAll('.modal-overlay').forEach(overlay => {
              overlay.addEventListener('click', e => {
                if (e.target === overlay) this.handleModalClose(e);
              });
            });

            // äº‹ä»¶å§”æ‰˜ï¼šèƒŒåŒ…å†…çš„ç‚¹å‡»äº‹ä»¶
            const inventoryContentArea = document.querySelector('#inventory-modal .inventory-content-area');
            if (inventoryContentArea) {
              inventoryContentArea.addEventListener('click', e => {
                if (e.target.classList.contains('item-equip-btn')) {
                  const itemElement = e.target.closest('.inventory-item');
                  const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, "'") || '{}');
                  const category = itemElement.dataset.category;
                  // å¤„ç†åŠŸæ³•è£…å¤‡æŒ‰é’®
                  if (e.target.dataset.equipType === 'zhuxiu') {
                    this.equipItem(itemData, category, e.target, 'zhuxiuGongfa');
                  } else if (e.target.dataset.equipType === 'fuxiu') {
                    this.equipItem(itemData, category, e.target, 'fuxiuXinfa');
                  } else {
                    this.equipItem(itemData, category, e.target);
                  }
                } else if (e.target.classList.contains('item-use-btn')) {
                  const itemElement = e.target.closest('.inventory-item');
                  const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, "'") || '{}');
                  this.useItem(itemData, e.target);
                } else if (e.target.classList.contains('item-unequip-btn')) {
                  const slotId = e.target.dataset.slotId;
                  const slotElement = document.getElementById(slotId);
                  if (slotElement) {
                    this.unequipItem(slotId, slotElement, true, true); // ä»èƒŒåŒ…å¸è½½ï¼Œéœ€è¦åˆ·æ–°èƒŒåŒ…UI
                  }
                } else if (e.target.classList.contains('item-discard-btn')) {
                  const itemElement = e.target.closest('.inventory-item');
                  const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, "'") || '{}');
                  const category = itemElement.dataset.category;
                  this.discardItem(itemData, category, itemElement);
                }
              });
            }

            // äº‹ä»¶å§”æ‰˜ï¼šå·¦ä¾§è£…å¤‡é¢æ¿çš„äº‹ä»¶
            const characterPanel = document.querySelector('.character-panel');
            if (characterPanel) {
              // æ‚¬æµ®æ˜¾ç¤ºTooltip
              characterPanel.addEventListener('mouseover', e => {
                const slot = e.target.closest('.equipment-slot');
                if (slot && slot.classList.contains('equipped')) {
                  this.showEquipmentTooltip(slot, e);
                }
              });
              characterPanel.addEventListener('mouseout', e => {
                const slot = e.target.closest('.equipment-slot');
                if (slot) {
                  this.hideEquipmentTooltip();
                }
              });
              // é•¿æŒ‰å¸è½½ï¼Œå•å‡»æ˜¾ç¤ºè¯¦æƒ…
              let longPressTimer = null;
              const longPressDuration = 1000; // æ”¹ä¸º1ç§’

              const handlePressStart = (e, slot) => {
                if (!slot || !slot.classList.contains('equipped')) return;

                // ç§»é™¤æ—§çš„æŒ‡ç¤ºå™¨
                const oldIndicator = document.getElementById('long-press-indicator-instance');
                if (oldIndicator) oldIndicator.remove();
                const oldStyle = document.getElementById('long-press-style-instance');
                if (oldStyle) oldStyle.remove();

                const rect = slot.getBoundingClientRect();

                // 1. åˆ›å»ºåŠ¨ç”»æ ·å¼
                const styleId = 'long-press-style-instance';
                const keyframes = `
                    @keyframes border-top-anim { to { width: 100%; } }
                    @keyframes border-right-anim { to { height: 100%; } }
                    @keyframes border-bottom-anim { to { width: 100%; } }
                    @keyframes border-left-anim { to { height: 100%; } }
                `;
                const styleSheet = document.createElement('style');
                styleSheet.id = styleId;
                styleSheet.textContent = keyframes;
                document.head.appendChild(styleSheet);

                // 2. åˆ›å»ºæŒ‡ç¤ºå™¨å®¹å™¨
                const indicator = document.createElement('div');
                indicator.id = 'long-press-indicator-instance';
                Object.assign(indicator.style, {
                    position: 'fixed',
                    top: `${rect.top}px`,
                    left: `${rect.left}px`,
                    width: `${rect.width}px`,
                    height: `${rect.height}px`,
                    pointerEvents: 'none',
                    zIndex: '9999',
                    borderRadius: '5px',
                    overflow: 'hidden'
                });

                // 3. åˆ›å»ºå››ä¸ªè¾¹æ¡†æ®µ
                const borderTop = document.createElement('div');
                Object.assign(borderTop.style, { position: 'absolute', top: '0', left: '0', width: '0', height: '2px', backgroundColor: '#c9aa71', animation: `border-top-anim ${longPressDuration / 4000}s linear forwards` });
                
                const borderRight = document.createElement('div');
                Object.assign(borderRight.style, { position: 'absolute', top: '0', right: '0', width: '2px', height: '0', backgroundColor: '#c9aa71', animation: `border-right-anim ${longPressDuration / 4000}s linear forwards ${longPressDuration / 4000}s` });
                
                const borderBottom = document.createElement('div');
                Object.assign(borderBottom.style, { position: 'absolute', bottom: '0', right: '0', width: '0', height: '2px', backgroundColor: '#c9aa71', animation: `border-bottom-anim ${longPressDuration / 4000}s linear forwards ${longPressDuration / 2000}s` });

                const borderLeft = document.createElement('div');
                Object.assign(borderLeft.style, { position: 'absolute', bottom: '0', left: '0', width: '2px', height: '0', backgroundColor: '#c9aa71', animation: `border-left-anim ${longPressDuration / 4000}s linear forwards ${longPressDuration * 3 / 4000}s` });

                indicator.append(borderTop, borderRight, borderBottom, borderLeft);
                document.body.appendChild(indicator);
                
                longPressTimer = setTimeout(() => {
                  this.unequipItem(slot.id, slot, true, false);
                  longPressTimer = null;
                  const existingIndicator = document.getElementById('long-press-indicator-instance');
                  if (existingIndicator) existingIndicator.remove();
                  const existingStyle = document.getElementById(styleId);
                  if (existingStyle) existingStyle.remove();
                }, longPressDuration);
              };

              const removeIndicator = () => {
                  const existingIndicator = document.getElementById('long-press-indicator-instance');
                  if (existingIndicator) existingIndicator.remove();
                  const existingStyle = document.getElementById('long-press-style-instance');
                  if (existingStyle) existingStyle.remove();
              }

              const handlePressEnd = (e, slot) => {
                removeIndicator();
                if (longPressTimer) {
                  clearTimeout(longPressTimer);
                  longPressTimer = null;
                  if (slot && slot.classList.contains('equipped')) {
                    this.showEquipmentTooltip(slot, e); // å•å‡»è§¦å‘æ˜¾ç¤ºTooltip
                  }
                }
              };
              
              const handlePressCancel = (e) => {
                  removeIndicator();
                  if (longPressTimer) {
                      clearTimeout(longPressTimer);
                      longPressTimer = null;
                  }
              };

              characterPanel.addEventListener('mousedown', e => {
                  const slot = e.target.closest('.equipment-slot');
                  handlePressStart(e, slot);
              });
              characterPanel.addEventListener('mouseup', e => {
                  const slot = e.target.closest('.equipment-slot');
                  handlePressEnd(e, slot);
              });
              characterPanel.addEventListener('mouseleave', handlePressCancel);
              
              characterPanel.addEventListener('touchstart', e => {
                  const slot = e.target.closest('.equipment-slot');
                  handlePressStart(e, slot);
              }, { passive: true });
              characterPanel.addEventListener('touchend', e => {
                  const slot = e.target.closest('.equipment-slot');
                  handlePressEnd(e, slot);
              });
              characterPanel.addEventListener('touchmove', handlePressCancel, { passive: true });
            }

            // ä¸ºå¿«é€Ÿå‘é€æŒ‰é’®ç»‘å®šäº‹ä»¶
            document.getElementById('btn-quick-send')?.addEventListener('click', () => this.executeQuickSend());

            // --- æ–°å¢ï¼šä¸ºè¾“å…¥ç¼“å­˜ç»‘å®šäº‹ä»¶ ---
            document.getElementById('btn-show-cache')?.addEventListener('click', () => this.showInputCacheModal());

            // æ–°å¢ï¼šä¸ºè¡ŒåŠ¨é€‰é¡¹å®¹å™¨ç»‘å®šäº‹ä»¶å§”æ‰˜
            document.getElementById('action-options-container')?.addEventListener('click', (e) => {
                if (e.target && e.target.classList.contains('action-option-btn')) {
                    const actionText = e.target.dataset.actionText;
                    if (actionText) {
                        if (this.isActionAutoSend) {
                            // å¼€å¯æ—¶ï¼Œç›´æ¥ç‚¹å‡»å‘é€
                            this.handleAction(actionText);
                        } else {
                            // å…³é—­æ—¶ï¼ŒåŠ å…¥è¾“å…¥æ¡†
                            const input = document.getElementById('quick-send-input');
                            if (input) {
                                input.value = actionText;
                            }
            if (document.getElementById('gacha-modal').style.display === 'flex') {
                this.renderSummonTab();
            }

                        }
                    }
                }
            });


            // ç»‘å®šæ–°å­˜æ¡£ç•Œé¢çš„äº‹ä»¶
            const newSaveLoadContainer = document.getElementById('new-save-load-container');
            if (newSaveLoadContainer) {
              newSaveLoadContainer.addEventListener('click', (e) => {
                const header = e.target.closest('.accordion-header');
                if (header && !e.target.closest('.save-header-actions')) {
                  const item = header.parentElement;
                  const content = item.querySelector('.content-grid');
                  
                  // æ‰‹é£ç´æ•ˆæœï¼šå…³é—­å…¶ä»–æ‰€æœ‰å·²æ‰“å¼€çš„
                  const allItems = newSaveLoadContainer.querySelectorAll('.accordion-item');
                  allItems.forEach(otherItem => {
                    if (otherItem !== item && otherItem.classList.contains('active')) {
                      otherItem.classList.remove('active');
                      otherItem.querySelector('.content-grid').style.display = 'none';
                    }
                  });

                  // åˆ‡æ¢å½“å‰ç‚¹å‡»çš„
                  item.classList.toggle('active');
                  if (content) {
                    content.style.display = item.classList.contains('active') ? 'grid' : 'none';
                  }
                }
              });
            }
            
            // è‡ªåŠ¨å­˜æ¡£å¤é€‰æ¡†
            const autoSaveCheckbox = document.getElementById('auto-save-checkbox');
            if (autoSaveCheckbox) {
              autoSaveCheckbox.addEventListener('change', (e) => {
                  this.isAutoSaveEnabled = e.target.checked;
                  this.saveAutoSaveState();
                  this.showTemporaryMessage(`è‡ªåŠ¨å­˜æ¡£å·²${this.isAutoSaveEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
              });
            }

            document.getElementById('btn-cancel-trim')?.addEventListener('click', () => {
                this.closeModal('trim-journey-modal');
            });


            // ç»‘å®šé”®ç›˜å¿«æ·é”®
            this.bindKeyboardShortcuts();

            this.listenersBound = true; // è®¾ç½®æ ‡å¿—ä½ï¼Œç¡®ä¿æ­¤ä»£ç å—åªè¿è¡Œä¸€æ¬¡


            // ä¸ºæ–°çš„å­˜æ¡£/è¯»æ¡£æ¨¡æ€æ¡†æ·»åŠ äº‹ä»¶å§”æ‰˜
            const saveLoadModal = document.getElementById('save-load-modal');
            if (saveLoadModal) {
                saveLoadModal.addEventListener('click', (e) => {
                    const target = e.target;
                    
                    // æ‰‹åŠ¨å­˜æ¡£æŒ‰é’®
                    if (target.id === 'btn-manual-save') {
                        this.saveGame(false);
                        return;
                    }

                    // å¯¼å…¥å­˜æ¡£æŒ‰é’®
                    if (target.id === 'btn-import-save') {
                        document.getElementById('import-file-input').click();
                        return;
                    }

                    // ç®¡ç†ç³»åˆ—æŒ‰é’®
                    if (target.id === 'btn-manage-series') {
                        this.showSeriesManager();
                        return;
                    }

                    // æ¸…é™¤æ‰€æœ‰å­˜æ¡£æŒ‰é’®
                    if (target.id === 'btn-clear-all-saves') {
                        this.showCustomConfirm('ç¡®å®šè¦åˆ é™¤æ‰€æœ‰å­˜æ¡£å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼', () => {
                            this.deleteAllSaves().then(() => this.showNewSaveLoadManager());
                        });
                        return;
                    }

                    const accordionItem = target.closest('.accordion-item');
                    if (!accordionItem) return;

                    const saveId = accordionItem.dataset.saveId;
                    if (!saveId) return;

                    if (target.classList.contains('btn-load-new')) {
                        this.loadGame(saveId);
                    } else if (target.classList.contains('btn-delete-new')) {
                        this.showCustomConfirm(`ç¡®å®šè¦åˆ é™¤å­˜æ¡£â€œ${accordionItem.querySelector('.save-name').textContent}â€å—ï¼Ÿ`, () => {
                            this.deleteGameSave(saveId).then(() => this.showNewSaveLoadManager());
                        });
                    } else if (target.classList.contains('btn-rename-new')) {
                       e.stopPropagation(); // é˜»æ­¢æ‰‹é£ç´å±•å¼€
                       this.renameSave(saveId);
                    } else if (target.classList.contains('btn-export-new')) {
                       e.stopPropagation(); // é˜»æ­¢æ‰‹é£ç´å±•å¼€
                       this.exportSave(saveId);
                   }
                });
            }
 
            // ç»‘å®šèƒŒæ™¯å›¾è®¾ç½®æ¨¡æ€æ¡†ä¸­çš„é™æ€äº‹ä»¶
            this.bindBackgroundSettingsListeners();

            // ç»‘å®šä¸–ç•Œå¤§äº‹å¯¼èˆªæŒ‰é’®ï¼ˆä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œå› ä¸ºæŒ‰é’®æ˜¯åŠ¨æ€ç”Ÿæˆçš„ï¼‰
            document.addEventListener('click', (e) => {
              const target = e.target.closest('#world-events-nav-prev, #world-events-nav-next');
              if (!target) return;
              
              e.preventDefault();
              e.stopPropagation();
              
              if (target.id === 'world-events-nav-prev') {
                this.navigateWorldEvent('prev');
              } else if (target.id === 'world-events-nav-next') {
                this.navigateWorldEvent('next');
              }
            });
          },
 
// ===æŒ‰é’®ç»Ÿä¸€ç›‘å¬ç»‘å®šæ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰ç»“æŸ===




// ===ç•Œé¢æ§åˆ¶æ¨¡å—å¼€å§‹===



            showSettings() {
              this.isFromSettingsModal = false; // ç¡®ä¿ä»å…¶ä»–åœ°æ–¹æ‰“å¼€æ—¶é‡ç½®çŠ¶æ€
              this.openModal('settings-modal');
              // åˆå§‹åŒ–é€æ˜åº¦æ»‘å—
              this.initOpacitySlider();
              this.initPanelWidthSliders(); // æ–°å¢ï¼šåˆå§‹åŒ–é¢æ¿å®½åº¦æ»‘å—
              // åˆå§‹åŒ–æ–‡å­—è®¾ç½®UI
              this.updateTextSettingsUI();
              this.updateCustomFontsList();
              // ç¡®ä¿å½“å‰å­—ä½“æ ·å¼ç«‹å³ç”Ÿæ•ˆ
              this.applyTextSettings();
              // åˆå§‹åŒ–ä¸–ç•Œä¹¦æ§åˆ¶çŠ¶æ€
              this.initWorldbookControlsInSettings();
              
              // æ–°å¢ï¼šåŠ¨æ€è®¾ç½®å…¨å±å°ºå¯¸
              const rootContainer = document.querySelector('.guixu-root-container');
              const modalContent = document.querySelector('#settings-modal .modal-content');
              if (rootContainer && modalContent) {
                  const rect = rootContainer.getBoundingClientRect();
                  modalContent.style.setProperty('width', `${rect.width}px`, 'important');
                  modalContent.style.setProperty('height', `${rect.height}px`, 'important');
                  modalContent.style.setProperty('top', `${rect.top}px`, 'important');
                  modalContent.style.setProperty('left', `${rect.left}px`, 'important');
                  modalContent.style.setProperty('max-width', 'none', 'important');
                  modalContent.style.setProperty('max-height', 'none', 'important');
              }
            },

           // åˆå§‹åŒ–é€æ˜åº¦æ»‘å—
           initOpacitySlider() {
             const slider = document.getElementById('opacity-slider');
             const valueDisplay = document.getElementById('opacity-value');
             
             if (slider && valueDisplay) {
               // è®¾ç½®å½“å‰å€¼
               slider.value = this.mainOpacity;
               valueDisplay.textContent = `å½“å‰è®¾ç½®: ${this.mainOpacity}%`;
               
               // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
               slider.addEventListener('input', (e) => {
                 this.updateOpacity(parseInt(e.target.value));
               });
             }
           },

           // æ›´æ–°é€æ˜åº¦
           updateOpacity(value) {
             this.mainOpacity = value;
             const valueDisplay = document.getElementById('opacity-value');
             if (valueDisplay) {
               valueDisplay.textContent = `å½“å‰è®¾ç½®: ${value}%`;
             }
             
             // åº”ç”¨é€æ˜åº¦åˆ°ä¸»ç•Œé¢
             this.applyOpacityToMainInterface(value);
             
             // ä¿å­˜è®¾ç½®
             this.saveOpacitySettings();
           },

           // åº”ç”¨é€æ˜åº¦åˆ°ä¸»ç•Œé¢
           applyOpacityToMainInterface(opacity) {
             // å°†é€æ˜åº¦å€¼è½¬æ¢ä¸º0-1çš„èŒƒå›´
             const opacityValue = opacity / 100;
             
             // é€šè¿‡åŠ¨æ€åˆ›å»ºCSSè§„åˆ™æ¥æ§åˆ¶ä¼ªå…ƒç´ çš„é€æ˜åº¦
             let styleElement = document.getElementById('dynamic-overlay-style');
             if (!styleElement) {
               styleElement = document.createElement('style');
               styleElement.id = 'dynamic-overlay-style';
               document.head.appendChild(styleElement);
             }
             
             // åˆ›å»ºCSSè§„åˆ™æ¥æ§åˆ¶ä¼ªå…ƒç´ çš„é€æ˜åº¦
             styleElement.textContent = `
               .guixu-root-container::before {
                 content: '';
                 position: absolute;
                 top: 0;
                 left: 0;
                 width: 100%;
                 height: 100%;
                 background: rgba(26, 26, 46, ${opacityValue}) !important;
                 pointer-events: none;
                 z-index: -1;
               }
             `;
           },

           // æ–°å¢ï¼šä¿å­˜é€æ˜åº¦è®¾ç½®
           saveOpacitySettings() {
             try {
               localStorage.setItem('guixu_main_opacity', this.mainOpacity.toString());
             } catch (e) {
               console.error('ä¿å­˜é€æ˜åº¦è®¾ç½®å¤±è´¥:', e);
             }
           },

           // æ–°å¢ï¼šåŠ è½½é€æ˜åº¦è®¾ç½®
           loadOpacitySettings() {
             try {
               const saved = localStorage.getItem('guixu_main_opacity');
               if (saved) {
                 this.mainOpacity = parseInt(saved);
                 this.applyOpacityToMainInterface(this.mainOpacity);
               }
             } catch (e) {
               console.error('åŠ è½½é€æ˜åº¦è®¾ç½®å¤±è´¥:', e);
               this.mainOpacity = 100; // é»˜è®¤å€¼
             }
           },



// ===ç•Œé¢æ§åˆ¶æ¨¡å—ç»“æŸ===



// ===æ–‡å­—ã€å­—ä½“ç›¸å…³è®¾ç½®æ¨¡å—å¼€å§‹===
           // åº”ç”¨æ–‡å­—è®¾ç½®åˆ°é¡µé¢
           async applyTextSettings() {
             try {
               // ç¡®ä¿è‡ªå®šä¹‰å­—ä½“çš„CSSæ ·å¼å­˜åœ¨
               await this.ensureCustomFontsLoaded();
               
               // ä¼˜åŒ–æ€§èƒ½ï¼šæŸ¥æ‰¾ç°æœ‰æ ·å¼æ ‡ç­¾ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºï¼Œå¦åˆ™ç›´æ¥æ›´æ–°å†…å®¹
               let style = document.getElementById('guixu-text-settings-style');
               if (!style) {
                 style = document.createElement('style');
                 style.id = 'guixu-text-settings-style';
                 document.head.appendChild(style);
               }
               style.textContent = `
                 .game-text-container {
                   color: ${this.textSettings.colors.normal} !important;
                   font-size: ${this.textSettings.fontSizes?.normal}px !important;
                   font-family: ${this.textSettings.fontFamily} !important;
                 }
                 .text-language {
                   color: ${this.textSettings.colors.dialogue} !important;
                   font-size: ${this.textSettings.fontSizes?.dialogue}px !important;
                   font-style: italic;
                 }
                 .text-psychology {
                   color: ${this.textSettings.colors.psychology} !important;
                   font-size: ${this.textSettings.fontSizes?.psychology}px !important;
                   font-style: italic;
                   opacity: 0.8;
                 }
                 .text-scenery {
                   color: ${this.textSettings.colors.scenery} !important;
                   font-size: ${this.textSettings.fontSizes?.scenery}px !important;
                 }
                 .character-link {
                   color: ${this.textSettings.colors.character} !important;
                   font-size: ${this.textSettings.fontSizes?.character}px !important;
                 }
                  .game-text-container,
                  .game-text-container > *:not(.text-language):not(.text-psychology):not(.text-scenery):not(.character-link),
                  .game-text-container p,
                  .game-text-container div:not([class*="text-"]) {
                    font-size: ${this.textSettings.fontSizes?.normal}px !important;
                  }
               `;
               
               // å¼ºåˆ¶åˆ·æ–°é¡µé¢ä¸Šçš„æ–‡å­—æ˜¾ç¤º
               this.refreshTextDisplay();
               
             } catch (e) {
               console.error('åº”ç”¨æ–‡å­—è®¾ç½®å¤±è´¥:', e);
             }
           },

           // ç¡®ä¿è‡ªå®šä¹‰å­—ä½“å·²åŠ è½½
           async ensureCustomFontsLoaded() {
             try {
               const loadPromises = this.textSettings.customFonts.map(async (font) => {
                 const existingStyle = document.getElementById(`font-style-${font.hash}`);
                 if (!existingStyle && font.cacheKey) {
                   try {
                     // å¦‚æœå­—ä½“æ ·å¼ä¸å­˜åœ¨ï¼Œå°è¯•ä»ç¼“å­˜é‡æ–°åŠ è½½
                     const cachedFont = await this.loadFontFromIndexedDB(font.cacheKey);
                     const style = document.createElement('style');
                     style.id = `font-style-${font.hash}`;
                     style.textContent = `
                       @font-face {
                         font-family: ${font.family};
                         src: url(${cachedFont.data});
                         font-display: swap;
                       }
                     `;
                     document.head.appendChild(style);
                     return true;
                   } catch (error) {
                     console.warn('[å½’å¢Ÿæ–‡å­—è®¾ç½®] æ— æ³•é‡æ–°åŠ è½½å­—ä½“:', font.name, error);
                     return false;
                   }
                 }
                 return true;
               });
               
               await Promise.all(loadPromises);
             } catch (e) {
               console.error('ç¡®ä¿è‡ªå®šä¹‰å­—ä½“åŠ è½½å¤±è´¥:', e);
             }
           },

           // å¼ºåˆ¶åˆ·æ–°æ–‡å­—æ˜¾ç¤º
           refreshTextDisplay() {
             try {
               // æ‰¾åˆ°æ‰€æœ‰æ–‡å­—å®¹å™¨å¹¶å¼ºåˆ¶é‡æ–°æ¸²æŸ“
               const textContainers = document.querySelectorAll('.game-text-container');
               textContainers.forEach(container => {
                 // è§¦å‘é‡æ–°æ¸²æŸ“
                 const display = container.style.display;
                 container.style.display = 'none';
                 container.offsetHeight; // å¼ºåˆ¶é‡æ’
                 container.style.display = display;
               });

               // åˆ·æ–°æ‰€æœ‰æ–‡å­—æ ·å¼å…ƒç´ 
               const textElements = document.querySelectorAll('.text-language, .text-psychology, .text-scenery');
               textElements.forEach(element => {
                 // å¼ºåˆ¶é‡æ–°åº”ç”¨æ ·å¼
                 const className = element.className;
                 element.className = '';
                 element.offsetHeight; // å¼ºåˆ¶é‡æ’
                 element.className = className;
               });
             } catch (e) {
               console.error('åˆ·æ–°æ–‡å­—æ˜¾ç¤ºå¤±è´¥:', e);
             }
           },

           // ä¿å­˜æ–‡å­—è®¾ç½®
           saveTextSettings() {
             try {
               localStorage.setItem('guixu_text_settings', JSON.stringify(this.textSettings));
             } catch (e) {
               console.error('ä¿å­˜æ–‡å­—è®¾ç½®å¤±è´¥:', e);
             }
           },

           // åŠ è½½æ–‡å­—è®¾ç½®
           loadTextSettings() {
             try {
               const saved = localStorage.getItem('guixu_text_settings');
               if (saved) {
                 const settings = JSON.parse(saved);
                 this.textSettings = { ...this.textSettings, ...settings };

                 // åŠ è½½å¹¶åº”ç”¨è‡ªå®šä¹‰å­—ä½“ï¼ˆä»IndexedDBç¼“å­˜ï¼‰
                 if (this.textSettings.customFonts && this.textSettings.customFonts.length > 0) {
                   // ä½¿ç”¨Promise.allç¡®ä¿æ‰€æœ‰å­—ä½“éƒ½åŠ è½½å®Œæˆ
                   const fontLoadPromises = this.textSettings.customFonts.map(async (font) => {
                     try {
                       if (font.cacheKey) {
                         // ä»IndexedDBåŠ è½½
                         const cachedFont = await this.loadFontFromIndexedDB(font.cacheKey);
                         if (!cachedFont) {
                            console.warn(`[å½’å¢Ÿ] å­—ä½“ "${font.name}" ä»ç¼“å­˜åŠ è½½å¤±è´¥ï¼Œè·³è¿‡ã€‚`);
                            return false; 
                         }
                         const oldStyle = document.getElementById(`font-style-${font.hash}`);
                         if (oldStyle) {
                           oldStyle.remove();
                         }
                         
                         const style = document.createElement('style');
                         style.id = `font-style-${font.hash}`;
                         style.textContent = `
                           @font-face {
                             font-family: "${font.family}";
                             src: url(${cachedFont.data});
                             font-display: swap;
                           }
                         `;
                         document.head.appendChild(style);
                         return true;
                       } else if (font.data) {
                         const style = document.createElement('style');
                         style.id = `font-style-${font.hash || 'legacy'}`;
                         style.textContent = `
                           @font-face {
                             font-family: ${font.family};
                             src: url(${font.data});
                             font-display: swap;
                           }
                         `;
                         document.head.appendChild(style);
                         return true;
                       }
                     } catch (error) {
                       console.warn(`[å½’å¢Ÿæ–‡å­—è®¾ç½®] æ— æ³•åŠ è½½å­—ä½“ ${font.name}:`, error);
                       return false;
                     }
                   });

                   // ç­‰å¾…æ‰€æœ‰å­—ä½“åŠ è½½å®Œæˆåå†åº”ç”¨è®¾ç½®
                   Promise.all(fontLoadPromises).then((results) => {
                     this.textSettings.customFonts = this.textSettings.customFonts.filter((font, index) => results[index]);
                     
                     // åº”ç”¨æ–‡å­—è®¾ç½®
                     this.updateTextSettingsUI();
                     this.applyTextSettings();
                   });
                 } else {
                   // æ²¡æœ‰è‡ªå®šä¹‰å­—ä½“ï¼Œç›´æ¥åº”ç”¨è®¾ç½®
                   this.updateTextSettingsUI();
                   this.applyTextSettings();
                 }
               } else {
                 // æ²¡æœ‰ä¿å­˜çš„è®¾ç½®ï¼Œä½¿ç”¨é»˜è®¤è®¾ç½®
                 this.updateTextSettingsUI();
                 this.applyTextSettings();
               }
             } catch (e) {
               console.error('åŠ è½½æ–‡å­—è®¾ç½®å¤±è´¥:', e);
               // å‡ºé”™æ—¶ä¹Ÿè¦åº”ç”¨é»˜è®¤è®¾ç½®
               this.updateTextSettingsUI();
               this.applyTextSettings();
             }
           },

           // æ›´æ–°æ–‡å­—è®¾ç½®UI
           updateTextSettingsUI() {
             try {
               const normalInput = document.getElementById('text-color-normal');
               const dialogueInput = document.getElementById('text-color-dialogue');
               const psychologyInput = document.getElementById('text-color-psychology');
               const sceneryInput = document.getElementById('text-color-scenery');
               const characterInput = document.getElementById('text-color-character');
               const fontFamilySelect = document.getElementById('font-family-select');

               if (normalInput) normalInput.value = this.textSettings.colors.normal;
               if (dialogueInput) dialogueInput.value = this.textSettings.colors.dialogue;
               if (psychologyInput) psychologyInput.value = this.textSettings.colors.psychology;
               if (sceneryInput) sceneryInput.value = this.textSettings.colors.scenery;
               if (characterInput) characterInput.value = this.textSettings.colors.character;

               // æ›´æ–°ç‹¬ç«‹å­—ä½“å¤§å°æ»‘å—çš„UI
               const fontSizes = this.textSettings.fontSizes;
               if (fontSizes) {
                   const normalSizeSlider = document.getElementById('font-size-normal');
                   const normalSizeValue = document.getElementById('font-size-normal-value');
                   if (normalSizeSlider && fontSizes.normal) {
                       normalSizeSlider.value = fontSizes.normal;
                       if (normalSizeValue) normalSizeValue.textContent = fontSizes.normal + 'px';
                   }

                   const dialogueSizeSlider = document.getElementById('font-size-dialogue');
                   const dialogueSizeValue = document.getElementById('font-size-dialogue-value');
                   if (dialogueSizeSlider && fontSizes.dialogue) {
                       dialogueSizeSlider.value = fontSizes.dialogue;
                       if (dialogueSizeValue) dialogueSizeValue.textContent = fontSizes.dialogue + 'px';
                   }

                   const psychologySizeSlider = document.getElementById('font-size-psychology');
                   const psychologySizeValue = document.getElementById('font-size-psychology-value');
                   if (psychologySizeSlider && fontSizes.psychology) {
                       psychologySizeSlider.value = fontSizes.psychology;
                       if (psychologySizeValue) psychologySizeValue.textContent = fontSizes.psychology + 'px';
                   }

                   const scenerySizeSlider = document.getElementById('font-size-scenery');
                   const scenerySizeValue = document.getElementById('font-size-scenery-value');
                   if (scenerySizeSlider && fontSizes.scenery) {
                     scenerySizeSlider.value = fontSizes.scenery;
                     scenerySizeValue.textContent = fontSizes.scenery + 'px';
                   }

                   const characterSizeSlider = document.getElementById('font-size-character');
                   const characterSizeValue = document.getElementById('font-size-character-value');
                   if (characterSizeSlider && fontSizes.character) {
                     characterSizeSlider.value = fontSizes.character;
                     characterSizeValue.textContent = fontSizes.character + 'px';
                   }
               }
               
               if (fontFamilySelect) {
                 this.updateFontFamilyOptions();
                 fontFamilySelect.value = this.textSettings.fontFamily;
               }
             } catch (e) {
               console.error('æ›´æ–°æ–‡å­—è®¾ç½®UIå¤±è´¥:', e);
             }
           },

           // --- è‡ªåŠ¨é˜…è¯» ---
           initAutoRead() {
             const autoReadCheckbox = document.getElementById('auto-read-checkbox');
             const autoReadSpeedSlider = document.getElementById('auto-read-speed');
             const autoReadSpeedValue = document.getElementById('auto-read-speed-value');
             const autoReadFloat = document.getElementById('auto-read-float');
             const autoReadFloatSpeedSlider = document.getElementById('auto-read-float-speed');
             const autoReadFloatSpeedValue = document.getElementById('auto-read-float-speed-value');
             const autoReadCloseBtn = document.getElementById('auto-read-close-btn');
             const autoReadToggleBtn = document.getElementById('auto-read-toggle-btn');
             const mainContent = document.getElementById('main-content');

             const updateSpeedDisplay = (speed) => {
               if (autoReadSpeedValue) autoReadSpeedValue.textContent = speed;
               if (autoReadFloatSpeedValue) autoReadFloatSpeedValue.textContent = speed;
               if (autoReadSpeedSlider) autoReadSpeedSlider.value = speed;
               if (autoReadFloatSpeedSlider) autoReadFloatSpeedSlider.value = speed;
             };

             this.loadAutoReadSettings();
             updateSpeedDisplay(this.autoReadSpeed);

             autoReadCheckbox.addEventListener('change', (e) => {
               this.isAutoReading = e.target.checked;
               
               // ç¡®ä¿æ‚¬æµ®çª—å…ƒç´ å­˜åœ¨
               let autoReadFloat = document.getElementById('auto-read-float');
               if (!autoReadFloat) {
                 console.error('[è‡ªåŠ¨é˜…è¯»] æ‚¬æµ®çª—å…ƒç´ ä¸¢å¤±');
                 return;
               }
               
               // ç¡®ä¿æ‚¬æµ®çª—åœ¨bodyä¸­
               if (!document.body.contains(autoReadFloat)) {
                 document.body.appendChild(autoReadFloat);
               }
               
               if (this.isAutoReading) {
                 this.startAutoRead();
                 autoReadFloat.style.display = 'block';
               } else {
                 this.stopAutoRead();
                 autoReadFloat.style.display = 'none';
               }
               this.saveAutoReadSettings();
             });

             const handleSpeedChange = (e) => {
               this.autoReadSpeed = parseInt(e.target.value, 10);
               updateSpeedDisplay(this.autoReadSpeed);
               if (this.isAutoReading) {
                 this.stopAutoRead();
                 this.startAutoRead();
               }
               this.saveAutoReadSettings();
             };

             autoReadSpeedSlider.addEventListener('input', handleSpeedChange);
             autoReadFloatSpeedSlider.addEventListener('input', handleSpeedChange);

             autoReadCloseBtn.addEventListener('click', () => {
               this.isAutoReading = false;
               const autoReadCheckbox = document.getElementById('auto-read-checkbox');
               if (autoReadCheckbox) {
                 autoReadCheckbox.checked = false;
               }
               this.stopAutoRead();
               
               const autoReadFloat = document.getElementById('auto-read-float');
               if (autoReadFloat) {
                 autoReadFloat.style.display = 'none';
               }
               this.saveAutoReadSettings();
             });

             autoReadToggleBtn.addEventListener('click', () => {
               if (this.autoReadInterval) {
                 this.stopAutoRead();
                 autoReadToggleBtn.textContent = 'å¼€å§‹';
                 autoReadToggleBtn.classList.add('paused');
               } else {
                 this.startAutoRead();
                 autoReadToggleBtn.textContent = 'æš‚åœ';
                 autoReadToggleBtn.classList.remove('paused');
               }
             });
           },

           startAutoRead() {
             if (this.autoReadInterval) return;
             const mainContent = document.getElementById('main-content');
             let userInteracting = false;
             let interactionTimeout;
             let lastTimestamp = 0;
             let scrollAccumulator = 0;
             const TARGET_FPS = 60; // ç›®æ ‡å¸§ç‡
             const FRAME_TIME = 1000 / TARGET_FPS; // æ¯å¸§æ—¶é—´(ms)

             const onUserScroll = () => {
               userInteracting = true;
               clearTimeout(interactionTimeout);
               interactionTimeout = setTimeout(() => userInteracting = false, 2000);
             };

             mainContent.addEventListener('wheel', onUserScroll, { passive: true });
             mainContent.addEventListener('touchmove', onUserScroll, { passive: true });

             const scrollStep = (timestamp) => {
               if (!lastTimestamp) lastTimestamp = timestamp;
               const deltaTime = timestamp - lastTimestamp;
               
               if (!userInteracting && this.isAutoReading) {
                 // é€Ÿåº¦å€¼ * 10 = åƒç´ /ç§’
                 const pixelsPerSecond = this.autoReadSpeed * 10;
                 const scrollAmount = (pixelsPerSecond * deltaTime) / 1000;
                 scrollAccumulator += scrollAmount;
                 
                 // æ¯å¸§è‡³å°‘æ»šåŠ¨0.5åƒç´ ,é¿å…ç´¯ç§¯è¿‡å¤šé€ æˆå¡é¡¿
                 if (scrollAccumulator >= 0.5) {
                   // ä½¿ç”¨scrollByè€ŒéscrollTop,æ€§èƒ½æ›´å¥½
                   mainContent.scrollBy(0, scrollAccumulator);
                   scrollAccumulator = 0;
                 }
               }
               
               lastTimestamp = timestamp;
               this.autoReadInterval = requestAnimationFrame(scrollStep);
             };
             this.autoReadInterval = requestAnimationFrame(scrollStep);
           },

           stopAutoRead() {
             if (this.autoReadInterval) {
               cancelAnimationFrame(this.autoReadInterval);
             }
             this.autoReadInterval = null;
           },

           saveAutoReadSettings() {
             try {
               const settings = {
                 isAutoReading: this.isAutoReading,
                 autoReadSpeed: this.autoReadSpeed
               };
               localStorage.setItem('guixu_auto_read_settings', JSON.stringify(settings));
             } catch (e) {
               console.error('Failed to save auto read settings', e);
             }
           },

           loadAutoReadSettings() {
             try {
               const saved = localStorage.getItem('guixu_auto_read_settings');
               if (saved) {
                 const settings = JSON.parse(saved);
                 this.isAutoReading = settings.isAutoReading || false;
                 this.autoReadSpeed = settings.autoReadSpeed || 3;
                 
                 const autoReadCheckbox = document.getElementById('auto-read-checkbox');
                 if (autoReadCheckbox) {
                   autoReadCheckbox.checked = this.isAutoReading;
                 }
                 
                 // ç¡®ä¿æ‚¬æµ®çª—å­˜åœ¨ä¸”åœ¨bodyä¸­
                 let autoReadFloat = document.getElementById('auto-read-float');
                 if (!autoReadFloat) {
                   console.warn('[è‡ªåŠ¨é˜…è¯»] æ‚¬æµ®çª—å…ƒç´ æœªæ‰¾åˆ°');
                   return;
                 }
                 
                 // ç¡®ä¿æ‚¬æµ®çª—åœ¨bodyæœ«å°¾(é˜²æ­¢è¢«å…¶ä»–DOMæ“ä½œç§»é™¤)
                 if (!document.body.contains(autoReadFloat)) {
                   console.warn('[è‡ªåŠ¨é˜…è¯»] æ‚¬æµ®çª—ä¸åœ¨DOMä¸­,é‡æ–°æ·»åŠ åˆ°body');
                   document.body.appendChild(autoReadFloat);
                 }
                 
                 if (this.isAutoReading) {
                   autoReadFloat.style.display = 'block';
                   this.startAutoRead();
                 } else {
                   autoReadFloat.style.display = 'none';
                 }
               }
             } catch (e) {
               console.error('Failed to load auto read settings', e);
             }
           },

           // æ–°å¢ï¼šåˆå§‹åŒ–è®¾ç½®ç•Œé¢ä¸­çš„ä¸–ç•Œä¹¦æ§åˆ¶çŠ¶æ€
           initWorldbookControlsInSettings() {
             try {
               // åˆå§‹åŒ–ç»Ÿä¸€åºå·è¾“å…¥æ¡†
               const unifiedIndexInput = document.getElementById('unified-index-input');
               if (unifiedIndexInput) {
                 unifiedIndexInput.value = this.unifiedIndex;
               }

               // åˆå§‹åŒ–è‡ªåŠ¨å¼€å…³ä¸–ç•Œä¹¦å¤é€‰æ¡†
               const autoToggleCheckbox = document.getElementById('auto-toggle-lorebook-checkbox');
               if (autoToggleCheckbox) {
                 autoToggleCheckbox.checked = this.isAutoToggleLorebookEnabled;
               }

               // åˆå§‹åŒ–é¢„è®¾æ˜¾ç¤º
               this.updatePresetsInSettings();

               console.log('[å½’å¢Ÿè®¾ç½®] å·²åˆå§‹åŒ–ä¸–ç•Œä¹¦æ§åˆ¶çŠ¶æ€');
             } catch (e) {
               console.error('åˆå§‹åŒ–ä¸–ç•Œä¹¦æ§åˆ¶çŠ¶æ€å¤±è´¥:', e);
             }
           },

           // æ›´æ–°å­—ä½“é€‰æ‹©ä¸‹æ‹‰æ¡†é€‰é¡¹
           updateFontFamilyOptions() {
             const fontFamilySelect = document.getElementById('font-family-select');
             if (!fontFamilySelect) return;

             // ä¿å­˜å½“å‰é€‰æ‹©çš„å€¼
             const currentValue = fontFamilySelect.value;

             // æ¸…ç©ºç°æœ‰é€‰é¡¹
             fontFamilySelect.innerHTML = '';

             // æ·»åŠ é¢„è®¾å­—ä½“é€‰é¡¹
             const presetFonts = [
               { value: "'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif", text: "é»˜è®¤å­—ä½“" },
               { value: "'Microsoft YaHei', sans-serif", text: "å¾®è½¯é›…é»‘" },
               { value: "'SimSun', serif", text: "å®‹ä½“" },
               { value: "'KaiTi', serif", text: "æ¥·ä½“" },
               { value: "'FangSong', serif", text: "ä»¿å®‹" },
               { value: "'Arial', sans-serif", text: "Arial" },
               { value: "'Times New Roman', serif", text: "Times New Roman" }
             ];

             presetFonts.forEach(font => {
               const option = document.createElement('option');
               option.value = font.value;
               option.textContent = font.text;
               fontFamilySelect.appendChild(option);
             });

             // æ·»åŠ åˆ†éš”çº¿ï¼ˆå¦‚æœæœ‰è‡ªå®šä¹‰å­—ä½“ï¼‰
             if (this.textSettings.customFonts.length > 0) {
               const separator = document.createElement('option');
               separator.disabled = true;
               separator.textContent = '--- è‡ªå®šä¹‰å­—ä½“ ---';
               fontFamilySelect.appendChild(separator);

               // æ·»åŠ è‡ªå®šä¹‰å­—ä½“é€‰é¡¹
               this.textSettings.customFonts.forEach(font => {
                 const option = document.createElement('option');
                 option.value = font.family;
                 option.textContent = font.name;
                 fontFamilySelect.appendChild(option);
               });
             }

             // æ·»åŠ ä¸Šä¼ æ–°å­—ä½“é€‰é¡¹
             const uploadOption = document.createElement('option');
             uploadOption.value = 'upload_new';
             uploadOption.textContent = '+ ä¸Šä¼ æ–°å­—ä½“';
             fontFamilySelect.appendChild(uploadOption);

             // æ¢å¤ä¹‹å‰çš„é€‰æ‹©
             if (currentValue && currentValue !== 'upload_new') {
               fontFamilySelect.value = currentValue;
             }
           },

           // é‡ç½®æ–‡å­—è®¾ç½®
           resetTextSettings() {
             this.textSettings = {
               colors: {
                 normal: '#e8dcc6',
                 dialogue: '#ff1493',
                 psychology: '#808080',
                 scenery: '#98fb98',
                 character: '#87CEFA'
               },
               fontSizes: {
                 normal: 14,
                 dialogue: 14,
                 psychology: 13,
                 scenery: 15,
                 character: 14
               },
               fontFamily: "'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif",
               customFonts: []
             };
             this.updateTextSettingsUI();
             this.applyTextSettings();
             this.saveTextSettings();
             this.showTemporaryMessage('æ–‡å­—è®¾ç½®å·²é‡ç½®ä¸ºé»˜è®¤å€¼');
           },

           // é¢„è§ˆæ–‡å­—è®¾ç½®æ•ˆæœ
           previewTextSettings() {
             const previewText = `
               <div style="padding: 15px; background: rgba(0,0,0,0.8); border: 1px solid #c9aa71; border-radius: 5px; margin: 10px 0;">
                 <div style="color: #c9aa71; font-size: 14px; margin-bottom: 10px;">æ–‡å­—æ•ˆæœé¢„è§ˆï¼š</div>
                 <div class="text-language">è¿™æ˜¯å¯¹è¯æ–‡å­—çš„æ•ˆæœé¢„è§ˆ</div>
                 <div class="text-psychology">è¿™æ˜¯å¿ƒç†æ´»åŠ¨æ–‡å­—çš„æ•ˆæœé¢„è§ˆ</div>
                 <div class="text-scenery">è¿™æ˜¯æ™¯ç‰©æå†™æ–‡å­—çš„æ•ˆæœé¢„è§ˆ</div>
                 <span class="character-link">è¿™æ˜¯äººç‰©åç§°æ–‡å­—çš„æ•ˆæœé¢„è§ˆ</span>
               </div>
             `;
             
             // åˆ›å»ºé¢„è§ˆæ¨¡æ€æ¡†
             const modal = document.createElement('div');
             modal.className = 'modal-overlay';
             modal.style.display = 'flex';
             modal.style.zIndex = '2002';
             modal.innerHTML = `
               <div class="modal-content" style="max-width: 500px;">
                 <div class="modal-header">
                   <h2 class="modal-title">æ–‡å­—æ•ˆæœé¢„è§ˆ</h2>
                   <button class="modal-close-btn">&times;</button>
                 </div>
                 <div class="modal-body">
                   ${previewText}
                   <div style="text-align: center; margin-top: 15px;">
                     <button class="interaction-btn" onclick="this.closest('.modal-overlay').remove()">å…³é—­é¢„è§ˆ</button>
                   </div>
                 </div>
               </div>
             `;
             
             document.body.appendChild(modal);
             
             // ç»‘å®šå…³é—­äº‹ä»¶
             modal.querySelector('.modal-close-btn').addEventListener('click', () => {
               modal.remove();
             });
             modal.addEventListener('click', (e) => {
               if (e.target === modal) modal.remove();
             });
           },

           // å¤„ç†å­—ä½“æ–‡ä»¶ä¸Šä¼ 
           handleFontUpload(event) {
             const file = event.target.files[0];
             if (!file) return;

             // é‡ç½®æ–‡ä»¶è¾“å…¥æ¡†ï¼Œå…è®¸é‡æ–°é€‰æ‹©ç›¸åŒæ–‡ä»¶
             event.target.value = '';

             const allowedTypes = ['font/ttf', 'font/otf', 'font/woff', 'font/woff2', 'application/font-woff', 'application/font-woff2'];
             const fileExtension = file.name.split('.').pop().toLowerCase();
             const allowedExtensions = ['ttf', 'otf', 'woff', 'woff2'];

             if (!allowedExtensions.includes(fileExtension)) {
               this.showTemporaryMessage('è¯·é€‰æ‹©æœ‰æ•ˆçš„å­—ä½“æ–‡ä»¶ (.ttf, .otf, .woff, .woff2)');
               return;
             }

             // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶ä¸º10MBï¼Œä½†ç»™å‡ºè­¦å‘Šï¼‰
             if (file.size > 10 * 1024 * 1024) {
               this.showTemporaryMessage('å­—ä½“æ–‡ä»¶è¿‡å¤§ï¼Œè¯·é€‰æ‹©å°äº10MBçš„æ–‡ä»¶');
               return;
             }
             
             // å¯¹äºå¤§äº2MBçš„æ–‡ä»¶ç»™å‡ºè­¦å‘Š
             if (file.size > 2 * 1024 * 1024) {
               const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
               const shouldContinue = confirm(`å­—ä½“æ–‡ä»¶è¾ƒå¤§ (${sizeMB}MB)ï¼Œå¯èƒ½å½±å“åŠ è½½é€Ÿåº¦å’Œå­˜å‚¨ç©ºé—´ã€‚æ˜¯å¦ç»§ç»­ä¸Šä¼ ï¼Ÿ`);
               if (!shouldContinue) {
                 this.showTemporaryMessage('ä¸Šä¼ å·²å–æ¶ˆ');
                 return;
               }
               this.showTemporaryMessage(`æ­£åœ¨ä¸Šä¼ å¤§å­—ä½“æ–‡ä»¶ (${sizeMB}MB)ï¼Œè¯·ç¨å€™...`);
             }

             // æ˜¾ç¤ºä¸Šä¼ å¼€å§‹æç¤º
             this.showTemporaryMessage(`æ­£åœ¨å¤„ç†å­—ä½“æ–‡ä»¶: ${file.name}`);

             const reader = new FileReader();
             
             reader.onload = (e) => {
               try {
                 const fontData = e.target.result;
                 const fontName = file.name.replace(/\.[^/.]+$/, ""); // ç§»é™¤æ‰©å±•å
                 const fontFamily = `'${fontName}'`;
                 
                 // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒåå­—ä½“
                 const existingFont = this.textSettings.customFonts.find(f => f.name === fontName);
                 if (existingFont) {
                   const shouldReplace = confirm(`å­—ä½“ "${fontName}" å·²å­˜åœ¨ï¼Œæ˜¯å¦æ›¿æ¢ï¼Ÿ`);
                   if (!shouldReplace) {
                     this.showTemporaryMessage('ä¸Šä¼ å·²å–æ¶ˆ');
                     return;
                   }
                   // ç§»é™¤æ—§å­—ä½“
                   const index = this.textSettings.customFonts.indexOf(existingFont);
                   this.removeCustomFont(index);
                 }
                 
                 // ç”Ÿæˆå­—ä½“æ–‡ä»¶çš„å“ˆå¸Œå€¼ä½œä¸ºç¼“å­˜é”®
                 const fontHash = this.generateFontHash(fontName, file.size, file.lastModified);
                 const cacheKey = `guixu_font_${fontHash}`;

                 // ä½¿ç”¨IndexedDBå­˜å‚¨å­—ä½“æ–‡ä»¶
                 this.storeFontInIndexedDB(cacheKey, fontData, fontName, fontFamily)
                   .then(() => {
                     // åˆ›å»ºå­—ä½“æ ·å¼
                     const style = document.createElement('style');
                     style.id = `font-style-${fontHash}`;
                     style.textContent = `
                       @font-face {
                         font-family: ${fontFamily};
                         src: url(${fontData});
                         font-display: swap;
                       }
                     `;
                     document.head.appendChild(style);

                     // æ·»åŠ åˆ°è‡ªå®šä¹‰å­—ä½“åˆ—è¡¨ï¼ˆåªä¿å­˜å…ƒæ•°æ®ï¼Œä¸ä¿å­˜æ–‡ä»¶æ•°æ®ï¼‰
                     const customFont = {
                       name: fontName,
                       family: fontFamily,
                       hash: fontHash,
                       cacheKey: cacheKey,
                       size: file.size,
                       lastModified: file.lastModified
                     };
                     
                     this.textSettings.customFonts.push(customFont);
                     this.updateCustomFontsList();
                     
                     // æ›´æ–°å­—ä½“é€‰æ‹©ä¸‹æ‹‰æ¡†
                     this.updateFontFamilyOptions();
                     
                     // è‡ªåŠ¨åº”ç”¨æ–°ä¸Šä¼ çš„å­—ä½“
                     this.textSettings.fontFamily = fontFamily;
                     const fontFamilySelect = document.getElementById('font-family-select');
                     if (fontFamilySelect) {
                       fontFamilySelect.value = fontFamily;
                     }
                     this.applyTextSettings();
                     this.saveTextSettings();
                     
                     const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
                     this.showTemporaryMessage(`å­—ä½“ "${fontName}" (${sizeMB}MB) ä¸Šä¼ æˆåŠŸå¹¶å·²åº”ç”¨`);
                   })
                   .catch(error => {
                     console.error('å­—ä½“ç¼“å­˜å¤±è´¥:', error);
                     this.showTemporaryMessage(`å­—ä½“ç¼“å­˜å¤±è´¥: ${error.message}`);
                     
                     // å³ä½¿ç¼“å­˜å¤±è´¥ï¼Œä¹Ÿåˆ›å»ºä¸´æ—¶æ ·å¼
                     const style = document.createElement('style');
                     style.textContent = `
                       @font-face {
                         font-family: ${fontFamily};
                         src: url(${fontData});
                         font-display: swap;
                       }
                     `;
                     document.head.appendChild(style);
                     
                     // æ·»åŠ ä¸´æ—¶å­—ä½“åˆ°åˆ—è¡¨ï¼ˆä¸ä¿å­˜åˆ°localStorageï¼‰
                     const tempFont = {
                       name: fontName + ' (ä¸´æ—¶)',
                       family: fontFamily,
                       hash: fontHash,
                       size: file.size,
                       temporary: true
                     };
                     this.textSettings.customFonts.push(tempFont);
                     this.updateCustomFontsList();
                   });
               } catch (error) {
                 console.error('å­—ä½“å¤„ç†å¤±è´¥:', error);
                 this.showTemporaryMessage(`å­—ä½“å¤„ç†å¤±è´¥: ${error.message}`);
               }
             };
             
             reader.onerror = (error) => {
               console.error('æ–‡ä»¶è¯»å–å¤±è´¥:', error);
               this.showTemporaryMessage('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•');
             };
             
             reader.readAsDataURL(file);
           },

           // ç”Ÿæˆå­—ä½“æ–‡ä»¶å“ˆå¸Œå€¼
           generateFontHash(name, size, lastModified) {
             const str = `${name}_${size}_${lastModified}`;
             let hash = 0;
             for (let i = 0; i < str.length; i++) {
               const char = str.charCodeAt(i);
               hash = ((hash << 5) - hash) + char;
               hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
             }
             return Math.abs(hash).toString(36);
           },

           // ä½¿ç”¨IndexedDBå­˜å‚¨å­—ä½“æ–‡ä»¶
           // --- Dexie DB ç»Ÿä¸€ç®¡ç† ---
           async initializeDatabase() {
               try {
                   // æ£€æŸ¥ç¯å¢ƒæ”¯æŒ
                   if (!window.indexedDB) {
                       console.warn('[å½’å¢Ÿ] IndexedDBä¸å—æ”¯æŒï¼Œå­—ä½“å’Œå¤´åƒç¼“å­˜åŠŸèƒ½å°†è¢«ç¦ç”¨');
                       this.dbAvailable = false;
                       return false;
                   }

                   // æ£€æŸ¥Dexieåº“æ˜¯å¦å¯ç”¨
                   if (typeof window.Dexie === 'undefined') {
                       console.warn('[å½’å¢Ÿ] Dexieåº“æœªåŠ è½½ï¼ŒIndexedDBåŠŸèƒ½å°†è¢«ç¦ç”¨');
                       this.dbAvailable = false;
                       return false;
                   }

                   // åˆå§‹åŒ–æ•°æ®åº“
                   this.db = new window.Dexie('GuixuDB');
                   this.db.version(6).stores({
                       fonts: 'cacheKey, name, family', // ä¸»é”®æ˜¯ cacheKey
                       character_avatars: 'characterName', // ä¸»é”®æ˜¯ characterNameï¼Œå…¶ä»–å­—æ®µè‡ªåŠ¨å­˜å‚¨
                       game_saves: 'id, timestamp, auto_generated', // æ¸¸æˆå­˜æ¡£è¡¨
                       background_images: 'id, uploadTime, isPreset', // æ–°å¢ï¼šèƒŒæ™¯å›¾å­˜å‚¨è¡¨
                       key_value_store: 'key' // æ–°å¢ï¼šé”®å€¼å¯¹å­˜å‚¨ï¼Œç”¨äºå­˜å‚¨æ–‡ä»¶å¤¹å¥æŸ„ç­‰
                   });
                   
                   // ç¡®ä¿æ•°æ®åº“æ‰“å¼€
                   await this.db.open();
                   this.dbAvailable = true;
                   console.log('[å½’å¢Ÿ] Dexie æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ');

                   // å°è£…é”®å€¼å¯¹å­˜å‚¨æ–¹æ³•
                   this.db.setItem = (key, value) => this.db.key_value_store.put({ key, value });
                   this.db.getItem = async (key) => {
                       const item = await this.db.key_value_store.get(key);
                       return item ? item.value : null;
                   };

                   return true;
               } catch (error) {
                   console.warn('[å½’å¢Ÿ] IndexedDBåˆå§‹åŒ–å¤±è´¥ï¼Œç›¸å…³åŠŸèƒ½å°†è¢«ç¦ç”¨:', error.message);
                   this.db = null;
                   this.dbAvailable = false;
                   return false;
               }
           },



// ===æ–‡å­—ã€å­—ä½“ç›¸å…³è®¾ç½®æ¨¡å—ç»“æŸ===



// ===æ–°ç‰ˆæœ¬indexedDBå­˜æ¡£å­˜å‚¨æ¨¡å—å¼€å§‹===
           

           async saveGameToStorage(saveData) {
               try {
                   // ä¼˜å…ˆä½¿ç”¨IndexedDB
                   if (this.dbAvailable && this.db) {
                       await this.db.game_saves.put(saveData);
                       console.log('[å½’å¢Ÿå­˜æ¡£] IndexedDBå­˜å‚¨æˆåŠŸ:', saveData.name);
                       return true;
                   } else {
                       // é™çº§åˆ°localStorage
                       const allSaves = this.getLocalStorageGameSaves();
                       allSaves[saveData.id] = saveData;
                       localStorage.setItem('guixu_new_save_data', JSON.stringify(allSaves));
                       console.log('[å½’å¢Ÿå­˜æ¡£] localStorageé™çº§å­˜å‚¨æˆåŠŸ:', saveData.name);
                       return true;
                   }
               } catch (error) {
                   console.error('[å½’å¢Ÿå­˜æ¡£] å­˜å‚¨å¤±è´¥:', error);
                   // å¦‚æœIndexedDBå¤±è´¥ï¼Œå°è¯•localStorageé™çº§
                   try {
                       const allSaves = this.getLocalStorageGameSaves();
                       allSaves[saveData.id] = saveData;
                       localStorage.setItem('guixu_new_save_data', JSON.stringify(allSaves));
                       console.log('[å½’å¢Ÿå­˜æ¡£] localStorageé™çº§å­˜å‚¨æˆåŠŸ:', saveData.name);
                       return true;
                   } catch (fallbackError) {
                       console.error('[å½’å¢Ÿå­˜æ¡£] é™çº§å­˜å‚¨ä¹Ÿå¤±è´¥:', fallbackError);
                       return false;
                   }
               }
           },

           // ===ç³»åˆ—ç®¡ç†æ¨¡å—å¼€å§‹===
           // ç³»åˆ—æ•°æ®ç»“æ„: { seriesId: 'unique_id', name: 'ç³»åˆ—å', createTime: timestamp }
           
           // åŠ è½½æ‰€æœ‰ç³»åˆ—
           loadSeriesList() {
               try {
                   const data = localStorage.getItem('guixu_series_list');
                   const series = data ? JSON.parse(data) : [];
                   return series;
               } catch (e) {
                   console.error('[ç³»åˆ—ç®¡ç†] åŠ è½½ç³»åˆ—åˆ—è¡¨å¤±è´¥:', e);
                   return [];
               }
           },
           
           // ä¿å­˜ç³»åˆ—åˆ—è¡¨
           saveSeriesList(series) {
               try {
                   localStorage.setItem('guixu_series_list', JSON.stringify(series));
                   return true;
               } catch (e) {
                   console.error('[ç³»åˆ—ç®¡ç†] ä¿å­˜ç³»åˆ—åˆ—è¡¨å¤±è´¥:', e);
                   return false;
               }
           },
           
           // æ·»åŠ æ–°ç³»åˆ—
           addSeries(seriesName) {
               if (!seriesName || seriesName.trim() === '') {
                   this.showTemporaryMessage('ç³»åˆ—åç§°ä¸èƒ½ä¸ºç©º');
                   return null;
               }
               
               const series = this.loadSeriesList();
               
               // æ£€æŸ¥é‡å¤
               if (series.some(s => s.name === seriesName)) {
                   this.showTemporaryMessage('è¯¥ç³»åˆ—å·²å­˜åœ¨');
                   return null;
               }
               
               const newSeries = {
                   seriesId: 'series_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                   name: seriesName,
                   createTime: new Date().toISOString()
               };
               
               series.push(newSeries);
               this.saveSeriesList(series);
               this.showTemporaryMessage(`ç³»åˆ—"${seriesName}"å·²æ·»åŠ `);
               return newSeries;
           },
           
           // åˆ é™¤ç³»åˆ—(å°†è¯¥ç³»åˆ—ä¸‹çš„æ‰€æœ‰å­˜æ¡£è½¬ä¸º"æ— ç³»åˆ—")
           async deleteSeries(seriesId) {
               const series = this.loadSeriesList();
               const seriesName = series.find(s => s.seriesId === seriesId)?.name || 'æœªçŸ¥ç³»åˆ—';
               
               // æ›´æ–°å­˜æ¡£:å°†è¯¥ç³»åˆ—çš„æ ‡è®°æ¸…ç©º
               const allSaves = await this.getAllGameSaves();
               const savesToUpdate = allSaves.filter(save => save.series === seriesId);
               
               for (const save of savesToUpdate) {
                   save.series = '';
                   await this.saveGameToStorage(save);
               }
               
               // åˆ é™¤ç³»åˆ—
               const updatedSeries = series.filter(s => s.seriesId !== seriesId);
               this.saveSeriesList(updatedSeries);
               
               // é‡ç½®å½“å‰ç³»åˆ—é€‰æ‹©
               if (this.currentSeries === seriesId) {
                   this.currentSeries = '';
                   this.updateCurrentSeriesSelect();
               }
               
               this.showTemporaryMessage(`ç³»åˆ—"${seriesName}"å·²åˆ é™¤`);
           },
           
           // é‡å‘½åç³»åˆ—
           renameSeries(seriesId, newName) {
               if (!newName || newName.trim() === '') {
                   this.showTemporaryMessage('ç³»åˆ—åç§°ä¸èƒ½ä¸ºç©º');
                   return false;
               }
               
               const series = this.loadSeriesList();
               const seriesIndex = series.findIndex(s => s.seriesId === seriesId);
               
               if (seriesIndex === -1) {
                   this.showTemporaryMessage('ç³»åˆ—ä¸å­˜åœ¨');
                   return false;
               }
               
               // æ£€æŸ¥æ–°åç§°æ˜¯å¦å·²å­˜åœ¨
               if (series.some((s, idx) => idx !== seriesIndex && s.name === newName)) {
                   this.showTemporaryMessage('è¯¥ç³»åˆ—åç§°å·²å­˜åœ¨');
                   return false;
               }
               
               series[seriesIndex].name = newName;
               this.saveSeriesList(series);
               this.showTemporaryMessage('ç³»åˆ—å·²é‡å‘½å');
               return true;
           },
           
           // è·å–å½“å‰é€‰ä¸­çš„ç³»åˆ—
           getCurrentSeries() {
               return this.currentSeries || '';
           },
           
           // è®¾ç½®å½“å‰ç³»åˆ—
           setCurrentSeries(seriesId) {
               this.currentSeries = seriesId;
               localStorage.setItem('guixu_current_series', seriesId);
               this.updateCurrentSeriesSelect();
           },
           
           // æ›´æ–°"å½“å‰ç³»åˆ—"ä¸‹æ‹‰æ¡†
           updateCurrentSeriesSelect() {
               const select = document.getElementById('current-series-select');
               if (!select) return;
               
               select.value = this.currentSeries || '';
           },
           
           // åˆå§‹åŒ–ç³»åˆ—é€‰æ‹©å™¨
           initializeSeriesSelector() {
               const select = document.getElementById('current-series-select');
               if (!select) return;
               
               const series = this.loadSeriesList();
               
               // æ¸…ç©ºé€‰é¡¹
               select.innerHTML = '<option value="">æ— ç³»åˆ—</option>';
               
               // æ·»åŠ ç³»åˆ—é€‰é¡¹
               series.forEach(s => {
                   const option = document.createElement('option');
                   option.value = s.seriesId;
                   option.textContent = s.name;
                   select.appendChild(option);
               });
               
               // æ¢å¤ä¹‹å‰é€‰æ‹©çš„ç³»åˆ—
               this.currentSeries = localStorage.getItem('guixu_current_series') || '';
               select.value = this.currentSeries;
               
               // ç»‘å®šå˜åŒ–äº‹ä»¶
               select.addEventListener('change', (e) => {
                   this.setCurrentSeries(e.target.value);
               });
           },
           
           // ===ç³»åˆ—ç®¡ç†æ¨¡å—ç»“æŸ===

           // ä»å­˜å‚¨ä¸­è·å–æ‰€æœ‰å­˜æ¡£
           async getAllGameSaves() {
               try {
                   if (this.dbAvailable && this.db) {
                       // ä»IndexedDBè·å–
                       const saves = await this.db.game_saves.orderBy('timestamp').reverse().toArray();
                       console.log(`[å½’å¢Ÿå­˜æ¡£] ä»IndexedDBè¯»å–åˆ° ${saves.length} ä¸ªå­˜æ¡£`);
                       return saves;
                   } else {
                       // ä»localStorageè·å–
                       const saves = this.getLocalStorageGameSaves();
                       const saveArray = Object.values(saves).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                       console.log(`[å½’å¢Ÿå­˜æ¡£] ä»localStorageè¯»å–åˆ° ${saveArray.length} ä¸ªå­˜æ¡£`);
                       return saveArray;
                   }
               } catch (error) {
                   console.error('[å½’å¢Ÿå­˜æ¡£] è¯»å–å­˜æ¡£å¤±è´¥:', error);
                   // é™çº§åˆ°localStorage
                   const saves = this.getLocalStorageGameSaves();
                   return Object.values(saves).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
               }
           },

           // è·å–localStorageä¸­çš„å­˜æ¡£æ•°æ®
           getLocalStorageGameSaves() {
               try {
                   const saves = localStorage.getItem('guixu_new_save_data');
                   return saves ? JSON.parse(saves) : {};
               } catch (e) {
                   console.error('[å½’å¢Ÿå­˜æ¡£] localStorageè¯»å–å¤±è´¥:', e);
                   return {};
               }
           },

           // åˆ é™¤å­˜æ¡£
           async deleteGameSave(saveId) {
               try {
                   if (this.dbAvailable && this.db) {
                       await this.db.game_saves.delete(saveId);
                       console.log('[å½’å¢Ÿå­˜æ¡£] IndexedDBåˆ é™¤æˆåŠŸ:', saveId);
                   } else {
                       const allSaves = this.getLocalStorageGameSaves();
                       delete allSaves[saveId];
                       localStorage.setItem('guixu_new_save_data', JSON.stringify(allSaves));
                       console.log('[å½’å¢Ÿå­˜æ¡£] localStorageåˆ é™¤æˆåŠŸ:', saveId);
                   }
                   return true;
               } catch (error) {
                   console.error('[å½’å¢Ÿå­˜æ¡£] åˆ é™¤å¤±è´¥:', error);
                   return false;
               }
           },

           // ç”Ÿæˆå­˜æ¡£å”¯ä¸€ID
           generateSaveId() {
               const timestamp = Date.now();
               const random = Math.random().toString(36).substr(2, 9);
               return `save_${timestamp}_${random}`;
           },


           // è®¡ç®—å­˜æ¡£æŒ‡çº¹ç”¨äºå»é‡
           calculateSaveFingerprint(saveData) {
               try {
                   // åªä½¿ç”¨å…³é”®çš„æ¸¸æˆçŠ¶æ€æ•°æ®,æ’é™¤å¯èƒ½å˜åŒ–çš„å…ƒæ•°æ®
                   const statData = saveData.mvu_data?.stat_data || {};
                   
                   // æå–æ ¸å¿ƒæ¸¸æˆçŠ¶æ€ç”¨äºæŒ‡çº¹è®¡ç®—,æ’é™¤æ—¶é—´æˆ³ç­‰å…ƒæ•°æ®
                   const coreGameState = {
                       // ç©å®¶æ ¸å¿ƒå±æ€§
                       å½“å‰å¢ƒç•Œ: statData.å½“å‰å¢ƒç•Œ,
                       å½“å‰æ—¶é—´çºªå¹´: statData.å½“å‰æ—¶é—´çºªå¹´
                   };
                   
                   // ä¸–ç•Œä¹¦å†…å®¹å“ˆå¸Œ
                   const worldbookHashes = {
                       journey: this.hashContent(saveData.worldbook_contents?.journey || ''),
                       novel_mode: this.hashContent(saveData.worldbook_contents?.novel_mode || ''),
                       past_lives: this.hashContent(saveData.worldbook_contents?.past_lives || '')
                   };
                   
                   // ä½¿ç”¨æ’åºåçš„JSONå­—ç¬¦ä¸²ç¡®ä¿ä¸€è‡´æ€§
                   const fingerprint = this.hashContent(
                       JSON.stringify(coreGameState, Object.keys(coreGameState).sort()) +
                       JSON.stringify(worldbookHashes, Object.keys(worldbookHashes).sort())
                   );
                   
                   console.log('[å½’å¢Ÿå­˜æ¡£] è®¡ç®—æŒ‡çº¹:', fingerprint, 'æ ¸å¿ƒçŠ¶æ€:', coreGameState);
                   return fingerprint;
               } catch (error) {
                   console.warn('[å½’å¢Ÿå­˜æ¡£] è®¡ç®—æŒ‡çº¹å¤±è´¥:', error);
                   return Math.random().toString(36);
               }
           },

           // ç®€å•å“ˆå¸Œå‡½æ•°
           hashContent(content) {
               if (!content) return '0';
               let hash = 0;
               for (let i = 0; i < content.length; i++) {
                   const char = content.charCodeAt(i);
                   hash = ((hash << 5) - hash) + char;
                   hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
               }
               return Math.abs(hash).toString(36);
           },

           // æ£€æŸ¥æ˜¯å¦ä¸ºé‡å¤å­˜æ¡£
           async isDuplicateSave(newSaveData) {
               try {
                   const recentSaves = await this.getAllGameSaves();
                   const newFingerprint = this.calculateSaveFingerprint(newSaveData);
                   
                   // åªæ£€æŸ¥æœ€è¿‘3ä¸ªå­˜æ¡£
                   const recentThree = recentSaves.slice(0, 3);
                   
                   for (const save of recentThree) {
                       const existingFingerprint = this.calculateSaveFingerprint(save);
                       if (newFingerprint === existingFingerprint) {
                           console.log('[å½’å¢Ÿå­˜æ¡£] æ£€æµ‹åˆ°é‡å¤å­˜æ¡£ï¼Œè·³è¿‡ä¿å­˜');
                           return true;
                       }
                   }
                   
                   return false;
               } catch (error) {
                   console.warn('[å½’å¢Ÿå­˜æ¡£] å»é‡æ£€æŸ¥å¤±è´¥:', error);
                   return false; // æ£€æŸ¥å¤±è´¥æ—¶å…è®¸ä¿å­˜
               }
           },



           
// ===æ–°ç‰ˆæœ¬indexedDBå­˜æ¡£å­˜å‚¨æ¨¡å—ç»“æŸ===




// ===indexedDBå­—ä½“ç›¸å…³è®¾ç½®æ¨¡å—å¼€å§‹===



           async storeFontInIndexedDB(cacheKey, fontData, fontName, fontFamily) {
               try {
                   // æ£€æŸ¥æ•°æ®åº“å¯ç”¨æ€§
                   if (!this.dbAvailable) {
                       console.warn('[å½’å¢Ÿ] IndexedDBä¸å¯ç”¨ï¼Œè·³è¿‡å­—ä½“ç¼“å­˜:', fontName);
                       return false;
                   }

                   // ç¡®ä¿æ•°æ®åº“å·²åˆå§‹åŒ–
                   if (!this.db) {
                       const initSuccess = await this.initializeDatabase();
                       if (!initSuccess) {
                           return false;
                       }
                   }
                   
                   const fontRecord = {
                       cacheKey: cacheKey,
                       name: fontName,
                       family: fontFamily,
                       data: fontData,
                       timestamp: Date.now()
                   };
                   await this.db.fonts.put(fontRecord);
                   console.log('[å½’å¢Ÿ] å­—ä½“ç¼“å­˜æˆåŠŸ:', fontName);
                   return true;
               } catch (error) {
                   console.warn('[å½’å¢Ÿ] å­—ä½“ç¼“å­˜å¤±è´¥ï¼Œè·³è¿‡:', error.message);
                   return false;
               }
           },

           // ä»IndexedDBåŠ è½½å­—ä½“æ–‡ä»¶
           async loadFontFromIndexedDB(cacheKey) {
               try {
                   // æ£€æŸ¥æ•°æ®åº“å¯ç”¨æ€§
                   if (!this.dbAvailable) {
                       console.warn('[å½’å¢Ÿ] IndexedDBä¸å¯ç”¨ï¼Œè·³è¿‡å­—ä½“åŠ è½½:', cacheKey);
                       return null;
                   }

                   // ç¡®ä¿æ•°æ®åº“å·²åˆå§‹åŒ–
                   if (!this.db) {
                       const initSuccess = await this.initializeDatabase();
                       if (!initSuccess) {
                           return null;
                       }
                   }
                   
                   const fontRecord = await this.db.fonts.get(cacheKey);
                   if (fontRecord) {
                       console.log('[å½’å¢Ÿ] å­—ä½“ç¼“å­˜åŠ è½½æˆåŠŸ:', fontRecord.name);
                       return fontRecord;
                   } else {
                       console.warn('[å½’å¢Ÿ] å­—ä½“ç¼“å­˜æœªæ‰¾åˆ°:', cacheKey);
                       return null;
                   }
               } catch (error) {
                   console.warn('[å½’å¢Ÿ] å­—ä½“ç¼“å­˜è¯»å–å¤±è´¥ï¼Œè·³è¿‡:', error.message);
                   return null;
               }
           },

           // æ›´æ–°è‡ªå®šä¹‰å­—ä½“åˆ—è¡¨æ˜¾ç¤º
           updateCustomFontsList() {
             const container = document.getElementById('uploaded-fonts-list');
             if (!container) return;

             if (this.textSettings.customFonts.length === 0) {
               container.innerHTML = '<div style="color: #8b7355; font-size: 11px; text-align: center; padding: 10px;">æš‚æ— ä¸Šä¼ çš„å­—ä½“</div>';
               return;
             }

             let html = '';
             this.textSettings.customFonts.forEach((font, index) => {
               html += `
                 <div style="display: flex; align-items: center; justify-content: space-between; padding: 5px; border: 1px solid #8b7355; border-radius: 3px; margin-bottom: 5px;">
                   <span style="font-size: 11px; color: #e0dcd1;">${font.name}</span>
                   <div>
                     <button class="interaction-btn font-use-btn" style="padding: 2px 6px; font-size: 10px; margin-right: 5px;" data-font-index="${index}">ä½¿ç”¨</button>
                     <button class="interaction-btn font-remove-btn" style="padding: 2px 6px; font-size: 10px; background: #8b0000; border-color: #ff6b6b;" data-font-index="${index}">åˆ é™¤</button>
                   </div>
                 </div>
               `;
             });
             
             container.innerHTML = html;

             // ç»‘å®šäº‹ä»¶å§”æ‰˜
             container.addEventListener('click', (e) => {
               const index = parseInt(e.target.dataset.fontIndex);
               if (isNaN(index)) return;

               if (e.target.classList.contains('font-use-btn')) {
                 this.useCustomFont(index);
               } else if (e.target.classList.contains('font-remove-btn')) {
                 this.removeCustomFont(index);
               }
             });
           },
            // ç¡®ä¿è‡ªå®šä¹‰å­—ä½“å·²åŠ è½½
            async ensureCustomFontLoaded(fontFamily) {
              // æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå®šä¹‰å­—ä½“
              const customFont = this.textSettings.customFonts.find(font => font.family === fontFamily);
              if (!customFont) {
                return; // ä¸æ˜¯è‡ªå®šä¹‰å­—ä½“ï¼Œç›´æ¥è¿”å›
              }

              // æ£€æŸ¥å­—ä½“æ ·å¼æ˜¯å¦å·²å­˜åœ¨
              const existingStyle = document.getElementById(`font-style-${customFont.hash}`);
              if (existingStyle) {
                return; // å­—ä½“æ ·å¼å·²å­˜åœ¨ï¼Œç›´æ¥è¿”å›
              }

              // å­—ä½“æ ·å¼ä¸å­˜åœ¨ï¼Œéœ€è¦é‡æ–°åŠ è½½
              if (customFont.cacheKey) {
                try {
                  const cachedFont = await this.loadFontFromIndexedDB(customFont.cacheKey);
                  const style = document.createElement('style');
                  style.id = `font-style-${customFont.hash}`;
                  style.textContent = `
                    @font-face {
                      font-family: '${cachedFont.name}';
                      src: url(data:font/truetype;base64,${cachedFont.data}) format('truetype');
                    }
                  `;
                  document.head.appendChild(style);
                  console.log('è‡ªå®šä¹‰å­—ä½“é‡æ–°åŠ è½½æˆåŠŸ:', cachedFont.name);
                } catch (error) {
                  console.error('è‡ªå®šä¹‰å­—ä½“åŠ è½½å¤±è´¥:', error);
                }
              }
            },


           // ä½¿ç”¨è‡ªå®šä¹‰å­—ä½“
           useCustomFont(index) {
             if (index >= 0 && index < this.textSettings.customFonts.length) {
               const font = this.textSettings.customFonts[index];
               this.textSettings.fontFamily = font.family;
               
               // æ›´æ–°å­—ä½“é€‰æ‹©ä¸‹æ‹‰æ¡†ä¸ºå¯¹åº”çš„è‡ªå®šä¹‰å­—ä½“
               const fontFamilySelect = document.getElementById('font-family-select');
               if (fontFamilySelect) {
                 fontFamilySelect.value = font.family;
               }
               if (customFontSection) {
                 customFontSection.style.display = 'block';
               }
               
               // ç¡®ä¿å­—ä½“å·²åŠ è½½åå†åº”ç”¨
               this.ensureCustomFontLoaded(font.family).then(() => {
                 this.applyTextSettings();
                 this.saveTextSettings();
               });
               this.showTemporaryMessage(`å·²åº”ç”¨å­—ä½“ "${font.name}"`);
             }
           },

           // åˆ é™¤è‡ªå®šä¹‰å­—ä½“
           removeCustomFont(index) {
             if (index >= 0 && index < this.textSettings.customFonts.length) {
               const font = this.textSettings.customFonts[index];
               this.showCustomConfirm(`ç¡®å®šè¦åˆ é™¤å­—ä½“ "${font.name}" å—ï¼Ÿ`, async () => {
                 try {
                   // ä»IndexedDBä¸­åˆ é™¤ç¼“å­˜çš„å­—ä½“æ–‡ä»¶
                   if (font.cacheKey) {
                     await this.removeFontFromIndexedDB(font.cacheKey);
                   }
                   
                   // ç§»é™¤é¡µé¢ä¸­çš„å­—ä½“æ ·å¼
                   if (font.hash) {
                     const styleElement = document.getElementById(`font-style-${font.hash}`);
                     if (styleElement) {
                       styleElement.remove();
                     }
                   }
                   
                   // æ£€æŸ¥å½“å‰æ˜¯å¦æ­£åœ¨ä½¿ç”¨è¢«åˆ é™¤çš„å­—ä½“
                   const isCurrentFont = this.textSettings.fontFamily === font.family;
                   
                   // ä»è®¾ç½®ä¸­ç§»é™¤
                   this.textSettings.customFonts.splice(index, 1);
                   this.updateCustomFontsList();
                   
                   // æ›´æ–°å­—ä½“é€‰æ‹©ä¸‹æ‹‰æ¡†
                   this.updateFontFamilyOptions();
                   
                   // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ä½¿ç”¨çš„å­—ä½“ï¼Œåˆ‡æ¢åˆ°é»˜è®¤å­—ä½“
                   if (isCurrentFont) {
                     this.textSettings.fontFamily = "'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif";
                     const fontFamilySelect = document.getElementById('font-family-select');
                     if (fontFamilySelect) {
                       fontFamilySelect.value = this.textSettings.fontFamily;
                     }
                     this.applyTextSettings();
                   }
                   
                   this.saveTextSettings();
                   this.showTemporaryMessage(`å­—ä½“ "${font.name}" å·²åˆ é™¤`);
                 } catch (error) {
                   console.error('åˆ é™¤å­—ä½“ç¼“å­˜å¤±è´¥:', error);
                   // å³ä½¿ç¼“å­˜åˆ é™¤å¤±è´¥ï¼Œä¹Ÿè¦ä»è®¾ç½®ä¸­ç§»é™¤
                   this.textSettings.customFonts.splice(index, 1);
                   this.updateCustomFontsList();
                   this.updateFontFamilyOptions();
                   this.saveTextSettings();
                   this.showTemporaryMessage(`å­—ä½“ "${font.name}" å·²åˆ é™¤ï¼ˆç¼“å­˜æ¸…ç†å¯èƒ½å¤±è´¥ï¼‰`);
                 }
               });
             }
           },

           // ä»IndexedDBä¸­åˆ é™¤å­—ä½“æ–‡ä»¶
           async removeFontFromIndexedDB(cacheKey) {
               try {
                   // æ£€æŸ¥æ•°æ®åº“å¯ç”¨æ€§
                   if (!this.dbAvailable) {
                       console.warn('[å½’å¢Ÿ] IndexedDBä¸å¯ç”¨ï¼Œè·³è¿‡å­—ä½“åˆ é™¤:', cacheKey);
                       return false;
                   }

                   // ç¡®ä¿æ•°æ®åº“å·²åˆå§‹åŒ–
                   if (!this.db) {
                       const initSuccess = await this.initializeDatabase();
                       if (!initSuccess) {
                           return false;
                       }
                   }
                   
                   await this.db.fonts.delete(cacheKey);
                   console.log('[å½’å¢Ÿ] å­—ä½“ç¼“å­˜åˆ é™¤æˆåŠŸ:', cacheKey);
                   return true;
               } catch (error) {
                   console.warn('[å½’å¢Ÿ] å­—ä½“ç¼“å­˜åˆ é™¤å¤±è´¥ï¼Œè·³è¿‡:', error.message);
                   return false;
               }
           },



// ===indexedDBå­—ä½“ç›¸å…³è®¾ç½®æ¨¡å—ç»“æŸ===



// ===indexedDBäººç‰©å…³ç³»/äººç‰©å¤´åƒç›¸å…³æ¨¡å—å¼€å§‹===



           async storeAvatarInDB(recordData) {
               try {
                   // æ£€æŸ¥æ•°æ®åº“å¯ç”¨æ€§
                   if (!this.dbAvailable) {
                       console.warn('[å½’å¢Ÿ] IndexedDBä¸å¯ç”¨ï¼Œè·³è¿‡å¤´åƒç¼“å­˜:', recordData?.characterName);
                       return false;
                   }

                   // ç¡®ä¿æ•°æ®åº“å·²åˆå§‹åŒ–
                   if (!this.db) {
                       const initSuccess = await this.initializeDatabase();
                       if (!initSuccess) {
                           return false;
                       }
                   }
                   
                   // è·å–è§’è‰²å
                   const characterName = recordData.characterName;
                   if (!characterName) {
                       console.warn('[å½’å¢Ÿ] è§’è‰²åä¸ºç©ºï¼Œè·³è¿‡å¤´åƒç¼“å­˜');
                       return false;
                   }
                   
                   // å…ˆè·å–ç°æœ‰è®°å½•
                   const existingRecord = await this.db.character_avatars.get(characterName);

                   // åˆå¹¶æ–°æ•°æ®å’Œç°æœ‰æ•°æ®
                   const avatarRecord = {
                       characterName: characterName,
                       avatarImage: recordData.avatarImage !== undefined ? recordData.avatarImage : existingRecord?.avatarImage,
                       backgroundImage: recordData.backgroundImage !== undefined ? recordData.backgroundImage : existingRecord?.backgroundImage,
                       backgroundOpacity: recordData.backgroundOpacity !== undefined ? recordData.backgroundOpacity : existingRecord?.backgroundOpacity ?? 0.5,
                       timestamp: Date.now()
                   };

                   await this.db.character_avatars.put(avatarRecord);
                   console.log(`[å½’å¢Ÿ] è§’è‰²å¤´åƒ [${characterName}] ç¼“å­˜æˆåŠŸ`);
                   return true;
               } catch (error) {
                   console.warn(`[å½’å¢Ÿ] è§’è‰²å¤´åƒ [${recordData?.characterName || 'unknown'}] ç¼“å­˜å¤±è´¥ï¼Œè·³è¿‡:`, error.message);
                   return false;
               }
           },

           async getAvatarFromDB(characterName) {
               try {
                   // æ£€æŸ¥æ•°æ®åº“å¯ç”¨æ€§
                   if (!this.dbAvailable) {
                       return null;
                   }

                   // ç¡®ä¿æ•°æ®åº“å·²åˆå§‹åŒ–
                   if (!this.db) {
                       const initSuccess = await this.initializeDatabase();
                       if (!initSuccess) {
                           return null;
                       }
                   }
                   
                   const result = await this.db.character_avatars.get(characterName);
                   return result || null; // æ˜ç¡®è¿”å›null
               } catch (error) {
                   // å¦‚æœæ•°æ®åº“åˆå§‹åŒ–å¤±è´¥ç­‰ï¼Œç›´æ¥è¿”å›null
                   console.warn('[å½’å¢Ÿ] IndexedDB (å¤´åƒ) è¯»å–å¼‚å¸¸ï¼Œè·³è¿‡:', error.message);
                   return null;
               }
           },

           async removeAvatarFromDB(characterName) {
               try {
                   // ç¡®ä¿æ•°æ®åº“å·²åˆå§‹åŒ–
                   if (!this.db) {
                       await this.initializeDatabase();
                   }
                   
                   await this.db.character_avatars.delete(characterName);
                   console.log(`è§’è‰²å¤´åƒ [${characterName}] åˆ é™¤æˆåŠŸ`);
               } catch (error) {
                   console.error(`è§’è‰²å¤´åƒ [${characterName}] åˆ é™¤å¤±è´¥:`, error);
                   throw error;
               }
           },

           // --- å¤´åƒä¸Šä¼ ä¸å‹ç¼© ---
           async compressImageForAvatar(file) {
               return new Promise((resolve, reject) => {
                   const MAX_WIDTH = 512;
                   const MAX_HEIGHT = 512;
                   const reader = new FileReader();
                   reader.readAsDataURL(file);
                   reader.onload = (e) => {
                       const img = new Image();
                       img.src = e.target.result;
                       img.onload = () => {
                           let width = img.width;
                           let height = img.height;

                           if (width > height) {
                               if (width > MAX_WIDTH) {
                                   height *= MAX_WIDTH / width;
                                   width = MAX_WIDTH;
                               }
                           } else {
                               if (height > MAX_HEIGHT) {
                                   width *= MAX_HEIGHT / height;
                                   height = MAX_HEIGHT;
                               }
                           }

                           const canvas = document.createElement('canvas');
                           canvas.width = width;
                           canvas.height = height;
                           const ctx = canvas.getContext('2d');
                           ctx.drawImage(img, 0, 0, width, height);
                           
                           // ä½¿ç”¨JPEGæ ¼å¼ä»¥è·å¾—æ›´å¥½çš„å‹ç¼©ç‡
                           resolve(canvas.toDataURL('image/jpeg', 0.8));
                       };
                       img.onerror = (error) => reject(error);
                   };
                   reader.onerror = (error) => reject(error);
               });
           },

           async handleAvatarUpload(characterName, file) {
               if (!file.type.startsWith('image/')) {
                   this.showTemporaryMessage('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶', 'error');
                   return;
               }
               this.showTemporaryMessage('æ­£åœ¨å¤„ç†å›¾ç‰‡...', 'info');
               try {
                   // ç›´æ¥ä½¿ç”¨åŸå§‹å›¾ç‰‡
                   const originalImage = await this.fileToDataUrl(file);
                   const avatarImage = originalImage;
                   const backgroundImage = originalImage;

                   // æ™ºèƒ½å¤„ç†é€æ˜åº¦ï¼šå…ˆè¯»å–æ—§çš„ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ç”¨é»˜è®¤å€¼0.5
                   const existingRecord = await this.getAvatarFromDB(characterName);
                   const backgroundOpacity = existingRecord ? existingRecord.backgroundOpacity : 0.5;

                   const newRecord = {
                       characterName: characterName,
                       avatarImage: avatarImage,
                       backgroundImage: backgroundImage,
                       backgroundOpacity: backgroundOpacity
                   };

                   await this.storeAvatarInDB(newRecord);
                   
                   this.showTemporaryMessage('å›¾ç‰‡ä¸Šä¼ æˆåŠŸ!', 'success');
                   
                   // ç«‹å³åˆ·æ–°UI
                   if (document.getElementById('relationships-modal').style.display === 'flex') {
                       this.renderCharacterDetails(characterName); // åˆ·æ–°è¯¦æƒ…
                       this.renderCharacterList(); // åˆ·æ–°åˆ—è¡¨
                   }
               } catch (error) {
                   console.error('å¤´åƒä¸Šä¼ å¤±è´¥:', error);
                   this.showTemporaryMessage('å¤´åƒä¸Šä¼ å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°', 'error');
               }
           },



           // æ˜¾ç¤ºå¤´åƒæ¥æºé€‰æ‹©å™¨
           showAvatarSourcePicker(characterName) {
               const menuId = 'avatar-source-picker-menu';
               const overlayId = 'avatar-source-picker-overlay';

               // é˜²æ­¢é‡å¤åˆ›å»º
               if (document.getElementById(menuId)) return;

               // åˆ›å»ºé®ç½©å±‚
               const overlay = document.createElement('div');
               overlay.id = overlayId;
               overlay.style.cssText = `
                   position: absolute;
                   top: 0;
                   left: 0;
                   width: 100%;
                   height: 100%;
                   background: rgba(0, 0, 0, 0.8);
                   z-index: 10000;
                   display: flex;
                   justify-content: center;
                   align-items: center;
               `;

               // åˆ›å»ºé€‰æ‹©èœå•
               const menu = document.createElement('div');
               menu.id = menuId;
               menu.style.cssText = `
                   width: 320px;
                   padding: var(--spacing-lg, 20px);
                   border-radius: var(--border-radius-lg, 8px);
                   border: 1px solid var(--primary-gold, #c9aa71);
                   background: var(--bg-primary, rgba(26, 26, 46, 0.95));
                   box-shadow: var(--shadow-lg, 0 8px 25px rgba(0, 0, 0, 0.5));
                   animation: fadeIn 0.3s var(--easing-smooth, ease);
               `;
               
               menu.innerHTML = `
                   <div style="padding: 0 0 var(--spacing-md, 15px) 0; text-align: center;">
                       <h2 style="margin: 0; font-size: var(--font-size-h3, 1.3rem); color: var(--primary-gold, #c9aa71);">é€‰æ‹©å›¾ç‰‡æ¥æº</h2>
                   </div>
                   <div style="display: flex; flex-direction: column; gap: var(--spacing-md, 15px);">
                       <button id="upload-local-btn" class="interaction-btn" style="width: 100%;">
                           <i class="fas fa-upload"></i> ä¸Šä¼ æœ¬åœ°å›¾ç‰‡
                       </button>
                       <button id="select-from-gallery-btn" class="interaction-btn" style="width: 100%;">
                           <i class="fas fa-images"></i> ä»å›¾åº“é€‰æ‹©
                       </button>
                       <button id="cancel-picker-btn" class="interaction-btn" style="width: 100%; background: rgba(255, 107, 107, 0.1); border-color: var(--danger-color, #ff6b6b); color: var(--danger-color, #ff6b6b);">
                           <i class="fas fa-times"></i> å–æ¶ˆ
                       </button>
                   </div>
               `;
               
               // æ·»åŠ åˆ°é¡µé¢
               overlay.appendChild(menu);
               const container = document.getElementById('guixu-root-container');
               if (container) {
                   container.appendChild(overlay);
               } else {
                   document.body.appendChild(overlay);
               }
               
               // å…³é—­èœå•å‡½æ•°
               const closeMenu = () => {
                   overlay.remove();
               };
               
               // ç»‘å®šäº‹ä»¶
               document.getElementById('upload-local-btn').onclick = () => {
                   closeMenu();
                   const input = document.createElement('input');
                   input.type = 'file';
                   input.accept = 'image/*';
                   input.onchange = (event) => {
                       const file = event.target.files[0];
                       if (file) this.handleAvatarUpload(characterName, file);
                   };
                   input.click();
               };
               
               document.getElementById('select-from-gallery-btn').onclick = () => {
                   closeMenu();
                   this.showAvatarGalleryPicker(characterName);
               };
               
               document.getElementById('cancel-picker-btn').onclick = closeMenu;
               overlay.addEventListener('click', (e) => {
                   if (e.target === overlay) {
                       closeMenu();
                   }
               });
           },

           // æ˜¾ç¤ºå¤´åƒå›¾åº“é€‰æ‹©å™¨
           async showAvatarGalleryPicker(characterName) {
                console.log('[å½’å¢Ÿå¤´åƒ] æ‰“å¼€å¤´åƒå›¾åº“é€‰æ‹©å™¨ - ä½¿ç”¨é€šç”¨å›¾åº“ç»„ä»¶');
                
                // ä½¿ç”¨é€šç”¨å›¾åº“ç»„ä»¶
                await this.showUnifiedGalleryPicker({
                    title: `ä¸º ${characterName} é€‰æ‹©å¤´åƒ`,
                    mode: 'avatar',
                    enablePagination: true,
                    pageSize: 20,
                    enableSourceSwitch: true,
                    enableLazyLoad: true,
                    onSelect: async (imageData) => {
                        console.log('[å½’å¢Ÿå¤´åƒ] é€‰æ‹©äº†å¤´åƒ:', imageData);
                        await this.handleAvatarSelectFromGallery(characterName, imageData.dataUrl);
                    },
                    onClose: () => {
                        console.log('[å½’å¢Ÿå¤´åƒ] å…³é—­å¤´åƒé€‰æ‹©å™¨');
                    }
                });
            },
           
           // ä»å›¾åº“é€‰æ‹©å¤´åƒ
           async handleAvatarSelectFromGallery(characterName, imageUrl) {
               try {
                   this.showTemporaryMessage('æ­£åœ¨è®¾ç½®å¤´åƒ...', 'info');
                   
                   // è·å–ç°æœ‰è®°å½•ä»¥ä¿ç•™é€æ˜åº¦è®¾ç½®
                   const existingRecord = await this.getAvatarFromDB(characterName);
                   const backgroundOpacity = existingRecord ? existingRecord.backgroundOpacity : 0.5;
                   
                   // åˆ›å»ºæ–°è®°å½•
                   const newRecord = {
                       characterName: characterName,
                       avatarImage: imageUrl,
                       backgroundImage: imageUrl,
                       backgroundOpacity: backgroundOpacity
                   };
                   
                   // ä¿å­˜åˆ°æ•°æ®åº“
                   await this.storeAvatarInDB(newRecord);
                   
                   this.showTemporaryMessage('å¤´åƒè®¾ç½®æˆåŠŸï¼', 'success');
                   
                   // å…³é—­å›¾åº“é€‰æ‹©æ¨¡æ€æ¡†
                   this.closeModal('avatar-gallery-picker-modal');
                   
                   // åˆ·æ–°äººç‰©å…³ç³»ç•Œé¢
                   if (document.getElementById('relationships-modal').style.display === 'flex') {
                       this.renderCharacterDetails(characterName);
                       this.renderCharacterList();
                   }
               } catch (error) {
                   console.error('[å½’å¢Ÿå¤´åƒ] ä»å›¾åº“é€‰æ‹©å¤´åƒå¤±è´¥:', error);
                   this.showTemporaryMessage('è®¾ç½®å¤´åƒå¤±è´¥', 'error');
               }
           },

// ===indexedDBäººç‰©å…³ç³»/äººç‰©å¤´åƒç›¸å…³æ¨¡å—ç»“æŸ===



// ===å½’å¢Ÿç©ºé—´æ¨¡å—å¼€å§‹===



           async showGuixuSystem() {
            this.openModal('guixu-system-modal');
            try {
              if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                await this.loadMvuData();
                if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                  this.showTemporaryMessage('æ— æ³•åŠ è½½ç©å®¶æ•°æ®ï¼Œè¯·åˆ·æ–°é¡µé¢');
                  return;
                }
              }
              await this.renderGuixuCharacterDetails();
              this.bindGuixuSystemTabEvents();
              this.bindGuixuReincarnateButton();
              
              // æ–°å¢ï¼šåŠ¨æ€è®¾ç½®å…¨å±å°ºå¯¸
              const rootContainer = document.querySelector('.guixu-root-container');
              const modalContent = document.querySelector('#guixu-system-modal .modal-content');
              if (rootContainer && modalContent) {
                  const rect = rootContainer.getBoundingClientRect();
                  modalContent.style.setProperty('width', `${rect.width}px`, 'important');
                  modalContent.style.setProperty('height', `${rect.height}px`, 'important');
                  modalContent.style.setProperty('top', `${rect.top}px`, 'important');
                  modalContent.style.setProperty('left', `${rect.left}px`, 'important');
                  modalContent.style.setProperty('max-width', 'none', 'important');
                  modalContent.style.setProperty('max-height', 'none', 'important');
              }
              
            } catch (error) {
              console.error('åŠ è½½å½’å¢Ÿç³»ç»Ÿæ—¶å‡ºé”™:', error);
              this.showTemporaryMessage('åŠ è½½å½’å¢Ÿç³»ç»Ÿå¤±è´¥');
            }
          },

          // === å½’å¢Ÿç³»ç»Ÿæ–°å‡½æ•° ===
          
          // æ¸²æŸ“äººç‰©è¯¦æƒ…Tabå†…å®¹
          async renderGuixuCharacterDetails() {
            const stat_data = this.currentMvuState.stat_data;
            if (!stat_data) return;

            // æ ¸å¿ƒå±æ€§æ•°æ®
            const currentFali = this.SafeGetValue(stat_data, 'å½“å‰æ³•åŠ›', 0);
            const maxFali = this.SafeGetValue(stat_data, 'æ³•åŠ›', 0);
            const currentShenhai = this.SafeGetValue(stat_data, 'å½“å‰ç¥æµ·', 0);
            const maxShenhai = this.SafeGetValue(stat_data, 'ç¥æµ·', 0);
            const currentDaoxin = this.SafeGetValue(stat_data, 'å½“å‰é“å¿ƒ', 0);
            const maxDaoxin = this.SafeGetValue(stat_data, 'é“å¿ƒ', 0);
            const currentKongsu = this.SafeGetValue(stat_data, 'å½“å‰ç©ºé€Ÿ', 0);
            const maxKongsu = this.SafeGetValue(stat_data, 'ç©ºé€Ÿ', 0);
            const currentXueliang = this.SafeGetValue(stat_data, 'å½“å‰è¡€é‡', 0);
            const maxXueliang = this.SafeGetValue(stat_data, 'è¡€é‡', 0);
            
            // è¾…åŠ©å±æ€§æ•°æ®
            const qiyun = this.SafeGetValue(stat_data, 'æ°”è¿', 0);
            const meili = this.SafeGetValue(stat_data, 'é­…åŠ›', 0);
            const wuxing = this.SafeGetValue(stat_data, 'æ‚Ÿæ€§', 0);
            const xianling = this.SafeGetValue(stat_data, 'ä»™çµä¹‹æ°”', 0);
            const age = this.SafeGetValue(stat_data, 'å¹´é¾„', 18);
            const lifespan = this.SafeGetValue(stat_data, 'å¯¿å…ƒ', 70);
            const mentalAge = this.SafeGetValue(stat_data, 'å¿ƒç†å¹´é¾„', 18);
            const mentalAgeMax = this.SafeGetValue(stat_data, 'å¿ƒç†å¹´é¾„ä¸Šé™', 200);
            
            // å¢ƒç•Œä¸ä¿®ç‚¼è¿›åº¦
            const currentRealm = this.SafeGetValue(stat_data, 'å½“å‰å¢ƒç•Œ', 'ç»ƒæ°”ä¸€å±‚');
            const cultivationProgress = this.SafeGetValue(stat_data, 'ä¿®ä¸ºè¿›åº¦', 0);
            const cultivationBottleneck = this.SafeGetValue(stat_data, 'ä¿®ä¸ºç“¶é¢ˆ', 'æ— ');
            
            // å½“å‰çŠ¶æ€
            const currentStatus = this.SafeGetValue(stat_data, 'å½“å‰çŠ¶æ€', {});
            
            // çµæ ¹ä¸å¤©èµ‹
            const linggenList = this.SafeGetValue(stat_data, 'çµæ ¹åˆ—è¡¨', {});
            const talentList = this.SafeGetValue(stat_data, 'å¤©èµ‹åˆ—è¡¨', {});
            
            // å½“å‰ç™¾åˆ†æ¯”åŠ æˆ
            const bonusData = this.SafeGetValue(stat_data, 'å½“å‰ç™¾åˆ†æ¯”åŠ æˆ', {});
            const bonusFali = this.SafeGetValue(bonusData, 'æ³•åŠ›', '0%');
            const bonusShenhai = this.SafeGetValue(bonusData, 'ç¥æµ·', '0%');
            const bonusDaoxin = this.SafeGetValue(bonusData, 'é“å¿ƒ', '0%');
            const bonusKongsu = this.SafeGetValue(bonusData, 'ç©ºé€Ÿ', '0%');
            const bonusXiulian = this.SafeGetValue(bonusData, 'ä¿®ç‚¼é€Ÿåº¦', '0%');
            
            // å½’å¢Ÿä¿¡æ¯æ•°æ®
            const currentWorld = this.SafeGetValue(stat_data, 'å½“å‰ç¬¬xä¸–', '1');
            const currentTime = this.SafeGetValue(stat_data, 'å½“å‰æ—¶é—´çºªå¹´', 'ç„æ˜Šå†1å¹´1æœˆ1æ—¥');
            const guizhen = this.SafeGetValue(stat_data, 'å½’çœŸæ•°', 100);
            const guixuPoint = this.SafeGetValue(stat_data, 'å½’å¢Ÿç‚¹', '10');
            
            // è®¡ç®—æˆ˜åŠ›
            const combatPower = Math.floor(maxFali * 0.5 + maxShenhai * 1 + maxKongsu * 2 + maxDaoxin * 2);
            
            // æ›´æ–°å¢ƒç•Œä¸ä¿®ç‚¼è¿›åº¦ï¼ˆæ·»åŠ æŸ“è‰²ï¼‰
            const realmMatch = currentRealm.match(/^(\S{2})/);
            const realmTier = realmMatch ? realmMatch[1] : '';
            const realmStyle = this.getJingJieStyle(realmTier);
            const realmElement = document.getElementById('guixu-char-realm');
            realmElement.textContent = currentRealm;
            realmElement.style.cssText = realmStyle;
            
            document.getElementById('guixu-char-cultivation-percent').textContent = `${cultivationProgress}%`;
            document.getElementById('guixu-char-cultivation-fill').style.width = `${cultivationProgress}%`;
            document.getElementById('guixu-char-bottleneck').textContent = cultivationBottleneck;
            
            // æ›´æ–°çµæ ¹æ˜¾ç¤º
            const linggenNames = Object.keys(linggenList);
            const linggenText = linggenNames.length > 0
              ? linggenNames.map(name => {
                  const tier = linggenList[name]?.tier || '';
                  return tier ? `${name}(${tier})` : name;
                }).join('ã€')
              : 'æ— ';
            document.getElementById('guixu-char-linggen').textContent = linggenText;
            
            // æ›´æ–°å¤©èµ‹æ˜¾ç¤º
            const talentNames = Object.keys(talentList);
            const talentText = talentNames.length > 0
              ? talentNames.map(name => {
                  const tier = talentList[name]?.tier || '';
                  return tier ? `${name}(${tier})` : name;
                }).join('ã€')
              : 'æ— ';
            document.getElementById('guixu-char-talents').textContent = talentText;
            
            // æ›´æ–°ç™¾åˆ†æ¯”åŠ æˆæ˜¾ç¤º
            document.getElementById('guixu-char-bonus-fali').textContent = `+${bonusFali}`;
            document.getElementById('guixu-char-bonus-shenhai').textContent = `+${bonusShenhai}`;
            document.getElementById('guixu-char-bonus-daoxin').textContent = `+${bonusDaoxin}`;
            document.getElementById('guixu-char-bonus-kongsu').textContent = `+${bonusKongsu}`;
            document.getElementById('guixu-char-bonus-xiulian').textContent = `+${bonusXiulian}`;
            
            // æ›´æ–°å½“å‰çŠ¶æ€æ˜¾ç¤º
            this.renderCurrentStatus(currentStatus);
            
            // æ›´æ–°æˆ˜åŠ›æ˜¾ç¤ºï¼ˆçº¯æ•°å­—ï¼Œä¸å¸¦é€—å·ï¼‰
            document.getElementById('guixu-char-combat-power').textContent = combatPower;
            
            // æ›´æ–°è¾…åŠ©å±æ€§æ˜¾ç¤ºï¼ˆä½¿ç”¨æŸ“è‰²ç³»ç»Ÿï¼‰
            document.getElementById('guixu-char-qiyun').innerHTML = this.getQiyunDisplayHTML(qiyun);
            document.getElementById('guixu-char-meili').innerHTML = this.getCharmDisplayHTML(meili);
            document.getElementById('guixu-char-wuxing').innerHTML = this.getWuxingDisplayHTML(wuxing);
            document.getElementById('guixu-char-xianling').textContent = xianling;
            document.getElementById('guixu-char-age-physical').textContent = `${age} / ${lifespan}`;
            document.getElementById('guixu-char-age-mental').textContent = `${mentalAge} / ${mentalAgeMax}`;
            
            // æ›´æ–°å½’å¢Ÿä¿¡æ¯æ˜¾ç¤º
            document.getElementById('guixu-char-time').textContent = currentTime;
            document.getElementById('guixu-char-world').textContent = `ç¬¬ ${currentWorld} ä¸–`;
            document.getElementById('guixu-char-guizhen').textContent = guizhen;
            document.getElementById('guixu-char-guixu-point').textContent = guixuPoint;
            
            // æ¸²æŸ“æ ¸å¿ƒå±æ€§è¿›åº¦æ¡
            this.renderGuixuAttributes(currentFali, maxFali, currentShenhai, maxShenhai, currentDaoxin, maxDaoxin, currentKongsu, maxKongsu);
            this.renderGuixuHealth(currentXueliang, maxXueliang);
          },
          // æ¸²æŸ“å½“å‰çŠ¶æ€
          renderCurrentStatus(statusData) {
            const container = document.getElementById('guixu-char-current-status');
            if (!container) return;
            
            if (!statusData || typeof statusData !== 'object' || Object.keys(statusData).length === 0) {
              container.innerHTML = '<div class="current-status-placeholder" style="color: #8b7355; font-size: 12px; padding: 8px;">æš‚æ— çŠ¶æ€</div>';
              return;
            }
            
            let html = '';
            const entries = Object.entries(statusData).filter(([key]) => key !== '$meta');
            
            entries.forEach(([statusName, statusInfo], index) => {
              const description = (typeof statusInfo === 'object' && statusInfo?.description) ? statusInfo.description : (typeof statusInfo === 'string' ? statusInfo : 'æ— æè¿°');
              html += `<div class="current-status-item">
                <div class="current-status-name">${statusName}</div>
                <div class="current-status-desc">${description}</div>
              </div>`;
              
              // æ·»åŠ åˆ†å‰²çº¿ï¼Œæœ€åä¸€é¡¹ä¸æ·»åŠ 
              if (index < entries.length - 1) {
                html += '<div class="current-status-divider2"></div>';
              }
            });
            
            if (html === '') {
              container.innerHTML = '<div class="current-status-placeholder" style="color: #8b7355; font-size: 12px; padding: 8px;">æš‚æ— çŠ¶æ€</div>';
            } else {
              container.innerHTML = html;
            }
          },


          bindGuixuSystemTabEvents() {
            const tabBtns = document.querySelectorAll('.guixu-tab-btn');
            const tabContents = document.querySelectorAll('.guixu-tab-content');
            
            tabBtns.forEach(btn => {
              btn.addEventListener('click', async () => {
                const tabName = btn.dataset.tab;
                tabBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                tabContents.forEach(content => content.classList.remove('active'));
                const targetContent = document.getElementById(`guixu-tab-${tabName}`);
                if (targetContent) {
                  targetContent.classList.add('active');
                  if (tabName === 'gacha') {
                    await this.loadGachaIntoGuixu();
                  } else if (tabName === 'shop') {
                    await this.loadShopIntoGuixu();
                  } else if (tabName === 'character') {
                    await this.renderGuixuCharacterDetails();
                  }
                }
              });
            });
          },

                    async loadGachaIntoGuixu() {
            const container = document.getElementById('gacha-embedded-container');
            if (!container) return;
            
            // æ£€æŸ¥MVUæ•°æ®æ˜¯å¦å·²åŠ è½½
            if (!this.currentMvuState || !this.currentMvuState.stat_data) {
              container.innerHTML = '<p style="text-align:center; color:#8b7355; padding: 50px;">æ— æ³•åŠ è½½è§’è‰²æ•°æ®ï¼Œè¯·å…ˆå¼€å§‹æ¸¸æˆæˆ–å‘é€ä¸€æ¡æ¶ˆæ¯ä»¥åˆå§‹åŒ–çŠ¶æ€ã€‚</p>';
              return;
            }
            
            // åˆ›å»ºå†…åµŒçš„è¡æ¢¦å°˜ç•Œé¢ç»“æ„
            const poolInfo = {
              character: { title: 'é•œèŠ±æ°´æœˆ', bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
              item: { title: 'ä¸‡è±¡å¥‡ç', bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
              talent: { title: 'å¤©å‘½çµæ ¹', bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
            };
            
            const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, 'å½’å¢Ÿç‚¹', 0);
            
            // æ„å»ºå¡æ± åˆ‡æ¢æŒ‰é’®
            let switcherHtml = '';
            for (const [poolType, data] of Object.entries(poolInfo)) {
              switcherHtml += `<button class="pool-switch-btn-embedded ${poolType === 'character' ? 'active' : ''}" data-pool="${poolType}" data-title="${data.title}" style="background-image: url('${data.bg}');"></button>`;
            }
            
            container.innerHTML = `
              <div class="gacha-embedded-wrapper">
                <div id="gacha-pool-display-embedded" class="gacha-pool-display-embedded"></div>
                <div class="gacha-embedded-header">
                  <div class="gacha-pool-switcher-embedded">${switcherHtml}</div>
                </div>
                <div class="gacha-currency-top-right">å½’å¢Ÿç‚¹: <strong>${guixuPoints}</strong></div>
                <div class="gacha-embedded-controls">
                  <button id="btn-gacha-settings-embedded" class="gacha-corner-btn-embedded" title="è®¾ç½®">âš™ï¸</button>
                  <button id="btn-gacha-gallery-embedded" class="gacha-corner-btn-embedded" title="å›¾é‰´">ğŸ–¼ï¸</button>
                </div>
              </div>
            `;
            
            // ç»‘å®šå¡æ± åˆ‡æ¢äº‹ä»¶
            container.querySelectorAll('.pool-switch-btn-embedded').forEach(btn => {
              btn.addEventListener('click', () => {
                container.querySelectorAll('.pool-switch-btn-embedded').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this._renderGachaPoolEmbedded(btn.dataset.pool);
              });
            });
            
            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            document.getElementById('btn-gacha-settings-embedded')?.addEventListener('click', () => this.showGachaSettingsPopup());
            document.getElementById('btn-gacha-gallery-embedded')?.addEventListener('click', () => this.showGachaGalleryPopup(this.currentGachaPoolType || 'character'));
            
            // æ¸²æŸ“é»˜è®¤å¡æ± 
            this._renderGachaPoolEmbedded('character');
          },
          async loadShopIntoGuixu() {
            const container = document.getElementById('shop-embedded-container');
            if (!container) return;
            
            // æ£€æŸ¥MVUæ•°æ®
            if (!this.currentMvuState || !this.currentMvuState.stat_data) {
              container.innerHTML = '<p style="text-align:center; color:#8b7355; padding: 20px;">æ­£åœ¨åŠ è½½ç©å®¶æ•°æ®...</p>';
              await this.loadMvuData();
              if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                container.innerHTML = '<p style="text-align:center; color:#8b7355; padding: 20px;">æ— æ³•åŠ è½½ç©å®¶æ•°æ®ï¼Œè¯·åˆ·æ–°é¡µé¢</p>';
                return;
              }
            }
            
            // åŠ è½½å•†å“
            if (!this.guixuStoreItems || this.guixuStoreItems.length === 0) {
              container.innerHTML = '<p style="text-align:center; color:#8b7355; padding: 20px;">æ­£åœ¨ä»ä¸–ç•Œä¹¦ä¸­åŠ è½½å•†å“...</p>';
              const allItems = await this.loadGuixuStoreItems();
              this.guixuStoreItems = allItems;
            }
            
            // æ¸²æŸ“å½’å¢Ÿç©ºé—´ç•Œé¢
            this._renderGuixuSpaceEmbedded(container);
          },

          // å†…åµŒç‰ˆæœ¬çš„è¡æ¢¦å°˜å¡æ± æ¸²æŸ“
          _renderGachaPoolEmbedded(poolType) {
            this.currentGachaPoolType = poolType;
            const displayContainer = document.getElementById('gacha-pool-display-embedded');
            if (!displayContainer) return;
            
            const poolData = {
              character: { title: 'é•œèŠ±æ°´æœˆ (è§’è‰²æ± )', cost: 320, pitySSR: this.gachaState.pitySSR_char, pitySR: this.gachaState.pitySR_char, bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
              item: { title: 'ä¸‡è±¡å¥‡ç (é“å…·æ± )', cost: 160, pitySSR: this.gachaState.pitySSR_item, pitySR: this.gachaState.pitySR_item, bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
              talent: { title: 'å¤©å‘½çµæ ¹ (å¤©èµ‹æ± )', cost: 160, pitySSR: this.gachaState.pitySSR_talent, pitySR: this.gachaState.pitySR_talent, bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
            };
            const currentPool = poolData[poolType];
            
            displayContainer.innerHTML = `
              <div class="summon-container-embedded" style="background-image: url('${currentPool.bg}');">
                <div class="summon-container-overlay"></div>
                <div class="summon-header-info-embedded"></div>
                <div class="summon-main-controls-embedded">
                  <h3 class="pool-title">${currentPool.title}</h3>
                  <p style="font-size:12px; color:#a09c91;">SSRä¿åº•: ${currentPool.pitySSR}/90 | SRä¿åº•: ${currentPool.pitySR}/10</p>
                  <div class="summon-buttons">
                    <button id="gacha-pull-1-embedded" class="interaction-btn">å¬å”¤1æ¬¡ (${currentPool.cost} æ¢¦å°˜)</button>
                    <button id="gacha-pull-10-embedded" class="interaction-btn primary-btn">å¬å”¤10æ¬¡ (${currentPool.cost * 10} æ¢¦å°˜)</button>
                  </div>
                </div>
              </div>
            `;
            
            document.getElementById('gacha-pull-1-embedded')?.addEventListener('click', () => this.handlePull(1, poolType));
            document.getElementById('gacha-pull-10-embedded')?.addEventListener('click', () => this.handlePull(10, poolType));
          },
          
          // å†…åµŒç‰ˆæœ¬çš„å½’å¢Ÿç©ºé—´æ¸²æŸ“
          _renderGuixuSpaceEmbedded(container) {
            const filterType = this.currentGuixuFilter || 'å…¨éƒ¨';
            let filteredItems = filterType === 'å…¨éƒ¨' ? this.guixuStoreItems : this.guixuStoreItems.filter(item => item.type === filterType);
            
            // åº”ç”¨æ’åº
            switch (this.currentGuixuSort) {
              case 'å“é˜¶ (é«˜åˆ°ä½)':
                filteredItems = this.sortByTier(filteredItems, item => item.tier);
                break;
              case 'å“é˜¶ (ä½åˆ°é«˜)':
                filteredItems = this.sortByTier(filteredItems, item => item.tier).reverse();
                break;
              case 'ç‚¹æ•° (é«˜åˆ°ä½)':
                filteredItems.sort((a, b) => b.price - a.price);
                break;
              case 'ç‚¹æ•° (ä½åˆ°é«˜)':
                filteredItems.sort((a, b) => a.price - b.price);
                break;
            }
            
            const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, 'å½’å¢Ÿç‚¹', 0);
            const filters = ['å…¨éƒ¨', 'å¤©èµ‹', 'èƒŒæ™¯'];
            const sorts = ['é»˜è®¤', 'å“é˜¶ (é«˜åˆ°ä½)', 'å“é˜¶ (ä½åˆ°é«˜)', 'ç‚¹æ•° (é«˜åˆ°ä½)', 'ç‚¹æ•° (ä½åˆ°é«˜)'];
            
            const headerHtml = `
              <div class="guixu-space-header-embedded">
                <div class="guixu-filter-tabs">
                  ${filters.map(f => `<button class="tab-btn ${filterType === f ? 'active' : ''}" data-filter="${f}">${f}</button>`).join('')}
                </div>
                <div class="guixu-controls">
                  <select class="guixu-sort-select">
                    ${sorts.map(s => `<option value="${s}" ${this.currentGuixuSort === s ? 'selected' : ''}>${s}</option>`).join('')}
                  </select>
                  <div class="points-display">
                    <span>å½’å¢Ÿç‚¹: ${guixuPoints}</span>
                  </div>
                </div>
              </div>
            `;
            
            let itemsHtml = '';
            if (filteredItems && filteredItems.length > 0) {
              filteredItems.forEach((item, index) => {
                const tierStyle = this.getItemTierStyle(item.tier);
                const canAfford = guixuPoints >= item.price;
                itemsHtml += `
                  <div class="guixu-item-card" style="animation-delay: ${index * 0.05}s;">
                    <div class="item-content">
                      <h4 class="item-name" style="${tierStyle}">
                        ${item.name}
                        <span class="item-tier">${item.tier}</span>
                      </h4>
                      <p class="item-description">${item.description}</p>
                    </div>
                    <div class="item-footer">
                      <span class="item-price">${item.price} ç‚¹</span>
                      <button class="purchase-btn" data-item-id="${item.id}" ${!canAfford ? 'disabled' : ''}>è´­ä¹°</button>
                    </div>
                  </div>
                `;
              });
            } else {
              itemsHtml = '<p class="modal-placeholder">æš‚æ— æ­¤ç±»å•†å“</p>';
            }
            
            container.innerHTML = headerHtml + `<div class="guixu-item-grid-embedded">${itemsHtml}</div>`;
            
            // ç»‘å®šäº‹ä»¶
            container.querySelectorAll('.tab-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                this.currentGuixuFilter = btn.dataset.filter;
                this._renderGuixuSpaceEmbedded(container);
              });
            });
            
            container.querySelector('.guixu-sort-select')?.addEventListener('change', (e) => {
              this.currentGuixuSort = e.target.value;
              this._renderGuixuSpaceEmbedded(container);
            });
            
            container.querySelectorAll('.purchase-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                if (!btn.disabled) {
                  this.handlePurchase(btn.dataset.itemId);
                } else {
                  this.showTemporaryMessage('å½’å¢Ÿç‚¹ä¸è¶³');
                }
              });
            });
          },

          
          // æ¸²æŸ“å¤©èµ‹å’Œçµæ ¹(å¸¦å“é˜¶æŸ“è‰²)
          renderGuixuTalentAndLinggen(talentList, linggenList) {
            const container = document.getElementById('guixu-char-talent-container');
            if (!container) return;
            
            let html = '';
            
            const linggenEntries = Object.entries(linggenList).filter(([name]) => name !== '$meta');
            if (linggenEntries.length > 0) {
              const sortedLinggen = this.sortByTier(linggenEntries, ([, linggen]) => 
                this.SafeGetValue(linggen, 'tier', 'å‡¡å“')
              );
              
              sortedLinggen.forEach(([name, linggen]) => {
                const tier = this.SafeGetValue(linggen, 'tier', 'å‡¡å“');
                const description = this.SafeGetValue(linggen, 'description', 'æ— æè¿°');
                const tierStyle = this.getItemTierStyle(tier);
                
                html += `
                  <details class="details-container" style="margin-bottom: 8px;">
                    <summary style="cursor: pointer; padding: 8px; background: rgba(201, 170, 113, 0.1); border-radius: 4px;">
                      <span style="color: #c9aa71;">ã€çµæ ¹ã€‘</span>
                      <span style="${tierStyle}">ã€${tier}ã€‘${name}</span>
                    </summary>
                    <div style="padding: 10px; font-size: 13px; color: #e8dcc6; line-height: 1.6;">
                      ${description}
                    </div>
                  </details>
                `;
              });
            } else {
              html += `<div style="padding: 8px; color: #8b7355; font-size: 13px;">çµæ ¹: æœªè§‰é†’</div>`;
            }
            
            const tianfuEntries = Object.entries(talentList).filter(([name]) => name !== '$meta');
            if (tianfuEntries.length > 0) {
              const sortedTianfu = this.sortByTier(tianfuEntries, ([, tianfu]) =>
                this.SafeGetValue(tianfu, 'tier', 'å‡¡å“')
              );
              
              sortedTianfu.forEach(([name, tianfu]) => {
                const tier = this.SafeGetValue(tianfu, 'tier', 'å‡¡å“');
                const description = this.SafeGetValue(tianfu, 'description', 'æ— æè¿°');
                const tierStyle = this.getItemTierStyle(tier);
                
                html += `
                  <details class="details-container" style="margin-bottom: 8px;">
                    <summary style="cursor: pointer; padding: 8px; background: rgba(201, 170, 113, 0.1); border-radius: 4px;">
                      <span style="color: #c9aa71;">ã€å¤©èµ‹ã€‘</span>
                      <span style="${tierStyle}">ã€${tier}ã€‘${name}</span>
                    </summary>
                    <div style="padding: 10px; font-size: 13px; color: #e8dcc6; line-height: 1.6;">
                      ${description}
                    </div>
                  </details>
                `;
              });
            } else {
              html += `<div style="padding: 8px; color: #8b7355; font-size: 13px;">å¤©èµ‹: æœªè§‰é†’</div>`;
            }
            
            container.innerHTML = html;
          },
          
          // æ¸²æŸ“å››ç»´å±æ€§(å¸¦è¿›åº¦æ¡)
          renderGuixuAttributes(currentFali, maxFali, currentShenhai, maxShenhai, currentDaoxin, maxDaoxin, currentKongsu, maxKongsu) {
            const container = document.getElementById('guixu-char-attributes-container');
            if (!container) return;
            
            let html = '';
            html += this.getAttributeProgressHTML(currentFali, maxFali, 'æ³•åŠ›');
            html += this.getAttributeProgressHTML(currentShenhai, maxShenhai, 'ç¥æµ·');
            html += this.getAttributeProgressHTML(currentDaoxin, maxDaoxin, 'é“å¿ƒ');
            html += this.getAttributeProgressHTML(currentKongsu, maxKongsu, 'ç©ºé€Ÿ');
            
            container.innerHTML = html;
          },
          
          // æ¸²æŸ“è¡€é‡(å¸¦è¿›åº¦æ¡)
          renderGuixuHealth(currentXueliang, maxXueliang) {
            const container = document.getElementById('guixu-char-health-container');
            if (!container) return;
            
            const html = this.getAttributeProgressHTML(currentXueliang, maxXueliang, 'è¡€é‡');
            container.innerHTML = html;
          },

          bindGuixuReincarnateButton() {
            const reincarnateBtn = document.getElementById('btn-guixu-reincarnate');
            if (!reincarnateBtn) return;
            const newBtn = reincarnateBtn.cloneNode(true);
            reincarnateBtn.parentNode.replaceChild(newBtn, reincarnateBtn);
            newBtn.addEventListener('click', async () => {
              const stat_data = this.currentMvuState.stat_data;
              const chargeTime = this.SafeGetValue(stat_data, 'å½’çœŸæ•°', 0);
              if (chargeTime >= 1) {
                this.showCustomConfirm('ä½ ç¡®å®šè¦å½’å¢Ÿå—ï¼Ÿ', async () => {
                  try {
                    const command = '<user>é€‰æ‹©å½’å¢Ÿï¼Œä¸–ç•Œå°†å›åˆ°æœ€åˆçš„é”šç‚¹';
                    await this.handleAction(command);
                    this.showTemporaryMessage('è½®å›å·²å¼€å¯...');
                    this.closeAllModals();
                  } catch (error) {
                    console.error('æ‰§è¡Œå½’å¢ŸæŒ‡ä»¤æ—¶å‡ºé”™:', error);
                    this.showTemporaryMessage('æ‰§è¡Œå½’å¢ŸæŒ‡ä»¤å¤±è´¥ï¼');
                  }
                });
              } else {
                this.showTemporaryMessage('æ‚é±¼ï¼å½’çœŸæ•°ä¸å¤Ÿäº†ï¼');
              }
            });
          },

          YAMLParser: {
            parse: function (text) {
              if (!text || typeof text !== 'string') return {};
              const lines = text.split('\n');
              const result = {};
              const stack = [{ indent: -1, obj: result, lastKey: null }];

              for (const line of lines) {
                  const trimmed = line.trim();
                  if (!trimmed || trimmed.startsWith('#')) continue;

                  const indent = line.search(/\S/);

                  while (stack.length > 1 && indent <= stack[stack.length - 1].indent) {
                      stack.pop();
                  }
                  const parent = stack[stack.length - 1].obj;
                  let lastKeyInParent = stack[stack.length - 1].lastKey;

                  if (trimmed.startsWith('- ')) {
                      const value = trimmed.substring(2).trim();
                      if (lastKeyInParent && Array.isArray(parent[lastKeyInParent])) {
                          parent[lastKeyInParent].push(this._parseValue(value));
                      }
                  } else {
                      const colonIndex = trimmed.indexOf(':');
                      if (colonIndex > -1) {
                          const key = trimmed.substring(0, colonIndex).trim();
                          let value = trimmed.substring(colonIndex + 1).trim();
                          
                          stack[stack.length - 1].lastKey = key;

                          if (value === '|' || value === '>') {
                              let multiline = '';
                              const blockStartIndex = lines.indexOf(line) + 1;
                              for (let i = blockStartIndex; i < lines.length; i++) {
                                  const nextLine = lines[i];
                                  const nextIndent = nextLine.search(/\S/);
                                  if (nextLine.trim() === '' || nextIndent > indent) {
                                      multiline += nextLine.substring(indent + 2) + '\n';
                                  } else {
                                      break;
                                  }
                              }
                              parent[key] = multiline.trim();
                          } else if (value === '') {
                               const nextLine = lines[lines.indexOf(line) + 1] || '';
                               const nextTrimmed = nextLine.trim();
                               const nextIndent = nextLine.search(/\S/);
                               if (nextTrimmed.startsWith('- ') && nextIndent > indent) {
                                   const newArr = [];
                                   parent[key] = newArr;
                               } else if (nextIndent > indent) {
                                   const newObj = {};
                                   parent[key] = newObj;
                                   stack.push({ indent: indent, obj: newObj, lastKey: null });
                               } else {
                                   parent[key] = '';
                               }
                          } else {
                              parent[key] = this._parseValue(value);
                          }
                      }
                  }
              }
              return result;
            },
            _parseValue: function (val) {
              const numVal = Number(val);
              if (!isNaN(numVal) && val.trim() !== '') {
                return numVal;
              }
              if (val === 'true') return true;
              if (val === 'false') return false;
              return val;
            },
          },

// ã€å½’å¢Ÿç©ºé—´ï¼šåŠ è½½å•†å“ã€‘
          async loadGuixuStoreItems() {
            try {
              if (typeof TavernHelper === 'undefined' || typeof TavernHelper.getGlobalWorldbookNames !== 'function' || typeof TavernHelper.getWorldbook !== 'function') {
                console.error('TavernHelper API not available.');
                this.showTemporaryMessage('é”™è¯¯ï¼šä¸–ç•Œä¹¦APIä¸å¯ç”¨');
                return [];
              }

              // 1. è·å–æ‰€æœ‰å¯ç”¨çš„ä¸–ç•Œä¹¦åç§°
              const enabledBookNames = TavernHelper.getGlobalWorldbookNames();
              
              // 2. ç­›é€‰å‡ºç›®æ ‡ä¸–ç•Œä¹¦åç§°
              let targetBookNames = enabledBookNames.filter(name => name.startsWith('ã€å½’å¢Ÿæ‰©å±•ã€‘'));
              
              // 3. æ·»åŠ  '1å½’å¢Ÿ' å¹¶å»é‡
              if (!targetBookNames.includes('1å½’å¢Ÿ')) {
                  targetBookNames.push('1å½’å¢Ÿ');
              }
              
              let allEntries = [];
              for (const bookName of targetBookNames) {
                  try {
                      const entries = await TavernHelper.getWorldbook(bookName);
                      allEntries.push(...entries);
                  } catch (e) {
                      console.warn(`æ— æ³•åŠ è½½ä¸–ç•Œä¹¦ "${bookName}" çš„å†…å®¹:`, e);
                  }
              }

              if (allEntries.length === 0) {
                console.warn('åœ¨ç›®æ ‡ä¸–ç•Œä¹¦ä¸­æœªæ‰¾åˆ°ä»»ä½•æ¡ç›®ã€‚');
                return [];
              }

              const validItemPrefixes = ['ã€å¤©èµ‹ã€‘', 'ã€èƒŒæ™¯ã€‘'];
              const itemEntries = allEntries.filter(entry => {
                return validItemPrefixes.some(prefix => entry.name.startsWith(prefix));
              });

              if (itemEntries.length === 0) {
                  console.log('åœ¨ç›®æ ‡ä¸–ç•Œä¹¦ä¸­æœªæ‰¾åˆ°ç¬¦åˆå•†å“å‰ç¼€çš„æ¡ç›®ã€‚');
                  return [];
              }
              
              const items = itemEntries.map(entry => {
                try {
                  const parsedContent = this.YAMLParser.parse(entry.content);
                  // ä¿®å¤ï¼šå…¼å®¹â€œä»·æ ¼â€å’Œâ€œæ¶ˆè€—ç‚¹æ•°â€ä¸¤ç§å­—æ®µï¼Œå¹¶æä¾›é»˜è®¤å€¼
                  const priceValue = parsedContent.ä»·æ ¼ ?? parsedContent.æ¶ˆè€—ç‚¹æ•° ?? 0;
                  const price = parseInt(priceValue, 10);

                  const itemId = `gs-item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                  return {
                    id: itemId,
                    name: parsedContent.åç§° || entry.name.replace(/ã€.*?ã€‘/g, '').trim(),
                    price: price,
                    description: parsedContent.æè¿° || 'æš‚æ— æè¿°',
                    type: parsedContent.ç±»å‹ || entry.name.match(/ã€(.*?)ã€‘/)?.[1] || 'ç‰©å“',
                    tier: parsedContent.å“é˜¶ || 'å‡¡å“',
                    fullContent: entry.content,
                  };
                } catch (e) {
                  console.error(`è§£æä¸–ç•Œä¹¦æ¡ç›® "${entry.name}" æ—¶å‡ºé”™:`, e);
                  return null;
                }
              }).filter(item => item !== null);

              return items;

            } catch (error) {
              console.error('åŠ è½½å½’å¢Ÿç©ºé—´å•†å“æ—¶å‡ºé”™:', error);
              this.showTemporaryMessage('åŠ è½½å•†å“å¤±è´¥');
              return [];
            }
          },

          currentGuixuSort: 'é»˜è®¤',
          guixuItemDOMElements: {}, // æ–°å¢ï¼šç”¨äºç¼“å­˜DOMå…ƒç´ 
          // --- å½’å¢Ÿç©ºé—´ï¼šä¸»ç•Œé¢ ---
          async showGuixuSpace(filterType = 'å…¨éƒ¨', isUpdate = false) {
            this.currentGuixuFilter = filterType;
            this.openModal('guixu-space-modal', true);
            const body = document.querySelector('#guixu-space-modal .modal-body');
            if (!body) return;

            // --- æ€§èƒ½ä¼˜åŒ–ï¼šä»…åœ¨é¦–æ¬¡åŠ è½½æ—¶å®Œå…¨é‡ç»˜ ---
            if (!isUpdate) {
               if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                   body.innerHTML = '<p class="modal-placeholder">æ­£åœ¨åŠ è½½ç©å®¶æ•°æ®...</p>';
                   await this.loadMvuData();
                   if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                       this.showTemporaryMessage('æ— æ³•åŠ è½½ç©å®¶æ•°æ®ï¼Œè¯·åˆ·æ–°é¡µé¢');
                       return;
                   }
               }

               body.innerHTML = '<p class="modal-placeholder">æ­£åœ¨ä»ä¸–ç•Œä¹¦ä¸­åŠ è½½å•†å“...</p>';
               const allItems = await this.loadGuixuStoreItems();
               this.guixuStoreItems = allItems;
               this.guixuItemDOMElements = {}; // æ¸…ç©ºç¼“å­˜
            }

            let filteredItems = filterType === 'å…¨éƒ¨' ? this.guixuStoreItems : this.guixuStoreItems.filter(item => item.type === filterType);

            switch (this.currentGuixuSort) {
               case 'å“é˜¶ (é«˜åˆ°ä½)':
                   filteredItems = this.sortByTier(filteredItems, item => item.tier);
                   break;
               case 'å“é˜¶ (ä½åˆ°é«˜)':
                   filteredItems = this.sortByTier(filteredItems, item => item.tier).reverse();
                   break;
               case 'ç‚¹æ•° (é«˜åˆ°ä½)':
                   filteredItems.sort((a, b) => b.price - a.price);
                   break;
               case 'ç‚¹æ•° (ä½åˆ°é«˜)':
                   filteredItems.sort((a, b) => a.price - b.price);
                   break;
            }

            const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, 'å½’å¢Ÿç‚¹', 0);
            
//ã€æ€§èƒ½ä¼˜åŒ–ï¼šä»…åœ¨é¦–æ¬¡åŠ è½½æ—¶æ¸²æŸ“Headerå’ŒGridå®¹å™¨ã€‘

            if (!isUpdate) {
               const filters = ['å…¨éƒ¨', 'å¤©èµ‹', 'èƒŒæ™¯'];
               const sorts = ['é»˜è®¤', 'å“é˜¶ (é«˜åˆ°ä½)', 'å“é˜¶ (ä½åˆ°é«˜)', 'ç‚¹æ•° (é«˜åˆ°ä½)', 'ç‚¹æ•° (ä½åˆ°é«˜)'];
               const headerHtml = `
                 <div class="guixu-space-header">
                   <div class="guixu-filter-tabs">
                     ${filters.map(f => `<button class="tab-btn ${filterType === f ? 'active' : ''}" data-filter="${f}">${f}</button>`).join('')}
                   </div>
                   <div class="guixu-controls">
                      <select class="guixu-sort-select">
                          ${sorts.map(s => `<option value="${s}" ${this.currentGuixuSort === s ? 'selected' : ''}>${s}</option>`).join('')}
                      </select>
                      <div class="points-display">
                        <span>å½’å¢Ÿç‚¹: ${guixuPoints}</span>
                      </div>
                   </div>
                 </div>`;
               body.innerHTML = headerHtml + '<div class="guixu-item-grid"></div><p class="modal-placeholder" style="display:none;">æš‚æ— æ­¤ç±»å•†å“</p>';
               this.bindGuixuSpaceEvents(body);
            }
            
  // ã€æ€§èƒ½ä¼˜åŒ–ï¼šDOMå¤ç”¨å’Œå±€éƒ¨æ›´æ–°ã€‘

            const grid = body.querySelector('.guixu-item-grid');
            const placeholder = body.querySelector('.modal-placeholder');
            if (!grid || !placeholder) return;

            // æ›´æ–°UIçŠ¶æ€
            body.querySelectorAll('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.filter === filterType));
            body.querySelector('.guixu-sort-select').value = this.currentGuixuSort;
            body.querySelector('.points-display span').textContent = `å½’å¢Ÿç‚¹: ${guixuPoints}`;

            if (!filteredItems || filteredItems.length === 0) {
                grid.innerHTML = '';
                placeholder.style.display = 'block';
                return;
            }
            
            placeholder.style.display = 'none';

            const fragment = document.createDocumentFragment();
            
            // åˆ›å»ºæˆ–æ›´æ–°DOMå…ƒç´ 
            filteredItems.forEach((item, index) => {
               let card = this.guixuItemDOMElements[item.id];
               if (!card) {
                   const tierStyle = this.getItemTierStyle(item.tier);
                   const cardHtml = `
                       <div class="item-content">
                         <h4 class="item-name" style="${tierStyle}">
                           ${item.name}
                           <span class="item-tier">${item.tier}</span>
                         </h4>
                         <p class="item-description">${item.description}</p>
                       </div>
                       <div class="item-footer">
                         <span class="item-price">${item.price} ç‚¹</span>
                         <button class="purchase-btn" data-item-id="${item.id}"></button>
                       </div>`;
                   card = document.createElement('div');
                   card.className = 'guixu-item-card';
                   card.innerHTML = cardHtml;
                   this.guixuItemDOMElements[item.id] = card;
               }
               
               // æ›´æ–°åŠ¨æ€å†…å®¹
               card.style.animationDelay = `${index * 0.05}s`;
               const purchaseBtn = card.querySelector('.purchase-btn');
               purchaseBtn.disabled = guixuPoints < item.price;
               purchaseBtn.textContent = 'è´­ä¹°';
               
               fragment.appendChild(card);
            });
          
            grid.innerHTML = ''; // æ¸…ç©º
            grid.appendChild(fragment); // é™„åŠ 
          },

          bindGuixuSpaceEvents(container) {

// ã€ åˆ†ç¦»clickå’Œchangeäº‹ä»¶å¤„ç†å™¨ï¼Œè§£å†³ç‚¹å‡»å³åˆ·æ–°çš„bugã€‘

              const clickHandler = (event) => {
                  const target = event.target;
                  if (target.classList.contains('purchase-btn')) {
                      if (target.disabled) {
                          this.showTemporaryMessage('å½’å¢Ÿç‚¹ä¸è¶³');
                          return;
                      }
                      const itemId = target.dataset.itemId;
                      this.handlePurchase(itemId);
                  } else if (target.classList.contains('tab-btn')) {
                      const filter = target.dataset.filter;
                      this.showGuixuSpace(filter, true);
                  }
              };

              const changeHandler = (event) => {
                  const target = event.target;
                  if (target.classList.contains('guixu-sort-select')) {
                      this.currentGuixuSort = target.value;
                      this.showGuixuSpace(this.currentGuixuFilter, true);
                  }
              };

              if (!this.guixuEventHandlers) {
                  this.guixuEventHandlers = new WeakMap();
              }

              if (this.guixuEventHandlers.has(container)) {
                  const oldHandlers = this.guixuEventHandlers.get(container);
                  container.removeEventListener('click', oldHandlers.click);
                  container.removeEventListener('change', oldHandlers.change);
              }

              container.addEventListener('click', clickHandler);
              container.addEventListener('change', changeHandler);
              
              this.guixuEventHandlers.set(container, {
                  click: clickHandler,
                  change: changeHandler
              });
          },

          // å½’å¢Ÿç©ºé—´UIé™é»˜åˆ·æ–°
          _silentUpdateGuixuSpaceUI() {
              const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, 'å½’å¢Ÿç‚¹', 0);
              const modalBody = document.querySelector('#guixu-space-modal .modal-body');
              if (!modalBody) return;

              // 1. æ›´æ–°å½’å¢Ÿç‚¹æ˜¾ç¤º
              const pointsDisplay = modalBody.querySelector('.points-display span');
              if (pointsDisplay) {
                  pointsDisplay.textContent = `å½’å¢Ÿç‚¹: ${guixuPoints}`;
              }

              // 2. æ›´æ–°æ‰€æœ‰è´­ä¹°æŒ‰é’®çš„çŠ¶æ€
              this.guixuStoreItems.forEach(item => {
                  const purchaseBtn = modalBody.querySelector(`button[data-item-id="${item.id}"]`);
                  if (purchaseBtn) {
                      purchaseBtn.disabled = guixuPoints < item.price;
                  }
              });
              console.log('[å½’å¢Ÿç©ºé—´] UIé™é»˜åˆ·æ–°å®Œæˆ');
          },


          // å½’å¢Ÿç©ºé—´ï¼šå¤„ç†è´­ä¹°
          async handlePurchase(itemId) {
              const item = this.guixuStoreItems.find(i => i.id === itemId);
              if (!item) {
                  console.error('æ‰¾ä¸åˆ°è¦è´­ä¹°çš„å•†å“:', itemId);
                  return;
              }

              const currentPoints = parseInt(this.SafeGetValue(this.currentMvuState.stat_data, 'å½’å¢Ÿç‚¹', 0), 10);

              if (currentPoints < item.price) {
                  this.showTemporaryMessage('å½’å¢Ÿç‚¹ä¸è¶³');
                  return;
              }

              const confirmMessage = `ç¡®å®šè¦èŠ±è´¹ ${item.price} å½’å¢Ÿç‚¹è´­ä¹°ã€${item.name}ã€‘å—ï¼Ÿ`;

              this.showCustomConfirm(confirmMessage, async () => {
                  try {
                      // --- MVU API é‡æ„å¼€å§‹ ---
                      // 1. è·å–æœ€æ–°çš„â€œæœ¬åœ°è‰ç¨¿â€
                      const mvuData = this.currentMvuState;
                      if (!mvuData) {
                          this.showTemporaryMessage('å‘ç”Ÿå†…éƒ¨é”™è¯¯ï¼Œè´­ä¹°å¤±è´¥', 'error');
                          return;
                      }

                      // 2. åœ¨â€œæœ¬åœ°è‰ç¨¿â€ä¸Šè¿›è¡ŒåŸå­åŒ–ä¿®æ”¹
                      const path = 'å½’å¢Ÿç‚¹';
                      const currentPoints = parseInt(Mvu.getMvuVariable(mvuData, path, { default_value: 0 }), 10);
                      await Mvu.setMvuVariable(mvuData, path, currentPoints - item.price, { reason: `è´­ä¹° ${item.name}` });
                      console.log(`[å½’å¢Ÿç©ºé—´] æœ¬åœ°å½’å¢Ÿç‚¹å·²æ›´æ–°ä¸º: ${Mvu.getMvuVariable(mvuData, path)}`); // è°ƒè¯•æ—¥å¿—

                      // 3. å°†ä¿®æ”¹åçš„â€œæœ¬åœ°è‰ç¨¿â€åŒæ­¥å›â€œäº‘ç«¯æ­£æœ¬â€
                      await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });
                      // 4. æ„å»ºåç»­æŒ‡ä»¤å¹¶æ›´æ–°UI
                      const gainMessage = `<user>è´­ä¹°äº†${item.name}ï¼Œè¯¦ç»†ä¿¡æ¯ï¼š\n${item.fullContent}`;
                      this.addCommand(gainMessage);
                      this.savePendingActions();
                      
                      this.showTemporaryMessage(`è´­ä¹°ã€${item.name}ã€‘æˆåŠŸï¼ï¼ï¼å¥½æ¬¸ï¼ï¼ï¼`,`success`);
                      this._silentUpdateGuixuSpaceUI(); // é™é»˜åˆ·æ–°UI,ä¸è·³è½¬

                  } catch (error) {
                      console.error('è´­ä¹°è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
                      this.showTemporaryMessage(`è´­ä¹°å¤±è´¥: ${error.message}`);
                  }
              }, null, true, { customClass: 'guixu-confirm-modal' });
          },



// ===å½’å¢Ÿç©ºé—´æ¨¡å—ç»“æŸ===



// ===æ¨¡æ€æ¡†æ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰å¼€å§‹===




          openModal(modalId, keepOpen = false) {
            if (!keepOpen) {
                this.closeAllModals();
            }
            const modal = document.getElementById(modalId);
            if (modal) {
                const rootContainer = document.querySelector('.guixu-root-container');
                if (rootContainer && modal.parentNode !== rootContainer) {
                    // å¦‚æœæ˜¯ï¼Œåˆ™å°†å…¶ç§»åŠ¨åˆ°æ ¹å®¹å™¨çš„æœ«å°¾ï¼Œä»¥ç¡®ä¿å®ƒåœ¨å…¨å±æ—¶å¯è§
                    rootContainer.appendChild(modal);
                }

                modal.style.display = 'flex';
                if (keepOpen) {
                    const highestZ = Array.from(document.querySelectorAll('.modal-overlay'))
                        .filter(el => el.style.display === 'flex' && el.id !== modalId)
                        .reduce((maxZ, el) => Math.max(maxZ, parseInt(window.getComputedStyle(el).zIndex, 10) || 1000), 1000);
                    modal.style.zIndex = highestZ + 1;
                } else {
                    modal.style.zIndex = ''; 
                }
              
                this.applyModalSizeToModal(modal);

            }
          },

          // æ–°å¢ï¼šä¸ºç‰¹å®šæ¨¡æ€æ¡†åº”ç”¨å¤§å°è®¾ç½®
          applyModalSizeToModal(modal) {
              try {
                  // æ ¸å¿ƒï¼šå¦‚æœæ¨¡æ€æ¡†æ˜¯å®šåˆ¶åŒ–ç¡®è®¤æ¡†ï¼Œåˆ™è·³è¿‡å…¨å±€å¤§å°è°ƒæ•´
                  if (modal.classList.contains('guixu-confirm-modal')) {
                      return;
                  }
                  const savedState = localStorage.getItem('guixu_modal_size');
                  // è±å…äººç‰©å…³ç³»æ¨¡æ€æ¡†ã€å½’å¢Ÿç³»ç»Ÿæ¨¡æ€æ¡†ã€è®¾ç½®æ¨¡æ€æ¡†ã€ä¸–ç•Œå¤§äº‹æ¨¡æ€æ¡†å’ŒèƒŒåŒ…æ¨¡æ€æ¡†ï¼Œå®ƒä»¬çš„å°ºå¯¸ç”±å…¶å†…éƒ¨CSSæ§åˆ¶
                  if (savedState && modal.id !== 'relationships-modal' && modal.id !== 'guixu-system-modal' && modal.id !== 'settings-modal' && modal.id !== 'world-events-modal' && modal.id !== 'inventory-modal') {
                      const { width, height } = JSON.parse(savedState);
                      if (width && height) {
                          const modalContent = modal.querySelector('.modal-content');
                          if (modalContent) {
                              modalContent.style.maxWidth = `${width}px`;
                              modalContent.style.width = `${Math.min(width, window.innerWidth * 0.9)}px`;
                              modalContent.style.height = `${Math.min(height, window.innerHeight * 0.9)}px`;
                              modalContent.style.maxHeight = `${Math.min(height, window.innerHeight * 0.9)}px`;
                              modalContent.style.overflow = 'auto';
                          }
                      }
                  }
              } catch (e) {
                  console.error('åº”ç”¨æ¨¡æ€æ¡†å¤§å°è®¾ç½®å¤±è´¥:', e);
              }
          },

          closeModal(modalId) {
              const modal = document.getElementById(modalId);
              if (modal) {
                  modal.style.display = 'none';
                  modal.style.zIndex = ''; // Reset z-index

              }
          },

          // ã€é‡è¦ï¼šå¤„ç†æ¨¡æ€æ¡†å…³é—­çš„ç»Ÿä¸€æ–¹æ³•ã€‘
           handleModalClose(event) {
            const modalOverlay = event.target.closest('.modal-overlay');

           if (modalOverlay && modalOverlay.id === 'guixu-space-modal') {
               this.closeModal('guixu-space-modal');
               this.openModal('guixu-system-modal');
               return;
           }

            // è¡æ¢¦å°˜å­çª—å£å…³é—­é€»è¾‘ä¿®æ”¹
            if (modalOverlay && (modalOverlay.id === 'gacha-results-modal' || modalOverlay.id === 'gacha-history-modal' || modalOverlay.id === 'gacha-details-modal' || modalOverlay.id === 'gacha-gallery-popup' || modalOverlay.id === 'gacha-settings-popup')) {
        this.closeModal(modalOverlay.id); // åªå…³é—­å½“å‰å­çª—å£
                 // æ ¸å¿ƒä¿®å¤ï¼šå¦‚æœå…³é—­çš„æ˜¯å¬å”¤ç»“æœçª—å£ï¼Œåˆ™åˆ·æ–°å¬å”¤ä¸»ç•Œé¢
                if (modalOverlay.id === 'gacha-results-modal') {
                    this.renderSummonTab(this.currentGachaPoolType);
                }
                return;
            }

            // æ–°å¢ï¼šäººç‰©å…³ç³»ç•Œé¢å…³é—­é€»è¾‘ - æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ¨¡æ€æ¡†æ‰“å¼€
            if (modalOverlay && modalOverlay.id === 'relationships-modal') {
                // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ¨¡æ€æ¡†åœ¨ä¸‹å±‚ï¼ˆå¦‚å®—é—¨ç•Œé¢ï¼‰
                const otherModals = Array.from(document.querySelectorAll('.modal-overlay'))
                    .filter(el => el.style.display === 'flex' && el.id !== 'relationships-modal');
                
                if (otherModals.length > 0) {
                    // æœ‰å…¶ä»–æ¨¡æ€æ¡†æ‰“å¼€ï¼Œåªå…³é—­äººç‰©å…³ç³»ç•Œé¢
                    this.closeModal('relationships-modal');
                    return;
                }
                // æ²¡æœ‰å…¶ä»–æ¨¡æ€æ¡†ï¼Œæ‰§è¡Œé»˜è®¤å…³é—­é€»è¾‘ï¼ˆå…³é—­æ‰€æœ‰ï¼‰
            }

            // è¡æ¢¦å°˜ä¸»çª—å£å…³é—­é€»è¾‘
            if (modalOverlay && modalOverlay.id === 'gacha-modal') {
                // æ£€æŸ¥æ˜¯å¦ä»å½’å¢Ÿç³»ç»Ÿè¿›å…¥
                if (this.isFromGuixuSystem) {
                    this.closeModal(modalOverlay.id); // å…³é—­gachaä¸»çª—å£
                    this.showGuixuSystem(); // è¿”å›å½’å¢Ÿç³»ç»Ÿç•Œé¢
                    this.isFromGuixuSystem = false; // é‡ç½®æ ‡å¿—
                    return; // ç»“æŸå¤„ç†
                }
                // å¦‚æœä¸æ˜¯ä»å½’å¢Ÿç³»ç»Ÿè¿›å…¥ï¼Œåˆ™ä¼šæ‰§è¡Œä¸‹é¢çš„é»˜è®¤å…³é—­é€»è¾‘
            }

            // æ–°å¢ï¼šå¤„ç†ä»è®¾ç½®ç•Œé¢æ‰“å¼€çš„çª—å£çš„è¿”å›é€»è¾‘
            if (this.isFromSettingsModal) {
                this.closeModal(modalOverlay.id);
                this.showSettings();
                this.isFromSettingsModal = false; // é‡ç½®æ ‡å¿—
                return;
            }

            if (!modalOverlay) {
              this.closeAllModals();
              return;
            }

            const modalId = modalOverlay.id;
            
            // ç‰¹æ®Šå¤„ç†æ ¼å¼éªŒè¯æ¨¡æ€æ¡†å…³é—­
            if (modalId === 'format-validation-modal') {
              // å…³é—­ç­‰å¾…æ¶ˆæ¯
              this.hideWaitingMessage();
              // å¡«å……åŸå§‹å†…å®¹è€Œä¸æ˜¯æ¸…ç©º
              const gameTextDisplay = document.getElementById('game-text-display');
              if (gameTextDisplay && this.lastValidGametxtHTML) {
                gameTextDisplay.innerHTML = this.lastValidGametxtHTML;
                this.updateLiveWordCount(); // æ–°å¢ï¼šè°ƒç”¨å­—æ•°ç»Ÿè®¡å‡½æ•°
              }
              this.closeModal(modalId);
              this.showTemporaryMessage('å·²å–æ¶ˆæ ¼å¼éªŒè¯ï¼Œå†…å®¹å·²æ¢å¤ã€‚');
              return;
            }
            
            // ç‰¹æ®Šå¤„ç†ï¼šç³»åˆ—ç®¡ç†æ¨¡æ€æ¡†å…³é—­åè¿”å›å­˜æ¡£ç•Œé¢
            if (modalId === 'series-manager-modal') {
              this.closeModal(modalId);
              this.showNewSaveLoadManager(); // è¿”å›å­˜æ¡£ç•Œé¢
              return;
            }

            // æ£€æŸ¥æ˜¯å¦æ˜¯ä»è®¾ç½®ç•Œé¢è¿›å…¥çš„å­çª—å£
            if (this.isFromSettingsModal &&
                (modalId === 'command-center-modal' ||
                 modalId === 'extracted-content-modal' ||
                 modalId === 'map-modal' ||
                 modalId === 'background-settings-modal' ||
                 modalId === 'worldbook-manager-modal' ||
                 modalId === 'segmented-memory-modal')) { // æ–°å¢å¯¹åˆ†æ®µè®°å¿†æ¨¡æ€æ¡†çš„åˆ¤æ–­
              // å…³é—­å½“å‰å­çª—å£å¹¶è¿”å›è®¾ç½®ç•Œé¢
              this.closeModal(modalId);
              this.isFromSettingsModal = false; // é‡ç½®çŠ¶æ€
              this.showSettings();
            } else {
              // æ­£å¸¸å…³é—­æ‰€æœ‰æ¨¡æ€æ¡†
              this.closeAllModals();
            }
          },

          closeAllModals() {
            document.querySelectorAll('.modal-overlay').forEach(modal => {
              modal.style.display = 'none';
            });
           this.hideWindowSizePanel();
          },

          showCustomConfirm(message, onConfirm, onCancel = null, keepCurrentModal = false, options = {}) {
            const modal = document.getElementById('custom-confirm-modal');
            const messageEl = document.getElementById('custom-confirm-message');
            const okBtn = document.getElementById('custom-confirm-btn-ok');
            const cancelBtn = document.getElementById('custom-confirm-btn-cancel');
            const closeBtn = modal?.querySelector('.modal-close-btn');

            if (!modal || !messageEl || !okBtn || !cancelBtn) return;

            // --- æ–°å¢ï¼šå¤„ç†è‡ªå®šä¹‰æ ·å¼ç±» ---
            if (options.customClass) {
                modal.classList.add(options.customClass);
            }

            messageEl.textContent = message;
            const newOkBtn = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);

            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            const closeAction = () => {
                // --- æ–°å¢ï¼šæ¸…ç†è‡ªå®šä¹‰æ ·å¼ç±» ---
                if (options.customClass) {
                    modal.classList.remove(options.customClass);
                }
                if (keepCurrentModal) {
                    this.closeModal('custom-confirm-modal');
                    // å¦‚æœæ˜¯ä»é¢„è®¾ç®¡ç†ç•Œé¢è¿›å…¥çš„ï¼Œè¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
                    if (this.isFromWorldbookManager) {
                        this.showWorldbookPresets();
                    }
                } else {
                    this.closeAllModals();
                }
            };

            newOkBtn.addEventListener('click', () => {
              closeAction();
              if (typeof onConfirm === 'function') {
                onConfirm();
              }
            });

            newCancelBtn.addEventListener('click', () => {
              closeAction();
              if (typeof onCancel === 'function') {
                onCancel();
              }
            });

            // å¤„ç†å…³é—­æŒ‰é’®ï¼ˆÃ—ï¼‰
            if (closeBtn) {
              closeBtn.onclick = () => {
                closeAction();
                if (typeof onCancel === 'function') {
                  onCancel();
                }
              };
            }

            this.openModal('custom-confirm-modal', keepCurrentModal);
          },


// ===æ¨¡æ€æ¡†æ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰ç»“æŸ===



// ===ä»»åŠ¡ç³»ç»Ÿæ¨¡å—å¼€å§‹===



          // ä»»åŠ¡ç³»ç»Ÿï¼šåˆå§‹åŒ–
          initQuestSystem() {
              // ç»‘å®šçŠ¶æ€ç­›é€‰æŒ‰é’®äº‹ä»¶
              const statusTabs = document.querySelectorAll('.quest-status-tabs .panel-tab-btn');
              statusTabs.forEach(btn => {
                  btn.addEventListener('click', (e) => {
                      statusTabs.forEach(b => b.classList.remove('active'));
                      e.target.classList.add('active');
                      const status = e.target.getAttribute('data-status');
                      this.renderQuestList(status);
                  });
              });

              // åˆå§‹æ¸²æŸ“
              const activeStatus = document.querySelector('.quest-status-tabs .panel-tab-btn.active');
              const initialStatus = activeStatus ? activeStatus.getAttribute('data-status') : 'unfinished';
              this.renderQuestList(initialStatus);
          },

          // ä»»åŠ¡ç³»ç»Ÿï¼šæ¸²æŸ“ä»»åŠ¡åˆ—è¡¨
          renderQuestList(statusFilter = 'unfinished') {
              const container = document.getElementById('quest-list-container');
              if (!container) return;

              const mvuData = this.currentMvuState;
              if (!mvuData || !mvuData.stat_data) {
                  container.innerHTML = `
                      <div class="quest-placeholder">
                          <div class="placeholder-icon">ğŸ“œ</div>
                          <div class="placeholder-text">æš‚æ— ä»»åŠ¡</div>
                          <div class="placeholder-desc">å®Œæˆä¸»çº¿å‰§æƒ…å¯è·å¾—ä»»åŠ¡</div>
                      </div>
                  `;
                  this.updateQuestBadges({});
                  return;
              }

              const questList = this.SafeGetValue(mvuData.stat_data, 'ä»»åŠ¡åˆ—è¡¨', {});
              const quests = Object.entries(questList).filter(([key]) => key !== '$meta');

              if (quests.length === 0) {
                  container.innerHTML = `
                      <div class="quest-placeholder">
                          <div class="placeholder-icon">ğŸ“œ</div>
                          <div class="placeholder-text">æš‚æ— ä»»åŠ¡</div>
                          <div class="placeholder-desc">å®Œæˆä¸»çº¿å‰§æƒ…å¯è·å¾—ä»»åŠ¡</div>
                      </div>
                  `;
                  this.updateQuestBadges({});
                  return;
              }

              // ç­›é€‰ä»»åŠ¡
              const filteredQuests = quests.filter(([_, quest]) => {
                  const status = quest['ä»»åŠ¡çŠ¶æ€'] || 'æœªæ¥å–';
                  if (statusFilter === 'unclaimed') {
                      return status === 'æœªæ¥å–';
                  } else if (statusFilter === 'unfinished') {
                      return ['è¿›è¡Œä¸­', 'å¤±è´¥'].includes(status);
                  } else {
                      return status === 'å®Œæˆ';
                  }
              });

              // æ›´æ–°å¾½ç« 
              this.updateQuestBadges(questList);

              if (filteredQuests.length === 0) {
                  const statusName = statusFilter === 'unclaimed' ? 'å¾…æ¥å–' : (statusFilter === 'unfinished' ? 'æœªå®Œæˆ' : 'å·²å®Œæˆ');
                  container.innerHTML = `
                      <div class="quest-placeholder">
                          <div class="placeholder-icon">ğŸ“œ</div>
                          <div class="placeholder-text">æš‚æ— ${statusName}ä»»åŠ¡</div>
                      </div>
                  `;
                  return;
              }

              // æ¸²æŸ“ä»»åŠ¡å¡ç‰‡
              const questCardsHtml = filteredQuests.map(([questName, quest]) => {
                  return this.renderQuestCard(questName, quest);
              }).join('');

              container.innerHTML = questCardsHtml;

              // ç»‘å®šå±•å¼€/æŠ˜å äº‹ä»¶
              this.bindQuestCardEvents();
          },

          // ä»»åŠ¡ç³»ç»Ÿï¼šæ¸²æŸ“å•ä¸ªä»»åŠ¡å¡ç‰‡
          renderQuestCard(questName, quest) {
              const tier = quest['ä»»åŠ¡å“é˜¶'] || 1;
              const description = quest['ä»»åŠ¡æè¿°'] || '';
              const category = quest['ä»»åŠ¡ç±»åˆ«'] || 'ä¸»çº¿';
              const status = quest['ä»»åŠ¡çŠ¶æ€'] || 'æœªæ¥å–';
              const deadline = quest['å®Œæˆæ—¶é—´æœŸé™'] || '';
              const completeTime = quest['ä»»åŠ¡å®Œæˆæ—¶é—´'] || '';
              const rewards = quest['ä»»åŠ¡å¥–åŠ±'] || {};
              const penalty = quest['ä»»åŠ¡æƒ©ç½š'] || {};

              // å“é˜¶æŸ“è‰² - æ³¨æ„å“é˜¶æ˜¯æ•°å­—ï¼Œéœ€è¦åŠ "é˜¶"åç¼€
              const tierText = `${tier}é˜¶`;
              const tierStyle = this.getItemTierStyle(tierText);
              const statusClass = `status-${status}`;

              // æ¸²æŸ“å¥–åŠ±éƒ¨åˆ†
              const rewardsHtml = this.renderQuestRewards(rewards);
              
              // æ¸²æŸ“æƒ©ç½šéƒ¨åˆ†
              const penaltyHtml = penalty && penalty['æè¿°'] ? `
                  <div class="quest-penalty-section">
                      <div class="quest-penalty-text">${penalty['æè¿°']}</div>
                  </div>
              ` : '';

              return `
                  <div class="quest-card" data-quest-name="${questName}">
                      <div class="quest-card-header">
                          <div class="quest-card-title-section">
                              <div class="quest-card-title" style="${tierStyle}">${questName}</div>
                              <span class="quest-tier-badge" style="${tierStyle}">${tier}</span>
                          </div>
                          <div class="quest-card-meta">
                              <span class="quest-status-badge ${statusClass}">${status}</span>
                              <span class="quest-category-badge">${category}</span>
                              <span class="quest-expand-icon">â–¼</span>
                          </div>
                      </div>
                      <div class="quest-card-content">
                          <div class="quest-card-body">
                              <div class="quest-description">${description}</div>
                              <div class="quest-time-info">
                                  <span><span class="quest-time-label">æ—¶é—´æœŸé™:</span> ${deadline || 'æ— é™åˆ¶'}</span>
                                  ${completeTime ? `<span><span class="quest-time-label">å®Œæˆæ—¶é—´:</span> ${completeTime}</span>` : ''}
                              </div>
                              ${rewardsHtml}
                              ${penaltyHtml}
                          </div>
                      </div>
                  </div>
              `;
          },

          // ä»»åŠ¡ç³»ç»Ÿï¼šæ¸²æŸ“ä»»åŠ¡å¥–åŠ±
          renderQuestRewards(rewards) {
              if (!rewards || Object.keys(rewards).length === 0) return '';

              let html = '<div class="quest-rewards-section">';
              html += '<div class="quest-section-title">ä»»åŠ¡å¥–åŠ±</div>';

              // åŸºç¡€å¥–åŠ±ï¼ˆä¿®ä¸ºã€å½’å¢Ÿç‚¹ã€çµçŸ³ï¼‰
              const basicRewards = [];
              if (rewards['ä¿®ä¸ºè¿›åº¦'] && rewards['ä¿®ä¸ºè¿›åº¦'] > 0) {
                  basicRewards.push({name: 'ä¿®ä¸ºè¿›åº¦', value: rewards['ä¿®ä¸ºè¿›åº¦']});
              }
              if (rewards['å½’å¢Ÿç‚¹'] && rewards['å½’å¢Ÿç‚¹'] > 0) {
                  basicRewards.push({name: 'å½’å¢Ÿç‚¹', value: rewards['å½’å¢Ÿç‚¹']});
              }
              if (rewards['çµçŸ³'] && rewards['çµçŸ³'] > 0) {
                  basicRewards.push({name: 'çµçŸ³', value: rewards['çµçŸ³']});
              }

              if (basicRewards.length > 0) {
                  html += '<div class="quest-rewards-grid">';
                  basicRewards.forEach(reward => {
                      html += `
                          <div class="quest-reward-item">
                              <span class="reward-name">${reward.name}</span>
                              <span>${reward.value}</span>
                          </div>
                      `;
                  });
                  html += '</div>';
              }

              // ç‰©å“å¥–åŠ±
              if (rewards['ç‰©å“å¥–åŠ±']) {
                  html += this.renderItemRewards(rewards['ç‰©å“å¥–åŠ±'], 'ç‰©å“å¥–åŠ±');
              }

              // å…¶ä»–å¥–åŠ±
              if (rewards['å…¶ä»–å¥–åŠ±']) {
                  html += this.renderItemRewards(rewards['å…¶ä»–å¥–åŠ±'], 'å…¶ä»–å¥–åŠ±');
              }

              html += '</div>';
              return html;
          },

          // ä»»åŠ¡ç³»ç»Ÿï¼šæ¸²æŸ“ç‰©å“å¥–åŠ±ï¼ˆç‰©å“å¥–åŠ±å’Œå…¶ä»–å¥–åŠ±ï¼‰
          renderItemRewards(itemRewards, title) {
              if (!itemRewards || Object.keys(itemRewards).length === 0) return '';

              let html = `<div class="quest-section-title" style="margin-top: 10px;">${title}</div>`;
              html += '<div class="quest-item-rewards">';

              Object.entries(itemRewards).forEach(([itemName, itemData]) => {
                  if (itemName === '$meta') return;

                  const tier = itemData.tier || itemData['å“é˜¶'] || '';
                  const quantity = itemData.quantity || 1;
                  const description = itemData.description || itemData['æè¿°'] || '';
                  const specialEffects = itemData.special_effects || itemData['è¯æ¡'] || {};
                  
                  // å“é˜¶æŸ“è‰²
                  const tierStyle = tier ? this.getItemTierStyle(tier) : '';

                  // ç”Ÿæˆå”¯ä¸€ID
                  const itemId = `quest-item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

                  html += `
                      <div class="quest-item-reward" data-item-id="${itemId}">
                          <div class="quest-item-reward-header">
                              <span style="${tierStyle}">${itemName} x${quantity}</span>
                              <span>â–¼</span>
                          </div>
                          <div class="quest-item-reward-details">
                              <div class="quest-item-detail-content">
                                  ${description ? `<div><strong>æè¿°:</strong> ${description}</div>` : ''}
                                  ${Object.keys(specialEffects).filter(k => k !== '$meta').length > 0 ? `
                                      <div><strong>è¯æ¡:</strong></div>
                                      <ul style="margin: 5px 0; padding-left: 20px;">
                                          ${Object.entries(specialEffects).filter(([k]) => k !== '$meta').map(([k, v]) => `<li>${k}: ${v}</li>`).join('')}
                                      </ul>
                                  ` : ''}
                              </div>
                          </div>
                      </div>
                  `;
              });

              html += '</div>';
              return html;
          },

          // ä»»åŠ¡ç³»ç»Ÿï¼šæ›´æ–°å¾½ç« 
          updateQuestBadges(questList) {
              const quests = Object.entries(questList).filter(([key]) => key !== '$meta');
              
              // è®¡ç®—å„çŠ¶æ€ä»»åŠ¡æ•°é‡
              const counts = {
                  unclaimed: 0,
                  unfinished: 0,
                  completed: 0
              };

              quests.forEach(([_, quest]) => {
                  const status = quest['ä»»åŠ¡çŠ¶æ€'] || 'æœªæ¥å–';
                  if (status === 'æœªæ¥å–') {
                      counts.unclaimed++;
                  } else if (['è¿›è¡Œä¸­', 'å¤±è´¥'].includes(status)) {
                      counts.unfinished++;
                  } else if (status === 'å®Œæˆ') {
                      counts.completed++;
                  }
              });

              // æ›´æ–°å„tabçš„å¾½ç« 
              const tabs = {
                  unclaimed: document.querySelector('.quest-status-tabs .panel-tab-btn[data-status="unclaimed"]'),
                  unfinished: document.querySelector('.quest-status-tabs .panel-tab-btn[data-status="unfinished"]'),
                  completed: document.querySelector('.quest-status-tabs .panel-tab-btn[data-status="completed"]')
              };

              Object.entries(tabs).forEach(([status, tabElement]) => {
                  if (tabElement) {
                      let badge = tabElement.querySelector('.inventory-tab-badge');
                      if (!badge) {
                          badge = document.createElement('span');
                          badge.className = 'inventory-tab-badge';
                          // å°†å¾½ç« æ·»åŠ åˆ°æŒ‰é’®çš„ç¬¬ä¸€ä¸ªspanå­å…ƒç´ ä¹‹å
                          const textSpan = tabElement.querySelector('span');
                          if(textSpan) {
                            textSpan.insertAdjacentElement('afterend', badge);
                          } else {
                            tabElement.appendChild(badge);
                          }
                      }
                      
                      const count = counts[status];
                      if (count > 0) {
                          badge.textContent = count;
                          badge.style.display = 'inline-block';
                      } else {
                          badge.style.display = 'none';
                      }
                  }
              });
          },

          // ä»»åŠ¡ç³»ç»Ÿï¼šç»‘å®šå¡ç‰‡äº‹ä»¶
          bindQuestCardEvents() {
              // ç»‘å®šå¡ç‰‡å¤´éƒ¨ç‚¹å‡»äº‹ä»¶ï¼ˆå±•å¼€/æŠ˜å ï¼‰
              const headers = document.querySelectorAll('.quest-card-header');
              headers.forEach(header => {
                  header.addEventListener('click', (e) => {
                      // é˜²æ­¢ç‚¹å‡»å­å…ƒç´ æ—¶è§¦å‘
                      if (e.target.closest('.quest-card-header') !== header) return;

                      const card = header.closest('.quest-card');
                      const content = card.querySelector('.quest-card-content');
                      const icon = header.querySelector('.quest-expand-icon');

                      // åˆ‡æ¢å±•å¼€çŠ¶æ€
                      content.classList.toggle('expanded');
                      header.classList.toggle('expanded');
                      icon.classList.toggle('expanded');
                  });
              });

              // ç»‘å®šç‰©å“å¥–åŠ±å±•å¼€äº‹ä»¶
              const itemRewards = document.querySelectorAll('.quest-item-reward');
              itemRewards.forEach(item => {
                  item.addEventListener('click', (e) => {
                      // é˜²æ­¢å†’æ³¡åˆ°å¡ç‰‡å¤´éƒ¨
                      e.stopPropagation();
                      
                      const details = item.querySelector('.quest-item-reward-details');
                      details.classList.toggle('expanded');
                  });
              });
          },

// ===ä»»åŠ¡ç³»ç»Ÿæ¨¡å—ç»“æŸ===



// ===èƒŒåŒ…æ¨¡å—å¼€å§‹===



          async showInventory(useLocalState = false) {
            this.openModal('inventory-modal');

            // åŠ¨æ€è®¾ç½®å…¨å±å°ºå¯¸
            const rootContainer = document.querySelector('.guixu-root-container');
            const modalContent = document.querySelector('#inventory-modal .modal-content');
            if (rootContainer && modalContent) {
              const rect = rootContainer.getBoundingClientRect();
              modalContent.style.setProperty('width', `${rect.width}px`, 'important');
              modalContent.style.setProperty('height', `${rect.height}px`, 'important');
              modalContent.style.setProperty('top', `${rect.top}px`, 'important');
              modalContent.style.setProperty('left', `${rect.left}px`, 'important');
              modalContent.style.setProperty('max-width', 'none', 'important');
              modalContent.style.setProperty('max-height', 'none', 'important');
            }

            const tabsContainer = document.querySelector('#inventory-modal .inventory-tabs');
            const contentArea = document.querySelector('#inventory-modal .inventory-content-area');
            if (!tabsContainer || !contentArea) return;

            contentArea.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨æ¸…ç‚¹è¡Œå›Š...</p>';

            try {
              let stat_data;
              // ä¿®å¤ï¼šå¦‚æœæ˜¯åœ¨è£…å¤‡/å¸ä¸‹æ“ä½œä¸­ï¼Œç›´æ¥ä½¿ç”¨å†…å­˜ä¸­çš„æœ€æ–°çŠ¶æ€è¿›è¡Œæ¸²æŸ“ï¼Œé¿å…å› åç«¯åŒæ­¥å»¶è¿Ÿå¯¼è‡´çš„UIä¸åˆ·æ–°
              if (useLocalState && this.currentMvuState?.stat_data) {
                stat_data = this.currentMvuState.stat_data;
              } else {
                const messages = await getChatMessages(getCurrentMessageId());
                if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
                  contentArea.innerHTML =
                    '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ— æ³•è·å–èƒŒåŒ…æ•°æ®ã€‚</p>';
                  console.warn('æ— æ³•ä»å½“å‰æ¶ˆæ¯ä¸­åŠ è½½ stat_data ç”¨äºèƒŒåŒ…ã€‚');
                  return;
                }
                stat_data = messages[0].data.stat_data;
              }

              this.renderInventoryWithTabs(stat_data || {});
            } catch (error) {
              console.error('åŠ è½½èƒŒåŒ…æ—¶å‡ºé”™:', error);
              contentArea.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">åŠ è½½èƒŒåŒ…æ—¶å‡ºé”™: ${error.message}</p>`;
            }
          },



// ===èƒŒåŒ…æ¨¡å—ç»“æŸ===



// ===ä¸–ç•Œå¤§äº‹æ¨¡å—å¼€å§‹===



          async showWorldEvents() {
            if (this.isFromSettingsModal) {
                this.closeModal('settings-modal');
            }
            this.openModal('world-events-modal');
            
            // åˆå§‹åŒ–çŠ¶æ€
            if (!this.worldEventsState) {
              this.worldEventsState = {
                isEditMode: false,
                isVerticalLayout: false,
                isTabsCollapsed: false,
                searchQuery: '',
                selectedEventId: null,
                filterCategory: 'all', // 'all', 'ongoing', 'ended'
                collapsedCategories: {} // è®°å½•æŠ˜å çŠ¶æ€
              };
            }

            const container = document.querySelector('#world-events-container');
            if (!container) return;

            container.innerHTML = '<p style="text-align:center; color:#ba8bff; padding:40px;">æ­£åœ¨åŠ è½½ä¸–ç•Œå¤§äº‹...</p>';

            try {
              const messages = await getChatMessages(getCurrentMessageId());
              if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
                container.innerHTML = '<div class="world-events-empty"><div class="world-events-empty-icon">ğŸŒ</div><div class="world-events-empty-title">æš‚æ— ä¸–ç•Œå¤§äº‹</div><div class="world-events-empty-description">å½“å‰æ²¡æœ‰å¯æ˜¾ç¤ºçš„ä¸–ç•Œå¤§äº‹è®°å½•</div></div>';
                console.warn('æ— æ³•ä»å½“å‰æ¶ˆæ¯ä¸­åŠ è½½ stat_data ç”¨äºä¸–ç•Œå¤§äº‹ã€‚');
                return;
              }
              
              const stat_data = messages[0].data.stat_data;
              this.currentWorldEventsData = stat_data;
              
              // å…ˆæ¸²æŸ“UI
              this.renderWorldEventsUI(stat_data);

              // ç»‘å®šæœç´¢äº‹ä»¶
              const searchInput = document.getElementById('world-events-search');
              if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                  this.worldEventsState.searchQuery = e.target.value;
                  this.renderWorldEventsUI(stat_data);
                });
              }

              // åŠ¨æ€è®¾ç½®å…¨å±å°ºå¯¸
              const rootContainer = document.querySelector('.guixu-root-container');
              const modalContent = document.querySelector('#world-events-modal .modal-content');
              if (rootContainer && modalContent) {
                  const rect = rootContainer.getBoundingClientRect();
                  modalContent.style.setProperty('width', `${rect.width}px`, 'important');
                  modalContent.style.setProperty('height', `${rect.height}px`, 'important');
                  modalContent.style.setProperty('top', `${rect.top}px`, 'important');
                  modalContent.style.setProperty('left', `${rect.left}px`, 'important');
                  modalContent.style.setProperty('max-width', 'none', 'important');
                  modalContent.style.setProperty('max-height', 'none', 'important');
              }

              // è‡ªåŠ¨è·³è½¬åˆ°æœ€æ–°äº‹ä»¶
              requestAnimationFrame(() => {
                setTimeout(() => {
                  const firstTab = document.querySelector('.world-events-tab-item');
                  if (firstTab) {
                    const latestEventId = firstTab.getAttribute('data-event-id');
                    this.selectWorldEvent(latestEventId);
                  }
                }, 300);
              });

            } catch (error) {
              console.error('åŠ è½½ä¸–ç•Œå¤§äº‹æ—¶å‡ºé”™:', error);
              container.innerHTML = `<div class="world-events-empty"><div class="world-events-empty-icon">âŒ</div><div class="world-events-empty-title">åŠ è½½å¤±è´¥</div><div class="world-events-empty-description">åŠ è½½ä¸–ç•Œå¤§äº‹æ—¶å‡ºé”™: ${error.message}</div></div>`;
            }
          },

          // æ¸²æŸ“ä¸–ç•Œå¤§äº‹UI
          renderWorldEventsUI(stat_data) {
            const worldEvents = stat_data.ä¸–ç•Œå¤§äº‹ || stat_data.world_events || {};
            const eventsArray = Object.entries(worldEvents)
              .filter(([key, event]) => key !== '$meta' && typeof event === 'object' && event !== null)
              .map(([key, event]) => ({ id: key, ...event }));

            // åº”ç”¨æœç´¢è¿‡æ»¤
            const filteredEvents = eventsArray.filter(event => {
              if (!this.worldEventsState.searchQuery) return true;
              const query = this.worldEventsState.searchQuery.toLowerCase();
              const title = (event.æ ‡é¢˜ || event.title || '').toLowerCase();
              const category = (event.åˆ†ç±» || event.category || '').toLowerCase();
              const participants = (event.å‚ä¸è€… || event.participants || []).join(' ').toLowerCase();
              return title.includes(query) || category.includes(query) || participants.includes(query);
            });

            if (filteredEvents.length === 0) {
              document.getElementById('world-events-container').innerHTML =
                '<div class="world-events-empty"><div class="world-events-empty-icon">ğŸ”</div><div class="world-events-empty-title">æœªæ‰¾åˆ°åŒ¹é…çš„äº‹ä»¶</div><div class="world-events-empty-description">è¯·å°è¯•å…¶ä»–æœç´¢å…³é”®è¯</div></div>';
              return;
            }

            // æŒ‰çŠ¶æ€åˆ†ç±»äº‹ä»¶
            const ongoingEvents = filteredEvents.filter(event => {
              const status = (event.çŠ¶æ€ || event.status || '').toLowerCase();
              return status.includes('è¿›è¡Œ') || status.includes('ongoing');
            });
            const endedEvents = filteredEvents.filter(event => {
              const status = (event.çŠ¶æ€ || event.status || '').toLowerCase();
              return status.includes('ç»“æŸ') || status.includes('ended') || status.includes('å®Œæˆ');
            });

            // è®¡ç®—æ€»token
            const totalTokens = filteredEvents.reduce((sum, event) => sum + this.calculateEventTokenCount(event), 0);

            // æ¸²æŸ“Tabåˆ—è¡¨å¤´éƒ¨ç»Ÿè®¡
            const tabsHeaderHtml = `
              <div class="world-events-tabs-header">
                <div class="tabs-stat-item">
                  <span class="tabs-stat-label">äº‹ä»¶æ€»æ•°</span>
                  <span class="tabs-stat-value">${filteredEvents.length}</span>
                </div>
                <div class="tabs-stat-item">
                  <span class="tabs-stat-label">Tokenæ€»æ•°</span>
                  <span class="tabs-stat-value">${totalTokens}</span>
                </div>
              </div>
            `;

            // æ¸²æŸ“å•ä¸ªäº‹ä»¶tabé¡¹
            const renderEventTab = (event) => {
              const title = event.æ ‡é¢˜ || event.title || 'æœªçŸ¥äº‹ä»¶';
              let timeString = '';
              if (event.æ—¶é—´ || event.time) {
                const timeData = event.æ—¶é—´ || event.time;
                const shi = timeData.ç¬¬å‡ ä¸– ? `ç¬¬${timeData.ç¬¬å‡ ä¸–}ä¸– ` : '';
                const date = timeData.æ—¥æœŸ || '';
                timeString = `${shi}${date}`;
              }
              const tokenCount = this.calculateEventTokenCount(event);
              const isActive = this.worldEventsState.selectedEventId === event.id;

              return `
                <div class="world-events-tab-item ${isActive ? 'active' : ''}" data-event-id="${event.id}" onclick="GuixuManager.selectWorldEvent('${event.id}')">
                  <div class="world-events-tab-title">${this.escapeHtml(title)}</div>
                  <div class="world-events-tab-time">${this.escapeHtml(timeString)}</div>
                  <div class="world-events-tab-meta">
                    <span class="world-events-tab-token">${tokenCount}</span>
                    <button class="world-events-tab-delete" onclick="event.stopPropagation(); GuixuManager.deleteWorldEvent('${event.id}')">åˆ é™¤</button>
                  </div>
                </div>
              `;
            };

            // æ¸²æŸ“ç­›é€‰åˆ†ç±»
            const renderFilterCategory = (categoryKey, categoryTitle, events) => {
              const isCollapsed = this.worldEventsState.collapsedCategories[categoryKey] || false;
              const collapsedClass = isCollapsed ? 'collapsed' : '';
              // å€’åºæ˜¾ç¤ºäº‹ä»¶
              const reversedEvents = [...events].reverse();
              const eventsHtml = reversedEvents.map(event => renderEventTab(event)).join('');
              
              return `
                <div class="world-events-filter-category ${collapsedClass}" data-category="${categoryKey}">
                  <div class="world-events-filter-header" onclick="GuixuManager.toggleFilterCategory('${categoryKey}')">
                    <div class="world-events-filter-title">
                      <span>${categoryTitle}</span>
                      <span class="world-events-filter-count">${events.length}</span>
                    </div>
                    <span class="world-events-filter-arrow">â–¼</span>
                  </div>
                  <div class="world-events-filter-content">
                    ${eventsHtml}
                  </div>
                </div>
              `;
            };

            // è®¾ç½®é»˜è®¤æŠ˜å çŠ¶æ€ï¼ˆé¦–æ¬¡åŠ è½½æ—¶ï¼‰- ç¡®ä¿å…¨éƒ¨åˆ†ç±»å§‹ç»ˆå±•å¼€
            if (!this.worldEventsState.collapsedCategories.hasOwnProperty('all')) {
              this.worldEventsState.collapsedCategories.all = false; // å…¨éƒ¨é»˜è®¤å±•å¼€
              this.worldEventsState.collapsedCategories.ongoing = true; // è¿›è¡Œä¸­é»˜è®¤æŠ˜å 
              this.worldEventsState.collapsedCategories.ended = true; // å·²ç»“æŸé»˜è®¤æŠ˜å 
            } else {
              // ç¡®ä¿å…¨éƒ¨åˆ†ç±»å§‹ç»ˆå±•å¼€
              this.worldEventsState.collapsedCategories.all = false;
            }

            // æ„å»ºåˆ†ç±»HTML
            const allCategoryHtml = renderFilterCategory('all', 'å…¨éƒ¨', filteredEvents);
            const ongoingCategoryHtml = renderFilterCategory('ongoing', 'è¿›è¡Œä¸­', ongoingEvents);
            const endedCategoryHtml = renderFilterCategory('ended', 'å·²ç»“æŸ', endedEvents);

            // æ¸²æŸ“æ—¶é—´è½´
            const timelineHtml = filteredEvents.map(event => this.renderWorldEventCard(event)).join('');

            const editModeClass = this.worldEventsState.isEditMode ? 'edit-mode' : '';
            const layoutClass = this.worldEventsState.isVerticalLayout ? 'vertical-layout' : '';

            document.getElementById('world-events-container').innerHTML = `
              <div class="world-events-tabs ${editModeClass}">
                ${tabsHeaderHtml}
                ${allCategoryHtml}
                ${ongoingCategoryHtml}
                ${endedCategoryHtml}
              </div>
              <div class="world-events-content">
                <div class="world-events-timeline ${layoutClass}">
                  <div class="timeline-container">
                    ${timelineHtml}
                  </div>
                </div>
                <button id="world-events-nav-prev" class="world-events-nav-btn world-events-nav-prev" title="ä¸Šä¸€ä¸ªäº‹ä»¶">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="15 18 9 12 15 6"></polyline>
                  </svg>
                </button>
                <button id="world-events-nav-next" class="world-events-nav-btn world-events-nav-next" title="ä¸‹ä¸€ä¸ªäº‹ä»¶">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="9 18 15 12 9 6"></polyline>
                  </svg>
                </button>
              </div>
            `;
          },

          // åˆ‡æ¢ç­›é€‰åˆ†ç±»çš„æŠ˜å çŠ¶æ€
          toggleFilterCategory(categoryKey) {
            this.worldEventsState.collapsedCategories[categoryKey] = !this.worldEventsState.collapsedCategories[categoryKey];
            const categoryElement = document.querySelector(`.world-events-filter-category[data-category="${categoryKey}"]`);
            if (categoryElement) {
              if (this.worldEventsState.collapsedCategories[categoryKey]) {
                categoryElement.classList.add('collapsed');
              } else {
                categoryElement.classList.remove('collapsed');
              }
            }
          },

          // äº‹ä»¶å¡ç‰‡å±•å¼€/æŠ˜å åŠŸèƒ½ï¼Œç¡®ä¿åŠ¨ç”»æµç•…
          toggleEventExpand(cardElement) {
            return new Promise(resolve => {
              const isExpanded = cardElement.classList.contains('fully-expanded');
              cardElement.setAttribute('data-expand-level', isExpanded ? '0' : '1');
              requestAnimationFrame(() => {
                if (isExpanded) {
                  cardElement.classList.remove('fully-expanded');
                } else {
                  cardElement.classList.add('fully-expanded');
                }
                const onTransitionEnd = () => {
                  cardElement.removeEventListener('transitionend', onTransitionEnd);
                  resolve();
                };
                cardElement.addEventListener('transitionend', onTransitionEnd);
              });
            });
          },
          renderWorldEvents(stat_data) {
            const worldEvents = stat_data.ä¸–ç•Œå¤§äº‹ || stat_data.world_events || {};
            
            if (!worldEvents || Object.keys(worldEvents).length === 0) {
              return `
                <div class="world-events-empty">
                  <div class="world-events-empty-icon">ğŸŒ</div>
                  <div class="world-events-empty-title">æš‚æ— ä¸–ç•Œå¤§äº‹</div>
                  <div class="world-events-empty-description">å½“å‰ä¸–ç•Œè¿˜æ²¡æœ‰å‘ç”Ÿé‡å¤§äº‹ä»¶</div>
                </div>
              `;
            }

            // å°†ä¸–ç•Œå¤§äº‹è½¬æ¢ä¸ºæ•°ç»„ï¼ŒæŒ‰å˜é‡ç»“æ„åŸå§‹é¡ºåºä¿ç•™ï¼ˆä¸æ’åºï¼‰
            const eventsArray = Object.entries(worldEvents)
              .filter(([key, event]) => key !== '$meta' && typeof event === 'object' && event !== null)
              .map(([key, event]) => ({ id: key, ...event }));

            if (this.worldEventsViewMode === 'list') {
              let html = '<div class="world-events-list">';
              eventsArray.forEach(event => {
                const title = event.title || event.æ ‡é¢˜ || 'æœªçŸ¥äº‹ä»¶';
                let timeString = '';
                 if (event.time || event.æ—¶é—´) {
                    const timeData = event.time || event.æ—¶é—´;
                    const shi = timeData.ç¬¬å‡ ä¸– ? `ç¬¬${timeData.ç¬¬å‡ ä¸–}ä¸– ` : '';
                    const date = timeData.æ—¥æœŸ || '';
                    timeString = `${shi}${date}`;
                }
                html += `
                  <div class="world-events-list-item">
                    <span class="world-events-list-time">${this.escapeHtml(timeString)}</span>
                    <span class="world-events-list-title">${this.escapeHtml(title)}</span>
                  </div>
                `;
              });
              html += '</div>';
              return html;
            } else {
              // é»˜è®¤æ—¶é—´è½´æ¨¡å¼
              let html = '<div class="world-events-timeline"><div class="timeline-container">';
              eventsArray.forEach(event => {
                html += this.renderWorldEventItem(event);
              });
              html += '</div></div>';
              return html;
            }
          },

          // æ¸²æŸ“å•ä¸ªä¸–ç•Œå¤§äº‹å¡ç‰‡ - æ–°å¸ƒå±€
          renderWorldEventCard(event) {
            const title = event.æ ‡é¢˜ || event.title || 'æœªçŸ¥äº‹ä»¶';
            const description = event.æè¿° || event.description || '';
            const category = event.åˆ†ç±» || event.category || '';
            const scope = event.å½±å“èŒƒå›´ || event.scope || '';
            const location = event.åœ°ç‚¹ || event.location || '';
            const status = event.çŠ¶æ€ || event.status || '';
            const participants = event.å‚ä¸è€… || event.participants || [];

            // å¤„ç†æ—¶é—´å¯¹è±¡
            let timeString = '';
            if (event.æ—¶é—´ || event.time) {
              const timeData = event.æ—¶é—´ || event.time;
              const shi = timeData.ç¬¬å‡ ä¸– ? `ç¬¬${timeData.ç¬¬å‡ ä¸–}ä¸– ` : '';
              const date = timeData.æ—¥æœŸ || '';
              timeString = `${shi}${date}`;
            }

            // æ—¶é—´+åœ°ç‚¹+å½±å“èŒƒå›´ï¼ˆåˆå¹¶æ˜¾ç¤ºï¼‰
            const metaInfo = [timeString, location, scope].filter(Boolean).join(' Â· ');

            // å¤„ç†ç»“æœ
            let resultHtml = '';
            if(event.ç»“æœ || event.result) {
                const resultData = event.ç»“æœ || event.result;
                const overview = resultData.æ¦‚è¿° || resultData.overview || '';
                if(overview) {
                    resultHtml = `
                      <div class="event-section">
                        <div class="event-section-title">æœ€ç»ˆç»“æœ</div>
                        <div class="event-section-content">${this.escapeHtml(overview)}</div>
                      </div>
                    `;
                }
            }

            // å¤„ç†å½±å“
            let impactHtml = '';
            if (event.å½±å“ || event.impact) {
              const impactData = event.å½±å“ || event.impact;
              const shortTerm = impactData.çŸ­æœŸå½±å“ || impactData.short_term_impact || '';
              const longTerm = impactData.é•¿æœŸå½±å“ || impactData.long_term_impact || '';
              if (shortTerm || longTerm) {
                impactHtml = `
                  <div class="event-section">
                    <div class="event-section-title">å½±å“ä¸åæœ</div>
                    <div class="event-section-content">
                      ${shortTerm ? `<div class="event-impact-item"><span class="event-impact-label">çŸ­æœŸï¼š</span>${this.escapeHtml(shortTerm)}</div>` : ''}
                      ${longTerm ? `<div class="event-impact-item"><span class="event-impact-label">é•¿æœŸï¼š</span>${this.escapeHtml(longTerm)}</div>` : ''}
                    </div>
                  </div>
                `;
              }
            }

            // åˆ¤æ–­æ˜¯å¦æœ‰å¯æŠ˜å å†…å®¹
            const hasCollapsibleContent = resultHtml || impactHtml;

            return `
              <div class="world-event-card ${hasCollapsibleContent ? 'has-collapsible' : ''}" data-event-id="${event.id}" id="event-${event.id}" data-expanded="false" onclick="GuixuManager.toggleEventCardExpand(this, event)">
                <div class="world-event-header">
                  <div class="event-title-row">
                    <div class="event-title">${this.escapeHtml(title)}</div>
                    ${status ? `<div class="event-status-badge status-${status}">${this.escapeHtml(status)}</div>` : ''}
                  </div>
                  <div class="event-tags-row">
                    ${category ? `<span class="event-category">${this.escapeHtml(category)}</span>` : ''}
                    ${participants.map(p => `<span class="event-participant-tag">${this.escapeHtml(p)}</span>`).join('')}
                  </div>
                  ${metaInfo ? `<div class="event-time-location">${this.escapeHtml(metaInfo)}</div>` : ''}
                </div>
                <div class="world-event-content">
                  ${description ? `<div class="event-description">${this.escapeHtml(description)}</div>` : ''}
                  ${hasCollapsibleContent ? `
                    <div class="event-collapsible-content">
                      ${resultHtml}
                      ${impactHtml}
                    </div>
                  ` : ''}
                </div>
              </div>
            `;
          },

          // é€‰æ‹©ä¸–ç•Œå¤§äº‹ï¼ˆtabç‚¹å‡»ï¼‰
          selectWorldEvent(eventId) {
            console.log('[selectWorldEvent] è¢«è°ƒç”¨ï¼ŒeventId:', eventId);
            this.worldEventsState.selectedEventId = eventId;
            
            // æ›´æ–°tabæ¿€æ´»çŠ¶æ€
            const allTabs = document.querySelectorAll('.world-events-tab-item');
            console.log('[selectWorldEvent] æ‰¾åˆ°tabæ•°é‡:', allTabs.length);
            
            let foundTab = false;
            allTabs.forEach(tab => {
              const tabEventId = tab.getAttribute('data-event-id');
              if (tabEventId === eventId) {
                tab.classList.add('active');
                foundTab = true;
                console.log('[selectWorldEvent] æ‰¾åˆ°å¹¶æ¿€æ´»tab');
                // ä¸æ»šåŠ¨tabåˆ—è¡¨ï¼Œå› ä¸ºäº‹ä»¶å·²ç»æ˜¯å€’åºæ’åˆ—ï¼ˆæœ€æ–°çš„åœ¨æœ€ä¸Šé¢ï¼‰
              } else {
                tab.classList.remove('active');
              }
            });
            
            if (!foundTab) {
              console.warn('[selectWorldEvent] æœªæ‰¾åˆ°åŒ¹é…çš„tabï¼ŒeventId:', eventId);
            }
            
            // æ»šåŠ¨åˆ°å¯¹åº”äº‹ä»¶å¡ç‰‡
            this.scrollToWorldEvent(eventId);
            
            // æ›´æ–°å¯¼èˆªæŒ‰é’®çŠ¶æ€
            this.updateWorldEventNavButtons();
          },

          // å¯¼èˆªåˆ°ä¸Šä¸€ä¸ªæˆ–ä¸‹ä¸€ä¸ªäº‹ä»¶
          navigateWorldEvent(direction) {
            const allTabs = Array.from(document.querySelectorAll('.world-events-tab-item'));
            if (allTabs.length === 0) return;
            
            const currentIndex = allTabs.findIndex(tab =>
              tab.getAttribute('data-event-id') === this.worldEventsState.selectedEventId
            );
            
            let targetIndex;
            if (direction === 'prev') {
              // ä¸Šä¸€ä¸ªï¼šç´¢å¼•å‡1ï¼ˆå› ä¸ºæ˜¯å€’åºï¼Œä¸Šä¸€ä¸ªæ˜¯æ›´æ—§çš„äº‹ä»¶ï¼‰
              targetIndex = currentIndex + 1;
            } else {
              // ä¸‹ä¸€ä¸ªï¼šç´¢å¼•åŠ 1ï¼ˆå› ä¸ºæ˜¯å€’åºï¼Œä¸‹ä¸€ä¸ªæ˜¯æ›´æ–°çš„äº‹ä»¶ï¼‰
              targetIndex = currentIndex - 1;
            }
            
            // è¾¹ç•Œæ£€æŸ¥
            if (targetIndex >= 0 && targetIndex < allTabs.length) {
              const targetEventId = allTabs[targetIndex].getAttribute('data-event-id');
              this.selectWorldEvent(targetEventId);
            }
          },

          // æ›´æ–°å¯¼èˆªæŒ‰é’®çš„å¯ç”¨/ç¦ç”¨çŠ¶æ€
          updateWorldEventNavButtons() {
            const allTabs = Array.from(document.querySelectorAll('.world-events-tab-item'));
            const prevBtn = document.getElementById('world-events-nav-prev');
            const nextBtn = document.getElementById('world-events-nav-next');
            
            if (!prevBtn || !nextBtn || allTabs.length === 0) return;
            
            const currentIndex = allTabs.findIndex(tab =>
              tab.getAttribute('data-event-id') === this.worldEventsState.selectedEventId
            );
            
            // ä¸Šä¸€ä¸ªæŒ‰é’®ï¼šå½“å‰æ˜¯æœ€åä¸€ä¸ªï¼ˆæœ€æ—§çš„ï¼‰æ—¶ç¦ç”¨
            if (currentIndex >= allTabs.length - 1) {
              prevBtn.classList.add('disabled');
              prevBtn.disabled = true;
            } else {
              prevBtn.classList.remove('disabled');
              prevBtn.disabled = false;
            }
            
            // ä¸‹ä¸€ä¸ªæŒ‰é’®ï¼šå½“å‰æ˜¯ç¬¬ä¸€ä¸ªï¼ˆæœ€æ–°çš„ï¼‰æ—¶ç¦ç”¨
            if (currentIndex <= 0) {
              nextBtn.classList.add('disabled');
              nextBtn.disabled = true;
            } else {
              nextBtn.classList.remove('disabled');
              nextBtn.disabled = false;
            }
          },

          // æ»šåŠ¨åˆ°æŒ‡å®šäº‹ä»¶
          scrollToWorldEvent(eventId) {
            console.log('[scrollToWorldEvent] è¢«è°ƒç”¨ï¼ŒeventId:', eventId);
            const eventCard = document.getElementById(`event-${eventId}`);
            console.log('[scrollToWorldEvent] æ‰¾åˆ°çš„å¡ç‰‡å…ƒç´ :', eventCard);
            
            // è°ƒè¯•ï¼šæ‰“å°æ‰€æœ‰å¡ç‰‡çš„ID
            const allCards = document.querySelectorAll('.world-event-card');
            console.log('[scrollToWorldEvent] æ‰€æœ‰å¡ç‰‡æ•°é‡:', allCards.length);
            if (allCards.length > 0) {
              console.log('[scrollToWorldEvent] å‰3ä¸ªå¡ç‰‡ID:',
                Array.from(allCards).slice(0, 3).map(c => c.id));
              console.log('[scrollToWorldEvent] æœ€åä¸€ä¸ªå¡ç‰‡ID:',
                allCards[allCards.length - 1].id);
            }
            
            if (eventCard) {
              console.log('[scrollToWorldEvent] å¼€å§‹æ»šåŠ¨');
              // è·å–æ—¶é—´è½´å®¹å™¨
              const timeline = document.querySelector('.world-events-timeline');
              if (timeline) {
                // è®¡ç®—å¡ç‰‡ç›¸å¯¹äºæ—¶é—´è½´å®¹å™¨çš„ä½ç½®
                const cardRect = eventCard.getBoundingClientRect();
                const timelineRect = timeline.getBoundingClientRect();
                const scrollLeft = timeline.scrollLeft + (cardRect.left - timelineRect.left) - (timelineRect.width / 2) + (cardRect.width / 2);
                
                // å¹³æ»‘æ»šåŠ¨åˆ°ç›®æ ‡ä½ç½®
                timeline.scrollTo({
                  left: scrollLeft,
                  behavior: 'smooth'
                });
              }
              
              // æ·»åŠ é«˜äº®æ•ˆæœ
              eventCard.style.boxShadow = '0 0 20px rgba(201, 170, 113, 0.6)';
              setTimeout(() => {
                eventCard.style.boxShadow = '';
              }, 2000);
            } else {
              console.warn('[scrollToWorldEvent] æœªæ‰¾åˆ°äº‹ä»¶å¡ç‰‡å…ƒç´ ï¼ŒID:', `event-${eventId}`);
            }
          },

          // åˆ‡æ¢ç¼–è¾‘æ¨¡å¼
          toggleWorldEventsEditMode() {
            this.worldEventsState.isEditMode = !this.worldEventsState.isEditMode;
            const editBtn = document.getElementById('world-events-edit-btn');
            const tabsContainer = document.querySelector('.world-events-tabs');
            
            if (this.worldEventsState.isEditMode) {
              editBtn.classList.add('active');
              editBtn.textContent = 'ç¼–è¾‘ing';
              tabsContainer.classList.add('edit-mode');
            } else {
              editBtn.classList.remove('active');
              editBtn.textContent = 'ç¼–è¾‘';
              tabsContainer.classList.remove('edit-mode');
            }
          },

          // åˆ‡æ¢å¸ƒå±€æ–¹å‘
          toggleWorldEventsLayout() {
            this.worldEventsState.isVerticalLayout = !this.worldEventsState.isVerticalLayout;
            const timeline = document.querySelector('.world-events-timeline');
            
            if (this.worldEventsState.isVerticalLayout) {
              timeline.classList.add('vertical-layout');
            } else {
              timeline.classList.remove('vertical-layout');
            }
          },

          // åˆ‡æ¢Tabä¾§è¾¹æ å±•å¼€/æŠ˜å 
          toggleWorldEventsTabs() {
            this.worldEventsState.isTabsCollapsed = !this.worldEventsState.isTabsCollapsed;
            const tabsContainer = document.querySelector('.world-events-tabs');
            const toggleIcon = document.getElementById('world-events-tabs-toggle-icon');
            
            if (this.worldEventsState.isTabsCollapsed) {
              tabsContainer.classList.add('collapsed');
              if (toggleIcon) toggleIcon.textContent = 'â–¶';
            } else {
              tabsContainer.classList.remove('collapsed');
              if (toggleIcon) toggleIcon.textContent = 'â—€';
            }
          },

          // åˆ‡æ¢äº‹ä»¶å¡ç‰‡å±•å¼€/æŠ˜å 
          toggleEventCardExpand(cardElement, evt) {
            if (evt) evt.stopPropagation();
            const isExpanded = cardElement.dataset.expanded === 'true';
            cardElement.dataset.expanded = isExpanded ? 'false' : 'true';
          },



// ===ä¸–ç•Œå¤§äº‹æ¨¡å—ç»“æŸ===



// ===å˜é‡ç¼–è¾‘å™¨æ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰å¼€å§‹===



          async showVariableEditor() {
            if (this.isFromSettingsModal) {
                this.closeModal('settings-modal');
            }
            this.openModal('variable-editor-modal');
            this.initVariableEditor();
          },

          _handleVariableEditorTabClick(event) {
              const tab = event.currentTarget;
              const tabs = document.querySelectorAll('#variable-editor-modal .tab-btn');
              tabs.forEach(t => t.classList.remove('active'));
              tab.classList.add('active');
              this.activeEditorCategory = tab.dataset.category;
              this.renderVariables(this.activeEditorCategory, this.editorSearchTerm);
          },

          _handleVariableEditorSearch() {
              const searchInput = document.getElementById('variable-search-input');
              this.editorSearchTerm = searchInput.value;
              this.renderVariables(this.activeEditorCategory, this.editorSearchTerm);
          },

          initVariableEditor() {
              if (this.isVariableEditorInitialized) {
                  // å¦‚æœå·²ç»åˆå§‹åŒ–è¿‡ï¼ŒåªåŒæ­¥UIçŠ¶æ€å¹¶é‡æ–°æ¸²æŸ“
                  this.editorSearchTerm = ''; // æ¯æ¬¡æ‰“å¼€é‡ç½®æœç´¢è¯
                  document.getElementById('variable-search-input').value = '';
                  
                  const tabs = document.querySelectorAll('#variable-editor-modal .tab-btn');
                  tabs.forEach(t => t.classList.remove('active'));
                  // ä½¿ç”¨æŒä¹…åŒ–çš„ activeEditorCategory æ¥è®¾ç½®æ­£ç¡®çš„æ¿€æ´»Tab
                  const activeTab = document.querySelector(`#variable-editor-modal .tab-btn[data-category="${this.activeEditorCategory || 'system'}"]`);
                  if (activeTab) activeTab.classList.add('active');
                  
                  this.renderVariables(this.activeEditorCategory || 'system', this.editorSearchTerm);
                  return;
              }

              // é¦–æ¬¡åˆå§‹åŒ–æ—¶è®¾ç½®é»˜è®¤å€¼
              this.activeEditorCategory = 'system';
              this.editorSearchTerm = '';

              const tabs = document.querySelectorAll('#variable-editor-modal .tab-btn');
              const searchInput = document.getElementById('variable-search-input');
              const saveButton = document.getElementById('save-variable-changes-btn');
              const addNewVariableBtn = document.getElementById('add-new-variable-btn');

              tabs.forEach(tab => {
                  tab.addEventListener('click', this._handleVariableEditorTabClick.bind(this));
              });

              searchInput.addEventListener('input', this._handleVariableEditorSearch.bind(this));
              saveButton.addEventListener('click', this.saveVariableChanges.bind(this));
              addNewVariableBtn.addEventListener('click', this.addNewVariable.bind(this));
              
              // åŒæ­¥åˆå§‹UIçŠ¶æ€
              const defaultTab = document.querySelector('#variable-editor-modal .tab-btn[data-category="system"]');
              if (defaultTab) defaultTab.classList.add('active');

              this.renderVariables(this.activeEditorCategory, this.editorSearchTerm);
              this.isVariableEditorInitialized = true;
          },

          // æ¸²æŸ“å˜é‡ (å·²é‡æ„: ä½¿ç”¨ Mvu API)
          renderVariables(category, searchTerm) {
              const displayArea = document.getElementById('variable-display-area');
              if (!displayArea) return;

              displayArea.innerHTML = '<div class="placeholder">åŠ è½½ä¸­...</div>';

              // ä½¿ç”¨ Mvu API è·å–æ•°æ®ï¼Œå¢å¼ºå…¼å®¹æ€§å’Œæœªæ¥æ‰©å±•æ€§
              let mvu_data;
              try {
                  mvu_data = Mvu.getMvuData({ type: 'message', message_id: 'latest' });
              } catch (error) {
                  console.warn('[å˜é‡ç¼–è¾‘å™¨] Mvu API ä¸å¯ç”¨ï¼Œå›é€€åˆ°æ—§æ–¹å¼:', error);
                  mvu_data = this.currentMvuState;
              }

              const stat_data = mvu_data?.stat_data;
              if (!stat_data) {
                  displayArea.innerHTML = '<div class="placeholder">å˜é‡æ•°æ®ä¸å¯ç”¨ã€‚</div>';
                  return;
              }

              let html = '';
              const systemVars = ['å½“å‰ç¬¬xä¸–', 'å½“å‰æ—¶é—´çºªå¹´', 'å½’å¢Ÿç©ºé—´', 'æœ¬ä¸–å½’å¢Ÿé€‰æ‹©', 'å½’çœŸæ•°', 'å½’å¢Ÿç‚¹', 'ä¸–ç•Œå¤§äº‹','å®—é—¨åˆ—è¡¨' ];
              
              let variablesToRender = {};

              if (category === 'system') {
                  systemVars.forEach(key => {
                      if (stat_data.hasOwnProperty(key)) {
                          variablesToRender[key] = stat_data[key];
                      }
                  });
              } else if (category === 'player') {
                  Object.keys(stat_data).forEach(key => {
                      if (!systemVars.includes(key) && key !== 'äººç‰©å…³ç³»åˆ—è¡¨' && key !== '$meta') {
                          variablesToRender[key] = stat_data[key];
                      }
                  });
              } else if (category === 'npc') {
                  variablesToRender = stat_data['äººç‰©å…³ç³»åˆ—è¡¨'] || {};
              }

              // è¿‡æ»¤
              if (searchTerm) {
                  const lowerCaseSearchTerm = searchTerm.toLowerCase();
                  variablesToRender = Object.keys(variablesToRender)
                      .filter(key => key.toLowerCase().includes(lowerCaseSearchTerm))
                      .reduce((obj, key) => {
                          obj[key] = variablesToRender[key];
                          return obj;
                      }, {});
              }

              if (Object.keys(variablesToRender).length === 0) {
                  displayArea.innerHTML = '<div class="placeholder">æ²¡æœ‰åŒ¹é…çš„å˜é‡ã€‚</div>';
                  return;
              }

              // ç”ŸæˆHTML
              if (category === 'npc') {
                  html = this.buildReadableHtml(variablesToRender, 0, 'äººç‰©å…³ç³»åˆ—è¡¨');
              } else {
                  html = this.buildReadableHtml(variablesToRender);
              }
              displayArea.innerHTML = html;
          },

          // æ„å»ºäººç±»å¯è¯»çš„HTML (æ·±åº¦æ¨¡æ¿åŒ–)
          buildReadableHtml(obj, level = 0, parentPath = '') {
              let html = '';
              const processedKeys = new Set();
              
              const bonusTemplates = {
                  'attributes_bonus': ['æ³•åŠ›', 'ç¥æµ·', 'é“å¿ƒ', 'ç©ºé€Ÿ', 'æ°”è¿', 'æ‚Ÿæ€§', 'é­…åŠ›'],
                  'ç™¾åˆ†æ¯”åŠ æˆ': ['æ³•åŠ›', 'ç¥æµ·', 'é“å¿ƒ', 'ç©ºé€Ÿ', 'ä¿®ç‚¼é€Ÿåº¦']
              };

              // 1. æ¸²æŸ“å·²å­˜åœ¨çš„é”®
              for (const key in obj) {
                  if (key === '$meta') continue;
                  processedKeys.add(key);

                  const value = obj[key];
                  const isObject = typeof value === 'object' && value !== null;
                  const currentPath = parentPath ? `${parentPath}.${key}` : key;

                  html += `<div class="readable-variable-item" style="margin-left: ${level * 20}px;">`;
                  html += `<div class="variable-title">${key}</div>`;
                  
                  if (isObject) {
                      html += `<div class="nested-item">${this.buildReadableHtml(value, level + 1, currentPath)}</div>`;
                  } else {
                      const displayValue = (value === null) ? 'null' : (value === undefined) ? 'undefined' : value;
                      html += `<div class="variable-value"><textarea rows="1" data-path="${currentPath}" oninput="this.classList.add('is-dirty')">${displayValue}</textarea></div>`;
                  }
                  html += `</div>`;
              }

              // 2. ä¸ºçˆ¶çº§å¯¹è±¡ï¼ˆå¦‚ç‰©å“ã€NPCï¼‰æ·»åŠ ç¼ºå¤±çš„æ¨¡æ¿çˆ¶é”®
              const isItemOrNpc = parentPath.includes('ç‰©å“åˆ—è¡¨') || parentPath.includes('è£…å¤‡æ ') || parentPath.includes('äººç‰©å…³ç³»åˆ—è¡¨');
              if (isItemOrNpc) {
                  Object.keys(bonusTemplates).forEach(templateKey => {
                      if (!processedKeys.has(templateKey)) {
                          html += `<div class="readable-variable-item" style="margin-left: ${level * 20}px;">`;
                          html += `<div class="variable-title">${templateKey}</div>`;
                          html += `<div class="nested-item"></div>`;
                          html += `</div>`;
                      }
                  });
              }
              
              // 3. ä¸ºattributes_bonuså’Œç™¾åˆ†æ¯”åŠ æˆå¯¹è±¡æœ¬èº«ï¼Œè¡¥å……ç¼ºå¤±çš„å­é”®
              const currentKey = parentPath.split('.').pop();
              if (bonusTemplates[currentKey]) {
                  bonusTemplates[currentKey].forEach(subKey => {
                      if (!processedKeys.has(subKey)) {
                          const subPath = `${parentPath}.${subKey}`;
                          html += `<div class="readable-variable-item template-item" style="margin-left: ${(level) * 20}px;">`;
                          html += `<div class="variable-title template-title">${subKey}</div>`;
                          html += `<div class="variable-value"><textarea rows="1" data-path="${subPath}" placeholder="è¾“å…¥æ•°å€¼..."></textarea></div>`;
                          html += `</div>`;
                      }
                  });
              }

              return html;
          },

          // ä¿å­˜å˜é‡æ›´æ”¹ (å·²é‡æ„: ä½¿ç”¨ Mvu API)
          async saveVariableChanges() {
              const displayArea = document.getElementById('variable-display-area');
              // æ ¸å¿ƒä¿®å¤ï¼šåªé€‰æ‹©è¢«ç”¨æˆ·å®é™…ä¿®æ”¹è¿‡çš„è¾“å…¥æ¡†
              const textareas = displayArea.querySelectorAll('textarea[data-path].is-dirty');
              
              // è·å–å½“å‰çš„ mvu_data
              let mvu_data;
              try {
                  mvu_data = Mvu.getMvuData({ type: 'message', message_id: 'latest' });
              } catch (error) {
                  console.warn('[å˜é‡ç¼–è¾‘å™¨] Mvu API ä¸å¯ç”¨ï¼Œå›é€€åˆ°æ—§æ–¹å¼:', error);
                  mvu_data = this.currentMvuState;
              }

              if (!mvu_data || !mvu_data.stat_data) {
                  this.showTemporaryMessage('æ— æ³•è·å–å˜é‡æ•°æ®ï¼Œä¿å­˜å¤±è´¥ã€‚', 'error');
                  return;
              }

              const originalState = mvu_data.stat_data;
              const changedVariables = [];

              // æ”¶é›†æ‰€æœ‰å˜æ›´
              textareas.forEach(textarea => {
                  const path = textarea.dataset.path;
                  const newValueStr = textarea.value;
                  const isNew = textarea.dataset.isNew === 'true';

                  // å¦‚æœè¾“å…¥æ¡†æ˜¯æ¨¡æ¿ç”Ÿæˆçš„ï¼ˆæœ‰placeholderï¼‰ä¸”å†…å®¹ä¸ºç©ºï¼Œåˆ™å¿½ç•¥å®ƒ
                  if (textarea.hasAttribute('placeholder') && newValueStr.trim() === '') {
                      return;
                  }
                  // å¯¹äºéæ¨¡æ¿ç”Ÿæˆçš„è¾“å…¥æ¡†ï¼Œå¦‚æœå†…å®¹ä¸ºç©ºï¼Œä¹Ÿè·³è¿‡ï¼ˆé™¤éå®ƒæ˜¯æ–°æ·»åŠ çš„å˜é‡ï¼Œå…è®¸è®¾ç½®ä¸ºç©ºå­—ç¬¦ä¸²ï¼‰
                  if (!isNew && !textarea.hasAttribute('placeholder') && newValueStr.trim() === '') {
                      // é€»è¾‘ä¸Šå¯ä»¥å…è®¸å°†ç°æœ‰å€¼æ¸…ç©ºï¼Œæ‰€ä»¥è¿™é‡Œæš‚æ—¶ä¸returnï¼Œä½†éœ€æ³¨æ„åç»­å¤„ç†
                  }
                  
                  let newValue;
                  try {
                      // å°è¯•è§£æä¸ºJSONï¼Œå¦‚æœå¤±è´¥åˆ™ä½œä¸ºå­—ç¬¦ä¸²
                      newValue = JSON.parse(newValueStr);
                  } catch (e) {
                      newValue = newValueStr;
                  }

                  if (isNew) {
                      // å¯¹äºæ–°å˜é‡ï¼Œç›´æ¥æ·»åŠ åˆ°å˜æ›´åˆ—è¡¨
                      changedVariables.push({ path, newValue, reason: 'å˜é‡ç¼–è¾‘å™¨æ·»åŠ ' });
                  } else {
                      // å¯¹äºç°æœ‰å˜é‡ï¼Œæ¯”è¾ƒå€¼æ˜¯å¦çœŸçš„æ”¹å˜äº†
                      const originalValue = this.SafeGetValue(originalState, path);
                      if (!_.isEqual(originalValue, newValue)) {
                          changedVariables.push({ path, newValue, reason: 'å˜é‡ç¼–è¾‘å™¨ä¿®æ”¹' });
                      }
                  }
              });
              
              if (changedVariables.length > 0) {
                  this.showTemporaryMessage(`æ­£åœ¨ä¿å­˜ ${changedVariables.length} ä¸ªå˜é‡çš„ä¿®æ”¹...`);

                  try {
                      let hasAnySuccess = false;

                      // ä½¿ç”¨ Mvu.setMvuVariable å®ç°å¢é‡æ›´æ–°
                      for (const { path, newValue, reason } of changedVariables) {
                          try {
                              // ç›´æ¥åœ¨å½“å‰çš„å‰ç«¯çŠ¶æ€ä¸Šè°ƒç”¨ setMvuVariable
                              // è¿™ä¸ªAPIä¼šåŒæ—¶æ›´æ–°JSå¯¹è±¡å’Œdisplay_dataç­‰å…ƒæ•°æ®
                              const success = await Mvu.setMvuVariable(this.currentMvuState, path, newValue, { reason });

                              if (success) {
                                  hasAnySuccess = true;
                              }
                          } catch (error) {
                              // ä¿ç•™é”™è¯¯å¤„ç†ï¼Œä½†ç§»é™¤å…·ä½“çš„æ—¥å¿—è¾“å‡º
                          }
                      }

                      if (hasAnySuccess) {
                          // å¢é‡æ›´æ–°åï¼Œåªéœ€ç”¨æœ€æ–°çš„å‰ç«¯çŠ¶æ€å…¨å±€è¦†å†™ä¸€æ¬¡åç«¯å³å¯
                          await Mvu.replaceMvuData(this.currentMvuState, { type: 'message', message_id: 'latest' });

                          // æ›´æ–°UI
                          this.renderUI(this.currentMvuState.stat_data);
                          
                          // é‡æ–°æ¸²æŸ“å˜é‡ç¼–è¾‘å™¨æœ¬èº«ä»¥åæ˜ æœ€æ–°çŠ¶æ€ï¼Œå¹¶åœç•™åœ¨å½“å‰Tab
                          const searchTerm = document.getElementById('variable-search-input').value;
                          this.renderVariables(this.activeEditorCategory, searchTerm);

                          this.showTemporaryMessage(`æˆåŠŸå¢é‡æ›´æ–° ${changedVariables.length} ä¸ªå˜é‡ï¼`, 'success');
                      } else {
                          this.showTemporaryMessage('æ‰€æœ‰å˜é‡æ›´æ–°éƒ½å¤±è´¥äº†ã€‚', 'error');
                      }

                  } catch (error) {
                      console.error('[å˜é‡ç¼–è¾‘å™¨] ä¿å­˜å˜é‡å¤±è´¥:', error);
                      this.showTemporaryMessage(`ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
                  }
              } else {
                  this.showTemporaryMessage('æ²¡æœ‰æ£€æµ‹åˆ°ä»»ä½•æ›´æ”¹ã€‚');
              }
          },

          // æ·»åŠ æ–°å˜é‡
          addNewVariable() {
              const path = prompt("è¯·è¾“å…¥æ–°å˜é‡çš„å®Œæ•´è·¯å¾„ (ä¾‹å¦‚: 'äººç‰©å…³ç³»åˆ—è¡¨.æ–°è§’è‰²'):ã€åŠŸèƒ½å¾…å®Œå–„ã€‘");
              if (!path) return;

              const value = prompt(`è¯·è¾“å…¥ '${path}' çš„åˆå§‹å€¼:`, '""');
              if (value === null) return;

              // åŠ¨æ€åˆ›å»ºä¸€ä¸ªæ–°çš„å¯ç¼–è¾‘é¡¹å¹¶æ·»åŠ åˆ°æ˜¾ç¤ºåŒºåŸŸ
              const displayArea = document.getElementById('variable-display-area');
              const newItemHtml = `
                  <div class="readable-variable-item" style="margin-left: 0px; border: 2px dashed #c9aa71; padding: 10px; border-radius: 5px;">
                      <div class="variable-title">${path}</div>
                      <div class="variable-value">
                          <textarea rows="1" data-path="${path}" data-is-new="true">${value}</textarea>
                      </div>
                  </div>
              `;
              displayArea.insertAdjacentHTML('afterbegin', newItemHtml);
          },


          // === æ•°æ®æ”¶é›†å’Œè§£æ ===
          collectVisualEditorData() {
            // ç›´æ¥è¿”å›å½“å‰çš„å˜é‡å€¼ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»å®æ—¶æ›´æ–°äº†
            return this.currentVariableValue;
          },

          parseVisualValue(value) {
            if (value === '' || value === 'null') return null;
            if (value === 'true') return true;
            if (value === 'false') return false;
            if (!isNaN(value) && !isNaN(parseFloat(value))) return parseFloat(value);
            return value;
          },

          // === ç®€å•å¯¹è±¡å’Œæ•°ç»„æ¸²æŸ“å™¨ ===
          renderSimpleObject(obj, path) {
            let html = `<div class="smart-form-group" data-path="${path}">
              <label class="smart-form-label">${path.split('.').pop() || 'å¯¹è±¡'}</label>`;
            
            Object.entries(obj).forEach(([key, value]) => {
              const fieldPath = `${path}.${key}`;
              html += `<div class="attribute-item">
                <label class="attribute-label">${key}</label>
                <input type="text" class="attribute-input"
                       value="${value}" data-path="${fieldPath}">
              </div>`;
            });
            
            html += `</div>`;
            return html;
          },

          renderSmartArray(arr, path) {
            let html = `<div class="relationships-container" data-path="${path}">
              <div class="details-toggle" onclick="this.nextElementSibling.classList.toggle('hidden')">
                <span>${path.split('.').pop() || 'æ•°ç»„'} (${arr.length}é¡¹)</span>
                <span>â–¼</span>
              </div>
              <div class="details-content">
                <ul class="sortable-list" data-path="${path}">`;

            arr.forEach((item, index) => {
              const itemPath = `${path}[${index}]`;
              html += `<li class="sortable-item" data-index="${index}">
                <span class="drag-handle">â‹®â‹®</span>
                <div style="flex: 1;">`;
              
              if (typeof item === 'object' && item !== null) {
                html += `<textarea class="rich-text-editor" data-path="${itemPath}" rows="2">${JSON.stringify(item, null, 2)}</textarea>`;
              } else {
                html += `<input type="text" class="attribute-input" value="${item}" data-path="${itemPath}">`;
              }
              
              html += `</div>
                <button class="action-btn secondary" onclick="guixuApp.removeArrayItem('${path}', ${index})">åˆ é™¤</button>
              </li>`;
            });

            html += `</ul>
              <div class="action-buttons">
                <button class="action-btn" onclick="guixuApp.addArrayItem('${path}')">æ·»åŠ é¡¹ç›®</button>
              </div>
            </div></div>`;

            return html;
          },

          renderPrimitiveValue(value, path) {
            const type = typeof value;
            let inputType = 'text';
            let inputClass = 'attribute-input';
            
            if (type === 'number') {
              inputType = 'number';
            } else if (type === 'boolean') {
              return `<div class="smart-form-group">
                <label class="smart-form-label">${path.split('.').pop() || 'å€¼'}</label>
                <select class="smart-select" data-path="${path}">
                  <option value="true" ${value ? 'selected' : ''}>æ˜¯</option>
                  <option value="false" ${!value ? 'selected' : ''}>å¦</option>
                </select>
              </div>`;
            }

            return `<div class="smart-form-group">
              <label class="smart-form-label">${path.split('.').pop() || 'å€¼'}</label>
              <input type="${inputType}" class="${inputClass}"
                     value="${value}" data-path="${path}">
            </div>`;
          },

          renderGenericObject(obj, path) {
            let html = `<div class="details-section" data-path="${path}">
              <div class="details-toggle" onclick="this.nextElementSibling.classList.toggle('hidden')">
                <span>${path.split('.').pop() || 'å¯¹è±¡'} (${Object.keys(obj).length}ä¸ªå±æ€§)</span>
                <span>â–¼</span>
              </div>
              <div class="details-content">`;

            Object.entries(obj).forEach(([key, value]) => {
              const fieldPath = `${path}.${key}`;
              html += this.renderGenericField(key, value, fieldPath);
            });

            html += `</div></div>`;
            return html;
          },
          // æ–°å¢ï¼šæ ¹æ®è·¯å¾„è®¾ç½®å€¼
          setValueByPath(obj, path, value) {
            const keys = path.split(/[\.\[\]]/).filter(key => key !== '');
            let current = obj;
            
            for (let i = 0; i < keys.length - 1; i++) {
              const key = keys[i];
              if (!(key in current)) {
                current[key] = isNaN(keys[i + 1]) ? {} : [];
              }
              current = current[key];
            }
            
            const lastKey = keys[keys.length - 1];
            current[lastKey] = value;
          },



// ===å˜é‡ç¼–è¾‘å™¨æ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰ç»“æŸ===



// ===äººç‰©å…³ç³»æ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰å¼€å§‹===



          async showRelationships() {
              this.loadRelationshipSortSettings(); // åŠ è½½æ’åºè®¾ç½®
              this.openModal('relationships-modal');
              
              const container = document.querySelector('#relationships-modal .relationships-container');
              if (!container) return;

              const listPanel = container.querySelector('.character-list-panel .character-list');
              const detailsPanel = container.querySelector('.character-details-panel');
              if (!listPanel || !detailsPanel) {
                return;
              }

              listPanel.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨æ¢³ç†äººè„‰...</p>';
              detailsPanel.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">è¯·å…ˆåœ¨å·¦ä¾§é€‰æ‹©äººç‰©</p>';

              try {
                  if (!this.currentMvuState) {
                      listPanel.innerHTML = '<p class="modal-placeholder">æ— æ³•è·å–äººç‰©å…³ç³»æ•°æ®ï¼ˆçŠ¶æ€æœªåˆå§‹åŒ–ï¼‰ã€‚</p>';
                      return;
                  }
                  const relationships = this.SafeGetValue(this.currentMvuState.stat_data, 'äººç‰©å…³ç³»åˆ—è¡¨', {});
                  this.currentRelationshipData = relationships; // ç¼“å­˜æ•°æ®
                  
                  this.renderCharacterList();
                  
                  // ä»localStorageæ¢å¤ä¸Šæ¬¡é€‰æ‹©çš„äººç‰©ï¼Œå¦‚æœæ²¡æœ‰åˆ™é€‰æ‹©ç¬¬ä¸€ä¸ª
                  const savedCharacter = localStorage.getItem('guixu_last_selected_character');
                  let targetCharacterName = null;
                  
                  // ä¼˜å…ˆä½¿ç”¨ä¿å­˜çš„äººç‰©åï¼Œä½†è¦ç¡®ä¿è¯¥äººç‰©ä»ç„¶å­˜åœ¨
                  if (savedCharacter && relationships[savedCharacter]) {
                      targetCharacterName = savedCharacter;
                  } else {
                      // å¦‚æœä¿å­˜çš„äººç‰©ä¸å­˜åœ¨ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ª
                      targetCharacterName = listPanel.querySelector('.character-card')?.dataset.characterName;
                  }
                  
                  if (targetCharacterName) {
                      // ç»™å¯¹åº”çš„å¡ç‰‡æ·»åŠ activeçŠ¶æ€
                      const targetCard = listPanel.querySelector(`.character-card[data-character-name="${targetCharacterName}"]`);
                      if (targetCard) {
                          targetCard.classList.add('active');
                      }
                      // æ˜¾ç¤ºè¯¦æƒ…
                      this.renderCharacterDetails(targetCharacterName);
                      // è®°å½•å½“å‰é€‰æ‹©
                      this.lastSelectedCharacter = targetCharacterName;
                  } else {
                      detailsPanel.innerHTML = '<p class="modal-placeholder">æš‚æ— äººç‰©è¯¦æƒ…ã€‚</p>';
                  }
                  
                  this.adjustRelationshipPanelWidth();
                  const rootContainer = document.querySelector('.guixu-root-container');
                  const modalContent = document.querySelector('#relationships-modal .modal-content');
                  if (rootContainer && modalContent) {
                      const rect = rootContainer.getBoundingClientRect();
                      modalContent.style.setProperty('width', `${rect.width}px`, 'important');
                      modalContent.style.setProperty('height', `${rect.height}px`, 'important');
                      modalContent.style.setProperty('top', `${rect.top}px`, 'important');
                      modalContent.style.setProperty('left', `${rect.left}px`, 'important');
                      modalContent.style.setProperty('max-width', 'none', 'important');
                      modalContent.style.setProperty('max-height', 'none', 'important');
                  }

              } catch (error) {
                  console.error('åŠ è½½äººç‰©å…³ç³»æ—¶å‡ºé”™:', error);
                  listPanel.innerHTML = `<p class="modal-placeholder">åŠ è½½äººç‰©å…³ç³»æ—¶å‡ºé”™: ${error.message}</p>`;
              }
          },

          renderCharacterList() {
              const listPanel = document.querySelector('#relationships-modal .character-list');
              const listHeader = document.querySelector('#relationships-modal .character-list-header');
              if (!listPanel || !this.currentRelationshipData || !listHeader) return;

              const relationships = this.currentRelationshipData;
              let allRelationshipEntries = Object.entries(relationships).filter(([name, rel]) => {
                  return name && name !== '$meta' && rel && typeof rel === 'object';
              });

              // æœç´¢è¿‡æ»¤
              const searchTerm = listHeader.querySelector('.character-search-input')?.value || '';
              if (searchTerm) {
                  allRelationshipEntries = allRelationshipEntries.filter(([name, rel]) => {
                      return name.toLowerCase().includes(searchTerm.toLowerCase());
                  });
              }

              // æ›´æ–°è§’è‰²è®¡æ•°
              const subtitleElement = document.querySelector('#relationships-modal .character-list-header .subtitle');
              if (subtitleElement) {
                  subtitleElement.textContent = `å…± ${allRelationshipEntries.length} ä¸ªè§’è‰²`;
              }

              const sortedEntries = this.sortRelationshipEntries(allRelationshipEntries);

              if (sortedEntries.length === 0) {
                  listPanel.innerHTML = '<p class="modal-placeholder">æš‚æ— äººç‰©å…³ç³»ã€‚</p>';
                  return;
              }

              try {
                  listPanel.innerHTML = sortedEntries.map(([name, rel]) => {
                      const cultivation = this.SafeGetValue(rel, 'å½“å‰ä¿®ä¸º', 'å‡¡äºº');
                      const tierMatch = cultivation.match(/^(ç»ƒæ°”|ç­‘åŸº|æ´ç„|åˆé“|é£å‡|ç¥æ¡¥|å‡¡äºº)/);
                      const tier = tierMatch ? tierMatch[0] : 'å‡¡äºº';
                      const style = this.getJingJieStyle(tier);
                      const favorability = this.SafeGetValue(rel, 'å¥½æ„Ÿåº¦', 0);
                      const favorPercentage = Math.min(Math.abs(favorability) / 200 * 100, 100);
                      const favorClass = favorability >= 0 ? 'positive' : 'negative';

                      // ä¸ºå¡ç‰‡èƒŒæ™¯é¢„ç•™ä¸€ä¸ªstyleå±æ€§
                      return `
                          <div class="character-card" id="card-${name}" data-character-name="${name}" style="">
                              <div class="card-background-overlay"></div>
                              <div class="avatar" id="avatar-${name}">${name.charAt(0)}</div>
                              <div class="info">
                                  <div class="name" style="${style}">${name}</div>
                                  <div class="favor-bar-container">
                                      <div class="favor-bar-bg">
                                          <div class="favor-bar ${favorClass}" style="width: ${favorPercentage}%;"></div>
                                      </div>
                                      <div class="favor-value">${favorability}</div>
                                  </div>
                              </div>
                          </div>
                      `;
                  }).join('');

                  // --- å¼‚æ­¥åŠ è½½æ‰€æœ‰åˆ—è¡¨å¤´åƒå’ŒèƒŒæ™¯ ---
                  sortedEntries.forEach(([name, rel]) => {
                      this.getAvatarFromDB(name).then(avatarRecord => {
                          const avatarEl = document.getElementById(`avatar-${name}`);
                          if (avatarEl && avatarRecord && avatarRecord.avatarImage) {
                              avatarEl.style.backgroundImage = `url(${avatarRecord.avatarImage})`;
                              avatarEl.style.backgroundSize = 'cover';
                              avatarEl.style.backgroundPosition = 'center';
                              avatarEl.textContent = ''; // æ¸…ç©ºæ–‡å­—
                          }

                          const cardEl = document.getElementById(`card-${name}`);
                          if (cardEl && avatarRecord && avatarRecord.backgroundImage) {
                              cardEl.style.backgroundImage = `url(${avatarRecord.backgroundImage})`;
                              cardEl.style.backgroundSize = 'cover';
                              cardEl.style.backgroundPosition = 'center';
                          }
                      });
                  });

              } catch (error) {
                  console.error('æ¸²æŸ“äººç‰©åˆ—è¡¨æ—¶å‡ºé”™:', error);
                  listPanel.innerHTML = '<p class="modal-placeholder">æ¸²æŸ“äººç‰©åˆ—è¡¨æ—¶å‡ºé”™ã€‚</p>';
              }
          },

           async renderCharacterDetails(characterName) {
               const detailsPanel = document.querySelector('#relationships-modal .character-details-panel');
               if (!detailsPanel || !this.currentRelationshipData) return;

               const characterData = this.currentRelationshipData[characterName];
               if (!characterData) {
                   detailsPanel.innerHTML = `<p class="modal-placeholder">æ— æ³•æ‰¾åˆ° ${characterName} çš„ä¿¡æ¯ã€‚</p>`;
                   return;
               }

               // 1. å¼‚æ­¥è·å–å›¾ç‰‡å’Œé€æ˜åº¦æ•°æ®
               const avatarRecord = await this.getAvatarFromDB(characterName);
               const avatarImage = avatarRecord ? avatarRecord.avatarImage : '';
               const backgroundImage = avatarRecord ? avatarRecord.backgroundImage : '';
               const backgroundOpacity = avatarRecord ? avatarRecord.backgroundOpacity : 0.5;

               const name = characterName;
               const cultivation = this.SafeGetValue(characterData, 'å½“å‰ä¿®ä¸º', 'å‡¡äºº');
               const tierMatch = cultivation.match(/^(ç»ƒæ°”|ç­‘åŸº|æ´ç„|åˆé“|é£å‡|ç¥æ¡¥|å‡¡äºº)/);
               const tier = tierMatch ? tierMatch[0] : 'å‡¡äºº';
               const age = this.SafeGetValue(characterData, 'å¹´é¾„', '??');
               const appearance = this.SafeGetValue(characterData, 'å¤–è²Œ', 'æš‚æ— ');
               const personality = this.SafeGetValue(characterData, 'æ€§æ ¼', 'æš‚æ— ');
               const origin = this.SafeGetValue(characterData, 'å‡ºèº«', 'æš‚æ— ');
               const lifespan = this.SafeGetValue(characterData, 'å¯¿å…ƒ', '??');
               const location = this.SafeGetValue(characterData, 'æ‰€å¤„åœ°ç‚¹', 'æœªçŸ¥');
               const cultivationProgress = this.SafeGetValue(characterData, 'ä¿®ç‚¼è¿›åº¦', 0);

               const style = this.getJingJieStyle(tier);
               
               // 2. æ›´æ–°HTMLæ¨¡æ¿
               const avatarStyle = avatarImage ? `background-image: url(${avatarImage}); background-size: cover; background-position: center;` : '';
               this.updateCharacterDetailsBackground(backgroundImage, backgroundOpacity);

               let html = `
                   <div class="details-header">
                       <div class="avatar-container">
                           <div class="large-avatar" id="large-avatar-${name}" style="${avatarStyle}">${avatarImage ? '' : name.charAt(0)}</div>
                           <div class="custom-image-prompt">
                               <i class="fas fa-camera"></i>
                               <span>ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡</span>
                           </div>
                       </div>
                       <div class="main-info">
                           <div class="name" style="${style}">${name}</div>
                           <div style="display: flex; align-items: center; justify-content: space-between; gap: 15px; margin-top: 5px;">
                             <div style="display: flex; align-items: center; gap: 15px;">
                               <div class="title">${cultivation} Â· ${age}/${lifespan}</div>
                               <div class="location-tag"><i class="fas fa-map-marker-alt"></i> ${location}</div>
                             </div>
                             <div style="display: flex; align-items: center; min-width: 280px;">
                                 <strong style="white-space: nowrap; color: #c9aa71; font-size: 13px; margin-right: 10px;">ä¿®ç‚¼è¿›åº¦:</strong>
                                 <div class="progress-bar-container" style="width: 150px; display: flex; align-items: center;">
                                     <div class="progress-bar-bg" style="flex-grow: 1;">
                                         <div class="progress-bar-fill" style="width: ${cultivationProgress}%;"></div>
                                     </div>
                                     <span style="margin-left: 10px; color: #e8dcc6; font-size: 13px; white-space: nowrap;">${cultivationProgress}%</span>
                                 </div>
                             </div>
                           </div>
                       </div>
                   </div>
                   <div class="details-tabs">
                       <button class="tab-button active" data-tab="attributes">è¯¦æƒ…</button>
                       <button class="tab-button" data-tab="journey">é“é€”</button>
                       <button class="tab-button" data-tab="skills">åŠŸæ³•</button>
                       <button class="tab-button" data-tab="equipment">è£…å¤‡</button>
                       <button class="tab-button" data-tab="inventory">å‚¨ç‰©è¢‹</button>
                       <button class="tab-button" data-tab="social">ç¤¾äº¤</button>
                       <button class="tab-button" data-tab="memory">è®°å¿†</button>
                       <button class="tab-button" data-tab="advanced">é«˜çº§</button>
                   </div>
                   <div class="details-content" style="display: flex; flex-direction: column; flex-grow: 1; min-height: 0;">
                       <div class="tab-pane active" id="tab-attributes">
                           <div class="info-section">
                               <h4>åŸºæœ¬ä¿¡æ¯</h4>
                               <div class="info-grid">
                                   <div class="info-item full-width"><strong style="color: #c9aa71;">èº«ä»½èƒŒæ™¯:</strong> ${this.SafeGetValue(characterData, 'èº«ä»½èƒŒæ™¯', 'æš‚æ— ')}</div>
                                   <div class="info-item full-width"><strong style="color: #c9aa71;">æ€§æ ¼:</strong> ${personality}</div>
                                   <div class="info-item full-width"><strong style="color: #c9aa71;">å¤–è²Œ:</strong> ${appearance}</div>
                                   <div class="info-item full-width"><strong style="color: #c9aa71;">ç©¿ç€:</strong> ${this.SafeGetValue(characterData, 'ç©¿ç€', 'æš‚æ— ')}</div>
                                   <div class="info-item"><strong style="color: #c9aa71;">é­…åŠ›:</strong> ${this.getCharmDisplayHTML(this.SafeGetValue(characterData, 'é­…åŠ›', 0))}</div>
                                   <div class="info-item"><strong style="color: #c9aa71;">å…³ç³»:</strong> ${this.SafeGetValue(characterData, 'å…³ç³»', 'æœªçŸ¥')}</div>
                               </div>
                               <div style="display: flex; gap: 15px; padding: 6px 0; border-top: 1px solid rgba(201, 170, 113, 0.15); border-bottom: 1px solid rgba(201, 170, 113, 0.15); flex-wrap: nowrap; margin-top: 0;">
                                    <div style="flex: 1; min-width: 0; font-size: 14px;"><strong style="color: #c9aa71;">æ°”è¿:</strong> ${this.getQiyunDisplayHTML(this.SafeGetValue(characterData, 'æ°”è¿', 0))}</div>
                                    <div style="flex: 1; min-width: 0; font-size: 14px;"><strong style="color: #c9aa71;">æ‚Ÿæ€§:</strong> ${this.getWuxingDisplayHTML(this.SafeGetValue(characterData, 'æ‚Ÿæ€§', 0))}</div>
                               </div>
                               <div class="info-grid" style="margin-top: 8px; gap: 4px;">
                                    ${this.getAttributeProgressHTML(this.SafeGetValue(characterData, 'å½“å‰è¡€é‡', 0), this.SafeGetValue(characterData, 'è¡€é‡', 0), 'è¡€é‡')}
                                    ${this.getAttributeProgressHTML(this.SafeGetValue(characterData, 'å½“å‰ç¥æµ·', 0), this.SafeGetValue(characterData, 'ç¥æµ·', 0), 'ç¥æµ·')}
                                    ${this.getAttributeProgressHTML(this.SafeGetValue(characterData, 'å½“å‰æ³•åŠ›', 0), this.SafeGetValue(characterData, 'æ³•åŠ›', 0), 'æ³•åŠ›')}
                                    ${this.getAttributeProgressHTML(this.SafeGetValue(characterData, 'å½“å‰é“å¿ƒ', 0), this.SafeGetValue(characterData, 'é“å¿ƒ', 0), 'é“å¿ƒ')}
                                    ${this.getAttributeProgressHTML(this.SafeGetValue(characterData, 'å½“å‰ç©ºé€Ÿ', 0), this.SafeGetValue(characterData, 'ç©ºé€Ÿ', 0), 'ç©ºé€Ÿ')}
                               </div>
                               <div class="info-grid" style="margin-top: 12px;">
                                   <input type="checkbox" id="toggle-mind" class="hidden-toggle">
                                   <label for="toggle-mind" class="info-item full-width separator-line">â€”â€” å†…å¿ƒ â€”â€”</label>
                                   <div class="collapsible-content">
                                       <div class="info-item full-width"><strong style="color: #c9aa71;">å½“å‰å†…å¿ƒæƒ³æ³•:</strong> ${this.SafeGetValue(characterData, 'å½“å‰å†…å¿ƒæƒ³æ³•', 'æš‚æ— ')}</div>
                                       <div class="info-item full-width"><strong style="color: #c9aa71;">çŸ­æœŸç›®æ ‡:</strong> ${this.SafeGetValue(characterData, 'çŸ­æœŸç›®æ ‡', 'æš‚æ— ')}</div>
                                       <div class="info-item full-width"><strong style="color: #c9aa71;">é•¿æœŸç›®æ ‡:</strong> ${this.SafeGetValue(characterData, 'é•¿æœŸç›®æ ‡', 'æš‚æ— ')}</div>
                                   </div>
                               </div>
                           </div>
                       </div>
                       <div class="tab-pane" id="tab-journey">${this._renderDaotuContent(characterData)}</div>
                       <div class="tab-pane" id="tab-skills">${this._renderGongfaSection(characterData)}</div>
                       <div class="tab-pane" id="tab-equipment">${this._renderEquipmentSection(characterData)}</div>
                       <div class="tab-pane" id="tab-inventory">${this._renderInventorySection(characterData)}</div>
                       <div class="tab-pane" id="tab-social">${this._renderSocialSection(characterData)}</div>
                       <div class="tab-pane" id="tab-memory">${this._renderMemorySection(characterData)}</div>
                       <div class="tab-pane" id="tab-advanced">
                            <div class="info-section">
                                <h4>èƒŒæ™¯è®¾ç½®</h4>
                                <div style="padding: 15px 0;">
                                    <div style="display: flex; align-items: center; margin-bottom: 15px;">
                                        <i class="fas fa-eye" style="color: #c9aa71; margin-right: 8px;"></i>
                                        <span style="color: #c9aa71; font-size: 14px; margin-right: 15px;">èƒŒæ™¯é€æ˜åº¦:</span>
                                        <input type="range" id="avatar-opacity-slider" min="0" max="1" step="0.05" value="${backgroundOpacity}" style="flex: 1; max-width: 200px;" title="è°ƒæ•´èƒŒæ™¯é€æ˜åº¦">
                                        <span id="avatar-opacity-value" style="margin-left: 10px; color: #e8dcc6; font-size: 14px; min-width: 40px;">${Math.round(backgroundOpacity * 100)}%</span>
                                    </div>
                                </div>
                            </div>
                            <div class="info-section" style="margin-top: 15px;">
                                <h4>æ•°æ®ç»Ÿè®¡</h4>
                                <div style="padding: 15px 0;">
                                    <div style="display: flex; align-items: center; color: #e8dcc6; font-size: 14px;">
                                        <i class="fas fa-database" style="color: #c9aa71; margin-right: 8px;"></i>
                                        <span style="color: #c9aa71; margin-right: 8px;">å ç”¨Token:</span>
                                        <span id="character-token-count" style="color: #daa520; font-weight: bold;">è®¡ç®—ä¸­...</span>
                                    </div>
                                </div>
                            </div>
                            <div class="info-section" style="margin-top: 15px;">
                                 <h4>é«˜çº§æŒ‡ä»¤</h4>
                                 <div class="action-buttons" style="padding-top: 15px; display: flex; flex-direction: column; gap: 10px; align-items: stretch;">
                                     <button class="interaction-btn" id="btn-enhance-character" style="width: 100%;">å®Œå–„äººè®¾</button>
                                     <button class="interaction-btn" id="btn-delete-character" style="width: 100%; background: linear-gradient(45deg, #8b2e2e, #cd5c5c); border-color: #cd5c5c;">åˆ é™¤äººç‰©</button>
                                 </div>
                             </div>
                        </div>
                   </div>
               `;
               detailsPanel.innerHTML = html;

               // 3. æ›´æ–°äº‹ä»¶ç»‘å®š
               const avatarContainer = detailsPanel.querySelector('.avatar-container');
               const opacitySlider = detailsPanel.querySelector('#avatar-opacity-slider');
               const opacityValueEl = detailsPanel.querySelector('#avatar-opacity-value');
               let debounceTimer;

               // ç»‘å®šå¤´åƒä¸Šä¼ äº‹ä»¶ï¼ˆæ–°å¢ï¼šæ”¯æŒä»å›¾åº“é€‰æ‹©ï¼‰
               if (avatarContainer) {
                   avatarContainer.onclick = (e) => {
                       if (e.target.closest('.large-avatar') || e.target.closest('.custom-image-prompt')) {
                           this.showAvatarSourcePicker(characterName);
                       }
                   };
               }

               // ç»‘å®šèƒŒæ™¯é€æ˜åº¦æ»‘å—äº‹ä»¶
               if (opacitySlider) {
                   let animationFrameId = null;
                   opacitySlider.addEventListener('input', () => {
                       const newOpacity = opacitySlider.value;

                       // ä½¿ç”¨requestAnimationFrameä¼˜åŒ–UIæ›´æ–°
                       if (animationFrameId) {
                           cancelAnimationFrame(animationFrameId);
                       }
                       animationFrameId = requestAnimationFrame(() => {
                           this.updateCharacterDetailsBackground(backgroundImage, newOpacity); // æ›´æ–°ä¼ªå…ƒç´ æ ·å¼
                           if (opacityValueEl) opacityValueEl.textContent = `${Math.round(newOpacity * 100)}%`;
                       });
                       
                       // ä½¿ç”¨é˜²æŠ–ä¼˜åŒ–æ•°æ®åº“å†™å…¥
                       clearTimeout(debounceTimer);
                       debounceTimer = setTimeout(() => {
                           this.storeAvatarInDB({
                               characterName: characterName,
                               backgroundOpacity: parseFloat(newOpacity)
                           });
                       }, 500);
                   });
               }

               // Re-bind tab events - æ›´æ–°ä¸ºæ”¯æŒtabè®°å¿†
               const tabs = detailsPanel.querySelectorAll('.tab-button');
               const panes = detailsPanel.querySelectorAll('.tab-pane');
               
               // ä»localStorageæ¢å¤ä¸Šæ¬¡æ¿€æ´»çš„tab
               const savedTab = localStorage.getItem('guixu_relationship_tab');
               const currentTab = savedTab || this.currentRelationshipTab || 'attributes';
               this.currentRelationshipTab = currentTab;
               
               tabs.forEach(t => t.classList.remove('active'));
               panes.forEach(p => p.classList.remove('active'));
               
               const activeTab = detailsPanel.querySelector(`[data-tab="${currentTab}"]`);
               const activePane = detailsPanel.querySelector(`#tab-${currentTab}`);
               if (activeTab && activePane) {
                   activeTab.classList.add('active');
                   activePane.classList.add('active');
               } else {
                   // å¦‚æœæ‰¾ä¸åˆ°ä¸Šæ¬¡çš„tabï¼Œå›é€€åˆ°ç¬¬ä¸€ä¸ª
                   tabs[0]?.classList.add('active');
                   panes[0]?.classList.add('active');
               }
               
               // ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼Œå¹¶è®°å½•tabçŠ¶æ€
               tabs.forEach(tab => {
                   tab.addEventListener('click', () => {
                       tabs.forEach(t => t.classList.remove('active'));
                       tab.classList.add('active');
                       panes.forEach(p => p.classList.remove('active'));
                       const targetPane = detailsPanel.querySelector(`#tab-${tab.dataset.tab}`);
                       if(targetPane) {
                           targetPane.classList.add('active');
                           // è®°å½•å½“å‰æ¿€æ´»çš„tabå¹¶ä¿å­˜åˆ°localStorage
                           this.currentRelationshipTab = tab.dataset.tab;
                           localStorage.setItem('guixu_relationship_tab', tab.dataset.tab);
                       }
                   });
               });

               // è®¡ç®—å¹¶æ˜¾ç¤ºtokenæ•°é‡
                const tokenCountEl = detailsPanel.querySelector('#character-token-count');
                if (tokenCountEl) {
                    const tokenCount = this.calculateCharacterTokenCount(characterData);
                    tokenCountEl.textContent = `çº¦ ${tokenCount} å­—ç¬¦`;
                }

                // ç»‘å®šé«˜çº§æ“ä½œæŒ‰é’®äº‹ä»¶
                const enhanceBtn = detailsPanel.querySelector('#btn-enhance-character');
                if (enhanceBtn) {
                    enhanceBtn.addEventListener('click', () => {
                        // ç›´æ¥ä½¿ç”¨ characterData å¯¹è±¡ï¼Œå³è§’è‰²çš„ stat_data
                        const statData = characterData;

                        // å°† stat_data æ ¼å¼åŒ–ä¸ºè¯¦ç»†çš„æŒ‡ä»¤æ–‡æœ¬
                        const detailedText = `[æœ€é«˜æŒ‡ä»¤] æ ¹æ®ä»¥ä¸‹è§’è‰²çš„stat_dataï¼Œè¿›è¡Œæ·±åº¦å®Œå–„å’Œæ‰©å±•ï¼š\n\`\`\`json\n${JSON.stringify(statData, null, 2)}\n\`\`\`\nè¯·ä¸¥æ ¼éµå¾ª<äººç‰©å…³ç³»åˆ—è¡¨ä¿®æ”¹å‡†åˆ™>ï¼Œä»æ­¦å™¨ã€è£…å¤‡ã€é¥°å“ã€é˜²å…·ã€ä¸»ä¿®åŠŸæ³•ã€è¾…ä¿®åŠŸæ³•ã€çœŸæ°”ã€ç­‘åŸºå¥‡ç‰©ã€æ´å¤©ã€ç¥å¦™ã€æœ¬å‘½ç¥å¦™ã€ä»™çµä¹‹æ°”ã€å‚¨ç‰©è¢‹ï¼ˆè‡³å°‘5ä»¶ç‰©å“ï¼‰ã€äººç‰©å…³ç³»ç½‘ç»œã€é‡è¦äº‹ä»¶ç­‰æ–¹é¢ï¼Œåˆ†æ­¥ä½¿ç”¨å˜é‡æŒ‡ä»¤å¯¹ ${characterName} çš„å˜é‡ç»“æ„è¿›è¡Œå®Œå–„ã€‚`;

                        // ä½¿ç”¨ç®€åŒ–çš„æŒ‡ä»¤ä¸­å¿ƒæ¥å£
                        this.addCommand(detailedText);
                        this.showTemporaryMessage(`å·²æ·»åŠ è¯¦ç»†æŒ‡ä»¤ï¼šå®Œå–„ ${characterName} çš„å˜é‡`);
                    });
                }

                // ç»‘å®šåˆ é™¤æŒ‰é’®äº‹ä»¶
                const deleteBtn = detailsPanel.querySelector('#btn-delete-character');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', () => {
                        this.deleteCharacterFromRelationships(characterName);
                    });
                }
                 // é‡æ–°ç»‘å®šäº‹ä»¶ä»¥å¤„ç†æ–°æ¸²æŸ“çš„å†…å®¹
                this.bindRelationshipEvents();
           },
           

          _renderSocialSection(characterData) {
              const socialNetwork = this.SafeGetValue(characterData, 'äººç‰©å…³ç³»ç½‘', {});
              const entries = Object.entries(socialNetwork).filter(([name]) => name !== '$meta');
              if (entries.length === 0) {
                  return '<p>æ­¤äººç‹¬æ¥ç‹¬å¾€ï¼Œå°šæœªå»ºç«‹èµ·è‡ªå·±çš„äººè„‰ã€‚</p>';
              }
              let html = '<div class="social-network-grid">';
              entries.forEach(([name, details]) => {
                  html += `
                      <div class="social-card">
                          <div class="social-card-name">${name}</div>
                          <div class="social-card-relationship">${this.SafeGetValue(details, 'relationship', 'æœªçŸ¥å…³ç³»')}</div>
                          <div class="social-card-intimacy">äº²å¯†åº¦: ${this.SafeGetValue(details, 'intimacy', '??')}</div>
                          <div class="social-card-description">${this.SafeGetValue(details, 'description', 'æš‚æ— æè¿°')}</div>
                      </div>
                  `;
              });
              html += '</div>';
              return html;
          },

          // è®¡ç®—äººç‰©æ•°æ®å ç”¨çš„å­—ç¬¦æ•°ï¼ˆTokenä¼°ç®—ï¼‰
          calculateCharacterTokenCount(characterData) {
              try {
                  const jsonString = JSON.stringify(characterData, null, 2);
                  return jsonString.length;
              } catch (error) {
                  console.error('è®¡ç®—Tokenæ•°é‡å¤±è´¥:', error);
                  return 0;
              }
          },

          // è®¡ç®—ä¸–ç•Œå¤§äº‹å ç”¨çš„å­—ç¬¦æ•°ï¼ˆTokenä¼°ç®—ï¼‰
          calculateEventTokenCount(eventData) {
              try {
                  const jsonString = JSON.stringify(eventData, null, 2);
                  return jsonString.length;
              } catch (error) {
                  console.error('è®¡ç®—äº‹ä»¶Tokenæ•°é‡å¤±è´¥:', error);
                  return 0;
              }
          },

          // åˆ é™¤ä¸–ç•Œå¤§äº‹ï¼ˆé€šç”¨ç»„ä»¶ï¼‰
          async deleteWorldEvent(eventId) {
              if (!eventId) {
                  this.showTemporaryMessage('äº‹ä»¶IDæ— æ•ˆ', 'error');
                  return;
              }

              // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
              this.showCustomConfirm(
                  `ç¡®å®šè¦åˆ é™¤äº‹ä»¶ "${eventId}" å—ï¼Ÿ\n\næ­¤æ“ä½œå°†ä»ä¸–ç•Œå¤§äº‹åˆ—è¡¨ä¸­ç§»é™¤è¯¥äº‹ä»¶ï¼Œä¸”æ— æ³•æ’¤é”€ã€‚`,
                  async () => {
                      try {
                          // ç¬¬ä¸€æ­¥ï¼šè·å–æœ€æ–°çš„"æœ¬åœ°è‰ç¨¿"
                          const mvuData = this.currentMvuState;
                          if (!mvuData) {
                              this.showTemporaryMessage('æ— æ³•è·å–MVUçŠ¶æ€ï¼', 'error');
                              return;
                          }

                          // ç¬¬äºŒæ­¥ï¼šåœ¨"æœ¬åœ°è‰ç¨¿"ä¸Šè¿›è¡Œåˆ é™¤æ“ä½œ
                          const worldEvents = Mvu.getMvuVariable(mvuData, 'ä¸–ç•Œå¤§äº‹', { default_value: {} });
                          
                          // æ£€æŸ¥äº‹ä»¶æ˜¯å¦å­˜åœ¨
                          if (!worldEvents[eventId]) {
                              this.showTemporaryMessage(`äº‹ä»¶ "${eventId}" ä¸å­˜åœ¨`, 'warning');
                              return;
                          }

                          // æ‰§è¡Œåˆ é™¤
                          await Mvu.setMvuVariable(
                              mvuData,
                              `ä¸–ç•Œå¤§äº‹.${eventId}`,
                              undefined,
                              { reason: `åˆ é™¤ä¸–ç•Œå¤§äº‹ï¼š${eventId}` }
                          );

                          // ç¬¬ä¸‰æ­¥ï¼šå°†ä¿®æ”¹åçš„"æœ¬åœ°è‰ç¨¿"åŒæ­¥å›"äº‘ç«¯æ­£æœ¬"
                          await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                          // ç¬¬å››æ­¥ï¼šåˆ·æ–°UIå¹¶ç»™äºˆåé¦ˆ
                          this.showTemporaryMessage(`å·²æˆåŠŸåˆ é™¤äº‹ä»¶ "${eventId}"`, 'success');
                          
                          // æ›´æ–°å½“å‰æ•°æ®å¹¶é‡æ–°æ¸²æŸ“ï¼Œä¸å…³é—­æ¨¡æ€æ¡†
                          this.currentWorldEventsData = mvuData.stat_data;
                          this.renderWorldEventsUI(mvuData.stat_data);

                      } catch (error) {
                          console.error('åˆ é™¤äº‹ä»¶å¤±è´¥:', error);
                          this.showTemporaryMessage(`åˆ é™¤å¤±è´¥: ${error.message}`, 'error');
                      }
                  },
                  () => {
                      this.showTemporaryMessage('å·²å–æ¶ˆåˆ é™¤');
                  },
                  true // keepCurrentModal = trueï¼Œä¿æŒå½“å‰æ¨¡æ€æ¡†
              );
          },

          // åˆ é™¤äººç‰©å…³ç³»ï¼ˆé€šç”¨ç»„ä»¶ï¼‰
          async deleteCharacterFromRelationships(characterName) {
              if (!characterName) {
                  this.showTemporaryMessage('äººç‰©åç§°æ— æ•ˆ', 'error');
                  return;
              }

              // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
              this.showCustomConfirm(
                  `ç¡®å®šè¦åˆ é™¤ "${characterName}" å—ï¼Ÿ\n\næ­¤æ“ä½œå°†ä»äººç‰©å…³ç³»åˆ—è¡¨ä¸­ç§»é™¤è¯¥äººç‰©ï¼Œä¸”æ— æ³•æ’¤é”€ã€‚`,
                  async () => {
                      try {
                          // ç¬¬ä¸€æ­¥ï¼šè·å–æœ€æ–°çš„"æœ¬åœ°è‰ç¨¿"
                          const mvuData = this.currentMvuState;
                          if (!mvuData) {
                              this.showTemporaryMessage('æ— æ³•è·å–MVUçŠ¶æ€ï¼', 'error');
                              return;
                          }

                          // ç¬¬äºŒæ­¥ï¼šåœ¨"æœ¬åœ°è‰ç¨¿"ä¸Šè¿›è¡Œåˆ é™¤æ“ä½œ
                          const relationships = Mvu.getMvuVariable(mvuData, 'äººç‰©å…³ç³»åˆ—è¡¨', { default_value: {} });
                          
                          // æ£€æŸ¥äººç‰©æ˜¯å¦å­˜åœ¨
                          if (!relationships[characterName]) {
                              this.showTemporaryMessage(`äººç‰© "${characterName}" ä¸å­˜åœ¨`, 'warning');
                              return;
                          }

                          // æ‰§è¡Œåˆ é™¤
                          await Mvu.setMvuVariable(
                              mvuData,
                              `äººç‰©å…³ç³»åˆ—è¡¨.${characterName}`,
                              undefined,
                              { reason: `åˆ é™¤äººç‰©ï¼š${characterName}` }
                          );

                          // ç¬¬ä¸‰æ­¥ï¼šå°†ä¿®æ”¹åçš„"æœ¬åœ°è‰ç¨¿"åŒæ­¥å›"äº‘ç«¯æ­£æœ¬"
                          await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                          // ç¬¬å››æ­¥ï¼šåˆ·æ–°UIå¹¶ç»™äºˆåé¦ˆ
                          this.showTemporaryMessage(`å·²æˆåŠŸåˆ é™¤ "${characterName}"`, 'success');
                          
                          // å…³é—­è¯¦æƒ…é¢æ¿ï¼Œåˆ·æ–°åˆ—è¡¨
                          this.closeModal('relationships-modal');
                          setTimeout(() => {
                              this.showRelationships();
                          }, 300);

                      } catch (error) {
                          console.error('åˆ é™¤äººç‰©å¤±è´¥:', error);
                          this.showTemporaryMessage(`åˆ é™¤å¤±è´¥: ${error.message}`, 'error');
                      }
                  },
                  () => {
                      this.showTemporaryMessage('å·²å–æ¶ˆåˆ é™¤');
                  },
                  true // keepCurrentModal = trueï¼Œä¿æŒå½“å‰æ¨¡æ€æ¡†
              );
          },

          _renderMemorySection(characterData) {
              const memory = this.SafeGetValue(characterData, 'é‡è¦äº‹ä»¶è®°å½•', {});
              const entries = Object.entries(memory).filter(([name]) => name !== '$meta');
              if (entries.length === 0) {
                  return '<p class="modal-placeholder">å¾€äº‹å¦‚çƒŸï¼Œæ­¤äººå¿ƒä¸­æœªç•™ä¸‹æ·±åˆ»çš„è®°å¿†ã€‚</p>';
              }
              try {
                entries.sort((a, b) => {
                    const dateA = new Date(a[0].substring(a[0].indexOf('-') + 1));
                    const dateB = new Date(b[0].substring(b[0].indexOf('-') + 1));
                    return dateB - dateA;
                });
              } catch (e) {
                console.error("è§£æè®°å¿†äº‹ä»¶æ—¶é—´å¤±è´¥:", e);
              }

              let html = '<div class="memory-list-new">';
              entries.forEach(([time, details]) => {
                  const type = this.SafeGetValue(details, 'type', 'äº‹ä»¶');
                  const description = this.SafeGetValue(details, 'description', '...');
                  html += `
                      <div class="memory-event-new" data-memory-key="${time}">
                          <div class="event-dot"></div>
                          <div class="event-main-content">
                              <span class="event-time">${time}</span>
                              <span class="event-description">${description}</span>
                          </div>
                          <div class="event-type-tag">${type}</div>
                      </div>
                  `;
              });
              html += '</div>';
              return html;
          },

          _renderDaotuContent(characterData) {
              const daotuOrder = ['çœŸæ°”', 'ç­‘åŸºå¥‡ç‰©', 'æ´å¤©', 'ç¥å¦™', 'æœ¬å‘½ç¥å¦™', 'ä»™çµä¹‹æ°”'];
              let html = '';
              let hasContent = false;

              daotuOrder.forEach(key => {
                  const data = this.SafeGetValue(characterData, key, null);
                  if (data && (typeof data !== 'object' || Object.keys(data).filter(k => k !== '$meta').length > 0)) {
                      hasContent = true;
                      switch (key) {
                          case 'çœŸæ°”':
                              html += this._renderZhenqiSection(data);
                              break;
                          case 'ç­‘åŸºå¥‡ç‰©':
                              html += this._renderZhujiSection(data);
                              break;
                          case 'æ´å¤©':
                              html += this._renderDongtianSection(data);
                              break;
                          case 'æœ¬å‘½ç¥å¦™':
                              html += this._renderBenmingSection(data);
                              break;
                          case 'ç¥å¦™':
                              html += this._renderShenmiaoSection(data);
                              break;
                          case 'ä»™çµä¹‹æ°”':
                              html += this._renderXianlingqiSection(data);
                              break;
                      }
                  }
              });

              return hasContent ? html : '<p>é“é€”æ¼«æ¼«ï¼Œæ­¤äººå°šæœªç•™ä¸‹ç‹¬ç‰¹çš„è¶³è¿¹ã€‚</p>';
          },

          _renderZhenqiSection(data) {
              if (!data) return '';
              const title = 'çœŸæ°”';
              const name = Object.keys(data).find(k => k !== '$meta');
              if (!name) return '';
              const item = data[name];
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.å“é˜¶ || 'å‡¡å“';
              const style = this.getItemTierStyle(tier);

              let descriptiveFieldsHtml = '';
              const time = item.è·å–æ—¶é—´ || item.ç‚¼å°±æ—¶é—´ || item.å¼€è¾Ÿæ—¶é—´ || item.å‡ç»ƒæ—¶é—´;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>è·å¾—äº:</strong> ${time}</div>`;
              if (item.ç»å†) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>ç»å†:</strong> ${item.ç»å†}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.ç™¾åˆ†æ¯”åŠ æˆ) {
                  attributesHtml += Object.entries(item.ç™¾åˆ†æ¯”åŠ æˆ).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }

              let termsHtml = '';
              const effects = item.special_effects || item.è¯æ¡;
              if (effects && typeof effects === 'object') {
                  const termEntries = Object.entries(effects).filter(([key]) => key !== '$meta');
                  if (termEntries.length > 0) {
                      termsHtml += termEntries.map(([key, value]) => `<div class="info-item full-width"><strong>${key}:</strong> ${value.æè¿° || value}</div>`).join('');
                  }
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.æè¿° || ''}</div>
                  ${descriptiveFieldsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">æ¥å†</h4></div><div class="info-grid">${descriptiveFieldsHtml}</div>` : ''}
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">å±æ€§åŠ æˆ</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${termsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">è¯æ¡</h4></div><div class="info-grid">${termsHtml}</div>` : ''}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">ã€${tier}ã€‘ ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderBenmingSection(data) {
              if (!data) return '';
              const title = 'æœ¬å‘½ç¥å¦™';
              const name = Object.keys(data).find(k => k !== '$meta');
              if (!name) return '';
              const item = data[name];
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.å“é˜¶ || 'å‡¡å“';
              const style = this.getItemTierStyle(tier);
              
              let descriptiveFieldsHtml = '';
              const time = item.è·å–æ—¶é—´ || item.ç‚¼å°±æ—¶é—´ || item.å¼€è¾Ÿæ—¶é—´ || item.å‡ç»ƒæ—¶é—´;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>è·å¾—äº:</strong> ${time}</div>`;
              if (item.ç»å†) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>ç»å†:</strong> ${item.ç»å†}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.ç™¾åˆ†æ¯”åŠ æˆ) {
                  attributesHtml += Object.entries(item.ç™¾åˆ†æ¯”åŠ æˆ).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }

              let termsHtml = '';
              if (item.è¯æ¡ && typeof item.è¯æ¡ === 'object') {
                  const termEntries = Object.entries(item.è¯æ¡).filter(([key]) => key !== '$meta');
                  if (termEntries.length > 0) {
                      termsHtml += termEntries.map(([key, value]) => `<div class="info-item full-width"><strong>${key}:</strong> ${value.æè¿° || value}</div>`).join('');
                  }
              }

              let fusedShenmiaoHtml = '';
              if (item.èåˆç¥å¦™ && typeof item.èåˆç¥å¦™ === 'object') {
                  const fusedEntries = Object.entries(item.èåˆç¥å¦™).filter(([key]) => key !== '$meta');
                  if (fusedEntries.length > 0) {
                      fusedShenmiaoHtml += `<div class="content-divider"><h4 class="daotu-subtitle">èåˆç¥å¦™</h4></div>`;
                      fusedEntries.forEach(([fusedName, fusedData]) => {
                          const fusedTier = fusedData.å“é˜¶ || '';
                          const fusedDesc = fusedData.æè¿° || 'æš‚æ— æè¿°';
                          fusedShenmiaoHtml += `<div class="info-item full-width"><strong>${fusedName}</strong> ${fusedTier ? `ã€${fusedTier}ã€‘` : ''}: ${fusedDesc}</div>`;
                      });
                  }
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.æè¿° || ''}</div>
                  ${descriptiveFieldsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">æ¥å†</h4></div><div class="info-grid">${descriptiveFieldsHtml}</div>` : ''}
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">å±æ€§åŠ æˆ</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${termsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">è¯æ¡</h4></div><div class="info-grid">${termsHtml}</div>` : ''}
                  ${fusedShenmiaoHtml}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">ã€${tier}ã€‘ ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderZhujiSection(data) {
              if (!data) return '';
              const title = 'ç­‘åŸºå¥‡ç‰©';
              const name = Object.keys(data).find(k => k !== '$meta');
              if (!name) return '';
              const item = data[name];
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.å“é˜¶ || 'å‡¡å“';
              const style = this.getItemTierStyle(tier);

              let descriptiveFieldsHtml = '';
              const time = item.è·å–æ—¶é—´ || item.ç‚¼å°±æ—¶é—´ || item.å¼€è¾Ÿæ—¶é—´ || item.å‡ç»ƒæ—¶é—´;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>è·å¾—äº:</strong> ${time}</div>`;
              if (item.å¥‘åˆåº¦) descriptiveFieldsHtml += `<div class="info-item"><strong>å¥‘åˆåº¦:</strong> ${item.å¥‘åˆåº¦}</div>`;
              if (item.ç»å†) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>ç»å†:</strong> ${item.ç»å†}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.ç™¾åˆ†æ¯”åŠ æˆ) {
                  attributesHtml += Object.entries(item.ç™¾åˆ†æ¯”åŠ æˆ).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }

              let specialEffectsHtml = '';
              if (item.è¯æ¡ && Object.keys(item.è¯æ¡).filter(k => k !== '$meta').length > 0) {
                  specialEffectsHtml = `<div class="content-divider"><h4 class="daotu-subtitle">è¯æ¡</h4></div>` + Object.entries(item.è¯æ¡)
                      .filter(([key]) => key !== '$meta')
                      .map(([key, value]) => `<div class="info-item"><strong>${key}:</strong> ${value}</div>`)
                      .join('');
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.æè¿° || ''}</div>
                  <div class="info-grid">${descriptiveFieldsHtml}</div>
                  <div class="info-grid">${specialEffectsHtml}</div>
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">å±æ€§åŠ æˆ</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">ã€${tier}ã€‘ ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderDongtianSection(data) {
              if (!data) return '';
              const title = 'æ´å¤©';
              const name = Object.keys(data).find(k => k !== '$meta');
              if (!name) return '';
              const item = data[name];
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.å“é˜¶ || 'å‡¡å“';
              const style = this.getItemTierStyle(tier);

              let descriptiveFieldsHtml = '';
              const time = item.è·å–æ—¶é—´ || item.ç‚¼å°±æ—¶é—´ || item.å¼€è¾Ÿæ—¶é—´ || item.å‡ç»ƒæ—¶é—´;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>è·å¾—äº:</strong> ${time}</div>`;
              if (item.ç»å†) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>ç»å†:</strong> ${item.ç»å†}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.ç™¾åˆ†æ¯”åŠ æˆ) {
                  attributesHtml += Object.entries(item.ç™¾åˆ†æ¯”åŠ æˆ).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }

              let daohanHtml = '';
              if (item.é“ç—• && typeof item.é“ç—• === 'object') {
                  const daohanEntries = Object.entries(item.é“ç—•).filter(([key]) => key !== '$meta');
                  if (daohanEntries.length > 0) {
                      daohanHtml += `<div class="content-divider" style="margin-top:10px; padding-top:10px;"><h4 class="daotu-subtitle">é“ç—•</h4></div>`;
                      daohanEntries.forEach(([daohanName, daohanData]) => {
                          const daohanTier = daohanData.å“é˜¶ || '';
                          const daohanDesc = daohanData.æè¿° || 'æš‚æ— æè¿°';
                          daohanHtml += `<div class="info-item full-width"><strong>${daohanName}</strong> ${daohanTier ? `ã€${daohanTier}ã€‘` : ''}: ${daohanDesc}`;
                          
                          // æ–°å¢ï¼šæ¸²æŸ“é“ç—•è¯æ¡
                          if (daohanData.é“ç—•è¯æ¡ && typeof daohanData.é“ç—•è¯æ¡ === 'object') {
                              const termsEntries = Object.entries(daohanData.é“ç—•è¯æ¡).filter(([key]) => key !== '$meta');
                              if (termsEntries.length > 0) {
                                  daohanHtml += `<div class="daotu-terms">`;
                                  termsEntries.forEach(([termName, termData]) => {
                                      daohanHtml += `<div class="term-item"><strong>${termName}:</strong> ${termData.æè¿° || termData}</div>`;
                                  });
                                  daohanHtml += `</div>`;
                              }
                          }
                          daohanHtml += `</div>`;
                      });
                  }
              }
              
              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.æè¿° || ''}</div>
                  ${descriptiveFieldsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">æ¥å†</h4></div><div class="info-grid">${descriptiveFieldsHtml}</div>` : ''}
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">å±æ€§åŠ æˆ</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${daohanHtml}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">ã€${tier}ã€‘ ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderShenmiaoSection(data) {
              if (!data || typeof data !== 'object') return '';
              const title = 'ç¥å¦™';
              let html = '';
              const shenmiaoEntries = Object.entries(data).filter(([key]) => key !== '$meta');
              if (shenmiaoEntries.length === 0) return '';
              
              shenmiaoEntries.forEach(([name, item]) => {
                  html += this._renderSingleShenmiao(title, name, item);
              });
              return html;
          },

          _renderSingleShenmiao(title, name, item) {
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.å“é˜¶ || 'å‡¡å“';
              const style = this.getItemTierStyle(tier);

              let descriptiveFieldsHtml = '';
              const time = item.è·å–æ—¶é—´ || item.ç‚¼å°±æ—¶é—´ || item.å¼€è¾Ÿæ—¶é—´ || item.å‡ç»ƒæ—¶é—´;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>è·å¾—äº:</strong> ${time}</div>`;
              if (item.ç»å†) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>ç»å†:</strong> ${item.ç»å†}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.ç™¾åˆ†æ¯”åŠ æˆ) {
                  attributesHtml += Object.entries(item.ç™¾åˆ†æ¯”åŠ æˆ).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }

              let termsHtml = '';
              if (item.è¯æ¡ && typeof item.è¯æ¡ === 'object') {
                  const termEntries = Object.entries(item.è¯æ¡).filter(([key]) => key !== '$meta');
                  if (termEntries.length > 0) {
                      termsHtml += termEntries.map(([key, value]) => `<div class="info-item full-width"><strong>${key}:</strong> ${value.æè¿° || value}</div>`).join('');
                  }
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.æè¿° || ''}</div>
                  ${descriptiveFieldsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">æ¥å†</h4></div><div class="info-grid">${descriptiveFieldsHtml}</div>` : ''}
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">å±æ€§åŠ æˆ</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${termsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">è¯æ¡</h4></div><div class="info-grid">${termsHtml}</div>` : ''}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">ã€${tier}ã€‘ ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderGongfaSection(characterData) {
              const mainGongfaData = this.SafeGetValue(characterData, 'ä¸»ä¿®åŠŸæ³•', null);
              const subGongfaData = this.SafeGetValue(characterData, 'è¾…ä¿®åŠŸæ³•', null);

              let html = '';
              let hasGongfa = false;

              if (mainGongfaData && typeof mainGongfaData === 'object') {
                  const mainEntries = Object.entries(mainGongfaData).filter(([key]) => key !== '$meta');
                  if (mainEntries.length > 0) {
                      const [name, item] = mainEntries[0];
                      html += this._renderSingleGongfa('ä¸»ä¿®åŠŸæ³•', name, item);
                      hasGongfa = true;
                  }
              }

              if (subGongfaData && typeof subGongfaData === 'object') {
                  const subEntries = Object.entries(subGongfaData).filter(([key]) => key !== '$meta');
                  if (subEntries.length > 0) {
                      const [name, item] = subEntries[0];
                      html += this._renderSingleGongfa('è¾…ä¿®åŠŸæ³•', name, item);
                      hasGongfa = true;
                  }
              }

              return hasGongfa ? html : '<p>æ­¤äººå°šæœªä¿®è¡Œä»»ä½•åŠŸæ³•ã€‚</p>';
          },

          _renderSingleGongfa(title, name, item) {
              if (!item || typeof item !== 'object' || Object.keys(item).length === 0) return '';
              const uniqueId = `toggle-gongfa-${title}-${name.replace(/\s/g, '-')}`;
              const tier = item.tier || item.å“é˜¶ || 'å‡¡å“';
              const style = this.getItemTierStyle(tier);

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.ç™¾åˆ†æ¯”åŠ æˆ) {
                  attributesHtml += Object.entries(item.ç™¾åˆ†æ¯”åŠ æˆ).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }

              let proficiencyHtml = '';
              const proficiency = item.proficiency;
              if (proficiency && typeof proficiency === 'object') {
                  const current = proficiency.current || 0;
                  const max = proficiency.max || 100;
                  const percentage = max > 0 ? Math.round((current / max) * 100) : 0;
                  proficiencyHtml += `<div class="info-item full-width"><strong>ç†Ÿç»ƒåº¦:</strong> ${current} / ${max} (${percentage}%)</div>`;
              }

              let skillEffectsHtml = '';
              const skillEffects = item.skill_effects;
              if (skillEffects && typeof skillEffects === 'object') {
                  const effectEntries = Object.entries(skillEffects).filter(([key]) => key !== '$meta');
                  if (effectEntries.length > 0) {
                      skillEffectsHtml += effectEntries.map(([key, effect]) => {
                          if (typeof effect === 'object' && effect !== null) {
                              const effectName = effect.name || key;
                              const description = effect.description || '';
                              return `<div class="info-item full-width">- <strong>${effectName}:</strong> ${description}</div>`;
                          } else {
                              return `<div class="info-item full-width">- <strong>${key}:</strong> ${effect}</div>`;
                          }
                      }).join('');
                  }
              }

              let skillMovesHtml = '';
              const skillMoves = item.skill_moves;
              if (skillMoves && typeof skillMoves === 'object') {
                  const moveEntries = Object.entries(skillMoves).filter(([key]) => key !== '$meta');
                  if (moveEntries.length > 0) {
                      skillMovesHtml += moveEntries.map(([key, move]) => {
                          if (typeof move === 'object' && move !== null) {
                              const moveName = move.name || key;
                              const description = move.description || '';
                              return `<div class="info-item full-width">- <strong>${moveName}:</strong> ${description}</div>`;
                          } else {
                              return `<div class="info-item full-width">- <strong>${key}:</strong> ${move}</div>`;
                          }
                      }).join('');
                  }
              }

              let termsHtml = '';
              const effects = item.special_effects || item.è¯æ¡;
              if (effects && typeof effects === 'object') {
                  const termEntries = Object.entries(effects).filter(([key]) => key !== '$meta');
                  if (termEntries.length > 0) {
                      termsHtml += termEntries.map(([key, value]) => {
                          // å…¼å®¹åµŒå¥—æ ¼å¼
                          if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                              let nestedHtml = `<div class="info-item full-width">- <strong>${key}:</strong></div>`;
                              const nestedEntries = Object.entries(value).filter(([k]) => k !== '$meta');
                              nestedEntries.forEach(([subKey, subValue]) => {
                                  nestedHtml += `<div class="info-item full-width" style="margin-left: 20px;">- <strong>${subKey}:</strong> ${subValue}</div>`;
                              });
                              return nestedHtml;
                          } else {
                              return `<div class="info-item full-width">- <strong>${key}:</strong> ${value.æè¿° || value}</div>`;
                          }
                      }).join('');
                  }
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.æè¿° || ''}</div>
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">å±æ€§åŠ æˆ</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${proficiencyHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">ç†Ÿç»ƒåº¦</h4></div><div class="info-grid">${proficiencyHtml}</div>` : ''}
                  ${skillEffectsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">åŠŸæ³•æ•ˆæœ</h4></div><div class="info-grid">${skillEffectsHtml}</div>` : ''}
                  ${skillMovesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">åŠŸæ³•æ‹›å¼</h4></div><div class="info-grid">${skillMovesHtml}</div>` : ''}
                  ${termsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">ç‰¹æ®Šè¯æ¡</h4></div><div class="info-grid">${termsHtml}</div>` : ''}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">ã€${tier}ã€‘ ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderEquipmentSection(characterData) {
              const equipmentKeys = ['æ­¦å™¨', 'é˜²å…·', 'é¥°å“', 'æ³•å®'];
              let html = '';
              let hasEquipment = false;

              equipmentKeys.forEach(key => {
                  const equipmentData = this.SafeGetValue(characterData, key, null);
                  if (equipmentData && typeof equipmentData === 'object') {
                      const entries = Object.entries(equipmentData).filter(([k]) => k !== '$meta');
                      if (entries.length > 0) {
                          const [name, item] = entries[0];
                          html += this._renderSingleGongfa(key, name, item); // å¤ç”¨åŠŸæ³•çš„æ¸²æŸ“é€»è¾‘
                          hasEquipment = true;
                      }
                  }
              });

              return hasEquipment ? html : '<p>æ­¤äººæœªç€å¯¸ç¼•ï¼Œäº¦æ— æ³•å®å‚èº«ã€‚</p>';
          },

          _renderInventorySection(characterData) {
              const inventoryData = this.SafeGetValue(characterData, 'å‚¨ç‰©è¢‹', null);
              if (!inventoryData || typeof inventoryData !== 'object') {
                  return '<p class="modal-placeholder" style="text-align:center;">æ­¤äººèº«æ— é•¿ç‰©ï¼Œå‚¨ç‰©è¢‹ç©ºç©ºå¦‚ä¹Ÿã€‚</p>';
              }

              const itemEntries = Object.entries(inventoryData).filter(([key]) => key !== '$meta');

              if (itemEntries.length === 0) {
                  return '<p class="modal-placeholder" style="text-align:center;">æ­¤äººèº«æ— é•¿ç‰©ï¼Œå‚¨ç‰©è¢‹ç©ºç©ºå¦‚ä¹Ÿã€‚</p>';
              }

              let html = '<div class="inventory-item-list">';
              const sortedItems = this.sortByTier(itemEntries, ([, item]) => this.SafeGetValue(item, 'tier', 'å‡¡å“'));
              
              sortedItems.forEach(([name, item]) => {
                  html += this._renderInventoryItem(name, item);
              });
              html += '</div>';

              return html;
          },

          _renderInventoryItem(name, item) {
              if (!item || typeof item !== 'object') return '';

              const tier = this.SafeGetValue(item, 'tier', 'å‡¡å“');
              const tierStyle = this.getItemTierStyle(tier);
              const quantity = this.SafeGetValue(item, 'quantity', 1);
              const quantityDisplay = quantity > 1 ? `<span class="item-quantity">x${quantity}</span>` : '';
              const description = this.SafeGetValue(item, 'description', this.SafeGetValue(item, 'effect', 'æ— æè¿°'));
              
              const tierDisplay = tier !== 'æ— ' ? `<span style="${tierStyle}">å“é˜¶: ${tier}</span>` : '';

              let detailsHtml = '';
              const attributes = this.SafeGetValue(item, 'attributes_bonus', null);
              const percentage = this.SafeGetValue(item, 'ç™¾åˆ†æ¯”åŠ æˆ', null);
              
              if (attributes) {
                  detailsHtml += Object.entries(attributes).map(([key, value]) => `<div>${key}: +${value}</div>`).join('');
              }
              if (percentage) {
                  detailsHtml += Object.entries(percentage).map(([key, value]) => `<div>${key}: +${value}</div>`).join('');
              }

              const proficiency = item.proficiency;
              if (proficiency && typeof proficiency === 'object') {
                  const current = proficiency.current || 0;
                  const max = proficiency.max || 100;
                  const percentageVal = max > 0 ? Math.round((current / max) * 100) : 0;
                  detailsHtml += `<div><strong>ç†Ÿç»ƒåº¦:</strong> ${current} / ${max} (${percentageVal}%)</div>`;
              }

              const skillEffects = item.skill_effects;
              if (skillEffects && typeof skillEffects === 'object') {
                  const effectEntries = Object.entries(skillEffects).filter(([key]) => key !== '$meta');
                  if (effectEntries.length > 0) {
                      detailsHtml += '<div style="margin-top: 8px;"><strong>åŠŸæ³•æ•ˆæœ:</strong></div>';
                      effectEntries.forEach(([key, effect]) => {
                          if (typeof effect === 'object' && effect !== null) {
                              const effectName = effect.name || key;
                              const effectDesc = effect.description || '';
                              detailsHtml += `<div style="margin-left: 15px;">- <strong>${effectName}:</strong> ${effectDesc}</div>`;
                          } else {
                              detailsHtml += `<div style="margin-left: 15px;">- <strong>${key}:</strong> ${effect}</div>`;
                          }
                      });
                  }
              }

              const skillMoves = item.skill_moves;
              if (skillMoves && typeof skillMoves === 'object') {
                  const moveEntries = Object.entries(skillMoves).filter(([key]) => key !== '$meta');
                  if (moveEntries.length > 0) {
                      detailsHtml += '<div style="margin-top: 8px;"><strong>åŠŸæ³•æ‹›å¼:</strong></div>';
                      moveEntries.forEach(([key, move]) => {
                          if (typeof move === 'object' && move !== null) {
                              const moveName = move.name || key;
                              const moveDesc = move.description || '';
                              detailsHtml += `<div style="margin-left: 15px;">- <strong>${moveName}:</strong> ${moveDesc}</div>`;
                          } else {
                              detailsHtml += `<div style="margin-left: 15px;">- <strong>${key}:</strong> ${move}</div>`;
                          }
                      });
                  }
              }

              const effects = item.special_effects || item.è¯æ¡;
              if (effects && typeof effects === 'object') {
                  detailsHtml += Object.entries(effects).filter(([key]) => key !== '$meta').map(([key, value]) => {
                      // å…¼å®¹åµŒå¥—æ ¼å¼
                      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                          let nestedHtml = `<div>- <strong>${key}:</strong></div>`;
                          const nestedEntries = Object.entries(value).filter(([k]) => k !== '$meta');
                          nestedEntries.forEach(([subKey, subValue]) => {
                              nestedHtml += `<div style="margin-left: 15px;">- <strong>${subKey}:</strong> ${subValue}</div>`;
                          });
                          return nestedHtml;
                      } else {
                          return `<div>- <strong>${key}:</strong> ${value.æè¿° || value}</div>`;
                      }
                  }).join('');
              }

              return `
                  <div class="inventory-item" data-item-name="${name}">
                      <div class="inventory-item-actions">
                          <button class="inventory-action-btn" data-action="request" data-item-name="${name}">è¯·æ±‚èµ äºˆ</button>
                          <button class="inventory-action-btn" data-action="trade" data-item-name="${name}">äº¤æ˜“</button>
                          <button class="inventory-action-btn" data-action="ask" data-item-name="${name}">è¯¢é—®</button>
                          <button class="inventory-action-btn" data-action="steal" data-item-name="${name}">ç›—å–</button>
                      </div>
                      <div class="item-header">
                          <div class="item-name" style="${tierStyle}">${name}</div>
                          <div class="item-meta">
                              ${tierDisplay}
                              ${quantityDisplay}
                          </div>
                      </div>
                      <div class="item-description">${description}</div>
                      ${detailsHtml ? `<div class="item-details">${detailsHtml}</div>` : ''}
                  </div>
              `;
          },

          _renderXianlingqiSection(data) {
             if (!data || data <= 0) return '';
             return `<div class="info-section"><h4>ä»™çµä¹‹æ°”</h4><div class="info-grid"><div class="info-item">${data}</div></div></div>`;
          },

           updateCharacterDetailsBackground(imageUrl, opacity) {
               const styleId = 'character-details-bg-style';
               let styleElement = document.getElementById(styleId);
               if (!styleElement) {
                   styleElement = document.createElement('style');
                   styleElement.id = styleId;
                   document.head.appendChild(styleElement);
               }
               
               let styleContent = '';
               if (imageUrl) {
                   styleContent = `
                       .character-details-panel::before {
                           background-image: url(${imageUrl});
                           opacity: ${opacity};
                       }
                   `;
               } else {
                   styleContent = `
                       .character-details-panel::before {
                           background-image: none;
                       }
                   `;
               }
               styleElement.textContent = styleContent;
           },

          bindRelationshipEvents() {
              const searchIcon = document.querySelector('#relationships-modal .header-icon[title="æœç´¢"]');
              const searchInput = document.querySelector('#relationships-modal .character-search-input');
              const listHeader = document.querySelector('#relationships-modal .character-list-header');

              if (searchIcon && searchInput && listHeader) {
                  // é˜²æ­¢é‡å¤ç»‘å®š
                  if (!searchIcon.dataset.listenerAttached) {
                      searchIcon.addEventListener('click', () => {
                          listHeader.classList.toggle('is-searching');
                          if (listHeader.classList.contains('is-searching')) {
                              searchInput.focus();
                          }
                      });
                      searchInput.addEventListener('input', () => {
                          this.renderCharacterList();
                      });
                      searchIcon.dataset.listenerAttached = 'true';
                  }
              }

              const listPanel = document.querySelector('#relationships-modal .character-list');
              if(listPanel) {
                  listPanel.addEventListener('click', (e) => {
                      const card = e.target.closest('.character-card');
                      if (card && card.dataset.characterName) {
                          // ç§»é™¤å…¶ä»–å¡ç‰‡çš„activeçŠ¶æ€
                          listPanel.querySelectorAll('.character-card').forEach(c => c.classList.remove('active'));
                          // ç»™å½“å‰å¡ç‰‡æ·»åŠ activeçŠ¶æ€
                          card.classList.add('active');
                          // ä¿å­˜é€‰æ‹©åˆ°localStorage
                          const characterName = card.dataset.characterName;
                          this.lastSelectedCharacter = characterName;
                          localStorage.setItem('guixu_last_selected_character', characterName);
                          // æ˜¾ç¤ºè¯¦æƒ…
                          this.renderCharacterDetails(characterName);
                      }
                  });
              }

              // â€œæ·»åŠ â€æŒ‰é’®äº‹ä»¶ç»‘å®š
              const addIcon = document.querySelector('#relationships-modal .header-icon[title="æ·»åŠ "]');
              if (addIcon && !addIcon.dataset.listenerAttached) {
                  addIcon.addEventListener('click', () => {
                      this.showRelationshipEditor();
                  });
                  addIcon.dataset.listenerAttached = 'true';
              }

              // æ’åºä¸‹æ‹‰èœå•äº‹ä»¶ç»‘å®š
              const sortDropdown = document.querySelector('#relationships-modal .sort-dropdown');
              if (sortDropdown && !sortDropdown.dataset.listenerAttached) {
                  const sortIcon = sortDropdown.querySelector('.header-icon');
                  const sortMenu = sortDropdown.querySelector('.sort-menu');

                  sortIcon.addEventListener('click', (e) => {
                      e.stopPropagation();
                      sortMenu.classList.toggle('active');
                  });

                  sortMenu.addEventListener('click', (e) => {
                      const option = e.target.closest('.sort-option');
                      if (option && option.dataset.sort) {
                          this.relationshipSortType = option.dataset.sort;
                          this.saveRelationshipSortSettings();
                          this.renderCharacterList();
                          
                          // æ›´æ–°é€‰ä¸­çŠ¶æ€
                          sortMenu.querySelectorAll('.sort-option').forEach(opt => opt.classList.remove('selected'));
                          option.classList.add('selected');

                          sortMenu.classList.remove('active');
                      }
                  });

                  // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
                  document.addEventListener('click', (e) => {
                      if (!sortDropdown.contains(e.target)) {
                          sortMenu.classList.remove('active');
                      }
                  });

                  sortDropdown.dataset.listenerAttached = 'true';
              }

              const detailsPanel = document.querySelector('#relationships-modal .character-details-panel');
              if(detailsPanel) {
                  // ç§»é™¤æ—§çš„ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                  if (detailsPanel._clickHandler) {
                      detailsPanel.removeEventListener('click', detailsPanel._clickHandler);
                  }
                  
                  // åˆ›å»ºæ–°çš„äº‹ä»¶å¤„ç†å™¨
                  detailsPanel._clickHandler = (e) => {
                      const tab = e.target.closest('.tab-button');
                      if (tab && tab.dataset.tab) {
                          detailsPanel.querySelectorAll('.tab-button').forEach(t => t.classList.remove('active'));
                          tab.classList.add('active');

                          detailsPanel.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
                          const targetPane = detailsPanel.querySelector(`#tab-${tab.dataset.tab}`);
                          if (targetPane) {
                              targetPane.classList.add('active');
                              // è®°å½•å½“å‰æ¿€æ´»çš„tabå¹¶ä¿å­˜åˆ°localStorage
                              this.currentRelationshipTab = tab.dataset.tab;
                              localStorage.setItem('guixu_relationship_tab', tab.dataset.tab);
                          }
                      }

                      // å‚¨ç‰©è¢‹æ“ä½œæŒ‰é’®ç‚¹å‡»äº‹ä»¶
                      const actionBtn = e.target.closest('.inventory-action-btn');
                      if (actionBtn) {
                          e.stopPropagation();
                          const action = actionBtn.dataset.action;
                          const itemName = actionBtn.dataset.itemName;
                          const characterName = document.querySelector('#relationships-modal .character-card.active')?.dataset.characterName;
                          
                          if (characterName && itemName) {
                              this.handleInventoryAction(action, itemName, characterName);
                          }
                      }
                  };
                  
                  // ç»‘å®šæ–°çš„äº‹ä»¶å¤„ç†å™¨
                  detailsPanel.addEventListener('click', detailsPanel._clickHandler);

                  // å‚¨ç‰©è¢‹ç‰©å“é•¿æŒ‰åˆ é™¤äº‹ä»¶ - ä½¿ç”¨è¾¹æ¡†åŠ¨ç”»
                  let inventoryLongPressTimer = null;
                  const inventoryLongPressDuration = 3000;

                  const handleInventoryPressStart = (e, item) => {
                      if (!item || e.target.closest('.inventory-action-btn')) return;

                      const oldIndicator = document.getElementById('inventory-long-press-indicator');
                      if (oldIndicator) oldIndicator.remove();

                      const rect = item.getBoundingClientRect();
                      const indicator = document.createElement('div');
                      indicator.id = 'inventory-long-press-indicator';
                      Object.assign(indicator.style, {
                          position: 'fixed',
                          top: `${rect.top}px`,
                          left: `${rect.left}px`,
                          width: `${rect.width}px`,
                          height: `${rect.height}px`,
                          pointerEvents: 'none',
                          zIndex: '9999',
                          borderRadius: '4px'
                      });

                      const borderTop = document.createElement('div');
                      Object.assign(borderTop.style, { position: 'absolute', top: '0', left: '0', width: '0', height: '2px', backgroundColor: '#ff6b6b', animation: `border-top-anim ${inventoryLongPressDuration / 4000}s linear forwards` });
                      
                      const borderRight = document.createElement('div');
                      Object.assign(borderRight.style, { position: 'absolute', top: '0', right: '0', width: '2px', height: '0', backgroundColor: '#ff6b6b', animation: `border-right-anim ${inventoryLongPressDuration / 4000}s linear forwards ${inventoryLongPressDuration / 4000}s` });
                      
                      const borderBottom = document.createElement('div');
                      Object.assign(borderBottom.style, { position: 'absolute', bottom: '0', right: '0', width: '0', height: '2px', backgroundColor: '#ff6b6b', animation: `border-bottom-anim ${inventoryLongPressDuration / 4000}s linear forwards ${inventoryLongPressDuration / 2000}s` });

                      const borderLeft = document.createElement('div');
                      Object.assign(borderLeft.style, { position: 'absolute', bottom: '0', left: '0', width: '2px', height: '0', backgroundColor: '#ff6b6b', animation: `border-left-anim ${inventoryLongPressDuration / 4000}s linear forwards ${inventoryLongPressDuration * 3 / 4000}s` });

                      indicator.append(borderTop, borderRight, borderBottom, borderLeft);
                      document.body.appendChild(indicator);
                      
                      inventoryLongPressTimer = setTimeout(() => {
                          const itemName = item.dataset.itemName;
                          const characterName = document.querySelector('#relationships-modal .character-card.active')?.dataset.characterName;
                          if (itemName && characterName) {
                              this.deleteInventoryItem(characterName, itemName);
                          }
                          inventoryLongPressTimer = null;
                          const existingIndicator = document.getElementById('inventory-long-press-indicator');
                          if (existingIndicator) existingIndicator.remove();
                      }, inventoryLongPressDuration);
                  };

                  const removeInventoryIndicator = () => {
                      const existingIndicator = document.getElementById('inventory-long-press-indicator');
                      if (existingIndicator) existingIndicator.remove();
                  };

                  const handleInventoryPressEnd = () => {
                      removeInventoryIndicator();
                      if (inventoryLongPressTimer) {
                          clearTimeout(inventoryLongPressTimer);
                          inventoryLongPressTimer = null;
                      }
                  };

                  // è®°å¿†äº‹ä»¶é•¿æŒ‰åˆ é™¤äº‹ä»¶ - ä½¿ç”¨è¾¹æ¡†åŠ¨ç”»
                  let memoryLongPressTimer = null;
                  const memoryLongPressDuration = 3000;

                  const handleMemoryPressStart = (e, memoryEvent) => {
                      if (!memoryEvent) return;

                      const oldIndicator = document.getElementById('memory-long-press-indicator');
                      if (oldIndicator) oldIndicator.remove();

                      const rect = memoryEvent.getBoundingClientRect();
                      const indicator = document.createElement('div');
                      indicator.id = 'memory-long-press-indicator';
                      Object.assign(indicator.style, {
                          position: 'fixed',
                          top: `${rect.top}px`,
                          left: `${rect.left}px`,
                          width: `${rect.width}px`,
                          height: `${rect.height}px`,
                          pointerEvents: 'none',
                          zIndex: '9999',
                          borderRadius: '6px'
                      });

                      const borderTop = document.createElement('div');
                      Object.assign(borderTop.style, { position: 'absolute', top: '0', left: '0', width: '0', height: '2px', backgroundColor: '#ff6b6b', animation: `border-top-anim ${memoryLongPressDuration / 4000}s linear forwards` });
                      
                      const borderRight = document.createElement('div');
                      Object.assign(borderRight.style, { position: 'absolute', top: '0', right: '0', width: '2px', height: '0', backgroundColor: '#ff6b6b', animation: `border-right-anim ${memoryLongPressDuration / 4000}s linear forwards ${memoryLongPressDuration / 4000}s` });
                      
                      const borderBottom = document.createElement('div');
                      Object.assign(borderBottom.style, { position: 'absolute', bottom: '0', right: '0', width: '0', height: '2px', backgroundColor: '#ff6b6b', animation: `border-bottom-anim ${memoryLongPressDuration / 4000}s linear forwards ${memoryLongPressDuration / 2000}s` });

                      const borderLeft = document.createElement('div');
                      Object.assign(borderLeft.style, { position: 'absolute', bottom: '0', left: '0', width: '2px', height: '0', backgroundColor: '#ff6b6b', animation: `border-left-anim ${memoryLongPressDuration / 4000}s linear forwards ${memoryLongPressDuration * 3 / 4000}s` });

                      indicator.append(borderTop, borderRight, borderBottom, borderLeft);
                      document.body.appendChild(indicator);
                      
                      memoryLongPressTimer = setTimeout(() => {
                          const memoryKey = memoryEvent.dataset.memoryKey;
                          const characterName = document.querySelector('#relationships-modal .character-card.active')?.dataset.characterName;
                          if (memoryKey && characterName) {
                              this.deleteMemoryEvent(characterName, memoryKey);
                          }
                          memoryLongPressTimer = null;
                          const existingIndicator = document.getElementById('memory-long-press-indicator');
                          if (existingIndicator) existingIndicator.remove();
                      }, memoryLongPressDuration);
                  };

                  const removeMemoryIndicator = () => {
                      const existingIndicator = document.getElementById('memory-long-press-indicator');
                      if (existingIndicator) existingIndicator.remove();
                  };

                  const handleMemoryPressEnd = () => {
                      removeMemoryIndicator();
                      if (memoryLongPressTimer) {
                          clearTimeout(memoryLongPressTimer);
                          memoryLongPressTimer = null;
                      }
                  };

                  // ç§»é™¤æ—§çš„é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                  if (detailsPanel._mousedownHandler) {
                      detailsPanel.removeEventListener('mousedown', detailsPanel._mousedownHandler);
                  }
                  if (detailsPanel._mouseupHandler) {
                      detailsPanel.removeEventListener('mouseup', detailsPanel._mouseupHandler);
                  }
                  if (detailsPanel._mouseleaveHandler) {
                      detailsPanel.removeEventListener('mouseleave', detailsPanel._mouseleaveHandler);
                  }
                  if (detailsPanel._touchstartHandler) {
                      detailsPanel.removeEventListener('touchstart', detailsPanel._touchstartHandler);
                  }
                  if (detailsPanel._touchendHandler) {
                      detailsPanel.removeEventListener('touchend', detailsPanel._touchendHandler);
                  }
                  if (detailsPanel._touchcancelHandler) {
                      detailsPanel.removeEventListener('touchcancel', detailsPanel._touchcancelHandler);
                  }
                  
                  // åˆ›å»ºå¹¶ä¿å­˜æ–°çš„äº‹ä»¶å¤„ç†å™¨
                  detailsPanel._mousedownHandler = (e) => {
                      const inventoryItem = e.target.closest('.inventory-item');
                      if (inventoryItem) {
                          handleInventoryPressStart(e, inventoryItem);
                      }
                      
                      const memoryEvent = e.target.closest('.memory-event-new');
                      if (memoryEvent) {
                          handleMemoryPressStart(e, memoryEvent);
                      }
                  };
                  
                  detailsPanel._mouseupHandler = () => {
                      handleInventoryPressEnd();
                      handleMemoryPressEnd();
                  };
                  
                  detailsPanel._mouseleaveHandler = () => {
                      handleInventoryPressEnd();
                      handleMemoryPressEnd();
                  };
                  
                  // è§¦æ‘¸äº‹ä»¶å¤„ç†å™¨
                  detailsPanel._touchstartHandler = (e) => {
                      const inventoryItem = e.target.closest('.inventory-item');
                      if (inventoryItem) {
                          handleInventoryPressStart(e, inventoryItem);
                      }
                      
                      const memoryEvent = e.target.closest('.memory-event-new');
                      if (memoryEvent) {
                          handleMemoryPressStart(e, memoryEvent);
                      }
                  };
                  
                  detailsPanel._touchendHandler = () => {
                      handleInventoryPressEnd();
                      handleMemoryPressEnd();
                  };
                  
                  detailsPanel._touchcancelHandler = () => {
                      handleInventoryPressEnd();
                      handleMemoryPressEnd();
                  };
                  
                  // ç»‘å®šæ–°çš„äº‹ä»¶å¤„ç†å™¨
                  detailsPanel.addEventListener('mousedown', detailsPanel._mousedownHandler);
                  detailsPanel.addEventListener('mouseup', detailsPanel._mouseupHandler);
                  detailsPanel.addEventListener('mouseleave', detailsPanel._mouseleaveHandler);
                  detailsPanel.addEventListener('touchstart', detailsPanel._touchstartHandler, { passive: true });
                  detailsPanel.addEventListener('touchend', detailsPanel._touchendHandler);
                  detailsPanel.addEventListener('touchcancel', detailsPanel._touchcancelHandler);
              }
          },

          // å¤„ç†å‚¨ç‰©è¢‹æ“ä½œæŒ‰é’®ç‚¹å‡»
          handleInventoryAction(action, itemName, characterName) {
              let commandText = '';
              switch (action) {
                  case 'request':
                      commandText = `[è¡ŒåŠ¨] æˆ‘å‘ ${characterName} è¯·æ±‚èµ äºˆç‰©å“ã€${itemName}ã€‘ã€‚`;
                      break;
                  case 'trade':
                      commandText = `[è¡ŒåŠ¨] æˆ‘å‘ ${characterName} æå‡ºäº¤æ˜“ç‰©å“ã€${itemName}ã€‘ã€‚`;
                      break;
                  case 'ask':
                      commandText = `[è¡ŒåŠ¨] æˆ‘å‘ ${characterName} è¯¢é—®å…³äºç‰©å“ã€${itemName}ã€‘çš„ä¿¡æ¯ã€‚`;
                      break;
                  case 'steal':
                      commandText = `[è¡ŒåŠ¨] æˆ‘å°è¯•ä» ${characterName} å¤„ç›—å–ç‰©å“ã€${itemName}ã€‘ã€‚`;
                      break;
              }
              
              if (commandText) {
                  this.addCommand(commandText);
                  this.showTemporaryMessage(`å·²æ·»åŠ æŒ‡ä»¤åˆ°æŒ‡ä»¤ä¸­å¿ƒ`, 'success');
              }
          },

          // åˆ é™¤å‚¨ç‰©è¢‹ç‰©å“
          async deleteInventoryItem(characterName, itemName) {
              if (!characterName || !itemName) {
                  this.showTemporaryMessage('å‚æ•°æ— æ•ˆ', 'error');
                  return;
              }

              try {
                  const mvuData = this.currentMvuState;
                  if (!mvuData) {
                      this.showTemporaryMessage('æ— æ³•è·å–MVUçŠ¶æ€ï¼', 'error');
                      return;
                  }

                  const inventory = Mvu.getMvuVariable(mvuData, `äººç‰©å…³ç³»åˆ—è¡¨.${characterName}.å‚¨ç‰©è¢‹`, { default_value: {} });
                  
                  if (!inventory[itemName]) {
                      this.showTemporaryMessage(`ç‰©å“ "${itemName}" ä¸å­˜åœ¨`, 'warning');
                      return;
                  }

                  await Mvu.setMvuVariable(
                      mvuData,
                      `äººç‰©å…³ç³»åˆ—è¡¨.${characterName}.å‚¨ç‰©è¢‹.${itemName}`,
                      undefined,
                      { reason: `åˆ é™¤${characterName}çš„å‚¨ç‰©è¢‹ç‰©å“ï¼š${itemName}` }
                  );

                  await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                  this.showTemporaryMessage(`å·²åˆ é™¤ç‰©å“ "${itemName}"`, 'success');
                  
                  // åˆ·æ–°è¯¦æƒ…é¢æ¿
                  setTimeout(() => {
                      this.renderCharacterDetails(characterName);
                  }, 100);

              } catch (error) {
                  console.error('åˆ é™¤ç‰©å“å¤±è´¥:', error);
                  this.showTemporaryMessage(`åˆ é™¤å¤±è´¥: ${error.message}`, 'error');
              }
          },

          // åˆ é™¤è®°å¿†äº‹ä»¶
          async deleteMemoryEvent(characterName, memoryKey) {
              if (!characterName || !memoryKey) {
                  this.showTemporaryMessage('å‚æ•°æ— æ•ˆ', 'error');
                  return;
              }

              try {
                  const mvuData = this.currentMvuState;
                  if (!mvuData) {
                      this.showTemporaryMessage('æ— æ³•è·å–MVUçŠ¶æ€ï¼', 'error');
                      return;
                  }

                  const memory = Mvu.getMvuVariable(mvuData, `äººç‰©å…³ç³»åˆ—è¡¨.${characterName}.é‡è¦äº‹ä»¶è®°å½•`, { default_value: {} });
                  
                  if (!memory[memoryKey]) {
                      this.showTemporaryMessage(`è®°å¿† "${memoryKey}" ä¸å­˜åœ¨`, 'warning');
                      return;
                  }

                  // ç›´æ¥ä»å¯¹è±¡ä¸­åˆ é™¤é”®
                  delete memory[memoryKey];
                  
                  // æ›´æ–°æ•´ä¸ªé‡è¦äº‹ä»¶è®°å½•å¯¹è±¡
                  await Mvu.setMvuVariable(
                      mvuData,
                      `äººç‰©å…³ç³»åˆ—è¡¨.${characterName}.é‡è¦äº‹ä»¶è®°å½•`,
                      memory,
                      { reason: `åˆ é™¤${characterName}çš„è®°å¿†ï¼š${memoryKey}` }
                  );

                  await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                  this.showTemporaryMessage(`å·²åˆ é™¤è®°å¿† "${memoryKey}"`, 'success');
                  
                  // åˆ·æ–°è¯¦æƒ…é¢æ¿
                  setTimeout(() => {
                      this.renderCharacterDetails(characterName);
                  }, 100);

              } catch (error) {
                  console.error('åˆ é™¤è®°å¿†å¤±è´¥:', error);
                  this.showTemporaryMessage(`åˆ é™¤å¤±è´¥: ${error.message}`, 'error');
              }
          },

          adjustRelationshipPanelWidth() {
            const container = document.querySelector('#relationships-modal .relationships-container');
            if (!container) return;
        
            const listPanel = container.querySelector('.character-list-panel');
            const detailsPanel = container.querySelector('.character-details-panel');
            if (!listPanel || !detailsPanel) return;
        
            const tabPanes = detailsPanel.querySelectorAll('.tab-pane');
            if (tabPanes.length === 0) return;
        
            let minContentWidth = Infinity;
            let maxContentWidth = 0;
            tabPanes.forEach(pane => {
                const originalDisplay = pane.style.display;
                pane.style.display = 'block'; 
                
                const currentWidth = pane.scrollWidth;
                if (currentWidth > 0) {
                    minContentWidth = Math.min(minContentWidth, currentWidth);
                }
                maxContentWidth = Math.max(maxContentWidth, currentWidth);
                
                pane.style.display = originalDisplay; 
            });
            if (minContentWidth === Infinity) {
                minContentWidth = 200;
            }
        
            const padding = 40; 
            const finalDetailsWidth = maxContentWidth + padding;
            detailsPanel.style.width = `${finalDetailsWidth}px`;
            detailsPanel.style.flexShrink = '0';
        
            tabPanes.forEach(pane => {
                pane.style.minWidth = `${minContentWidth}px`;
            });
        
            listPanel.style.flexGrow = '1';
          },

          renderIntimateRelationships(relationships) {
    return this.renderRelationships(relationships);
},

         // æ–°å¢ï¼šåŠ è½½äººç‰©å…³ç³»è®¾ç½®
         loadRelationshipSettings() {
           try {
             // åŠ è½½æ’åºè®¾ç½®
             const savedSort = localStorage.getItem('guixu_relationship_sort');
             this.relationshipSortType = savedSort || 'default';
             
             // åŠ è½½æ˜¾ç¤ºæ¨¡å¼è®¾ç½®
             const savedDisplayMode = localStorage.getItem('guixu_intimate_display_mode');
             this.intimateDisplayMode = savedDisplayMode === 'true';
             
             console.log('åŠ è½½çš„æ’åºè®¾ç½®:', this.relationshipSortType);
             console.log('åŠ è½½çš„æ˜¾ç¤ºæ¨¡å¼:', this.intimateDisplayMode);
           } catch (e) {
             console.error('åŠ è½½äººç‰©å…³ç³»è®¾ç½®å¤±è´¥:', e);
             this.relationshipSortType = 'default';
             this.intimateDisplayMode = false;
           }
         },
         
         setRelationshipSortValue() {
           setTimeout(() => {
             const sortSelect = document.getElementById('relationship-sort');
             if (sortSelect && this.relationshipSortType) {
               sortSelect.value = this.relationshipSortType;
               console.log('è®¾ç½®æ’åºä¸‹æ‹‰æ¡†å€¼ä¸º:', this.relationshipSortType);
             }
           }, 100);
         },

         saveRelationshipSortSettings() {
             localStorage.setItem('guixu_relationship_sort', this.relationshipSortType);
         },

         loadRelationshipSortSettings() {
             this.relationshipSortType = localStorage.getItem('guixu_relationship_sort') || 'default';
         },

         // æ’åºå…³ç³»æ¡ç›®çš„å‡½æ•°
         sortRelationshipEntries(entries) {
           const sortType = this.relationshipSortType || 'default';
           
           switch (sortType) {
               case 'cultivation-desc':
               case 'cultivation-asc':
                   const tierOrder = {'å‡¡äºº':0, 'ç»ƒæ°”':1, 'ç­‘åŸº':2, 'æ´ç„':3, 'åˆé“':4, 'é£å‡':5, 'ç¥æ¡¥':5 };
                   entries.sort(([nameA, relA], [nameB, relB]) => {
                       const cultivationA = this.SafeGetValue(relA, 'å½“å‰ä¿®ä¸º', 'å‡¡äºº');
                       const cultivationB = this.SafeGetValue(relB, 'å½“å‰ä¿®ä¸º', 'å‡¡äºº');

                       // æå–å‰ä¸¤ä¸ªå­—ä½œä¸ºå¢ƒç•Œè¿›è¡Œæ¯”è¾ƒ
                       const tierA = cultivationA.substring(0, 2);
                       const tierB = cultivationB.substring(0, 2);

                       const orderA = tierOrder.hasOwnProperty(tierA) ? tierOrder[tierA] : -1;
                       const orderB = tierOrder.hasOwnProperty(tierB) ? tierOrder[tierB] : -1;

                       // å¦‚æœä¸¤ä¸ªå¢ƒç•Œéƒ½åœ¨æ’åºåˆ—è¡¨ä¸­
                       if (orderA !== -1 && orderB !== -1) {
                           if (orderA !== orderB) {
                               return sortType === 'cultivation-desc' ? orderB - orderA : orderA - orderB;
                           }
                       }
                       // å¦‚æœåªæœ‰ä¸€ä¸ªåœ¨åˆ—è¡¨ä¸­ï¼Œåœ¨åˆ—è¡¨ä¸­çš„æ’å‰é¢
                       else if (orderA !== -1) { return sortType === 'cultivation-desc' ? -1 : 1; }
                       else if (orderB !== -1) { return sortType === 'cultivation-desc' ? 1 : -1; }

                       // å¦‚æœéƒ½ä¸åœ¨åˆ—è¡¨æˆ–å¢ƒç•Œç›¸åŒï¼Œåˆ™æŒ‰é»˜è®¤åç§°æ’åº
                       return nameA.localeCompare(nameB);
                   });
                   break;
               case 'favor-desc':
               case 'favor-asc':
                   entries.sort(([nameA, relA], [nameB, relB]) => {
                       const favA = parseInt(this.SafeGetValue(relA, 'å¥½æ„Ÿåº¦', 0), 10);
                       const favB = parseInt(this.SafeGetValue(relB, 'å¥½æ„Ÿåº¦', 0), 10);
                       if (favA !== favB) {
                           return sortType === 'favor-desc' ? favB - favA : favA - favB;
                       }
                       return nameA.localeCompare(nameB);
                   });
                   break;
               case 'default':
               default:
                   entries.sort(([nameA], [nameB]) => nameA.localeCompare(nameB));
                   break;
           }
           return entries;
         },

         // æ–°å¢ï¼šå¤„ç†æ’åºå˜æ›´
         handleRelationshipSort(sortType) {
           this.relationshipSortType = sortType;
           localStorage.setItem('guixu_relationship_sort', sortType);
           this.showRelationships(); // é‡æ–°æ¸²æŸ“
         },




// ===äººç‰©å…³ç³»æ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰ç»“æŸ===

// ===å®—é—¨æ¨¡å—å¼€å§‹===

async showSects() {
    this.loadSectSortSettings();
    this.openModal('sects-modal');
    
    const container = document.querySelector('#sects-modal .sects-container');
    if (!container) return;

    const listPanel = container.querySelector('.sect-list-panel .sect-list');
    const detailsPanel = container.querySelector('.sect-details-panel');
    if (!listPanel || !detailsPanel) {
        return;
    }

    listPanel.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨æ•´ç†å®—é—¨ä¿¡æ¯...</p>';
    detailsPanel.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">è¯·å…ˆåœ¨å·¦ä¾§é€‰æ‹©å®—é—¨</p>';

    try {
        if (!this.currentMvuState) {
            listPanel.innerHTML = '<p class="modal-placeholder">æ— æ³•è·å–å®—é—¨æ•°æ®ï¼ˆçŠ¶æ€æœªåˆå§‹åŒ–ï¼‰ã€‚</p>';
            return;
        }
        const sects = this.SafeGetValue(this.currentMvuState.stat_data, 'å®—é—¨åˆ—è¡¨', {});
        this.currentSectData = sects;
        
        this.renderSectList();
        
        const savedSect = localStorage.getItem('guixu_last_selected_sect');
        let targetSectName = null;
        
        if (savedSect && sects[savedSect]) {
            targetSectName = savedSect;
        } else {
            targetSectName = listPanel.querySelector('.sect-card')?.dataset.sectName;
        }
        
        if (targetSectName) {
            const targetCard = listPanel.querySelector(`.sect-card[data-sect-name="${targetSectName}"]`);
            if (targetCard) {
                targetCard.classList.add('active');
            }
            this.renderSectDetails(targetSectName);
            this.lastSelectedSect = targetSectName;
        } else {
            detailsPanel.innerHTML = '<p class="modal-placeholder">æš‚æ— å®—é—¨è¯¦æƒ…ã€‚</p>';
        }
        
        this.adjustSectPanelWidth();
        const rootContainer = document.querySelector('.guixu-root-container');
        const modalContent = document.querySelector('#sects-modal .modal-content');
        if (rootContainer && modalContent) {
            const rect = rootContainer.getBoundingClientRect();
            modalContent.style.setProperty('width', `${rect.width}px`, 'important');
            modalContent.style.setProperty('height', `${rect.height}px`, 'important');
            modalContent.style.setProperty('top', `${rect.top}px`, 'important');
            modalContent.style.setProperty('left', `${rect.left}px`, 'important');
            modalContent.style.setProperty('max-width', 'none', 'important');
            modalContent.style.setProperty('max-height', 'none', 'important');
        }

    } catch (error) {
        console.error('åŠ è½½å®—é—¨ä¿¡æ¯æ—¶å‡ºé”™:', error);
        listPanel.innerHTML = `<p class="modal-placeholder">åŠ è½½å®—é—¨ä¿¡æ¯æ—¶å‡ºé”™: ${error.message}</p>`;
    }
    
    this.bindSectEvents();
},

renderSectList() {
    const listPanel = document.querySelector('#sects-modal .sect-list');
    const listHeader = document.querySelector('#sects-modal .sect-list-header');
    if (!listPanel || !this.currentSectData || !listHeader) return;

    const sects = this.currentSectData;
    let allSectEntries = Object.entries(sects).filter(([name, sect]) => {
        return name && name !== '$meta' && sect && typeof sect === 'object';
    });

    const searchTerm = listHeader.querySelector('.sect-search-input')?.value || '';
    if (searchTerm) {
        allSectEntries = allSectEntries.filter(([name, sect]) => {
            return name.toLowerCase().includes(searchTerm.toLowerCase());
        });
    }

    const subtitleElement = document.querySelector('#sects-modal .sect-list-header .subtitle');
    if (subtitleElement) {
        subtitleElement.textContent = `å…± ${allSectEntries.length} ä¸ªå®—é—¨`;
    }

    const sortedEntries = this.sortSectEntries(allSectEntries);

    if (sortedEntries.length === 0) {
        listPanel.innerHTML = '<p class="modal-placeholder">æš‚æ— å®—é—¨ä¿¡æ¯ã€‚</p>';
        return;
    }

    try {
        listPanel.innerHTML = sortedEntries.map(([name, sect]) => {
            const level = this.SafeGetValue(sect, 'ç­‰çº§', 1);
            const reputation = this.SafeGetValue(sect, 'å£°æœ›å€¼', 0);
            const status = this.SafeGetValue(sect, 'å½“å‰çŠ¶æ€', 'æ­£å¸¸');
            const discipleCount = this.SafeGetValue(sect, 'å¼Ÿå­äººæ•°', 0);
            
            // è·å–ç­‰çº§æŸ“è‰²èƒŒæ™¯ç±»å
            const cardBgClass = this.getSectLevelCardBg(level);
            const levelNameHTML = this.getSectLevelDisplayHTML(level);
            
            return `
                <div class="sect-card ${cardBgClass}" data-sect-name="${name}">
                    <div class="sect-card-header">
                        <div class="sect-name">${name}</div>
                        <div class="sect-level">${levelNameHTML}</div>
                    </div>
                    <div class="sect-card-info">
                        <div class="sect-info-item">
                            <span class="sect-info-label">å£°æœ›:</span>
                            <span class="sect-info-value">${reputation}</span>
                        </div>
                        <div class="sect-info-item">
                            <span class="sect-info-label">å¼Ÿå­:</span>
                            <span class="sect-info-value">${discipleCount}</span>
                        </div>
                    </div>
                    <div class="sect-status">${status}</div>
                </div>
            `;
        }).join('');

    } catch (error) {
        console.error('æ¸²æŸ“å®—é—¨åˆ—è¡¨æ—¶å‡ºé”™:', error);
        listPanel.innerHTML = '<p class="modal-placeholder">æ¸²æŸ“å®—é—¨åˆ—è¡¨æ—¶å‡ºé”™ã€‚</p>';
    }
},

async renderSectDetails(sectName) {
    const detailsPanel = document.querySelector('#sects-modal .sect-details-panel');
    if (!detailsPanel || !this.currentSectData) return;

    const sectData = this.currentSectData[sectName];
    if (!sectData) {
        detailsPanel.innerHTML = `<p class="modal-placeholder">æ— æ³•æ‰¾åˆ° ${sectName} çš„ä¿¡æ¯ã€‚</p>`;
        return;
    }

    const name = sectName;
    const level = this.SafeGetValue(sectData, 'ç­‰çº§', 1);
    const location = this.SafeGetValue(sectData, 'ä½ç½®', 'æœªçŸ¥');
    const discipleCount = this.SafeGetValue(sectData, 'å¼Ÿå­äººæ•°', 0);
    const status = this.SafeGetValue(sectData, 'å½“å‰çŠ¶æ€', 'æ­£å¸¸');
    const coordinates = this.SafeGetValue(sectData, 'ä½ç½®åæ ‡', '');

    // è·å–å®—é—¨ç­‰çº§æŸ“è‰²æ ·å¼ï¼ˆç›´æ¥åº”ç”¨åˆ°åç§°ä¸Šï¼‰
    const nameStyle = this.getSectLevelStyle(level);
    
    let html = `
        <div class="details-header">
            <div class="main-info">
                <div class="name" style="${nameStyle} font-size: 24px; font-weight: bold;">${name}</div>
                <div style="display: flex; align-items: center; gap: 15px; margin-top: 5px;">
                    <div class="title">ç­‰çº§ ${level} Â· ${location}</div>
                    <div class="location-tag"><i class="fas fa-users"></i> ${discipleCount} åå¼Ÿå­</div>
                    <div class="status-tag">${status}</div>
                </div>
            </div>
        </div>
        <div class="details-tabs">
            <button class="tab-button active" data-tab="info">è¯¦æƒ…</button>
            <button class="tab-button" data-tab="members">äººç‰©</button>
            <button class="tab-button" data-tab="resources">èµ„æº</button>
            <button class="tab-button" data-tab="diplomacy">å¤–äº¤</button>
            <button class="tab-button" data-tab="events">äº‹ä»¶</button>
            <button class="tab-button" data-tab="advanced">é«˜çº§</button>
        </div>
        <div class="details-content" style="display: flex; flex-direction: column; flex-grow: 1; min-height: 0;">
            <div class="tab-pane active" id="tab-info">
                ${this._renderSectInfoSection(sectData)}
            </div>
            <div class="tab-pane" id="tab-members">
                ${this._renderSectMembersSection(sectData)}
            </div>
            <div class="tab-pane" id="tab-resources">
                ${this._renderSectResourcesSection(sectData)}
            </div>
            <div class="tab-pane" id="tab-diplomacy">
                ${this._renderSectDiplomacySection(sectData)}
            </div>
            <div class="tab-pane" id="tab-events">
                ${this._renderSectEventsSection(sectData)}
            </div>
            <div class="tab-pane" id="tab-advanced">
                ${this._renderSectAdvancedSection(sectData, sectName)}
            </div>
        </div>
    `;

    detailsPanel.innerHTML = html;
    this.bindSectEvents();
},

_renderSectInfoSection(sectData) {
    const description = this.SafeGetValue(sectData, 'æè¿°', 'æš‚æ— ');
    const philosophy = this.SafeGetValue(sectData, 'å®—æ—¨ç†å¿µ', 'æš‚æ— ');
    const rules = this.SafeGetValue(sectData, 'å®—é—¨è§„çŸ©', 'æš‚æ— ');
    const reputation = this.SafeGetValue(sectData, 'å£°æœ›å€¼', 0);
    const foundedTime = this.SafeGetValue(sectData, 'åˆ›ç«‹æ—¶é—´', 'æœªçŸ¥');
    const cultivationEnvDesc = this.SafeGetValue(sectData, 'ä¿®ç‚¼ç¯å¢ƒæè¿°', 'æš‚æ— ');
    const cultivationEnvLevel = this.SafeGetValue(sectData, 'ä¿®ç‚¼ç¯å¢ƒç­‰çº§', 1);

    return `
        <div class="info-section">
            <div class="info-item full-width"><strong style="color: #c9aa71;">æè¿°:</strong> ${description}</div>
            <div class="info-item full-width"><strong style="color: #c9aa71;">å®—æ—¨ç†å¿µ:</strong> ${philosophy}</div>
            <div class="info-item full-width"><strong style="color: #c9aa71;">å®—é—¨è§„çŸ©:</strong> ${rules}</div>
            <div class="info-item"><strong style="color: #c9aa71;">å£°æœ›å€¼:</strong> ${reputation}</div>
            <div class="info-item"><strong style="color: #c9aa71;">åˆ›ç«‹æ—¶é—´:</strong> ${foundedTime}</div>
            <div class="info-item full-width">
                <strong style="color: #c9aa71;">ä¿®ç‚¼ç¯å¢ƒ:</strong> ${cultivationEnvDesc}
                <span style="color: #e8dcc6;">(ç­‰çº§ ${cultivationEnvLevel})</span>
            </div>
        </div>
    `;
},

_renderSectMembersSection(sectData) {
    const members = this.SafeGetValue(sectData, 'å®—é—¨äººç‰©', {});
    const entries = Object.entries(members).filter(([key]) => key !== '$meta');
    
    if (entries.length === 0) {
        return '<p class="modal-placeholder">æš‚æ— å®—é—¨æˆå‘˜ä¿¡æ¯ã€‚</p>';
    }

    entries.sort((a, b) => {
        const weightA = this.SafeGetValue(a[1], 'èŒä½æƒé‡', 0);
        const weightB = this.SafeGetValue(b[1], 'èŒä½æƒé‡', 0);
        return weightB - weightA;
    });

    // è·å–äººç‰©å…³ç³»åˆ—è¡¨ç”¨äºè¡¥å……ä¿¡æ¯
    const relationships = this.SafeGetValue(this.currentMvuState?.stat_data, 'äººç‰©å…³ç³»åˆ—è¡¨', {});

    let html = '<div class="members-grid">';
    entries.forEach(([key, member]) => {
        const name = this.SafeGetValue(member, 'å§“å', key);
        const position = this.SafeGetValue(member, 'èŒä½', 'å¼Ÿå­');
        
        // ä»äººç‰©å…³ç³»åˆ—è¡¨ä¸­è·å–è¯¦ç»†ä¿¡æ¯
        const relationshipData = relationships[name];
        
        // åˆ¤æ–­æ˜¯å¦æœ‰äººç‰©å…³ç³»æ•°æ®
        const hasRelationshipData = relationshipData && Object.keys(relationshipData).length > 0;
        
        if (!hasRelationshipData) {
            // å¦‚æœæ²¡æœ‰äººç‰©å…³ç³»æ•°æ®ï¼Œåªæ˜¾ç¤ºåŸºæœ¬ä¿¡æ¯
            html += `
                <div class="sect-member-card">
                    <div class="sect-member-header">
                        <span class="sect-member-position">${position}</span>
                        <span class="sect-member-name" style="color: #e8dcc6;">${name}</span>
                    </div>
                </div>
            `;
        } else {
            // æœ‰äººç‰©å…³ç³»æ•°æ®ï¼Œæ˜¾ç¤ºå®Œæ•´ä¿¡æ¯
            const cultivation = this.SafeGetValue(relationshipData, 'å½“å‰ä¿®ä¸º', 'æœªçŸ¥');
            const identity = this.SafeGetValue(relationshipData, 'èº«ä»½èƒŒæ™¯', 'æš‚æ— ');
            const appearance = this.SafeGetValue(relationshipData, 'å¤–è²Œ', 'æš‚æ— ');
            const charm = this.SafeGetValue(relationshipData, 'é­…åŠ›', 0);
            const qiyun = this.SafeGetValue(relationshipData, 'æ°”è¿', 0);
            const wuxing = this.SafeGetValue(relationshipData, 'æ‚Ÿæ€§', 0);
            
            // æå–å¢ƒç•Œç”¨äºæŸ“è‰²
            const tierMatch = cultivation.match(/^(ç»ƒæ°”|ç­‘åŸº|æ´ç„|åˆé“|é£å‡|ç¥æ¡¥|å‡¡äºº)/);
            const tier = tierMatch ? tierMatch[0] : 'å‡¡äºº';
            const nameStyle = this.getJingJieStyle(tier);
            
            // è·å–é­…åŠ›ã€æ°”è¿ã€æ‚Ÿæ€§æ˜¾ç¤ºHTML
            const charmHTML = this.getCharmDisplayHTML(charm);
            const qiyunHTML = this.getQiyunDisplayHTML(qiyun);
            const wuxingHTML = this.getWuxingDisplayHTML(wuxing);
            
            html += `
                <div class="sect-member-card">
                    <div class="sect-member-header">
                        <span class="sect-member-position">${position}</span>
                        <span class="sect-member-name" style="${nameStyle}">${name}</span>
                        <span class="sect-member-cultivation">${cultivation}</span>
                        <button class="sect-member-detail-btn" data-character-name="${name}" title="æŸ¥çœ‹è¯¦æƒ…">æŸ¥çœ‹è¯¦æƒ…</button>
                    </div>
                    <div class="sect-member-divider"></div>
                    <div class="sect-member-identity">
                        <strong style="color: #c9aa71;">èº«ä»½èƒŒæ™¯ï¼š</strong><span style="color: #e8dcc6;">${identity}</span>
                    </div>
                    <div class="sect-member-divider"></div>
                    <div class="sect-member-attributes">
                        <div class="sect-member-attr-item">
                            <strong style="color: #c9aa71;">å¤–è²Œï¼š</strong><span style="color: #e8dcc6;">${appearance}</span>
                        </div>
                        <div class="sect-member-attr-item">
                            <strong style="color: #c9aa71;">é­…åŠ›ï¼š</strong>${charmHTML}
                        </div>
                    </div>
                    <div class="sect-member-divider"></div>
                    <div class="sect-member-attributes">
                        <div class="sect-member-attr-item">
                            <strong style="color: #c9aa71;">æ°”è¿ï¼š</strong>${qiyunHTML}
                        </div>
                        <div class="sect-member-attr-item">
                            <strong style="color: #c9aa71;">æ‚Ÿæ€§ï¼š</strong>${wuxingHTML}
                        </div>
                    </div>
                </div>
            `;
        }
    });
    html += '</div>';
    return html;
},

_renderSectResourcesSection(sectData) {
    let html = '<div class="resources-section">';
    
    const mainSkills = this.SafeGetValue(sectData, 'é•‡æ´¾åŠŸæ³•', {});
    const specialResources = this.SafeGetValue(sectData, 'ç‰¹äº§èµ„æº', {});
    const otherResources = this.SafeGetValue(sectData, 'å…¶ä»–èµ„æº', {});

    html += '<div class="resource-category">';
    html += '<h4 style="color: #c9aa71; margin-bottom: 10px;">é•‡æ´¾åŠŸæ³•</h4>';
    html += this._renderResourceItems(mainSkills);
    html += '</div>';

    html += '<div class="resource-category">';
    html += '<h4 style="color: #c9aa71; margin-bottom: 10px;">ç‰¹äº§èµ„æº</h4>';
    html += this._renderResourceItems(specialResources);
    html += '</div>';

    html += '<div class="resource-category">';
    html += '<h4 style="color: #c9aa71; margin-bottom: 10px;">å…¶ä»–èµ„æº</h4>';
    html += this._renderResourceItems(otherResources);
    html += '</div>';

    html += '</div>';
    return html;
},

_renderResourceItems(resources) {
    const entries = Object.entries(resources).filter(([key]) => key !== '$meta');
    
    if (entries.length === 0) {
        return '<p style="color: #8b7355; font-size: 12px;">æš‚æ— </p>';
    }

    let html = '<div class="resource-items">';
    entries.forEach(([name, item]) => {
        const tier = this.SafeGetValue(item, 'tier', '') || this.SafeGetValue(item, 'å“é˜¶', '');
        const description = this.SafeGetValue(item, 'description', '') || this.SafeGetValue(item, 'æè¿°', '');
        // ä½¿ç”¨å“é˜¶æŸ“è‰²ç³»ç»Ÿ
        const tierStyle = tier ? this.getItemTierStyle(tier) : 'color: #e8dcc6;';
        
        html += `
            <details class="resource-item">
                <summary>
                    <span style="${tierStyle}">${name}</span>
                    ${tier ? `<span class="resource-tier" style="${tierStyle}">${tier}</span>` : ''}
                </summary>
                <div class="resource-details">
                    ${description ? `<p><strong>æè¿°:</strong> ${description}</p>` : ''}
                </div>
            </details>
        `;
    });
    html += '</div>';
    return html;
},

_renderSectDiplomacySection(sectData) {
    const diplomacy = this.SafeGetValue(sectData, 'å¤–äº¤å…³ç³»', {});
    const entries = Object.entries(diplomacy).filter(([key]) => key !== '$meta');
    
    if (entries.length === 0) {
        return '<p class="modal-placeholder">æš‚æ— å¤–äº¤å…³ç³»ã€‚</p>';
    }

    let html = '<div class="sect-diplomacy-grid">';
    entries.forEach(([key, relation]) => {
        const factionName = this.SafeGetValue(relation, 'åŠ¿åŠ›åç§°', key);
        const relationStatus = this.SafeGetValue(relation, 'å…³ç³»çŠ¶æ€', 'ä¸­ç«‹');
        const description = this.SafeGetValue(relation, 'æè¿°', 'æš‚æ— æè¿°');
        
        // æ ¹æ®å…³ç³»çŠ¶æ€å¯¹å¡ç‰‡è¿›è¡ŒæŸ“è‰²
        let borderColor = 'rgba(201, 170, 113, 0.2)'; // é»˜è®¤è¾¹æ¡†
        let bgColor = 'rgba(26, 26, 46, 0.5)'; // é»˜è®¤èƒŒæ™¯
        const statusLower = relationStatus.toLowerCase();
        
        if (statusLower.includes('å‹å¥½') || statusLower.includes('ç›Ÿå‹') || statusLower.includes('å‹å–„')) {
            borderColor = 'rgba(102, 205, 170, 0.6)'; // ç»¿è‰²è¾¹æ¡†
            bgColor = 'rgba(102, 205, 170, 0.1)'; // ç»¿è‰²èƒŒæ™¯
        } else if (statusLower.includes('æ•Œå¯¹') || statusLower.includes('æ•Œäºº') || statusLower.includes('ä»‡æ•Œ')) {
            borderColor = 'rgba(220, 20, 60, 0.6)'; // çº¢è‰²è¾¹æ¡†
            bgColor = 'rgba(220, 20, 60, 0.1)'; // çº¢è‰²èƒŒæ™¯
        } else if (statusLower.includes('ä¸­ç«‹')) {
            borderColor = 'rgba(255, 215, 0, 0.6)'; // é»„è‰²è¾¹æ¡†
            bgColor = 'rgba(255, 215, 0, 0.1)'; // é»„è‰²èƒŒæ™¯
        }
        
        html += `
            <div class="social-card" style="border-color: ${borderColor}; background: ${bgColor};">
                <div class="social-card-name">${factionName}</div>
                <div class="social-card-relationship">${relationStatus}</div>
                <div class="social-card-description">${description}</div>
            </div>
        `;
    });
    html += '</div>';
    return html;
},

_renderSectEventsSection(sectData) {
    const events = this.SafeGetValue(sectData, 'ç‰¹æ®Šäº‹ä»¶', {});
    const entries = Object.entries(events).filter(([key]) => key !== '$meta');
    
    if (entries.length === 0) {
        return '<p class="modal-placeholder">æš‚æ— ç‰¹æ®Šäº‹ä»¶è®°å½•ã€‚</p>';
    }

    let html = '<div class="sect-events-grid">';
    entries.forEach(([key, event]) => {
        const eventName = this.SafeGetValue(event, 'åç§°', key);
        const eventDesc = this.SafeGetValue(event, 'æè¿°', 'æš‚æ— æè¿°');
        const eventTime = this.SafeGetValue(event, 'æ—¶é—´', 'æœªçŸ¥');
        
        html += `
            <div class="social-card">
                <div class="social-card-name">${eventName}</div>
                <div class="social-card-intimacy">æ—¶é—´: ${eventTime}</div>
                <div class="social-card-description">${eventDesc}</div>
            </div>
        `;
    });
    html += '</div>';
    return html;
},

_renderSectAdvancedSection(sectData, sectName) {
    const tokenCount = this.calculateSectTokenCount(sectData);
    
    return `
        <div class="advanced-section">
            <div class="info-item">
                <strong style="color: #c9aa71;">Tokenå ç”¨ä¼°ç®—:</strong>
                <span style="color: #e8dcc6;">${tokenCount} å­—ç¬¦</span>
            </div>
            <div style="margin-top: 20px;">
                <button id="btn-delete-sect" class="interaction-btn btn-danger" style="width: 100%;">
                    åˆ é™¤æ­¤å®—é—¨
                </button>
            </div>
        </div>
    `;
},

calculateSectTokenCount(sectData) {
    try {
        const jsonString = JSON.stringify(sectData, null, 2);
        return jsonString.length;
    } catch (error) {
        console.error('è®¡ç®—å®—é—¨Tokenæ•°é‡å¤±è´¥:', error);
        return 0;
    }
},

async deleteSect(sectName) {
    if (!sectName) {
        this.showTemporaryMessage('å®—é—¨åç§°æ— æ•ˆ', 'error');
        return;
    }

    this.showCustomConfirm(
        `ç¡®å®šè¦åˆ é™¤ "${sectName}" å—ï¼Ÿ\n\næ­¤æ“ä½œå°†ä»å®—é—¨åˆ—è¡¨ä¸­ç§»é™¤è¯¥å®—é—¨ï¼Œä¸”æ— æ³•æ’¤é”€ã€‚`,
        async () => {
            try {
                const mvuData = this.currentMvuState;
                if (!mvuData) {
                    this.showTemporaryMessage('æ— æ³•è·å–MVUçŠ¶æ€ï¼', 'error');
                    return;
                }

                const sects = Mvu.getMvuVariable(mvuData, 'å®—é—¨åˆ—è¡¨', { default_value: {} });
                
                if (!sects[sectName]) {
                    this.showTemporaryMessage(`å®—é—¨ "${sectName}" ä¸å­˜åœ¨`, 'warning');
                    return;
                }

                await Mvu.setMvuVariable(
                    mvuData,
                    `å®—é—¨åˆ—è¡¨.${sectName}`,
                    undefined,
                    { reason: `åˆ é™¤å®—é—¨ï¼š${sectName}` }
                );

                await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                this.showTemporaryMessage(`å·²æˆåŠŸåˆ é™¤ "${sectName}"`, 'success');
                
                // ç›´æ¥åˆ·æ–°å®—é—¨åˆ—è¡¨ï¼Œä¸å…³é—­æ¨¡æ€æ¡†
                this.currentSectData = Mvu.getMvuVariable(mvuData, 'å®—é—¨åˆ—è¡¨', { default_value: {} });
                this.renderSectList();
                
                // æ¸…ç©ºè¯¦æƒ…é¢æ¿
                const detailsPanel = document.querySelector('#sects-modal .sect-details-panel');
                if (detailsPanel) {
                    detailsPanel.innerHTML = '<p class="modal-placeholder">è¯·åœ¨å·¦ä¾§é€‰æ‹©å®—é—¨ã€‚</p>';
                }

            } catch (error) {
                console.error('åˆ é™¤å®—é—¨å¤±è´¥:', error);
                this.showTemporaryMessage(`åˆ é™¤å¤±è´¥: ${error.message}`, 'error');
            }
        },
        () => {
            this.showTemporaryMessage('å·²å–æ¶ˆåˆ é™¤');
        },
        true
    );
},

bindSectEvents() {
    const searchIcon = document.querySelector('#sects-modal .header-icon[title="æœç´¢"]');
    const searchInput = document.querySelector('#sects-modal .sect-search-input');
    const listHeader = document.querySelector('#sects-modal .sect-list-header');

    if (searchIcon && searchInput && listHeader) {
        if (!searchIcon.dataset.listenerAttached) {
            searchIcon.addEventListener('click', () => {
                listHeader.classList.toggle('is-searching');
                if (listHeader.classList.contains('is-searching')) {
                    searchInput.focus();
                }
            });
            searchInput.addEventListener('input', () => {
                this.renderSectList();
            });
            searchIcon.dataset.listenerAttached = 'true';
        }
    }

    const listPanel = document.querySelector('#sects-modal .sect-list');
    if(listPanel) {
        listPanel.addEventListener('click', (e) => {
            const card = e.target.closest('.sect-card');
            if (card && card.dataset.sectName) {
                listPanel.querySelectorAll('.sect-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                const sectName = card.dataset.sectName;
                this.lastSelectedSect = sectName;
                localStorage.setItem('guixu_last_selected_sect', sectName);
                this.renderSectDetails(sectName);
            }
        });
    }

    const sortDropdown = document.querySelector('#sects-modal .sort-dropdown');
    if (sortDropdown && !sortDropdown.dataset.listenerAttached) {
        const sortIcon = sortDropdown.querySelector('.header-icon');
        const sortMenu = sortDropdown.querySelector('.sort-menu');

        sortIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            sortMenu.classList.toggle('active');
        });

        sortMenu.addEventListener('click', (e) => {
            const option = e.target.closest('.sort-option');
            if (option && option.dataset.sort) {
                this.sectSortType = option.dataset.sort;
                this.saveSectSortSettings();
                this.renderSectList();
                
                sortMenu.querySelectorAll('.sort-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');

                sortMenu.classList.remove('active');
            }
        });

        document.addEventListener('click', (e) => {
            if (!sortDropdown.contains(e.target)) {
                sortMenu.classList.remove('active');
            }
        });

        sortDropdown.dataset.listenerAttached = 'true';
    }

    const detailsPanel = document.querySelector('#sects-modal .sect-details-panel');
    if(detailsPanel) {
        if (detailsPanel._clickHandler) {
            detailsPanel.removeEventListener('click', detailsPanel._clickHandler);
        }
        
        detailsPanel._clickHandler = (e) => {
            const tab = e.target.closest('.tab-button');
            if (tab && tab.dataset.tab) {
                detailsPanel.querySelectorAll('.tab-button').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                detailsPanel.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
                const targetPane = detailsPanel.querySelector(`#tab-${tab.dataset.tab}`);
                if (targetPane) {
                    targetPane.classList.add('active');
                    this.currentSectTab = tab.dataset.tab;
                    localStorage.setItem('guixu_sect_tab', tab.dataset.tab);
                }
            }
            
            // å¤„ç†"æŸ¥çœ‹è¯¦æƒ…"æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            const detailBtn = e.target.closest('.sect-member-detail-btn');
            if (detailBtn && detailBtn.dataset.characterName) {
                const characterName = detailBtn.dataset.characterName;
                // ç›´æ¥æ‰“å¼€äººç‰©å…³ç³»æ¨¡æ€æ¡†ï¼Œä¿æŒå®—é—¨æ¨¡æ€æ¡†æ‰“å¼€
                this.openModal('relationships-modal', true);
                
                // åˆå§‹åŒ–äººç‰©å…³ç³»æ•°æ®
                const container = document.querySelector('#relationships-modal .relationships-container');
                if (container) {
                    const listPanel = container.querySelector('.character-list-panel .character-list');
                    const detailsPanel = container.querySelector('.character-details-panel');
                    
                    if (listPanel && detailsPanel) {
                        listPanel.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨æ•´ç†äººç‰©å…³ç³»...</p>';
                        detailsPanel.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">è¯·å…ˆåœ¨å·¦ä¾§é€‰æ‹©äººç‰©</p>';
                        
                        // åŠ è½½äººç‰©å…³ç³»æ•°æ®
                        const relationships = this.SafeGetValue(this.currentMvuState?.stat_data, 'äººç‰©å…³ç³»åˆ—è¡¨', {});
                        this.currentRelationshipData = relationships;
                        
                        // æ¸²æŸ“äººç‰©åˆ—è¡¨
                        this.renderCharacterList();
                        
                        // ç­‰å¾…æ¸²æŸ“å®Œæˆåè·³è½¬åˆ°ç›®æ ‡äººç‰©
                        setTimeout(() => {
                            const characterCard = document.querySelector(`#relationships-modal .character-card[data-character-name="${characterName}"]`);
                            if (characterCard) {
                                // ç§»é™¤å…¶ä»–å¡ç‰‡çš„æ¿€æ´»çŠ¶æ€
                                document.querySelectorAll('#relationships-modal .character-card').forEach(c => c.classList.remove('active'));
                                // æ¿€æ´»ç›®æ ‡å¡ç‰‡
                                characterCard.classList.add('active');
                                // æ¸²æŸ“è¯¦æƒ…
                                this.renderCharacterDetails(characterName);
                                // æ»šåŠ¨åˆ°ç›®æ ‡å¡ç‰‡
                                characterCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                        }, 100);
                        
                        // è°ƒæ•´é¢æ¿å®½åº¦
                        this.adjustRelationshipPanelWidth();
                        
                        // ç»‘å®šäº‹ä»¶
                        this.bindRelationshipEvents();
                    }
                }
            }
        };
        
        detailsPanel.addEventListener('click', detailsPanel._clickHandler);
    }

    const deleteBtn = detailsPanel?.querySelector('#btn-delete-sect');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
            const sectName = document.querySelector('#sects-modal .sect-card.active')?.dataset.sectName;
            if (sectName) {
                this.deleteSect(sectName);
            }
        });
    }
},

sortSectEntries(entries) {
    const sortType = this.sectSortType || 'default';
    
    if (sortType === 'default') {
        return entries;
    }
    
    return entries.sort((a, b) => {
        const [nameA, sectA] = a;
        const [nameB, sectB] = b;
        
        switch(sortType) {
            case 'level-desc':
                return this.SafeGetValue(sectB, 'ç­‰çº§', 0) - this.SafeGetValue(sectA, 'ç­‰çº§', 0);
            case 'level-asc':
                return this.SafeGetValue(sectA, 'ç­‰çº§', 0) - this.SafeGetValue(sectB, 'ç­‰çº§', 0);
            case 'reputation-desc':
                return this.SafeGetValue(sectB, 'å£°æœ›å€¼', 0) - this.SafeGetValue(sectA, 'å£°æœ›å€¼', 0);
            case 'reputation-asc':
                return this.SafeGetValue(sectA, 'å£°æœ›å€¼', 0) - this.SafeGetValue(sectB, 'å£°æœ›å€¼', 0);
            default:
                return 0;
        }
    });
},

adjustSectPanelWidth() {
    const container = document.querySelector('#sects-modal .sects-container');
    if (!container) return;

    const listPanel = container.querySelector('.sect-list-panel');
    const detailsPanel = container.querySelector('.sect-details-panel');
    if (!listPanel || !detailsPanel) return;

    const containerWidth = container.offsetWidth;
    const listWidth = 280;
    const detailsWidth = containerWidth - listWidth;

    listPanel.style.width = `${listWidth}px`;
    detailsPanel.style.width = `${detailsWidth}px`;
},

loadSectSortSettings() {
    const saved = localStorage.getItem('guixu_sect_sort_type');
    if (saved) {
        this.sectSortType = saved;
    }
},

saveSectSortSettings() {
    if (this.sectSortType) {
        localStorage.setItem('guixu_sect_sort_type', this.sectSortType);
    }
},

// ===å®—é—¨æ¨¡å—ç»“æŸ===



// ===å“é˜¶ã€å¢ƒç•Œæ’åºã€æŸ“è‰²æ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰å¼€å§‹===



          // å“é˜¶æ’åºæ ¸å¿ƒå‡½æ•°
          getTierOrder(tier) {
            // å“é˜¶ç­‰çº§æ˜ å°„ï¼šæ•°å€¼è¶Šé«˜ï¼Œå“é˜¶è¶Šé«˜
            // å®šä¹‰äº†æ‰€æœ‰å“é˜¶çš„æ’åºè§„åˆ™ï¼Œç”¨äº sortByTier å‡½æ•°ã€‚
            const tierOrder = {
              // ç»ƒæ°”æœŸ
              'å‡¡å“': 1,
              'ç„å“': 2,
              'é“å“': 3,
              'è§æˆ‘': 4,
              'çŸ¥å‘½': 5,
              // ç­‘åŸºæœŸ
              'äººé˜¶': 6,
              'åœ°é˜¶': 7,
              'å¤©é˜¶': 8,

              // æ´ç„å¢ƒ
              'å‡¡å°˜': 9,
              'çµè„‰': 10,
              'å¤©è±¡': 11,
              'æœ¬æº': 12,
              
              // åˆé“å¢ƒ
              'æå“': 13,
              'å¤©å“': 14,
              'ä»™å“': 15,

              // ç¥å¦™
              'ä¸€å­—ç¥å¦™': 16,
              'äºŒå­—ç¥å¦™': 17,
              'ä¸‰å­—ç¥å¦™': 18,
              'å†åŠ«': 19,
              'çœŸä¸€': 20,
              'ç‹¬ä»™': 21,

              // é£å‡æœŸ
              'ç¥å“': 22,
              'ä¼ªä»™å™¨': 23,
              'ä»™å™¨': 24,

              // å…¼å®¹é“ç—•
              'å‡¡å°˜æµéŸµä¹‹ç—•': 9,
              'çµè„‰å¥”æ¶Œä¹‹ç—•': 10,
              'å¤©è±¡æ˜¾åŒ–ä¹‹ç—•': 11,
              'æœ¬æºé“­åˆ»ä¹‹ç—•': 12
            };
            return tierOrder[tier] || 0; // æœªçŸ¥å“é˜¶æ’åœ¨æœ€å‰
          },

          // --- æ–°å¢ï¼šé€šç”¨å“é˜¶æ’åºå‡½æ•° ---
          sortByTier(items, getTierFn) {
            if (!Array.isArray(items)) return items;
            
            return [...items].sort((a, b) => {
              const tierA = getTierFn(a);
              const tierB = getTierFn(b);
              const orderA = this.getTierOrder(tierA);
              const orderB = this.getTierOrder(tierB);
              
              // æŒ‰ getTierOrder ä¸­å®šä¹‰çš„å“é˜¶é¡ºåºä»é«˜åˆ°ä½è¿›è¡Œç¨³å®šæ’åºã€‚
              if (orderA === orderB) {
                return 0;
              }
              return orderB - orderA;
            });
          },

          // å¢ƒç•ŒæŸ“è‰²ç³»ç»Ÿ 
          getJingJieStyle(jingjie) {
              const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
              const baseStyle = 'font-style: italic;';
              const gradientAnimation = 'god-tier-animation 5s linear infinite';
              
              const styles = {
                  'ç»ƒæ°”': 'color: #B0C4DE;', 
                  'ç­‘åŸº': 'color: #66CDAA;', 
                  'æ´ç„': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`, // åŸå…ƒå©´é¢œè‰²
                  'åˆé“': `background: linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585); ${animatedStyle} animation: ${gradientAnimation};`,
                  'é£å‡': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation};`
              };
              return (styles[jingjie] || 'color: #e0dcd1;') + baseStyle;
          },

          // --- ä½“ç³»åˆ†ç¦»: å“é˜¶æŸ“è‰²ç³»ç»Ÿ ---
          getItemTierStyle(tier) {
              if (typeof tier !== 'string' || !tier) {
                  return 'color: #e0dcd1; font-style: italic;';
              }

              const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
              const baseStyle = 'font-style: italic;';
              const gradientAnimation = 'god-tier-animation 5s linear infinite';
              const fluorescentAnimation = 'breathing-glow 4s ease-in-out infinite';

              const styles = {
                // ç»ƒæ°”æœŸå“é˜¶
                'å‡¡å“': 'color: #FFFFFF;',
                'ç„å“': `background: linear-gradient(90deg, #87CEFA, #B0E0E6, #ADD8E6, #B0E0E6, #87CEFA); ${animatedStyle} animation: ${gradientAnimation};`,
                'é“å“': `background: linear-gradient(90deg, #FFD700, #FFFFFF, #FFD700, #FFFFFF, #FFD700); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'è§æˆ‘': `background: linear-gradient(90deg, #cccccc, #FFFACD, #ffffff, #FFFACD, #bbbbbb, #FFFACD, #cccccc); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'çŸ¥å‘½': `background: linear-gradient(90deg, #FFFACD, #206864, #ffffff, #206864, #FFFACD); ${animatedStyle} animation: ${gradientAnimation};`,
                // ç­‘åŸºæœŸå“é˜¶
                'äººé˜¶': 'color: #66CDAA;',
                'åœ°é˜¶': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`,
                'å¤©é˜¶': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                // æ´ç„å¢ƒå“é˜¶
                'å‡¡å°˜': 'color: #66CDAA;',
                'çµè„‰': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`,
                'å¤©è±¡': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle} animation: ${gradientAnimation};`,
                'æœ¬æº': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                
                // æ´å¤©é“ç—•å…¼å®¹
                'å‡¡å°˜æµéŸµä¹‹ç—•': 'color: #66CDAA;',
                'çµè„‰å¥”æ¶Œä¹‹ç—•': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`,
                'å¤©è±¡æ˜¾åŒ–ä¹‹ç—•': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle} animation: ${gradientAnimation};`,
                'æœ¬æºé“­åˆ»ä¹‹ç—•': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,

                // åˆé“å¢ƒå“é˜¶
                'æå“': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle} animation: ${gradientAnimation};`,
                'å¤©å“': `background: linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585); ${animatedStyle} animation: ${gradientAnimation};`,
                'ä»™å“': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation};`,
                // é£å‡æœŸå“é˜¶
                'ç¥å“': `background: linear-gradient(90deg, #cccccc, #ffffff, #bbbbbb, #ffffff, #cccccc); ${animatedStyle} animation: ${gradientAnimation};`,
                'ä¼ªä»™å™¨': `background: linear-gradient(90deg, #cccccc, #FFFACD, #ffffff, #FFFACD, #bbbbbb, #FFFACD, #cccccc); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'ä»™å™¨': `background: linear-gradient(90deg, #FFFACD, #206864, #ffffff, #206864, #FFFACD); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                // ç¥å¦™/æœ¬å‘½ç¥å¦™å“é˜¶
                'ä¸€å­—ç¥å¦™': `background: linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'äºŒå­—ç¥å¦™': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'ä¸‰å­—ç¥å¦™': `background: linear-gradient(90deg, #cccccc, #ffffff, #bbbbbb, #ffffff, #cccccc); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'å†åŠ«': `background: linear-gradient(90deg, #6A1B9A, #FFFFFF, #6A1B9A); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'çœŸä¸€': `background: linear-gradient(90deg, #FFD700, rgba(255, 255, 255, 0.8), #FFD700); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'ç‹¬ä»™': `background: linear-gradient(135deg, #a8ff78, #78ffd6, #a8ff78); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
              };

              // ä¼˜å…ˆå®Œå…¨åŒ¹é…
              if (styles[tier]) {
                  return styles[tier] + baseStyle;
              }

              // å¦‚æœå®Œå…¨åŒ¹é…å¤±è´¥ï¼Œåˆ™å°è¯•æå–æ ¸å¿ƒå“é˜¶è¿›è¡ŒåŒ¹é…
              const coreTiers = ['ç„å“', 'é“å“', 'äººé˜¶', 'åœ°é˜¶', 'å¤©é˜¶', 'æå“', 'å¤©å“', 'ä»™å“', 'ç¥å“', 'ä¼ªä»™å™¨', 'ä»™å™¨'];
              for (const coreTier of coreTiers) {
                  if (tier.startsWith(coreTier)) {
                      return styles[coreTier] + baseStyle;
                  }
              }

              // å¦‚æœéƒ½å¤±è´¥ï¼Œè¿”å›é»˜è®¤æ ·å¼
              return 'color: #e0dcd1;' + baseStyle;
          },
          // --- æ–°å¢ï¼šé€šç”¨é­…åŠ›æŸ“è‰²ç³»ç»Ÿ ---
          // æ ¹æ®é­…åŠ›æ•°å€¼è¿”å›å¯¹åº”çš„ç­‰çº§åç§°
          getCharmLevelName(charmValue) {
              const charm = parseInt(charmValue, 10);
              if (isNaN(charm)) return 'æœªçŸ¥';
              
              if (charm >= 181) return 'ä»™å§¿';
              if (charm >= 141) return 'å€¾å›½å€¾åŸ';
              if (charm >= 101) return 'ç»è‰²';
              if (charm >= 61) return 'å‡ºä¼—';
              if (charm >= 21) return 'æ¸…ç§€';
              if (charm >= 1) return 'å¯»å¸¸';
              if (charm >= -100) return 'åä¸‘';
              if (charm >= -200) return 'æä¸‘';
              return 'æœªçŸ¥';
          },

          // æ ¹æ®é­…åŠ›æ•°å€¼è¿”å›å¯¹åº”çš„æŸ“è‰²æ ·å¼
          getCharmStyle(charmValue) {
              const charm = parseInt(charmValue, 10);
              if (isNaN(charm)) return 'color: #e0dcd1;';
              
              const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
              const gradientAnimation = 'god-tier-animation 5s linear infinite';
              const fluorescentAnimation = 'breathing-glow 4s ease-in-out infinite';
              
              // 181 åˆ° 200ï¼šä»™å§¿â€”â€”ç²‰-çº¢æ¸å˜+å‘¼å¸+è§å…‰
              if (charm >= 181) {
                  return `background: linear-gradient(90deg, #FFB6C1, #FF69B4, #FF1493, #FF69B4, #FFB6C1); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 141 åˆ° 180ï¼šå€¾å›½å€¾åŸâ€”â€”ç²‰-çº¢æ¸å˜
              if (charm >= 141) {
                  return `background: linear-gradient(90deg, #FFB6C1, #FF69B4, #FF1493, #FF69B4, #FFB6C1); ${animatedStyle} animation: ${gradientAnimation};`;
              }
              // 101 åˆ° 140ï¼šç»è‰²â€”â€”ç²‰è‰²æ¸å˜
              if (charm >= 101) {
                  return `background: linear-gradient(90deg, #FFB6C1, #FFC0CB, #FFB6C1); ${animatedStyle} animation: ${gradientAnimation};`;
              }
              // 61 åˆ° 100ï¼šå‡ºä¼—â€”â€”è“è‰²
              if (charm >= 61) {
                  return 'color: #6495ED;';
              }
              // 21 åˆ° 60ï¼šæ¸…ç§€â€”â€”ç»¿è‰²
              if (charm >= 21) {
                  return 'color: #66CDAA;';
              }
              // 1 åˆ° 20ï¼šå¯»å¸¸â€”â€”ç™½è‰²
              if (charm >= 1) {
                  return 'color: #FFFFFF;';
              }
              // -100 åˆ° 0ï¼šåä¸‘â€”â€”ç°è‰²
              if (charm >= -100) {
                  return 'color: #808080;';
              }
              // -200 åˆ° -100ï¼šæä¸‘â€”â€”é»‘è‰²
              if (charm >= -200) {
                  return 'color: #2F2F2F;';
              }
              return 'color: #e0dcd1;';
          },

          // è·å–é­…åŠ›çš„å®Œæ•´æ˜¾ç¤ºHTMLï¼ˆåç§°+æ•°å€¼ï¼‰
          getCharmDisplayHTML(charmValue) {
              const charm = parseInt(charmValue, 10);
              if (isNaN(charm)) return '<span style="color: #e0dcd1;">æœªçŸ¥</span>';
              
              const levelName = this.getCharmLevelName(charm);
              const style = this.getCharmStyle(charm);
              
              return `<span style="${style}">${levelName}</span><span style="color: #e0dcd1;">ï¼ˆ${charm}ï¼‰</span>`;
          },

          // --- æ–°å¢ï¼šæ‚Ÿæ€§æŸ“è‰²ç³»ç»Ÿ ---
          // æ ¹æ®æ‚Ÿæ€§æ•°å€¼è¿”å›å¯¹åº”çš„ç­‰çº§åç§°
          getWuxingLevelName(wuxingValue) {
              const wuxing = parseInt(wuxingValue, 10);
              if (isNaN(wuxing)) return 'æœªçŸ¥';
              
              if (wuxing >= 151) return 'è¡é“';
              if (wuxing >= 121) return 'å† çµ';
              if (wuxing >= 81) return 'é€šç„';
              if (wuxing >= 41) return 'çµçª';
              if (wuxing >= 21) return 'æ‚é±¼';
              if (wuxing >= 0) return 'ç¬¨è›‹';
              return 'æœªçŸ¥';
          },

          // æ ¹æ®æ‚Ÿæ€§æ•°å€¼è¿”å›å¯¹åº”çš„æŸ“è‰²æ ·å¼
          getWuxingStyle(wuxingValue) {
              const wuxing = parseInt(wuxingValue, 10);
              if (isNaN(wuxing)) return 'color: #e0dcd1;';
              
              const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
              const gradientAnimation = 'god-tier-animation 5s linear infinite';
              const fluorescentAnimation = 'breathing-glow 4s ease-in-out infinite';
              
              // 151 åˆ° 200ï¼šè¡é“â€”â€”é‡‘è‰²ï¼ˆæ¸å˜+å‘¼å¸+è§å…‰+æ¸å˜çš„é¢œè‰²æ•°é‡è¾ƒå¤šï¼‰
              if (wuxing >= 151) {
                  return `background: linear-gradient(90deg, #FFD700, #FFA500, #FFFF00, #FFD700, #FFA500, #FFFF00, #FFD700); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 121 åˆ° 150ï¼šå† çµâ€”â€”çº¢è‰²ï¼ˆæ¸å˜+å‘¼å¸+è§å…‰+æ¸å˜çš„é¢œè‰²æ•°é‡è¾ƒå¤šï¼‰
              if (wuxing >= 121) {
                  return `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF6347, #DC143C, #FF4500, #B22222); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 81 åˆ° 120ï¼šé€šç„â€”â€”ç´«è‰²ï¼ˆæ¸å˜+å‘¼å¸+è§å…‰ï¼‰
              if (wuxing >= 81) {
                  return `background: linear-gradient(90deg, #9370DB, #8A2BE2, #9932CC, #8A2BE2, #9370DB); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 41 åˆ° 80ï¼šçµçªâ€”â€”è“è‰²ï¼ˆæ¸å˜ï¼‰
              if (wuxing >= 41) {
                  return `background: linear-gradient(90deg, #4169E1, #1E90FF, #6495ED, #1E90FF, #4169E1); ${animatedStyle} animation: ${gradientAnimation};`;
              }
              // 21 åˆ° 40ï¼šæ‚é±¼â€”â€”ç™½è‰²
              if (wuxing >= 21) {
                  return 'color: #FFFFFF;';
              }
              // 0 åˆ° 20ï¼šç¬¨è›‹â€”â€”ç°è‰²
              if (wuxing >= 0) {
                  return 'color: #808080;';
              }
              return 'color: #e0dcd1;';
          },

          // è·å–æ‚Ÿæ€§çš„å®Œæ•´æ˜¾ç¤ºHTMLï¼ˆåç§°+æ•°å€¼ï¼‰
          getWuxingDisplayHTML(wuxingValue) {
              const wuxing = parseInt(wuxingValue, 10);
              if (isNaN(wuxing)) return '<span style="color: #e0dcd1;">æœªçŸ¥</span>';
              
              const levelName = this.getWuxingLevelName(wuxing);
              const style = this.getWuxingStyle(wuxing);
              
              return `<span style="${style}">${levelName}</span><span style="color: #e0dcd1;">ï¼ˆ${wuxing}ï¼‰</span>`;
          },

          // --- æ–°å¢ï¼šæ°”è¿æŸ“è‰²ç³»ç»Ÿ ---
          // æ ¹æ®æ°”è¿æ•°å€¼è¿”å›å¯¹åº”çš„ç­‰çº§åç§°
          getQiyunLevelName(qiyunValue) {
              const qiyun = parseInt(qiyunValue, 10);
              if (isNaN(qiyun)) return 'æœªçŸ¥';
              
              if (qiyun >= 181) return 'å¤©å‘½ä¹‹å­';
              if (qiyun >= 161) return 'æ´ªç¦é½å¤©';
              if (qiyun >= 141) return 'æ°”è¿äº¨é€š';
              if (qiyun >= 121) return 'ç¦ç¼˜æ¸æ˜¾';
              if (qiyun >= 101) return 'å°æœ‰ç¦ç¼˜';
              if (qiyun >= 81) return 'æ°”è¿å°šå¯';
              if (qiyun >= 61) return 'å‡¡å¤«ä¿—å­';
              if (qiyun >= 41) return 'æ—¶è¿ä¸æµ';
              if (qiyun >= 21) return 'éœ‰è¿ç¼ èº«';
              if (qiyun >= 0) return 'å¤©ç…å­¤æ˜Ÿ';
              return 'æœªçŸ¥';
          },

          // æ ¹æ®æ°”è¿æ•°å€¼è¿”å›å¯¹åº”çš„æŸ“è‰²æ ·å¼
          getQiyunStyle(qiyunValue) {
              const qiyun = parseInt(qiyunValue, 10);
              if (isNaN(qiyun)) return 'color: #e0dcd1;';
              
              const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
              const gradientAnimation = 'god-tier-animation 5s linear infinite';
              const fluorescentAnimation = 'breathing-glow 4s ease-in-out infinite';
              
              // 181 åˆ° 200+ï¼šå¤©å‘½ä¹‹å­â€”â€”é‡‘çº¢ï¼ˆæ¸å˜+å‘¼å¸+è§å…‰+æ¸å˜çš„é¢œè‰²æ•°é‡è¾ƒå¤šï¼‰
              if (qiyun >= 181) {
                  return `background: linear-gradient(90deg, #FFD700, #FF6347, #FF4500, #FFD700, #DC143C, #FFD700, #FF6347); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 161 åˆ° 180ï¼šæ´ªç¦é½å¤©â€”â€”çº¢è‰²ï¼ˆæ¸å˜+å‘¼å¸+è§å…‰+æ¸å˜çš„é¢œè‰²æ•°é‡è¾ƒå¤šï¼‰
              if (qiyun >= 161) {
                  return `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF6347, #DC143C, #FF4500, #B22222); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 141 åˆ° 160ï¼šæ°”è¿äº¨é€šâ€”â€”ç´«è‰²ï¼ˆæ¸å˜+å‘¼å¸+è§å…‰ï¼‰
              if (qiyun >= 141) {
                  return `background: linear-gradient(90deg, #9370DB, #8A2BE2, #9932CC, #8A2BE2, #9370DB); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 121 åˆ° 140ï¼šç¦ç¼˜æ¸æ˜¾â€”â€”æ©™è‰²ï¼ˆæ¸å˜+å‘¼å¸ï¼‰
              if (qiyun >= 121) {
                  return `background: linear-gradient(90deg, #FF8C00, #FFA500, #FFB347, #FFA500, #FF8C00); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
              }
              // 101 åˆ° 120ï¼šå°æœ‰ç¦ç¼˜â€”â€”è“è‰²ï¼ˆæ¸å˜ï¼‰
              if (qiyun >= 101) {
                  return `background: linear-gradient(90deg, #4169E1, #1E90FF, #6495ED, #1E90FF, #4169E1); ${animatedStyle} animation: ${gradientAnimation};`;
              }
              // 81 åˆ° 100ï¼šæ°”è¿å°šå¯â€”â€”ç»¿è‰²
              if (qiyun >= 81) {
                  return 'color: #66CDAA;';
              }
              // 61 åˆ° 80ï¼šå‡¡å¤«ä¿—å­â€”â€”ç™½è‰²
              if (qiyun >= 61) {
                  return 'color: #FFFFFF;';
              }
              // 41 åˆ° 60ï¼šæ—¶è¿ä¸æµâ€”â€”ç°è‰²
              if (qiyun >= 41) {
                  return 'color: #808080;';
              }
              // 21 åˆ° 40ï¼šéœ‰è¿ç¼ èº«â€”â€”é»‘è‰²
              if (qiyun >= 21) {
                  return 'color: #2F2F2F;';
              }
              // 0 åˆ° 20ï¼šå¤©ç…å­¤æ˜Ÿâ€”â€”é»‘å¸¦æ³¢åŠ¨ï¼ˆæ¸å˜+å‘¼å¸ï¼‰
              if (qiyun >= 0) {
                  return `background: linear-gradient(90deg, #000000, #1a1a1a, #000000, #0d0d0d, #000000); ${animatedStyle} animation: ${gradientAnimation};`;
              }
              return 'color: #e0dcd1;';
          },

          // è·å–æ°”è¿çš„å®Œæ•´æ˜¾ç¤ºHTMLï¼ˆåç§°+æ•°å€¼ï¼‰
          getQiyunDisplayHTML(qiyunValue) {
              const qiyun = parseInt(qiyunValue, 10);
              if (isNaN(qiyun)) return '<span style="color: #e0dcd1;">æœªçŸ¥</span>';
              
              const levelName = this.getQiyunLevelName(qiyun);
              const style = this.getQiyunStyle(qiyun);
              
              return `<span style="${style}">${levelName}</span><span style="color: #e0dcd1;">ï¼ˆ${qiyun}ï¼‰</span>`;
          },

          // --- æ–°å¢ï¼šé€šç”¨æ•°å€¼æŸ“è‰²ç»„ä»¶ ---
          // ç»Ÿä¸€çš„æ•°å€¼æ˜¾ç¤ºæ¥å£ï¼Œæ”¯æŒé­…åŠ›ã€æ‚Ÿæ€§ã€æ°”è¿
          getAttributeDisplayHTML(attributeType, value) {
              switch(attributeType) {
                  case 'é­…åŠ›':
                      return this.getCharmDisplayHTML(value);
                  case 'æ‚Ÿæ€§':
                      return this.getWuxingDisplayHTML(value);
                  case 'æ°”è¿':
                      return this.getQiyunDisplayHTML(value);
                  default:
                      return `<span style="color: #e0dcd1;">${value}</span>`;
              }
          },

          // --- æ–°å¢ï¼šé€šç”¨å±æ€§ç™¾åˆ†æ¯”è¿›åº¦æ¡é¢œè‰²ç³»ç»Ÿ ---
          // æ ¹æ®ç™¾åˆ†æ¯”è¿”å›ä»çº¢åˆ°ç»¿çš„æ¸å˜è‰²
          getPercentageColor(percentage) {
              const percent = Math.max(0, Math.min(100, percentage)); // é™åˆ¶åœ¨0-100ä¹‹é—´
              
              // ä½¿ç”¨HSLè‰²å½©ç©ºé—´ï¼Œä»çº¢è‰²(0)åˆ°ç»¿è‰²(120)
              // 0% = çº¢è‰² (hsl(0, 100%, 50%))
              // 50% = é»„è‰² (hsl(60, 100%, 50%))
              // 100% = ç»¿è‰² (hsl(120, 100%, 50%))
              const hue = (percent * 1.2).toFixed(0); // 0-120åº¦
              return `hsl(${hue}, 70%, 45%)`;
          },

          // ç”Ÿæˆå±æ€§è¿›åº¦æ¡çš„HTML
          getAttributeProgressHTML(currentValue, maxValue, attributeName) {
              const current = parseInt(currentValue, 10) || 0;
              const max = parseInt(maxValue, 10) || 1;
              const percentage = Math.min(100, (current / max) * 100);
              const color = this.getPercentageColor(percentage);
              
              return `
                  <div class="info-item full-width" style="margin-top: 8px;">
                      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                          <strong style="white-space: nowrap; color: #c9aa71;">${attributeName}:</strong>
                          <span style="color: #e8dcc6; font-size: 13px;">${current} / ${max} (${percentage.toFixed(1)}%)</span>
                      </div>
                      <div class="progress-bar-bg" style="width: 100%; height: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; overflow: hidden;">
                          <div class="progress-bar-fill" style="width: ${percentage}%; height: 100%; background: ${color}; transition: width 0.3s ease, background 0.3s ease;"></div>
                      </div>
                  </div>
              `;
          },

        // ---æ–°å¢ï¼šå®—é—¨ç­‰çº§æŸ“è‰²ç³»ç»Ÿ ---
        // æ ¹æ®å®—é—¨ç­‰çº§è¿”å›å¯¹åº”çš„ç­‰çº§åç§°
          getSectLevelName(levelValue) {
            const level = parseInt(levelValue, 10);
            if (isNaN(level)) return 'æœªçŸ¥';  

            if (level >= 10) return 'é•¿ç”Ÿé“ç»Ÿ';
            if (level >= 9) return 'åœ£åœ°';
            if (level >= 8) return 'ä»™é“åå®—';
            if (level >= 7) return 'ä¸€æµ';
            if (level >= 6) return 'äºŒæµ';
            if (level >= 5) return 'ä¸‰æµ';
            if (level >= 4) return 'è¶…çº§æ— æ•Œæ‚é±¼å¤§ç‹';
            if (level >= 3) return 'é«˜çº§æ‚é±¼';
            if (level >= 2) return 'ä¸­ç­‰æ‚é±¼';
            if (level >= 1) return 'ä½ç­‰æ‚é±¼';
            return 'æœªçŸ¥';
          },

              // æ ¹æ®å®—é—¨ç­‰çº§è¿”å›å¯¹åº”çš„æŸ“è‰²æ ·å¼
              getSectLevelStyle(levelValue) {
                    const level = parseInt(levelValue, 10);
                        if (isNaN(level)) return 'color: #e0dcd1;';
        
                    const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
                    const gradientAnimation = 'god-tier-animation 8s linear infinite';
                    const fluorescentAnimation = 'breathing-glow 6s ease-in-out infinite';
        
                    // 10çº§ï¼šåœ£åœ° - ä»™å™¨æ¸å˜+å‘¼å¸+è§å…‰
                    if (level >= 10) {
                        return `background: linear-gradient(90deg, #FFFACD, #206864, #ffffff, #206864, #FFFACD); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
                    }
                      // 9çº§ï¼šé¡¶å°– - çº¢è‰²æ¸å˜+å‘¼å¸+è§å…‰
                    if (level >= 9) {
                        return `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF6347, #DC143C, #FF4500, #B22222); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
                    }
                    // 8çº§ï¼šä¸€æµ - é“å“æ¸å˜+å‘¼å¸+è§å…‰
                    if (level >= 8) {
                        return `background: linear-gradient(90deg, #FFD700, #FFFFFF, #FFD700, #FFFFFF, #FFD700); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
                    }
                    // 7çº§ï¼šäºŒæµ - æ©™è‰²æ¸å˜+å‘¼å¸+è§å…‰
                      if (level >= 7) {
                        return `background: linear-gradient(90deg, #FF8C00, #FFA500, #FFB347, #FFA500, #FF8C00); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
                    }
                    // 6çº§ï¼šä¸‰æµ - æµ…è“è‰²æ¸å˜+å‘¼å¸
                    if (level >= 6) {
                        return `background: linear-gradient(90deg, #87CEFA, #B0E0E6, #ADD8E6, #B0E0E6, #87CEFA); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`;
                    }
                    // 5çº§ï¼šå››æµ - ç„å“æ¸å˜
                    if (level >= 5) {
                        return `background: linear-gradient(90deg, #87CEFA, #B0E0E6, #ADD8E6, #B0E0E6, #87CEFA); ${animatedStyle} animation: ${gradientAnimation};`;
                    }
                    // 4çº§ï¼šäº”æµ - ç™½è‰²
                    if (level >= 4) {
                        return 'color: #FFFFFF;';
                    }
                    // 3çº§ï¼šå…­æµ - ç°è‰²
                    if (level >= 3) {
                        return 'color: #A9A9A9;';
                    }
                    // 2çº§ï¼šä¸ƒæµ - æ·±ç°
                    if (level >= 2) {
                        return 'color: #808080;';
                    }
                    // 1çº§ï¼šå…«æµ - æš—ç°
                    if (level >= 1) {
                        return 'color: #696969;';
                    }
                        return 'color: #e0dcd1;';
              },

            // è·å–å®—é—¨ç­‰çº§çš„å®Œæ•´æ˜¾ç¤ºHTMLï¼ˆåç§°+æ•°å€¼ï¼‰
          getSectLevelDisplayHTML(levelValue) {
                const level = parseInt(levelValue, 10);
                  if (isNaN(level)) return '<span style="color: #e0dcd1;">æœªçŸ¥</span>';
    
                  const levelName = this.getSectLevelName(level);
                  const style = this.getSectLevelStyle(level);
    
                return `<span style="${style}">${levelName}</span>`;
          },

            // è·å–å®—é—¨ç­‰çº§çš„å¡ç‰‡èƒŒæ™¯CSSç±»åï¼ˆç”¨äºå·¦ä¾§åˆ—è¡¨ï¼‰
          getSectLevelCardBg(levelValue) {
                const level = parseInt(levelValue, 10);
                if (isNaN(level)) return '';
    
                if (level >= 10) return 'sect-bg-level-10';
                if (level >= 9) return 'sect-bg-level-9';
                if (level >= 8) return 'sect-bg-level-8';
                if (level >= 7) return 'sect-bg-level-7';
                if (level >= 6) return 'sect-bg-level-6';
                if (level >= 5) return 'sect-bg-level-5';
                return '';
          },

// ===å“é˜¶ã€å¢ƒç•Œæ’åºã€æŸ“è‰²æ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰ç»“æŸ===



// ===å¤©èµ‹ã€çµæ ¹å¤„ç†ã€æ¸²æŸ“æ¨¡å—å¼€å§‹===



          updateTalentAndLinggen(data) {
            const container = document.getElementById('talent-linggen-list');
            if (!container) return;
            container.innerHTML = '';

            let html = '';
            const linggenList = this.SafeGetValue(data, 'çµæ ¹åˆ—è¡¨', {});
            const linggenEntries = Object.entries(linggenList).filter(([name]) => name !== '$meta');

            if (linggenEntries.length > 0) {
              const sortedLinggen = this.sortByTier(linggenEntries, ([, linggen]) =>
                this.SafeGetValue(linggen, 'tier', 'å‡¡å“')
              );

              sortedLinggen.forEach(([name, linggen]) => {
                const tier = this.SafeGetValue(linggen, 'tier', 'å‡¡å“');
                const description = this.SafeGetValue(linggen, 'description', 'æ— æè¿°');
                const tierStyle = this.getItemTierStyle(tier);
                const itemDetailsHtml = this.renderItemDetailsForInventory(linggen);

                html += `
                     <details class="details-container" style="margin-top: 10px;">
                         <summary>
                             <span class="attribute-name">çµæ ¹</span>
                             <span class="attribute-value" style="${tierStyle}">ã€${tier}ã€‘ ${name}</span>
                         </summary>
                         <div class="details-content">
                             <p>${description}</p>
                             ${itemDetailsHtml ? `<div class="item-details" style="border-top: 1px solid rgba(201, 170, 113, 0.2); padding-top: 10px; margin-top: 10px;">${itemDetailsHtml}</div>` : ''}
                         </div>
                     </details>
                 `;
              });
            } else {
                 html += `
                   <div class="attribute-item">
                       <span class="attribute-name">çµæ ¹</span>
                       <span class="attribute-value">æœªè§‰é†’</span>
                   </div>
               `;
            }
            const tianfuList = this.SafeGetValue(data, 'å¤©èµ‹åˆ—è¡¨', {});
            const tianfuEntries = Object.entries(tianfuList).filter(([name]) => name !== '$meta');
            
            if (tianfuEntries.length > 0) {
              const sortedTianfu = this.sortByTier(tianfuEntries, ([, tianfu]) =>
                this.SafeGetValue(tianfu, 'tier', 'å‡¡å“')
              );

              sortedTianfu.forEach(([name, tianfu]) => {
                const tier = this.SafeGetValue(tianfu, 'tier', 'å‡¡å“');
                const description = this.SafeGetValue(tianfu, 'description', 'æ— æè¿°');
                const tierStyle = this.getItemTierStyle(tier);
                const itemDetailsHtml = this.renderItemDetailsForInventory(tianfu);

                html += `
                         <details class="details-container" style="margin-top: 10px;">
                             <summary>
                                 <span class="attribute-name">å¤©èµ‹</span>
                                 <span class="attribute-value" style="${tierStyle}">ã€${tier}ã€‘ ${name}</span>
                             </summary>
                             <div class="details-content">
                                 <p>${description}</p>
                                 ${itemDetailsHtml ? `<div class="item-details" style="border-top: 1px solid rgba(201, 170, 113, 0.2); padding-top: 10px; margin-top: 10px;">${itemDetailsHtml}</div>` : ''}
                             </div>
                         </details>
                     `;
              });
            } else {
              html += `
                   <div class="attribute-item">
                       <span class="attribute-name">å¤©èµ‹</span>
                       <span class="attribute-value">æœªè§‰é†’</span>
                   </div>
               `;
            }

            container.innerHTML = html;
          },



// ===å¤©èµ‹ã€çµæ ¹å¤„ç†ã€æ¸²æŸ“æ¨¡å—å¼€å§‹===



// ===èƒŒåŒ…æ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰å¼€å§‹===

          // å­˜å‚¨å½“å‰æ¿€æ´»çš„tabå’Œæœç´¢å…³é”®è¯
          currentInventoryTab: 'åŠŸæ³•',
          currentInventorySearchKeyword: '',

          renderInventoryWithTabs(stat_data) {
            if (!stat_data || Object.keys(stat_data).length === 0) {
              const contentArea = document.querySelector('#inventory-modal .inventory-content-area');
              if (contentArea) {
                contentArea.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">èƒŒåŒ…æ•°æ®ä¸ºç©ºã€‚</p>';
              }
              return;
            }

            this.renderInventoryTabs();
            this.renderInventoryContent(stat_data, this.currentInventoryTab);
            this.initInventorySearch();
          },

          renderInventoryTabs() {
            const categories = [
              { title: 'åŠŸæ³•', key: 'åŠŸæ³•åˆ—è¡¨', equipable: true },
              { title: 'æ­¦å™¨', key: 'æ­¦å™¨åˆ—è¡¨', equipable: true },
              { title: 'é˜²å…·', key: 'é˜²å…·åˆ—è¡¨', equipable: true },
              { title: 'é¥°å“', key: 'é¥°å“åˆ—è¡¨', equipable: true },
              { title: 'æ³•å®', key: 'æ³•å®åˆ—è¡¨', equipable: true },
              { title: 'ä¸¹è¯', key: 'ä¸¹è¯åˆ—è¡¨', equipable: false },
              { title: 'æ‚ç‰©', key: 'å…¶ä»–åˆ—è¡¨', equipable: false },
            ];

            const tabsContainer = document.querySelector('#inventory-modal .inventory-tabs');
            if (!tabsContainer) return;

            const stat_data = this.currentMvuState?.stat_data || {};

            let tabsHtml = '';
            categories.forEach(cat => {
              const isActive = cat.title === this.currentInventoryTab ? 'active' : '';
              
              const rawItems = this.SafeGetValue(stat_data, cat.key, {});
              const itemEntries = Object.entries(rawItems).filter(([name]) => name !== '$meta');
              
              const validItems = itemEntries.filter(([name, item]) => {
                const hasQuantity = item && item.hasOwnProperty('quantity');
                if (hasQuantity) {
                  const quantity = parseInt(this.SafeGetValue(item, 'quantity', 1), 10);
                  return quantity > 0;
                }
                return true;
              });
              
              const itemCount = validItems.length;
              const badgeHtml = itemCount > 0 ? `<span class="inventory-tab-badge">${itemCount}</span>` : '';
              
              tabsHtml += `<button class="inventory-tab-btn ${isActive}" data-category="${cat.title}"><span>${cat.title}</span>${badgeHtml}</button>`;
            });

            tabsContainer.innerHTML = tabsHtml;

            tabsContainer.addEventListener('click', (e) => {
              const btn = e.target.closest('.inventory-tab-btn');
              if (btn) {
                const category = btn.dataset.category;
                this.switchInventoryTab(category);
              }
            });
          },

          switchInventoryTab(category) {
            this.currentInventoryTab = category;
            
            const tabButtons = document.querySelectorAll('#inventory-modal .inventory-tab-btn');
            tabButtons.forEach(btn => {
              btn.classList.toggle('active', btn.dataset.category === category);
            });

            const messages = this.currentMvuState?.stat_data;
            if (messages) {
              this.renderInventoryContent(messages, category);
              // åˆ‡æ¢tabåé‡æ–°åº”ç”¨æœç´¢è¿‡æ»¤
              if (this.currentInventorySearchKeyword) {
                this.filterInventoryItems(this.currentInventorySearchKeyword);
              }
            }
          },

          renderInventoryContent(stat_data, categoryTitle) {
            const categories = [
              { title: 'åŠŸæ³•', key: 'åŠŸæ³•åˆ—è¡¨', equipable: true },
              { title: 'æ­¦å™¨', key: 'æ­¦å™¨åˆ—è¡¨', equipable: true },
              { title: 'é˜²å…·', key: 'é˜²å…·åˆ—è¡¨', equipable: true },
              { title: 'é¥°å“', key: 'é¥°å“åˆ—è¡¨', equipable: true },
              { title: 'æ³•å®', key: 'æ³•å®åˆ—è¡¨', equipable: true },
              { title: 'ä¸¹è¯', key: 'ä¸¹è¯åˆ—è¡¨', equipable: false },
              { title: 'æ‚ç‰©', key: 'å…¶ä»–åˆ—è¡¨', equipable: false },
            ];

            const contentArea = document.querySelector('#inventory-modal .inventory-content-area');
            if (!contentArea) return;

            const cat = categories.find(c => c.title === categoryTitle);
            if (!cat) return;

            const rawItems = this.SafeGetValue(stat_data, cat.key, {});
            const itemEntries = Object.entries(rawItems).filter(([name]) => name !== '$meta');

            let html = '';

            if (itemEntries.length > 0) {
              html += '<div class="inventory-item-list">';
              
              const sortedItems = this.sortByTier(itemEntries, ([, item]) =>
                this.SafeGetValue(item, 'tier', 'å‡¡å“')
              );

              sortedItems.forEach(([name, item]) => {
                try {
                  const itemWithFixName = { ...item, name };
                  const itemJson = JSON.stringify(itemWithFixName).replace(/'/g, "'");
                  
                  const tier = this.SafeGetValue(item, 'tier', 'æ— ');
                  const hasQuantity = item.hasOwnProperty('quantity');
                  const quantity = parseInt(this.SafeGetValue(item, 'quantity', 1), 10);
                  const description = this.SafeGetValue(
                    item,
                    'description',
                    this.SafeGetValue(item, 'effect', 'æ— æè¿°'),
                  );
                  const displayQuantity = quantity;

                  if (hasQuantity && displayQuantity <= 0) {
                    return;
                  }
                  const tierStyle = this.getItemTierStyle(tier);
                  const tierDisplay =
                    tier !== 'æ— ' ? `<span style="${tierStyle} margin-right: 15px;">å“é˜¶: ${tier}</span>` : '';
                  const quantityDisplay = hasQuantity ? `<span class="item-quantity">æ•°é‡: ${displayQuantity}</span>` : '';
                  const currentEquipped = this._getEquipmentFromStatData(stat_data);
                  const isEquipped = Object.values(currentEquipped).some(equippedItem => equippedItem && equippedItem.name === name);
                  let actionButton = '';
                  if (cat.title === 'åŠŸæ³•') {
                    const isEquippedAsMain = currentEquipped.zhuxiuGongfa && currentEquipped.zhuxiuGongfa.name === name;
                    const isEquippedAsAux = currentEquipped.fuxiuXinfa && currentEquipped.fuxiuXinfa.name === name;
                    if (isEquippedAsMain) {
                      actionButton = `
                              <button class="item-unequip-btn" data-slot-id="equip-zhuxiuGongfa" style="margin-left: 5px;">å¸ä¸‹</button>
                              <button class="item-equip-btn" data-equip-type="fuxiu" style="margin-left: 5px; opacity: 0.5; cursor: not-allowed;" disabled>è¾…ä¿®</button>
                          `;
                    } else if (isEquippedAsAux) {
                      actionButton = `
                              <button class="item-equip-btn" data-equip-type="zhuxiu" style="margin-left: 5px; opacity: 0.5; cursor: not-allowed;" disabled>ä¸»ä¿®</button>
                              <button class="item-unequip-btn" data-slot-id="equip-fuxiuXinfa" style="margin-left: 5px;">å¸ä¸‹</button>
                          `;
                    } else {
                      actionButton = `
                              <button class="item-equip-btn" data-equip-type="zhuxiu" style="margin-left: 5px;">ä¸»ä¿®</button>
                              <button class="item-equip-btn" data-equip-type="fuxiu" style="margin-left: 5px;">è¾…ä¿®</button>
                          `;
                    }
                  } else if (cat.equipable) {
                    if (isEquipped) {
                      const slotKey = Object.keys(currentEquipped).find(
                        key => currentEquipped[key] && currentEquipped[key].name === name,
                      );
                      actionButton = `<button class="item-unequip-btn" data-slot-id="equip-${slotKey}">å¸ä¸‹</button>`;
                    } else {
                      actionButton = `<button class="item-equip-btn">è£…å¤‡</button>`;
                    }
                  } else if (cat.title === 'ä¸¹è¯' || cat.title === 'æ‚ç‰©') {
                    if (displayQuantity <= 0) {
                        actionButton = `<button class="item-use-btn" disabled>å·²ç”¨å®Œ</button>`;
                    } else {
                        actionButton = `<button class="item-use-btn">ä½¿ç”¨</button>`;
                    }
                  }

                  if (cat.title === 'ä¸¹è¯' || cat.title === 'æ‚ç‰©') {
                    actionButton += `<button class="item-discard-btn" style="margin-left: 5px; background: #8b0000; border-color: #ff6b6b;">ä¸¢å¼ƒ</button>`;
                  } else {
                    actionButton += `<button class="item-discard-btn" style="margin-left: 5px; background: #8b0000; border-color: #ff6b6b;">ä¸¢å¼ƒ</button>`;
                  }

                  let itemDetailsHtml = this.renderItemDetailsForInventory(item);

                  html += `
                                  <div class="inventory-item" data-item-details='${itemJson}' data-category='${cat.title}'>
                                      <div class="item-name" style="${tierStyle}">${name}</div>
                                      <div class="item-header">
                                          <div class="item-meta">
                                              ${tierDisplay}
                                              ${quantityDisplay}
                                          </div>
                                          <div class="item-actions">
                                              ${actionButton}
                                          </div>
                                      </div>
                                      <div class="item-description">${description}</div>
                                      ${itemDetailsHtml ? `<div class="item-details">${itemDetailsHtml}</div>` : ''}
                                  </div>
                              `;
                } catch (e) {
                  console.error('è§£æèƒŒåŒ…ç‰©å“å¤±è´¥:', item, e);
                  html += `<div class="inventory-item"><p class="item-description">ç‰©å“æ•°æ®æ ¼å¼é”™è¯¯</p></div>`;
                }
              });
              html += '</div>';
            } else {
              html += '<div class="inventory-item-list"><p class="empty-category-text">ç©ºç©ºå¦‚ä¹Ÿ</p></div>';
            }

            contentArea.innerHTML = html;
          },



          // åˆå§‹åŒ–èƒŒåŒ…æœç´¢åŠŸèƒ½
          initInventorySearch() {
            const searchInput = document.getElementById('inventory-search-input');
            const clearBtn = document.getElementById('inventory-search-clear');
            
            if (!searchInput || !clearBtn) return;

            let lastSearchValue = '';
            let searchInterval = null;

            // æ‰§è¡Œæœç´¢çš„å‡½æ•°
            const performSearch = () => {
              const currentValue = searchInput.value.trim();
              lastSearchValue = currentValue;
              this.currentInventorySearchKeyword = currentValue;
              
              // æ˜¾ç¤º/éšè—æ¸…é™¤æŒ‰é’®
              clearBtn.style.display = currentValue ? 'flex' : 'none';
              
              // æ‰§è¡Œå…¨å±€æœç´¢
              this.filterInventoryItems(currentValue);
            };

            // å®æ—¶æ£€æŸ¥è¾“å…¥æ¡†å†…å®¹å¹¶æœç´¢ï¼ˆæ¯50msæ£€æŸ¥ä¸€æ¬¡ï¼Œæ›´å¿«å“åº”ï¼‰
            const startRealTimeSearch = () => {
              if (searchInterval) {
                clearInterval(searchInterval);
              }
              
              searchInterval = setInterval(() => {
                const currentValue = searchInput.value.trim();
                
                // åªæœ‰å½“å€¼å‘ç”Ÿå˜åŒ–æ—¶æ‰æ‰§è¡Œæœç´¢
                if (currentValue !== lastSearchValue) {
                  performSearch();
                }
              }, 50); // æ¯50msæ£€æŸ¥ä¸€æ¬¡ï¼Œå®ç°çœŸæ­£çš„å®æ—¶æœç´¢
            };

            // è¾“å…¥æ¡†è·å¾—ç„¦ç‚¹æ—¶å¼€å§‹å®æ—¶æœç´¢
            searchInput.addEventListener('focus', () => {
              startRealTimeSearch();
            });

            // è¾“å…¥æ¡†å¤±å»ç„¦ç‚¹æ—¶åœæ­¢å®æ—¶æœç´¢
            searchInput.addEventListener('blur', () => {
              if (searchInterval) {
                clearInterval(searchInterval);
                searchInterval = null;
              }
            });

            // å›è½¦é”®å¼ºåˆ¶æœç´¢
            searchInput.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') {
                e.preventDefault();
                performSearch();
              }
            });

            // inputäº‹ä»¶ä½œä¸ºå¤‡ç”¨ï¼Œç¡®ä¿å³æ—¶å“åº”
            searchInput.addEventListener('input', () => {
              const currentValue = searchInput.value.trim();
              clearBtn.style.display = currentValue ? 'flex' : 'none';
            });

            // æ¸…é™¤æŒ‰é’®äº‹ä»¶
            clearBtn.addEventListener('click', () => {
              searchInput.value = '';
              lastSearchValue = '';
              this.currentInventorySearchKeyword = '';
              clearBtn.style.display = 'none';
              this.filterInventoryItems('');
            });

            // æ¢å¤ä¹‹å‰çš„æœç´¢å…³é”®è¯
            if (this.currentInventorySearchKeyword) {
              searchInput.value = this.currentInventorySearchKeyword;
              lastSearchValue = this.currentInventorySearchKeyword;
              clearBtn.style.display = 'flex';
              // ç«‹å³æ‰§è¡Œä¸€æ¬¡æœç´¢
              this.filterInventoryItems(this.currentInventorySearchKeyword);
            }

            // å¦‚æœè¾“å…¥æ¡†å·²ç»æœ‰ç„¦ç‚¹ï¼Œç«‹å³å¼€å§‹å®æ—¶æœç´¢
            if (document.activeElement === searchInput) {
              startRealTimeSearch();
            }
          },

          // è¿‡æ»¤èƒŒåŒ…ç‰©å“ - å…¨å±€æœç´¢ç‰ˆæœ¬
          filterInventoryItems(keyword) {
            if (!keyword) {
              // å¦‚æœæ²¡æœ‰å…³é”®è¯ï¼Œæ˜¾ç¤ºå½“å‰tabçš„æ‰€æœ‰ç‰©å“
              this.renderInventoryContent(this.currentMvuState?.stat_data, this.currentInventoryTab);
              return;
            }

            const stat_data = this.currentMvuState?.stat_data;
            if (!stat_data) return;

            const categories = [
              { title: 'åŠŸæ³•', key: 'åŠŸæ³•åˆ—è¡¨', equipable: true },
              { title: 'æ­¦å™¨', key: 'æ­¦å™¨åˆ—è¡¨', equipable: true },
              { title: 'é˜²å…·', key: 'é˜²å…·åˆ—è¡¨', equipable: true },
              { title: 'é¥°å“', key: 'é¥°å“åˆ—è¡¨', equipable: true },
              { title: 'æ³•å®', key: 'æ³•å®åˆ—è¡¨', equipable: true },
              { title: 'ä¸¹è¯', key: 'ä¸¹è¯åˆ—è¡¨', equipable: false },
              { title: 'æ‚ç‰©', key: 'å…¶ä»–åˆ—è¡¨', equipable: false },
            ];

            const lowerKeyword = keyword.toLowerCase();
            const matchedItems = [];

            // å…¨å±€æœç´¢æ‰€æœ‰åˆ†ç±»ï¼Œå¹¶è®¡ç®—åŒ¹é…ä¼˜å…ˆçº§
            categories.forEach(cat => {
              const rawItems = this.SafeGetValue(stat_data, cat.key, {});
              const itemEntries = Object.entries(rawItems).filter(([name]) => name !== '$meta');

              itemEntries.forEach(([name, item]) => {
                const tier = this.SafeGetValue(item, 'tier', 'æ— ');
                const description = this.SafeGetValue(
                  item,
                  'description',
                  this.SafeGetValue(item, 'effect', 'æ— æè¿°')
                );
                
                // è·å–æ‰€æœ‰è¯æ¡æ–‡æœ¬
                const specialEffects = this.SafeGetValue(item, 'special_effects', {});
                const effectsText = Object.entries(specialEffects)
                  .filter(([key]) => key !== '$meta')
                  .map(([key, value]) => `${key}: ${value}`)
                  .join(' ');

                // è®¡ç®—åŒ¹é…ä¼˜å…ˆçº§
                const nameLower = name.toLowerCase();
                const descriptionLower = description.toLowerCase();
                const tierLower = tier.toLowerCase();
                const effectsLower = effectsText.toLowerCase();
                
                let priority = 0;
                let matched = false;
                
                // ä¼˜å…ˆçº§1ï¼šé”®åå®Œå…¨åŒ¹é…
                if (nameLower === lowerKeyword) {
                  priority = 1;
                  matched = true;
                }
                // ä¼˜å…ˆçº§2ï¼šé”®ååŒ…å«å…³é”®è¯
                else if (nameLower.includes(lowerKeyword)) {
                  priority = 2;
                  matched = true;
                }
                // ä¼˜å…ˆçº§3ï¼šå“é˜¶åŒ¹é…
                else if (tierLower.includes(lowerKeyword)) {
                  priority = 3;
                  matched = true;
                }
                // ä¼˜å…ˆçº§4ï¼šè¯æ¡åŒ¹é…
                else if (effectsLower.includes(lowerKeyword)) {
                  priority = 4;
                  matched = true;
                }
                // ä¼˜å…ˆçº§5ï¼šæè¿°åŒ¹é…
                else if (descriptionLower.includes(lowerKeyword)) {
                  priority = 5;
                  matched = true;
                }
                
                if (matched) {
                  matchedItems.push({
                    name,
                    item,
                    category: cat.title,
                    categoryKey: cat.key,
                    equipable: cat.equipable,
                    priority
                  });
                }
              });
            });

            // æŒ‰ä¼˜å…ˆçº§æ’åºï¼Œä¼˜å…ˆçº§æ•°å­—è¶Šå°è¶Šé å‰
            matchedItems.sort((a, b) => {
              if (a.priority !== b.priority) {
                return a.priority - b.priority;
              }
              // åŒä¼˜å…ˆçº§æŒ‰å“é˜¶æ’åºï¼ˆä»é«˜åˆ°ä½ï¼‰
              const tierA = this.SafeGetValue(a.item, 'tier', 'å‡¡å“');
              const tierB = this.SafeGetValue(b.item, 'tier', 'å‡¡å“');
              const orderA = this.getTierOrder(tierA);
              const orderB = this.getTierOrder(tierB);
              return orderB - orderA; // å“é˜¶é«˜çš„æ’å‰é¢
            });

            // æ¸²æŸ“æœç´¢ç»“æœ
            const contentArea = document.querySelector('#inventory-modal .inventory-content-area');
            if (!contentArea) return;

            if (matchedItems.length === 0) {
              contentArea.innerHTML = `<div class="inventory-item-list"><p class="empty-category-text">æœªæ‰¾åˆ°åŒ…å«"${keyword}"çš„ç‰©å“</p></div>`;
              return;
            }

            // matchedItemså·²ç»æŒ‰ä¼˜å…ˆçº§æ’åºï¼Œç›´æ¥æ¸²æŸ“
            let html = '<div class="inventory-item-list">';
            
            matchedItems.forEach(matchedItem => {
              const { name, item, category, equipable } = matchedItem;
              
              try {
                const itemWithFixName = { ...item, name };
                const itemJson = JSON.stringify(itemWithFixName).replace(/'/g, "'");
                
                const tier = this.SafeGetValue(item, 'tier', 'æ— ');
                const hasQuantity = item.hasOwnProperty('quantity');
                const quantity = parseInt(this.SafeGetValue(item, 'quantity', 1), 10);
                const description = this.SafeGetValue(
                  item,
                  'description',
                  this.SafeGetValue(item, 'effect', 'æ— æè¿°')
                );

                if (hasQuantity && quantity <= 0) {
                  return;
                }

                const tierStyle = this.getItemTierStyle(tier);
                const tierDisplay = tier !== 'æ— ' ? `<span style="${tierStyle} margin-right: 15px;">å“é˜¶: ${tier}</span>` : '';
                const quantityDisplay = hasQuantity ? `<span class="item-quantity">æ•°é‡: ${quantity}</span>` : '';
                const categoryDisplay = `<span style="color: #8b7355; margin-right: 15px;">åˆ†ç±»: ${category}</span>`;
                
                const currentEquipped = this._getEquipmentFromStatData(stat_data);
                const isEquipped = Object.values(currentEquipped).some(equippedItem => equippedItem && equippedItem.name === name);
                
                let actionButton = '';
                if (category === 'åŠŸæ³•') {
                  const isEquippedAsMain = currentEquipped.zhuxiuGongfa && currentEquipped.zhuxiuGongfa.name === name;
                  const isEquippedAsAux = currentEquipped.fuxiuXinfa && currentEquipped.fuxiuXinfa.name === name;
                  if (isEquippedAsMain) {
                    actionButton = `
                      <button class="item-unequip-btn" data-slot-id="equip-zhuxiuGongfa" style="margin-left: 5px;">å¸ä¸‹</button>
                      <button class="item-equip-btn" data-equip-type="fuxiu" style="margin-left: 5px; opacity: 0.5; cursor: not-allowed;" disabled>è¾…ä¿®</button>
                    `;
                  } else if (isEquippedAsAux) {
                    actionButton = `
                      <button class="item-equip-btn" data-equip-type="zhuxiu" style="margin-left: 5px; opacity: 0.5; cursor: not-allowed;" disabled>ä¸»ä¿®</button>
                      <button class="item-unequip-btn" data-slot-id="equip-fuxiuXinfa" style="margin-left: 5px;">å¸ä¸‹</button>
                    `;
                  } else {
                    actionButton = `
                      <button class="item-equip-btn" data-equip-type="zhuxiu" style="margin-left: 5px;">ä¸»ä¿®</button>
                      <button class="item-equip-btn" data-equip-type="fuxiu" style="margin-left: 5px;">è¾…ä¿®</button>
                    `;
                  }
                } else if (equipable) {
                  if (isEquipped) {
                    const slotKey = Object.keys(currentEquipped).find(
                      key => currentEquipped[key] && currentEquipped[key].name === name
                    );
                    actionButton = `<button class="item-unequip-btn" data-slot-id="equip-${slotKey}">å¸ä¸‹</button>`;
                  } else {
                    actionButton = `<button class="item-equip-btn">è£…å¤‡</button>`;
                  }
                } else if (category === 'ä¸¹è¯' || category === 'æ‚ç‰©') {
                  if (quantity <= 0) {
                    actionButton = `<button class="item-use-btn" disabled>å·²ç”¨å®Œ</button>`;
                  } else {
                    actionButton = `<button class="item-use-btn">ä½¿ç”¨</button>`;
                  }
                }

                actionButton += `<button class="item-discard-btn" style="margin-left: 5px; background: #8b0000; border-color: #ff6b6b;">ä¸¢å¼ƒ</button>`;

                let itemDetailsHtml = this.renderItemDetailsForInventory(item);

                html += `
                  <div class="inventory-item" data-item-details='${itemJson}' data-category='${category}'>
                    <div class="item-name" style="${tierStyle}">${name}</div>
                    <div class="item-header">
                      <div class="item-meta">
                        ${categoryDisplay}
                        ${tierDisplay}
                        ${quantityDisplay}
                      </div>
                      <div class="item-actions">
                        ${actionButton}
                      </div>
                    </div>
                    <div class="item-description">${description}</div>
                    ${itemDetailsHtml ? `<div class="item-details">${itemDetailsHtml}</div>` : ''}
                  </div>
                `;
              } catch (e) {
                console.error('è§£æèƒŒåŒ…ç‰©å“å¤±è´¥:', item, e);
              }
            });

            html += '</div>';
            contentArea.innerHTML = html;
          },


// ===èƒŒåŒ…æ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰ç»“æŸ===



// ===è£…å¤‡ç³»ç»Ÿæ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰å¼€å§‹===



          renderTooltipContent(item) {
            const tierStyle = this.getItemTierStyle(this.SafeGetValue(item, 'tier'));
            const level = this.SafeGetValue(item, 'level', '');
            const tierDisplay = level
              ? `${this.SafeGetValue(item, 'tier', 'å‡¡å“')} ${level}`
              : this.SafeGetValue(item, 'tier', 'å‡¡å“');

            const itemDetailsHtml = this.renderItemDetailsForInventory(item);

            return `
                    <div class="tooltip-title" style="${tierStyle}">${this.SafeGetValue(item, 'name')}</div>
                    <p><strong>å“é˜¶:</strong> ${tierDisplay}</p>
                    <p><i>${this.SafeGetValue(item, 'description', 'æ— æè¿°')}</i></p>
                    <div class="tooltip-section tooltip-attributes">${itemDetailsHtml}</div>
                `;
          },

          showEquipmentTooltip(element, event) {
            const tooltip = document.getElementById('equipment-tooltip');
            const itemDataString = element.dataset.itemDetails;
            if (!tooltip || !itemDataString) return;

            try {
              const item = JSON.parse(itemDataString.replace(/'/g, "'"));
              tooltip.innerHTML = this.renderTooltipContent(item);
              tooltip.style.display = 'block';
              const tooltipRect = tooltip.getBoundingClientRect();
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;
              let left = event.pageX + 15;
              let top = event.pageY + 15;

              // å¦‚æœTooltipè¶…å‡ºå³è¾¹ç•Œï¼Œåˆ™æ˜¾ç¤ºåœ¨é¼ æ ‡å·¦ä¾§
              if (left + tooltipRect.width > viewportWidth) {
                left = event.pageX - tooltipRect.width - 15;
              }

              // å¦‚æœTooltipè¶…å‡ºä¸‹è¾¹ç•Œï¼Œåˆ™æ˜¾ç¤ºåœ¨é¼ æ ‡ä¸Šä¾§
              if (top + tooltipRect.height > viewportHeight) {
                top = event.pageY - tooltipRect.height - 15;
              }

              tooltip.style.left = `${left}px`;
              tooltip.style.top = `${top}px`;
            } catch (e) {
              console.error('è§£æè£…å¤‡Tooltipæ•°æ®å¤±è´¥:', e);
            }
          },

          hideEquipmentTooltip() {
            const tooltip = document.getElementById('equipment-tooltip');
            if (tooltip) tooltip.style.display = 'none';
          },

          renderItemDetailsForInventory(item) {
            let attributesHtml = '';
            const attributes = item.attributes_bonus;
            if (typeof attributes === 'object' && attributes !== null && Object.keys(attributes).length > 0) {
              attributesHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">å›ºå®šåŠ æˆ</div>';
              for (const [key, value] of Object.entries(attributes)) {
                attributesHtml += `<p><strong>${key}:</strong> ${value > 0 ? '+' : ''}${value}</p>`;
              }
            }

            const percentBonuses = item['ç™¾åˆ†æ¯”åŠ æˆ'];
            if (typeof percentBonuses === 'object' && percentBonuses !== null && Object.keys(percentBonuses).length > 0) {
              attributesHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">ç™¾åˆ†æ¯”åŠ æˆ</div>';
              for (const [key, value] of Object.entries(percentBonuses)) {
                 const displayValue = String(value).endsWith('%') ? value : `${value}%`;
                 attributesHtml += `<p><strong>${key}:</strong> +${displayValue}</p>`;
              }
            }

            let proficiencyHtml = '';
            const proficiency = item.proficiency;
            if (proficiency && typeof proficiency === 'object') {
              const current = proficiency.current || 0;
              const max = proficiency.max || 100;
              const percentage = max > 0 ? Math.round((current / max) * 100) : 0;
              proficiencyHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">ç†Ÿç»ƒåº¦</div>';
              proficiencyHtml += `<p><strong>å½“å‰ç†Ÿç»ƒåº¦:</strong> ${current} / ${max} (${percentage}%)</p>`;
            }

            let skillEffectsHtml = '';
            const skillEffects = item.skill_effects;
            if (skillEffects && typeof skillEffects === 'object') {
              const effectEntries = Object.entries(skillEffects).filter(([key]) => key !== '$meta');
              if (effectEntries.length > 0) {
                skillEffectsHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">åŠŸæ³•æ•ˆæœ</div>';
                effectEntries.forEach(([key, effect]) => {
                  if (typeof effect === 'object' && effect !== null) {
                    const name = effect.name || key;
                    const description = effect.description || '';
                    skillEffectsHtml += `<p>- <strong>${name}:</strong> <span class="citiao-description">${description}</span></p>`;
                  } else {
                    skillEffectsHtml += `<p>- <strong>${key}:</strong> <span class="citiao-description">${effect}</span></p>`;
                  }
                });
              }
            }

            let skillMovesHtml = '';
            const skillMoves = item.skill_moves;
            if (skillMoves && typeof skillMoves === 'object') {
              const moveEntries = Object.entries(skillMoves).filter(([key]) => key !== '$meta');
              if (moveEntries.length > 0) {
                skillMovesHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">åŠŸæ³•æ‹›å¼</div>';
                moveEntries.forEach(([key, move]) => {
                  if (typeof move === 'object' && move !== null) {
                    const name = move.name || key;
                    const description = move.description || '';
                    skillMovesHtml += `<p>- <strong>${name}:</strong> <span class="citiao-description">${description}</span></p>`;
                  } else {
                    skillMovesHtml += `<p>- <strong>${key}:</strong> <span class="citiao-description">${move}</span></p>`;
                  }
                });
              }
            }

            let effectsHtml = '';
            const effects = item.special_effects;

            if (effects) {
                effectsHtml += `<div class="tooltip-section-title" style="margin-top: 5px;">ç‰¹æ®Šè¯æ¡</div>`;
                if (typeof effects === 'object' && !Array.isArray(effects) && effects !== null) {
                    for (const [key, value] of Object.entries(effects)) {
                        if (key === '$meta') continue;
                        
                        // å…¼å®¹åµŒå¥—æ ¼å¼ï¼šå¦‚æœvalueæ˜¯å¯¹è±¡ï¼Œåˆ™é€’å½’æ¸²æŸ“
                        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                            effectsHtml += `<p>- <strong>${key}:</strong></p>`;
                            effectsHtml += '<div style="margin-left: 15px;">';
                            for (const [subKey, subValue] of Object.entries(value)) {
                                if (subKey === '$meta') continue;
                                effectsHtml += `<p>- <strong>${subKey}:</strong> <span class="citiao-description">${subValue}</span></p>`;
                            }
                            effectsHtml += '</div>';
                        } else {
                            effectsHtml += `<p>- <strong>${key}:</strong> <span class="citiao-description">${value}</span></p>`;
                        }
                    }
                } else if (Array.isArray(effects)) {
                    effectsHtml += effects.filter(eff => eff !== '$__META_EXTENSIBLE__$').map(eff => `<p>- ${eff}</p>`).join('');
                } else if (typeof effects === 'string' && effects.trim() !== '') {
                    effectsHtml += effects.split('\n').map(e => e.trim()).filter(e => e).map(eff => `<p>- ${eff}</p>`).join('');
                }
            }

            return `${attributesHtml}${percentBonuses ? '' : ''}${proficiencyHtml}${skillEffectsHtml}${skillMovesHtml}${effectsHtml}`;
          },

          async equipItem(item, category, buttonElement, equipType = null) {


            const itemName = this.SafeGetValue(item, 'name');
            if (!itemName || itemName === 'N/A') {
              console.warn('[è£…å¤‡ç³»ç»Ÿ] ç‰©å“æ— åç§°ï¼Œè£…å¤‡å¤±è´¥');
              this.showTemporaryMessage('ç‰©å“æ— åç§°ï¼Œæ— æ³•è£…å¤‡ã€‚');
              return;
            }
            
            // åŸºäºstat_dataæ£€æŸ¥åŠŸæ³•æ˜¯å¦å·²è¢«è£…å¤‡åœ¨å¦ä¸€ä¸ªæ§½ä½
            if (category === 'åŠŸæ³•') {
              const currentEquipped = this._getEquipmentFromStatData(this.currentMvuState?.stat_data);
              const isEquippedAsMain = currentEquipped.zhuxiuGongfa?.name === itemName;
              const isEquippedAsAux = currentEquipped.fuxiuXinfa?.name === itemName;
              if (
                (equipType === 'fuxiuXinfa' && isEquippedAsMain) ||
                (equipType === 'zhuxiuGongfa' && isEquippedAsAux)
              ) {
                console.warn('[è£…å¤‡ç³»ç»Ÿ] è¯¥åŠŸæ³•å·²è¢«è£…å¤‡åœ¨å¦ä¸€æ§½ä½');
                this.showTemporaryMessage('è¯¥åŠŸæ³•å·²è¢«è£…å¤‡åœ¨å¦ä¸€æ§½ä½ã€‚');
                return;
              }
            }

            let slotKey;
            if (category === 'åŠŸæ³•') {
                slotKey = equipType; // åŠŸæ³•ç›´æ¥ä½¿ç”¨equipTypeä½œä¸ºslotKey
            } else {
                const categoryMap = { æ­¦å™¨: 'wuqi', é˜²å…·: 'fangju', é¥°å“: 'shipin', æ³•å®: 'fabao1' };
                slotKey = categoryMap[category];
            }

            console.log('[è£…å¤‡ç³»ç»Ÿ] æ§½ä½æ˜ å°„', { category, equipType, slotKey });

            if (!slotKey) {
              console.error('[è£…å¤‡ç³»ç»Ÿ] é”™è¯¯çš„è£…å¤‡åˆ†ç±»æˆ–ç±»å‹', { category, equipType });
              this.showTemporaryMessage('é”™è¯¯çš„è£…å¤‡åˆ†ç±»æˆ–ç±»å‹ã€‚');
              return;
            }
            const currentEquipped = this._getEquipmentFromStatData(this.currentMvuState?.stat_data);
            const currentlyEquippedSlot = Object.keys(currentEquipped).find(
              key => currentEquipped[key]?.name === itemName,
            );
            if (currentlyEquippedSlot && currentlyEquippedSlot !== slotKey) {
              console.log('[è£…å¤‡ç³»ç»Ÿ] åœ¨å…¶ä»–æ§½ä½å‘ç°åŒåè£…å¤‡ï¼Œå…ˆå¸è½½');
              const oldSlotElement = document.getElementById(`equip-${currentlyEquippedSlot}`);
              if (oldSlotElement) {
                this.unequipItem(`equip-${currentlyEquippedSlot}`, oldSlotElement, false); // é™é»˜å¸è½½
              }
            }

            const slotElement = document.getElementById(`equip-${slotKey}`);
            if (!slotElement) {
              console.error('[è£…å¤‡ç³»ç»Ÿ] æ‰¾ä¸åˆ°æ§½ä½å…ƒç´ ', { slotKey });
              return;
            }

            // å¦‚æœè¯¥æ§½ä½å·²æœ‰è£…å¤‡ï¼Œå…ˆæ‰§è¡Œå¸è½½æ“ä½œ
            const oldItem = currentEquipped[slotKey];
            if (oldItem) {
              console.log('[è£…å¤‡ç³»ç»Ÿ] æ§½ä½å·²æœ‰è£…å¤‡ï¼Œå…ˆå¸è½½', { oldItem: oldItem.name });
              this.unequipItem(`equip-${slotKey}`, slotElement, false);
            }

            // æ›´æ–°UIæ˜¾ç¤º
            const tier = this.SafeGetValue(item, 'tier', 'å‡¡å“');
            const tierStyle = this.getItemTierStyle(tier);
            slotElement.textContent = this.SafeGetValue(item, 'name');
            slotElement.setAttribute('style', tierStyle);
            slotElement.classList.add('equipped');
            slotElement.dataset.itemDetails = JSON.stringify(item).replace(/'/g, "'");

            // ç”ŸæˆMVUå‘½ä»¤ - ä½¿ç”¨å®é™…çš„MVUé”®å
            const slotToMvuKeyMap = {
              wuqi: 'æ­¦å™¨',
              fangju: 'é˜²å…·',
              shipin: 'é¥°å“',
              fabao1: 'æ³•å®æ ', 
              zhuxiuGongfa: 'ä¸»ä¿®åŠŸæ³•',
              fuxiuXinfa: 'è¾…ä¿®å¿ƒæ³•',
            };
            const mvuKey = slotToMvuKeyMap[slotKey] || category;
            
            // --- MVU API é‡æ„å¼€å§‹ ---
            const mvuData = this.currentMvuState;
            if (!mvuData) {
              console.error('[è£…å¤‡ç³»ç»Ÿ] æ— æ³•è·å–MVUçŠ¶æ€ï¼Œæ“ä½œä¸­æ–­');
              this.showTemporaryMessage('å‘ç”Ÿå†…éƒ¨é”™è¯¯ï¼Œè£…å¤‡å¤±è´¥');
              return;
            }

            console.log(`[è£…å¤‡ç³»ç»Ÿ] å¼€å§‹é€šè¿‡MVU APIè£…å¤‡ ${itemName} åˆ° ${mvuKey}`);

            // 1. è®¾ç½®è£…å¤‡æ§½
            const cleanedItem = JSON.parse(JSON.stringify(item, (key, value) => (value === undefined ? null : value)));
            await Mvu.setMvuVariable(mvuData, mvuKey, cleanedItem, { reason: `è£…å¤‡ ${itemName}` });
            // 2.1 é¦–å…ˆæ›´æ–°æ€»ç™¾åˆ†æ¯”åŠ æˆå¯¹è±¡
            const percentBonuses = item['ç™¾åˆ†æ¯”åŠ æˆ'];
            if (percentBonuses && typeof percentBonuses === 'object') {
              for (const [mvuName, bonusValue] of Object.entries(percentBonuses)) {
                const value = parseFloat(String(bonusValue).replace('%', '')) || 0;
                if (value !== 0) {
                  const path = `å½“å‰ç™¾åˆ†æ¯”åŠ æˆ.${mvuName}`;
                  const currentValueStr = Mvu.getMvuVariable(mvuData, path, { default_value: '0%' });
                  const currentValue = parseFloat(currentValueStr.replace('%', '')) || 0;
                  await Mvu.setMvuVariable(mvuData, path, `${currentValue + value}%`, { reason: `è£…å¤‡ ${itemName}` });
                }
              }
            }

            // 2.2 ç„¶åç”¨ã€æ›´æ–°åã€‘çš„æ€»ç™¾åˆ†æ¯”è®¡ç®—æœ€ç»ˆå¢ç›Š
            const updatedPercentBonusesData = Mvu.getMvuVariable(mvuData, 'å½“å‰ç™¾åˆ†æ¯”åŠ æˆ', { default_value: {} });
            const flatBonuses = item.attributes_bonus;
            if (flatBonuses && typeof flatBonuses === 'object') {
              for (const [mvuName, bonusValue] of Object.entries(flatBonuses)) {
                const value = parseInt(bonusValue, 10) || 0;
                if (value !== 0) {
                  const percentStr = String(updatedPercentBonusesData[mvuName] || '0%');
                  const percent = (parseFloat(percentStr.replace('%', '')) || 0) / 100;
                  const finalGain = Math.floor(value * (1 + percent));
                  
                  const currentValue = Mvu.getMvuVariable(mvuData, mvuName, { default_value: 0 });
                  await Mvu.setMvuVariable(mvuData, mvuName, currentValue + finalGain, { reason: `è£…å¤‡ ${itemName} (+${value} -> +${finalGain})` });
                }
              }
            }

            // 4. æ›´æ–°è¡€é‡ä¸Šé™
            await this._updateHealthCap(mvuData);

            // 5. ä¹è§‚æ›´æ–°UIï¼šåœ¨ä¸åç«¯åŒæ­¥å‰ï¼Œç«‹åˆ»åˆ·æ–°å‰ç«¯ç•Œé¢ï¼Œæ¶ˆé™¤å»¶è¿Ÿæ„Ÿ
            this.renderUI(this.currentMvuState.stat_data);
            this.showTemporaryMessage(`å·²è£…å¤‡ ${this.SafeGetValue(item, 'name')}`);
            const inventoryModal = document.getElementById('inventory-modal');
            if (inventoryModal && inventoryModal.style.display !== 'none') {
                this.showInventory(true); // ä¿®å¤ï¼šå¼ºåˆ¶ä½¿ç”¨æœ¬åœ°çŠ¶æ€åˆ·æ–°èƒŒåŒ…UI
            }

            // 6. å°†æ‰€æœ‰å˜æ›´ä¸€æ¬¡æ€§åŒæ­¥åˆ°åç«¯ï¼ˆåœ¨åå°è¿›è¡Œï¼‰
            await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });
            console.log('[è£…å¤‡ç³»ç»Ÿ] MVUçŠ¶æ€å·²åŒæ­¥åˆ°åç«¯');
          },

          async unequipItem(slotId, slotElement, showMessage = true, refreshInventoryUI = true) {
            const slotKey = slotId.replace('equip-', '');
            const defaultTextMap = {
              wuqi: 'æ­¦å™¨',
              fangju: 'é˜²å…·',
              shipin: 'é¥°å“',
              fabao1: 'æ³•å®',
              zhuxiuGongfa: 'ä¸»ä¿®åŠŸæ³•',
              fuxiuXinfa: 'è¾…ä¿®å¿ƒæ³•',
            };

            const itemDataString = slotElement.dataset.itemDetails;
            if (!itemDataString) {
              console.warn('[è£…å¤‡ç³»ç»Ÿ] æ§½ä½æ²¡æœ‰è£…å¤‡æ•°æ®ï¼Œè·³è¿‡å¸è½½');
              return; // å¦‚æœæ²¡æœ‰ç‰©å“ï¼Œåˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œ
            }

            let itemName = 'ä¸€ä»¶è£…å¤‡';
            let item = null;
            try {
              item = JSON.parse(itemDataString.replace(/'/g, "'"));
              itemName = this.SafeGetValue(item, 'name');
            } catch (e) {
              console.error('[è£…å¤‡ç³»ç»Ÿ] å¸è½½æ—¶è§£æç‰©å“æ•°æ®å¤±è´¥', e);
            }

            // æ›´æ–°UIæ˜¾ç¤º
            slotElement.textContent = defaultTextMap[slotKey] || 'ç©º';
            slotElement.classList.remove('equipped');
            slotElement.removeAttribute('style');
            delete slotElement.dataset.itemDetails;
            const mvuData = this.currentMvuState;
            if (!mvuData) {
              console.error('[è£…å¤‡ç³»ç»Ÿ] æ— æ³•è·å–MVUçŠ¶æ€ï¼Œå¸è½½æ“ä½œä¸­æ–­');
              this.showTemporaryMessage('å‘ç”Ÿå†…éƒ¨é”™è¯¯ï¼Œå¸è½½å¤±è´¥');
              return;
            }
            const mvuKey = defaultTextMap[slotKey];
            console.log(`[è£…å¤‡ç³»ç»Ÿ] å¼€å§‹é€šè¿‡MVU APIå¸è½½ ${itemName} ä» ${mvuKey}`);

            // 1. æ¸…ç©ºè£…å¤‡æ§½
            await Mvu.setMvuVariable(mvuData, mvuKey, null, { reason: `å¸ä¸‹ ${itemName}` });

            if (item) {
              // 2.1 é¦–å…ˆè®¡ç®—å‡ºã€å¸ä¸‹å‰ã€‘çš„æœ€ç»ˆå‡ç›Šå€¼
              // æ³¨æ„ï¼šå‡ç›Šå¿…é¡»åŸºäºå¸ä¸‹å‰çš„ç™¾åˆ†æ¯”æ¥è®¡ç®—ï¼Œå¦åˆ™ä¼šå¤šæ‰£
              const originalPercentBonusesData = Mvu.getMvuVariable(mvuData, 'å½“å‰ç™¾åˆ†æ¯”åŠ æˆ', { default_value: {} });
              const flatBonuses = item.attributes_bonus;
              if (flatBonuses && typeof flatBonuses === 'object') {
                for (const [mvuName, bonusValue] of Object.entries(flatBonuses)) {
                  const value = parseInt(bonusValue, 10) || 0;
                  if (value !== 0) {
                    const percentStr = String(originalPercentBonusesData[mvuName] || '0%');
                    const percent = (parseFloat(percentStr.replace('%', '')) || 0) / 100;
                    const finalLoss = Math.floor(value * (1 + percent));
                    
                    const currentValue = Mvu.getMvuVariable(mvuData, mvuName, { default_value: 0 });
                    await Mvu.setMvuVariable(mvuData, mvuName, currentValue - finalLoss, { reason: `å¸ä¸‹ ${itemName} (-${value} -> -${finalLoss})` });
                  }
                }
              }

              // 2.2 ç„¶åå†æ›´æ–°æ€»ç™¾åˆ†æ¯”åŠ æˆå¯¹è±¡
              const percentBonuses = item['ç™¾åˆ†æ¯”åŠ æˆ'];
              if (percentBonuses && typeof percentBonuses === 'object') {
                for (const [mvuName, bonusValue] of Object.entries(percentBonuses)) {
                  const value = parseFloat(String(bonusValue).replace('%', '')) || 0;
                  if (value !== 0) {
                    const path = `å½“å‰ç™¾åˆ†æ¯”åŠ æˆ.${mvuName}`;
                    const currentValueStr = Mvu.getMvuVariable(mvuData, path, { default_value: '0%' });
                    const currentValue = parseFloat(currentValueStr.replace('%', '')) || 0;
                    await Mvu.setMvuVariable(mvuData, path, `${currentValue - value}%`, { reason: `å¸ä¸‹ ${itemName}` });
                  }
                }
              }
            }

            // 4. æ›´æ–°è¡€é‡ä¸Šé™
            await this._updateHealthCap(mvuData);

            // 5. ä¹è§‚æ›´æ–°UIï¼šåœ¨ä¸åç«¯åŒæ­¥å‰ï¼Œç«‹åˆ»åˆ·æ–°å‰ç«¯ç•Œé¢
            this.renderUI(this.currentMvuState.stat_data);
            if (showMessage) {
              this.showTemporaryMessage(`å·²å¸ä¸‹ ${itemName}`);
            }
            const inventoryModal = document.getElementById('inventory-modal');
            if (inventoryModal && inventoryModal.style.display !== 'none') {
                this.showInventory(true); // ä¿®å¤ï¼šå¼ºåˆ¶ä½¿ç”¨æœ¬åœ°çŠ¶æ€åˆ·æ–°èƒŒåŒ…UI
            }

            // 6. å°†æ‰€æœ‰å˜æ›´ä¸€æ¬¡æ€§åŒæ­¥åˆ°åç«¯ï¼ˆåœ¨åå°è¿›è¡Œï¼‰
            await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });
            console.log('[è£…å¤‡ç³»ç»Ÿ] MVUçŠ¶æ€å·²åŒæ­¥åˆ°åç«¯');
          },

          loadEquipmentFromMVU(data) {  
            const equipmentMap = {
              æ­¦å™¨: 'wuqi',
              ä¸»ä¿®åŠŸæ³•: 'zhuxiuGongfa',
              è¾…ä¿®å¿ƒæ³•: 'fuxiuXinfa',
              é˜²å…·: 'fangju',
              é¥°å“: 'shipin',
              æ³•å®æ : 'fabao1', 
            };
            const defaultTextMap = {
              wuqi: 'æ­¦å™¨',
              fangju: 'é˜²å…·',
              shipin: 'é¥°å“',
              fabao1: 'æ³•å®',
              zhuxiuGongfa: 'ä¸»ä¿®åŠŸæ³•',
              fuxiuXinfa: 'è¾…ä¿®å¿ƒæ³•',
            };

            for (const [mvuKey, slotKey] of Object.entries(equipmentMap)) {
              const slot = document.getElementById(`equip-${slotKey}`);
              if (!slot) {
                continue;
              }
              const item = _.get(data, mvuKey, null);
              if (item && typeof item === 'object' && item.name) {
                const tier = this.SafeGetValue(item, 'tier', 'å‡¡å“');
                const tierStyle = this.getItemTierStyle(tier);
                
                slot.textContent = this.SafeGetValue(item, 'name');
                slot.setAttribute('style', tierStyle);
                slot.classList.add('equipped');
                slot.dataset.itemDetails = JSON.stringify(item).replace(/'/g, "'");
              } else {
                slot.textContent = defaultTextMap[slotKey];
                slot.classList.remove('equipped');
                slot.removeAttribute('style');
                delete slot.dataset.itemDetails;
              }
            }
          },

          _getEquipmentFromStatData(stat_data) {
              const equipmentMap = {
                æ­¦å™¨: 'wuqi',
                ä¸»ä¿®åŠŸæ³•: 'zhuxiuGongfa',
                è¾…ä¿®å¿ƒæ³•: 'fuxiuXinfa',
                é˜²å…·: 'fangju',
                é¥°å“: 'shipin',
                æ³•å®æ : 'fabao1', 
              };
              const equippedItems = {};
              for (const [mvuKey, slotKey] of Object.entries(equipmentMap)) {
                  const item = _.get(stat_data, mvuKey, null);
                  if (item && typeof item === 'object' && item.name) {
                      equippedItems[slotKey] = item;
                  }
              }
              return equippedItems;
          },



// ===è£…å¤‡ç³»ç»Ÿæ¨¡å—ï¼ˆæä¸ºé‡è¦ï¼‰å¼€å§‹===



// ===å„ç±»æ•°å€¼å¤„ç†ã€æ¸²æŸ“æ¨¡å—ï¼ˆè¶…çº§é‡è¦ï¼‰å¼€å§‹===
// mvuå˜é‡


          updateDisplayedAttributes(stat_data_param = null) {
            // ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«
            // **é‡æ„ç¬¬ä¸€æ­¥ï¼šç»Ÿä¸€æ•°æ®æº**
            // ä¸¥æ ¼ä½¿ç”¨ä¼ å…¥çš„ stat_data_param ä½œä¸ºå”¯ä¸€æ•°æ®æºã€‚
            // ä»…å½“ stat_data_param ä¸º null æ—¶ï¼Œæ‰å®‰å…¨åœ°å›é€€åˆ° this.currentMvuState.stat_dataã€‚
            const stat_data = stat_data_param || (this.currentMvuState ? this.currentMvuState.stat_data : null);
            if (!stat_data) {
                console.warn('[å±æ€§æ›´æ–°] stat_dataä¸å¯ç”¨ï¼Œè®¡ç®—ç»ˆæ­¢ã€‚');
                // å½“æ•°æ®ä¸å¯ç”¨æ—¶ï¼Œæ˜¾ç¤ºé»˜è®¤çš„"..."è€Œä¸æ˜¯"0 / 0"
                document.getElementById('attr-xueliang').innerText = '...';
                document.getElementById('attr-fali').innerText = '...';
                document.getElementById('attr-shenhai').innerText = '...';
                document.getElementById('attr-daoxin').innerText = '...';
                document.getElementById('attr-kongsu').innerText = '...';
                document.getElementById('attr-qiyun').innerText = '...';
                document.getElementById('attr-wuxing').innerText = '...';
                document.getElementById('attr-meili').innerText = '...';
                return;
            }
            
            
            // **ç®€åŒ–ç‰ˆæ¸²æŸ“å‡½æ•°**
            // æœ¬å‡½æ•°ç°åœ¨åªè´Ÿè´£è¯»å–MVUä¸­çš„æœ€ç»ˆå€¼å¹¶å°†å…¶æ¸²æŸ“åˆ°UIï¼Œä¸å†è¿›è¡Œä»»ä½•è®¡ç®—ã€‚
            // å¤æ‚çš„å±æ€§è®¡ç®—é€»è¾‘å·²ç§»è‡³ equipItem å’Œ unequipItem ä¸­ã€‚

            // 1. è¯»å–æ‰€æœ‰ç›¸å…³çš„ä¸Šé™å’Œå½“å‰å€¼
            const finalMaxAttrs = {
              fali: parseInt(this.SafeGetValue(stat_data, 'æ³•åŠ›', 0), 10),
              shenhai: parseInt(this.SafeGetValue(stat_data, 'ç¥æµ·', 0), 10),
              daoxin: parseInt(this.SafeGetValue(stat_data, 'é“å¿ƒ', 0), 10),
              kongsu: parseInt(this.SafeGetValue(stat_data, 'ç©ºé€Ÿ', 0), 10),
              qiyun: parseInt(this.SafeGetValue(stat_data, 'æ°”è¿', 0), 10),
              wuxing: parseInt(this.SafeGetValue(stat_data, 'æ‚Ÿæ€§', 0), 10),
              meili: parseInt(this.SafeGetValue(stat_data, 'é­…åŠ›', 0), 10),
              xueliang: parseInt(this.SafeGetValue(stat_data, 'è¡€é‡', 0), 10)
            };
            
            const currentAttrs = {
                fali: parseInt(this.SafeGetValue(stat_data, 'å½“å‰æ³•åŠ›', finalMaxAttrs.fali), 10),
                shenhai: parseInt(this.SafeGetValue(stat_data, 'å½“å‰ç¥æµ·', finalMaxAttrs.shenhai), 10),
                daoxin: parseInt(this.SafeGetValue(stat_data, 'å½“å‰é“å¿ƒ', finalMaxAttrs.daoxin), 10),
                kongsu: parseInt(this.SafeGetValue(stat_data, 'å½“å‰ç©ºé€Ÿ', finalMaxAttrs.kongsu), 10),
                xueliang: parseInt(this.SafeGetValue(stat_data, 'å½“å‰è¡€é‡', finalMaxAttrs.xueliang), 10)
            };

            // 2. æ›´æ–°UI
            const updateAttr = (elementId, current, max) => {
                const element = document.getElementById(elementId);
                if (element) element.innerText = `${current} / ${max}`;
            };
            const updateSingleAttr = (elementId, value) => {
                const element = document.getElementById(elementId);
                if (element) element.innerText = value;
            };

            updateAttr('attr-xueliang', currentAttrs.xueliang, finalMaxAttrs.xueliang);
            updateAttr('attr-fali', currentAttrs.fali, finalMaxAttrs.fali);
            updateAttr('attr-shenhai', currentAttrs.shenhai, finalMaxAttrs.shenhai);
            updateAttr('attr-daoxin', currentAttrs.daoxin, finalMaxAttrs.daoxin);
            updateAttr('attr-kongsu', currentAttrs.kongsu, finalMaxAttrs.kongsu);
            updateSingleAttr('attr-qiyun', finalMaxAttrs.qiyun);
            updateSingleAttr('attr-wuxing', finalMaxAttrs.wuxing);
            updateSingleAttr('attr-meili', finalMaxAttrs.meili);
            const xiuxingjindu = this.SafeGetValue(stat_data, 'ä¿®ä¸ºè¿›åº¦', '0');
            const xiuxingpingjing = this.SafeGetValue(stat_data, 'ä¿®ä¸ºç“¶é¢ˆ', 'æ— ');
            const jingjieYingshe = this.SafeGetValue(stat_data, 'å¢ƒç•Œæ˜ å°„', '1');
            document.getElementById('attr-xiuxing-jindu').innerText = `${xiuxingjindu}%`;
            document.getElementById('attr-xiuxing-pingjing').innerText = xiuxingpingjing;
            document.getElementById('attr-jingjie-yingshe').innerText = jingjieYingshe;
            const progressBar = document.getElementById('progress-xiuxing');
            if (progressBar) {
              progressBar.style.width = `${xiuxingjindu}%`;
            }

            this.updateSpecialAttributes(stat_data);
          },

          async _updateHealthCap(mvuData) {
              if (!mvuData) return;
              const stat_data = mvuData.stat_data;
              
              const fali = parseInt(Mvu.getMvuVariable(mvuData, 'æ³•åŠ›', { default_value: 0 }), 10);
              const shenhai = parseInt(Mvu.getMvuVariable(mvuData, 'ç¥æµ·', { default_value: 0 }), 10);
              const daoxin = parseInt(Mvu.getMvuVariable(mvuData, 'é“å¿ƒ', { default_value: 0 }), 10);
              const kongsu = parseInt(Mvu.getMvuVariable(mvuData, 'ç©ºé€Ÿ', { default_value: 0 }), 10);

              const newHealthCap = Math.floor((fali * 0.2) + (daoxin * 0.5) + (shenhai * 0.3) + (kongsu * 0.1));
              
              const existingHealthCap = parseInt(Mvu.getMvuVariable(mvuData, 'è¡€é‡', { default_value: 0 }), 10);

              if (newHealthCap !== existingHealthCap) {
                  await Mvu.setMvuVariable(mvuData, 'è¡€é‡', newHealthCap, { reason: 'å››ç»´å±æ€§å˜åŒ–å¯¼è‡´è¡€é‡ä¸Šé™æ›´æ–°' });
                  // åŒæ—¶æ›´æ–°å½“å‰è¡€é‡ï¼Œç¡®ä¿ä¸ä¼šè¶…è¿‡æ–°ä¸Šé™
                  const currentHealth = parseInt(Mvu.getMvuVariable(mvuData, 'å½“å‰è¡€é‡', { default_value: 0 }), 10);
                  if (currentHealth > newHealthCap) {
                      await Mvu.setMvuVariable(mvuData, 'å½“å‰è¡€é‡', newHealthCap, { reason: 'è¡€é‡ä¸Šé™å˜åŒ–' });
                  }
              }
          },

          updateSpecialAttributes(stat_data) {
            const container = document.getElementById('xiuwei-details-list');
            const oldSpecialAttrs = container.querySelectorAll('.details-container');
            oldSpecialAttrs.forEach(el => el.remove());

            const specialAttrs = {
              'çœŸæ°”': 'zhenqi',
              'ç­‘åŸºå¥‡ç‰©': 'zhujiqiwu',
              'æ´å¤©': 'dongtian',
              'ç¥å¦™': 'shenmiao',
              'æœ¬å‘½ç¥å¦™': 'benmingshenmiao'
            };

            // å¤„ç†ä»™çµä¹‹æ°”
            const xianlingzhiqi = this.SafeGetValue(stat_data, 'ä»™çµä¹‹æ°”', null);
            // ç¡®ä¿åœ¨å¤„ç†å…¶ä»–å±æ€§ *ä¹‹å* å†å¤„ç†ä»™çµä¹‹æ°”ï¼Œä»¥ä¿è¯å…¶åœ¨æœ€ä¸‹æ–¹
            const finalHtmlProcessing = () => {
              const existingEl = document.getElementById('xianlingzhiqi-dynamic-item');
              if(existingEl) existingEl.remove();

              if (xianlingzhiqi !== null && xianlingzhiqi > 0) {
                const detailsContainer = document.getElementById('xiuwei-details-list');
                if(detailsContainer){
                  const xianlingzhiqiHtml = `
                    <div class="attribute-item" id="xianlingzhiqi-dynamic-item">
                      <span class="attribute-name xianlingzhiqi-special">ä»™çµä¹‹æ°”</span>
                      <span id="attr-xianlingzhiqi" class="attribute-value xianlingzhiqi-special">${xianlingzhiqi}</span>
                    </div>
                  `;
                  detailsContainer.insertAdjacentHTML('beforeend', xianlingzhiqiHtml);
                }
              }
            };

            let finalHtml = '';
            for (const [name, idPrefix] of Object.entries(specialAttrs)) {
                const data = this.SafeGetValue(stat_data, name, null);
                if (!data || typeof data !== 'object') continue;

                const entries = Object.entries(data).filter(([key]) => key !== '$meta');
                if (entries.length === 0) continue;

                let sectionHtml = '';
                // ç»Ÿä¸€å¤„ç†æ‰€æœ‰ç‰¹æ®Šå±æ€§
                let itemsHtml = '';
                entries.forEach(([itemName, itemDetails]) => {
                        const tier = this.SafeGetValue(itemDetails, 'å“é˜¶', 'å‡¡å“');
                        const tierStyle = this.getItemTierStyle(tier);
                        const itemDetailsHtml = this.renderRecursiveDetails(itemDetails, ['å“é˜¶']);
                        itemsHtml += `
                           <details class="details-container">
                               <summary>
                                   <span class="attribute-name">${name}</span>
                                   <span class="attribute-value" style="${tierStyle}">${tier ? `ã€${tier}ã€‘ ` : ''}${itemName}</span>
                               </summary>
                               <div class="details-content">${itemDetailsHtml}</div>
                           </details>
                        `;
                    });
                    // ä¿®æ”¹ï¼šä¸å†åˆ›å»ºç‹¬ç«‹çš„sectionï¼Œç›´æ¥ä½¿ç”¨itemsHtml
                    if (itemsHtml) {
                        sectionHtml = itemsHtml;
                    }
                 if(sectionHtml) {
                    finalHtml += sectionHtml;
                }
            }
            // ä¿®æ”¹ï¼šä½¿ç”¨appendChildè¿½åŠ å†…å®¹ï¼Œè€Œä¸æ˜¯innerHTMLè¦†ç›–
            container.insertAdjacentHTML('beforeend', finalHtml);
            
            // æœ€åå¤„ç†ä»™çµä¹‹æ°”
            finalHtmlProcessing();
          },

          renderRecursiveDetails(obj, excludeKeys = []) {
            if (!obj || typeof obj !== 'object') return '';

            let mainContentHtml = '';
            let descriptionHtml = '';
            let citiaoHtml = '';
            let bonusHtml = '';
            let percentBonusHtml = '';
            let nestedCollectionHtml = '';
            let historyHtml = '';

            const tempObj = { ...obj };

            // æå–å¹¶åˆ†ç¦»å„ç±»æ•°æ®
            const description = tempObj['æè¿°'] || '';
            if(description) delete tempObj['æè¿°'];

            const citiaoData = tempObj['è¯æ¡'] || null;
            if(citiaoData) {
                citiaoHtml = this.renderCitiaoBlock(citiaoData);
                delete tempObj['è¯æ¡'];
            }
            
            const bonusData = tempObj['attributes_bonus'] || null;
            if(bonusData) {
                bonusHtml = this.renderBonusBlock('å›ºå®šåŠ æˆ', bonusData);
                delete tempObj['attributes_bonus'];
            }

            const percentBonusData = tempObj['ç™¾åˆ†æ¯”åŠ æˆ'] || null;
            if(percentBonusData) {
                percentBonusHtml = this.renderBonusBlock('ç™¾åˆ†æ¯”åŠ æˆ', percentBonusData, true);
                delete tempObj['ç™¾åˆ†æ¯”åŠ æˆ'];
            }
            
            const timeKeys = ['è·å–æ—¶é—´', 'å¼€è¾Ÿæ—¶é—´', 'å‡ç»ƒæ—¶é—´', 'ç‚¼å°±æ—¶é—´'];
            let timeStr = '';
            timeKeys.forEach(key => {
                if (tempObj[key]) {
                    timeStr = tempObj[key];
                    delete tempObj[key];
                }
            });
            let historyStr = tempObj['ç»å†'] || '';
            if(historyStr) delete tempObj['ç»å†'];

            if (timeStr || historyStr) {
                 let combinedGossip = '';
                if (timeStr) combinedGossip += timeStr;
                if (historyStr) combinedGossip += (timeStr ? 'ï¼Œ' : '') + historyStr;
                historyHtml = `
                    <details class="details-container">
                        <summary>
                            <span class="attribute-name">è·å–ç»å†</span>
                            <span class="attribute-value"></span>
                        </summary>
                        <div class="details-content"><p>${combinedGossip}</p></div>
                    </details>
                `;
            }

            // æ¸²æŸ“å‰©ä½™çš„åµŒå¥—é›†åˆ
            for (const [key, value] of Object.entries(tempObj)) {
                 if (key !== '$meta' && typeof value === 'object' && value !== null) {
                    nestedCollectionHtml += this.renderNestedCollection(key, value);
                 }
            }

            // ç»„è£…æœ€ç»ˆHTML
            if(description) mainContentHtml += `<p>${description}</p>`;
            if(citiaoHtml) mainContentHtml += `<div class="item-details">${citiaoHtml}</div>`;
            if(nestedCollectionHtml) mainContentHtml += nestedCollectionHtml;
            if(bonusHtml) mainContentHtml += bonusHtml;
            if(percentBonusHtml) mainContentHtml += percentBonusHtml;
            if(historyHtml) mainContentHtml += historyHtml;

            return mainContentHtml;
          },

          renderCitiaoBlock(citiaoObj) {
            if (!citiaoObj || typeof citiaoObj !== 'object') return '';
            let html = '<p><strong>è¯æ¡</strong></p>';
            for (const [name, description] of Object.entries(citiaoObj)) {
              if (name === '$meta') continue;
              html += `<p><span class="attribute-value">${name}</span>: <span class="citiao-description">${description}</span></p>`;
            }
            return html;
          },

          renderBonusBlock(title, bonusObj, isPercentage = false) {
            if (!bonusObj || typeof bonusObj !== 'object') return '';
            let html = `<p><strong>${title}</strong></p>`;
            for (const [attr, value] of Object.entries(bonusObj)) {
              if (attr === '$meta') continue;
              const displayValue = isPercentage ? `${value}` : `+${value}`;
              html += `<p><strong style="color: white;">${attr}</strong>: ${displayValue}</p>`;
            }
            return html;
          },

          renderNestedCollection(collectionName, collectionObj) {
            if (!collectionObj || typeof collectionObj !== 'object') return '';
            let html = `<p><strong>${collectionName}</strong></p>`;
            for (const [itemName, itemData] of Object.entries(collectionObj)) {
              if (itemName === '$meta') continue;
              
              const tier = itemData.å“é˜¶ || '';
              const tierStyle = tier ? this.getItemTierStyle(tier) : '';
              const quantity = itemData.æ•°é‡ ? ` x${itemData.æ•°é‡}` : '';
              const subDetails = this.renderRecursiveDetails(itemData, ['å“é˜¶', 'æ•°é‡']);
              
              html += `
                <details class="details-container">
                  <summary>
                    <span class="attribute-name">${itemName}${quantity}</span>
                    <span class="attribute-value" ${tierStyle ? `style="${tierStyle}"` : ''}>${tier ? `ã€${tier}ã€‘` : ''}</span>
                  </summary>
                  <div class="details-content">
                    ${subDetails}
                  </div>
                </details>
              `;
            }
            return html;
          },



          
// ===å„ç±»æ•°å€¼å¤„ç†ã€æ¸²æŸ“æ¨¡å—ï¼ˆè¶…çº§é‡è¦ï¼‰ç»“æŸ===




// ã€ä¸´æ—¶æ¶ˆæ¯æç¤º (æ”¯æŒç±»å‹å’Œé¢œè‰²)ã€‘
          showTemporaryMessage(message, type = 'info', duration = 3000) {
              const existingMsg = document.querySelector('.temp-message-popup');
              if (existingMsg) existingMsg.remove();

              const colors = {
                  info: { bg: 'rgba(45, 27, 61, 0.9)', text: '#c9aa71' },
                  success: { bg: 'rgba(40, 167, 69, 0.9)', text: '#ffffff' },
                  warning: { bg: 'rgba(255, 193, 7, 0.9)', text: '#000000' },
                  error: { bg: 'rgba(220, 53, 69, 0.9)', text: '#ffffff' }
              };
              const selectedColor = colors[type] || colors.info;

              const msgElement = document.createElement('div');
              msgElement.className = 'temp-message-popup';
              msgElement.textContent = message;
              msgElement.style.cssText = `
                      position: absolute;
                      top: 20px;
                      left: 50%;
                      transform: translateX(-50%);
                      background: ${selectedColor.bg};
                      color: ${selectedColor.text};
                      padding: 10px 20px;
                      border-radius: 5px;
                      z-index: 2000;
                      font-size: 14px;
                      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
                      text-align: center;
                      transition: opacity 0.5s ease-out;
                      max-width: 90%;
                  `;
              document.querySelector('.guixu-root-container').appendChild(msgElement);

              setTimeout(() => {
                  msgElement.style.opacity = '0';
                  setTimeout(() => msgElement.remove(), 500);
              }, duration - 500);
          },

          showCommandCenter() {
              this.openModal('command-center-modal');
              const body = document.querySelector('#command-center-modal .modal-body');
              if (!body) return;
              
              if (this.pendingActions.length === 0) {
                  body.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æš‚æ— å¾…æ‰§è¡Œçš„æŒ‡ä»¤ã€‚</p>';
                  return;
              }
              
              let html = '<ul class="command-center-actions">';
              this.pendingActions.forEach(commandText => {
                  if (commandText) {
                      html += `<li class="command-center-action-item">${commandText}</li>`;
                  }
              });
              html += '</ul>';
              body.innerHTML = html;
          },

          clearPendingActions() {
              this.pendingActions = [];
              this.savePendingActions();
              this.showTemporaryMessage('æŒ‡ä»¤å·²æ¸…ç©º');
              if (document.getElementById('command-center-modal').style.display === 'flex') {
                  this.showCommandCenter();
              }
              if (document.getElementById('gacha-settings-popup').style.display === 'flex') {
                  this._renderGachaSettingsTab('command_center');
              }
              if (document.getElementById('gacha-gallery-popup').style.display === 'flex') {
                  this.showGachaGalleryPopup();
              }
          },

          async executePendingActions() {
            await this.handleAction();
          },

          useItem(item, buttonElement) {
            const itemName = this.SafeGetValue(item, 'name');
            if (itemName === 'N/A') {
              this.showTemporaryMessage('ç‰©å“ä¿¡æ¯é”™è¯¯ï¼Œæ— æ³•ä½¿ç”¨ã€‚');
              return;
            }
            this.addCommand(`ä½¿ç”¨ 1 ä¸ª [${itemName}]ã€‚`);
            this.showTemporaryMessage(`å·²å°† [ä½¿ç”¨ ${itemName}] åŠ å…¥æŒ‡ä»¤é˜Ÿåˆ—`);
            this.savePendingActions();
            this.showInventory();
          },

          discardItem(item, category, itemElement) {
            const itemName = this.SafeGetValue(item, 'name');
            if (itemName === 'N/A') {
              this.showTemporaryMessage('ç‰©å“ä¿¡æ¯é”™è¯¯ï¼Œæ— æ³•ä¸¢å¼ƒã€‚');
              return;
            }

            const hasQuantity = item.hasOwnProperty('quantity');
            
            if (hasQuantity && (category === 'ä¸¹è¯' || category === 'æ‚ç‰©')) {
              // æœ‰æ•°é‡çš„ç‰©å“ï¼Œéœ€è¦è¾“å…¥ä¸¢å¼ƒæ•°é‡
              this.promptDiscardQuantity(item, category, itemElement);
            } else {
              // è£…å¤‡ç±»ç‰©å“ï¼Œç›´æ¥ç¡®è®¤ä¸¢å¼ƒ
              this.confirmDiscardItem(item, category, itemElement, 1);
            }
          },

          async promptDiscardQuantity(item, category, itemElement) {
            const itemName = this.SafeGetValue(item, 'name');
            const currentQuantity = parseInt(this.SafeGetValue(item, 'quantity', 0), 10);
            const availableQuantity = currentQuantity;

            if (availableQuantity <= 0) {
              this.showTemporaryMessage(`${itemName} æ²¡æœ‰å¯ä¸¢å¼ƒçš„æ•°é‡ã€‚`);
              return;
            }

            return new Promise((resolve) => {
              // åˆ›å»ºæ•°é‡è¾“å…¥æ¨¡æ€æ¡†
              const modal = document.createElement('div');
              modal.className = 'modal-overlay';
              modal.style.display = 'flex';
              modal.style.zIndex = '2000';
              modal.innerHTML = `
                <div class="modal-content" style="width: 400px; height: auto; max-height: none;">
                  <div class="modal-header">
                    <h2 class="modal-title">ä¸¢å¼ƒç‰©å“</h2>
                  </div>
                  <div class="modal-body" style="padding: 20px;">
                    <p style="margin-bottom: 15px; color: #c9aa71;">è¯·è¾“å…¥è¦ä¸¢å¼ƒçš„ <strong>${itemName}</strong> æ•°é‡ï¼š</p>
                    <p style="font-size: 12px; color: #8b7355; margin-bottom: 10px;">å½“å‰å¯ä¸¢å¼ƒæ•°é‡ï¼š${availableQuantity}</p>
                    <input type="number" id="discard-quantity-input" min="1" max="${availableQuantity}" value="1"
                           style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355;
                                  color: #e0dcd1; border-radius: 4px; font-size: 14px; margin-bottom: 20px;">
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                      <button id="discard-quantity-cancel" class="interaction-btn">å–æ¶ˆ</button>
                      <button id="discard-quantity-confirm" class="interaction-btn" style="background: #8b0000; border-color: #ff6b6b;">ç¡®è®¤ä¸¢å¼ƒ</button>
                    </div>
                  </div>
                </div>
              `;

              const container = document.querySelector('.guixu-root-container');
              container.appendChild(modal);

              const input = modal.querySelector('#discard-quantity-input');
              const confirmBtn = modal.querySelector('#discard-quantity-confirm');
              const cancelBtn = modal.querySelector('#discard-quantity-cancel');

              confirmBtn.addEventListener('click', () => {
                const quantity = parseInt(input.value, 10);
                if (isNaN(quantity) || quantity <= 0 || quantity > availableQuantity) {
                  this.showTemporaryMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„ä¸¢å¼ƒæ•°é‡');
                  return;
                }
                modal.remove();
                this.confirmDiscardItem(item, category, itemElement, quantity);
                resolve();
              });

              cancelBtn.addEventListener('click', () => {
                modal.remove();
                resolve();
              });

              // è‡ªåŠ¨èšç„¦
              setTimeout(() => input.focus(), 100);
            });
          },

          async confirmDiscardItem(item, category, itemElement, quantity = 1) {
            const itemName = this.SafeGetValue(item, 'name');
            const hasQuantity = item.hasOwnProperty('quantity');
            
            let confirmMessage;
            if (hasQuantity) {
              confirmMessage = `ç¡®å®šè¦ä¸¢å¼ƒ ${quantity} ä¸ª ${itemName} å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`;
            } else {
              confirmMessage = `ç¡®å®šè¦ä¸¢å¼ƒ ${itemName} å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`;
            }

            this.showCustomConfirm(confirmMessage, async () => {
              try {
                // ç¬¬ä¸€æ­¥ï¼šè·å–æœ€æ–°çš„"æœ¬åœ°è‰ç¨¿"
                const mvuData = this.currentMvuState;
                if (!mvuData) {
                  this.showTemporaryMessage('æ— æ³•è·å–MVUçŠ¶æ€ï¼', 'error');
                  return;
                }

                // æ˜ å°„categoryåˆ°å¯¹åº”çš„åˆ—è¡¨é”®å
                const categoryKeyMap = {
                  'åŠŸæ³•': 'åŠŸæ³•åˆ—è¡¨',
                  'æ­¦å™¨': 'æ­¦å™¨åˆ—è¡¨',
                  'é˜²å…·': 'é˜²å…·åˆ—è¡¨',
                  'é¥°å“': 'é¥°å“åˆ—è¡¨',
                  'æ³•å®': 'æ³•å®åˆ—è¡¨',
                  'ä¸¹è¯': 'ä¸¹è¯åˆ—è¡¨',
                  'æ‚ç‰©': 'å…¶ä»–åˆ—è¡¨'
                };

                const listKey = categoryKeyMap[category];
                if (!listKey) {
                  this.showTemporaryMessage(`æœªçŸ¥çš„ç‰©å“ç±»åˆ«ï¼š${category}`, 'error');
                  return;
                }

                // ç¬¬äºŒæ­¥ï¼šåœ¨"æœ¬åœ°è‰ç¨¿"ä¸Šè¿›è¡Œåˆ é™¤æ“ä½œ
                if (hasQuantity) {
                  // æœ‰æ•°é‡çš„ç‰©å“ï¼Œå‡å°‘æ•°é‡æˆ–åˆ é™¤
                  const currentQuantity = parseInt(this.SafeGetValue(item, 'quantity', 0), 10);
                  const newQuantity = currentQuantity - quantity;

                  if (newQuantity <= 0) {
                    // æ•°é‡å½’é›¶ï¼Œåˆ é™¤æ•´ä¸ªç‰©å“ - ä½¿ç”¨deleteæ“ä½œç¬¦ç¡®ä¿é”®è¢«å®Œå…¨ç§»é™¤
                    const itemList = Mvu.getMvuVariable(mvuData, listKey, { default_value: {} });
                    delete itemList[itemName];
                    await Mvu.setMvuVariable(
                      mvuData,
                      listKey,
                      itemList,
                      { reason: `ä¸¢å¼ƒç‰©å“ï¼š${itemName}` }
                    );
                  } else {
                    // å‡å°‘æ•°é‡
                    await Mvu.setMvuVariable(
                      mvuData,
                      `${listKey}.${itemName}.quantity`,
                      newQuantity,
                      { reason: `ä¸¢å¼ƒ ${quantity} ä¸ª ${itemName}` }
                    );
                  }
                } else {
                  // è£…å¤‡ç±»ç‰©å“ï¼Œç›´æ¥åˆ é™¤ - ä½¿ç”¨deleteæ“ä½œç¬¦ç¡®ä¿é”®è¢«å®Œå…¨ç§»é™¤
                  const itemList = Mvu.getMvuVariable(mvuData, listKey, { default_value: {} });
                  delete itemList[itemName];
                  await Mvu.setMvuVariable(
                    mvuData,
                    listKey,
                    itemList,
                    { reason: `ä¸¢å¼ƒç‰©å“ï¼š${itemName}` }
                  );
                }

                // ç¬¬ä¸‰æ­¥ï¼šå°†ä¿®æ”¹åçš„"æœ¬åœ°è‰ç¨¿"åŒæ­¥å›"äº‘ç«¯æ­£æœ¬"
                await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                // ç¬¬å››æ­¥ï¼šåˆ·æ–°UIå¹¶ç»™äºˆåé¦ˆ
                if (hasQuantity) {
                  this.showTemporaryMessage(`å·²æˆåŠŸä¸¢å¼ƒ ${quantity} ä¸ª ${itemName}`, 'success');
                } else {
                  this.showTemporaryMessage(`å·²æˆåŠŸä¸¢å¼ƒ ${itemName}`, 'success');
                }

                // åˆ·æ–°èƒŒåŒ…UI
                this.showInventory(true);

              } catch (error) {
                console.error('ä¸¢å¼ƒç‰©å“å¤±è´¥:', error);
                this.showTemporaryMessage(`ä¸¢å¼ƒå¤±è´¥: ${error.message}`, 'error');
              }
            }, null, true);
          },



// ===æŸ¥çœ‹æå–å†…å®¹æ¨¡å—å¼€å§‹===      



          showExtractedContent() {
            this.openModal('extracted-content-modal');
            const journeyEl = document.getElementById('extracted-journey');
            const pastLivesEl = document.getElementById('extracted-past-lives');
            const mapCommandsEl = document.getElementById('extracted-map-commands');
            const variablesEl = document.getElementById('extracted-variable-changes');
            const sentPromptEl = document.getElementById('sent-prompt-display');
            const currentMvuEl = document.getElementById('current-mvu-variables');

            if (currentMvuEl) {
              if (this.currentMvuState) {
                currentMvuEl.textContent = JSON.stringify(this.currentMvuState, null, 2);
              } else {
                currentMvuEl.textContent = 'MVU çŠ¶æ€å°šæœªåŠ è½½ã€‚';
              }
            }

            if (sentPromptEl) {
              sentPromptEl.textContent = this.lastSentPrompt || 'å°šæœªå‘é€ä»»ä½•å†…å®¹';
            }
            if (journeyEl) {
              journeyEl.textContent = this.lastExtractedJourney || 'æœªæå–åˆ°å†…å®¹';
            }
            if (pastLivesEl) {
              pastLivesEl.textContent = this.lastExtractedPastLives || 'æœªæå–åˆ°å†…å®¹';
            }
            if (variablesEl) {
              variablesEl.textContent = this.lastExtractedVariables || 'æœ¬æ¬¡æ— å˜é‡æ”¹å˜';
            }
            const novelModeEl = document.getElementById('extracted-novel-mode');
            const novelModeBtn = document.getElementById('btn-write-novel-mode');
            if (novelModeEl && novelModeBtn) {
              // å§‹ç»ˆæ˜¾ç¤ºæå–åˆ°çš„å†…å®¹ã€‚æŒ‰é’®å¯ç”¨æ€§ä»…å–å†³äºå†…å®¹æ˜¯å¦å­˜åœ¨ã€‚
              novelModeEl.textContent = this.lastExtractedNovelText || 'å½“å‰AIå›å¤ä¸­æœªæå–åˆ°æ­£æ–‡å†…å®¹ã€‚';
              novelModeBtn.disabled = !this.lastExtractedNovelText;

              // æ›´æ–°æ ‡ç­¾æ–‡æœ¬ä»¥æä¾›å…³äºè‡ªåŠ¨å†™å…¥çŠ¶æ€çš„å³æ—¶åé¦ˆ
              const label = document.querySelector('label[for="novel-mode-enabled-checkbox"]');
              if (label) {
                const statusText = this.isNovelModeEnabled ? 'å¼€å¯' : 'å…³é—­';
                label.title = `ç‚¹å‡»åˆ‡æ¢è‡ªåŠ¨å†™å…¥çŠ¶æ€ï¼Œå½“å‰ä¸ºï¼š${statusText}`;
              }
            }

            // æ–°å¢ï¼šå¤„ç†æå–çš„è§’è‰²å¡
            const characterCardEl = document.getElementById('extracted-character-card');
            const characterCardBtn = document.getElementById('btn-write-character-card');
            if (characterCardEl && characterCardBtn) {
              characterCardEl.textContent = this.lastExtractedCharacterCard || 'æœªæå–åˆ°è§’è‰²å¡å†…å®¹ã€‚';
              characterCardBtn.disabled = !this.lastExtractedCharacterCard;
            }
          },

          async showJourney() {
            this.openModal('history-modal');
            this.loadUnifiedIndex(); // ç¡®ä¿è¾“å…¥æ¡†æ˜¾ç¤ºæ­£ç¡®çš„åºå·
            const titleEl = document.getElementById('history-modal-title');
            if (titleEl) titleEl.textContent = 'æœ¬ä¸–å†ç¨‹';

            // æ–°å¢ï¼šå‘æ¨¡æ€æ¡†å¤´éƒ¨æ³¨å…¥ä¿®å‰ªç›¸å…³çš„UIå…ƒç´ 
            const headerControls = document.querySelector('#history-modal .modal-header > div');
            if (headerControls) {
                 headerControls.innerHTML = ``; // æ¸…ç©ºæ—§çš„ä¿®å‰ªæŒ‰é’®
            }
             // æ˜¾ç¤ºä¿®å‰ªæ§åˆ¶å°å¹¶åŠ è½½çŠ¶æ€
            const trimConsole = document.getElementById('trim-console');
            if (trimConsole) {
                trimConsole.style.display = 'block';
                this.loadTrimFieldsState(); // ç¡®ä¿æ¯æ¬¡æ‰“å¼€éƒ½åŠ è½½æœ€æ–°çš„çŠ¶æ€
            }

            const body = document.getElementById('history-modal-body');
            if (!body) return;

            // ä¿®å¤BUGï¼šä¸å†å®Œå…¨è¦†ç›–innerHTMLï¼Œè€Œæ˜¯åªæ›´æ–°æ—¶é—´çº¿éƒ¨åˆ†
            const timelinePlaceholder = document.createElement('div');
            timelinePlaceholder.id = 'timeline-placeholder';
            timelinePlaceholder.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨è¯»å–å‘½è¿ä¹‹å·...</p>';
            
            const existingTimeline = body.querySelector('#timeline-placeholder, .timeline-container');
            if (existingTimeline) {
                existingTimeline.remove();
            }
            body.appendChild(timelinePlaceholder);

            try {
              const bookName = '1å½’å¢Ÿ';
              const index = this.unifiedIndex;
              const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

              if (!journeyEntry) {
                console.warn(`åœ¨ä¸–ç•Œä¹¦ "${bookName}" ä¸­æœªæ‰¾åˆ°æ ‡é¢˜ä¸º "${journeyKey}" çš„æ¡ç›®ã€‚`);
              }
              // å°†æ¸²æŸ“å¥½çš„æ—¶é—´çº¿å†…å®¹æ›¿æ¢æ‰å ä½ç¬¦
              timelinePlaceholder.innerHTML = this.renderJourneyFromContent(journeyEntry);
              // ç»‘å®šç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
              this.bindJourneyListeners();

              // æ–°å¢ï¼šä¸ºåŠ¨æ€æ·»åŠ çš„ä¿®å‰ªUIç»‘å®šäº‹ä»¶
              document.querySelectorAll('.trim-field-checkbox').forEach(checkbox => {
                  checkbox.addEventListener('change', () => this.saveTrimFieldsState());
              });
              document.getElementById('btn-precise-trim')?.addEventListener('click', () => this.handlePreciseTrim());
              document.getElementById('btn-auto-trim')?.addEventListener('click', () => this.handleAutoTrim());
              document.getElementById('btn-full-trim')?.addEventListener('click', () => this.handleFullTrim());

            } catch (error) {
              console.error('è¯»å–"æœ¬ä¸–å†ç¨‹"æ—¶å‡ºé”™:', error);
              body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">è¯»å–è®°å¿†æ—¶å‡ºç°é”™è¯¯ï¼š${error.message}</p>`;
            }
          },

          async showPastLives() {
            this.openModal('history-modal');
            this.loadUnifiedIndex(); 
            const titleEl = document.getElementById('history-modal-title');
            if (titleEl) titleEl.textContent = 'å¾€ä¸–æ¶Ÿæ¼ª';
            // éšè—ä¿®å‰ªæ§åˆ¶å°
            const trimConsole = document.getElementById('trim-console');
            if (trimConsole) {
                trimConsole.style.display = 'none';
            }
            const body = document.getElementById('history-modal-body');
            if (!body) return;

            // ç»Ÿä¸€ä½¿ç”¨å ä½ç¬¦å’ŒDOMæ“ä½œï¼Œé¿å…innerHTMLè¦†ç›–
            const timelinePlaceholder = document.createElement('div');
            timelinePlaceholder.id = 'timeline-placeholder';
            timelinePlaceholder.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨å›æº¯æ—¶å…‰é•¿æ²³...</p>';

            const existingTimeline = body.querySelector('#timeline-placeholder, .timeline-container');
            if (existingTimeline) {
                existingTimeline.remove();
            }
            body.appendChild(timelinePlaceholder);

            try {
              const bookName = '1å½’å¢Ÿ';
              const index = this.unifiedIndex;
              const pastLivesKey = index > 1 ? `å¾€ä¸–æ¶Ÿæ¼ª(${index})` : 'å¾€ä¸–æ¶Ÿæ¼ª';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const pastLivesEntry = allEntries.find(entry => entry.comment === pastLivesKey);

              if (!pastLivesEntry) {
                console.warn(`åœ¨ä¸–ç•Œä¹¦ "${bookName}" ä¸­æœªæ‰¾åˆ°æ ‡é¢˜ä¸º "${pastLivesKey}" çš„æ¡ç›®ã€‚`);
              }

              timelinePlaceholder.innerHTML = this.renderPastLives(pastLivesEntry);
            } catch (error) {
              console.error('è¯»å–â€œå¾€ä¸–æ¶Ÿæ¼ªâ€æ—¶å‡ºé”™:', error);
              timelinePlaceholder.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">å›æº¯æ—¶å…‰é•¿æ²³æ—¶å‡ºç°é”™è¯¯ï¼š${error.message}</p>`;
            }
          },

         async showNovelMode() {
          if (this.isFromSettingsModal) {
            this.closeModal('settings-modal');
          }
          this.openModal('novel-mode-modal');
          this.loadUnifiedIndex(); 
          const input = document.getElementById('novel-mode-index-input');
          if (input) {
            input.value = this.unifiedIndex;
          }
          const titleEl = document.getElementById('novel-mode-modal-title');
          if (titleEl) titleEl.textContent = 'å°è¯´æ¨¡å¼';

          const body = document.getElementById('novel-mode-modal-body');
          const chapterNav = document.getElementById('novel-chapter-nav');
          if (!body) return;

          body.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨åŠ è½½å°è¯´å†…å®¹...</p>';
          
          try {
            const bookName = '1å½’å¢Ÿ';
            const index = this.unifiedIndex; // ä½¿ç”¨ç»Ÿä¸€çš„ä¸–ç•Œä¹¦å†™å…¥åºå·
            const novelModeKey = index > 1 ? `å°è¯´æ¨¡å¼(${index})` : 'å°è¯´æ¨¡å¼';
            const allEntries = await TavernHelper.getLorebookEntries(bookName);
            const novelModeEntry = allEntries.find(entry => entry.comment === novelModeKey);

            if (novelModeEntry && novelModeEntry.content) {
                // è§£æç« èŠ‚
                this.novelChapters = this.parseNovelChapters(novelModeEntry.content);
                this.loadNovelBookmarks(); // åŠ è½½ä¹¦ç­¾
                this.loadNovelDisplayMode(); // åŠ è½½æ˜¾ç¤ºæ¨¡å¼
                this.loadNovelBackgroundSettings(); // åŠ è½½èƒŒæ™¯è®¾ç½®
                
                if (this.novelChapters.length > 1) {
                    // æ˜¾ç¤ºç« èŠ‚å¯¼èˆª
                    if (chapterNav) chapterNav.style.display = 'block';
                    
                    // æ›´æ–°ç« èŠ‚é€‰æ‹©å™¨
                    const chapterSelect = document.getElementById('chapter-select');
                    if (chapterSelect) {
                        chapterSelect.innerHTML = '<option value="">é€‰æ‹©ç« èŠ‚...</option>';
                        this.novelChapters.forEach((chapter, index) => {
                            const option = document.createElement('option');
                            option.value = index;
                            option.textContent = chapter.title;
                            chapterSelect.appendChild(option);
                        });
                    }
                    
                    // æ›´æ–°ä¹¦ç­¾é€‰æ‹©å™¨
                    this.updateBookmarkSelect();
                    
                    // æ ¹æ®æ˜¾ç¤ºæ¨¡å¼æ˜¾ç¤ºå†…å®¹
                    if (this.novelDisplayMode === 'continuous') {
                        this.showAllChaptersContinuous();
                    } else {
                        this.showNovelChapter(0);
                    }
                } else {
                    // æ²¡æœ‰ç« èŠ‚ï¼Œéšè—å¯¼èˆªï¼Œæ˜¾ç¤ºå…¨éƒ¨å†…å®¹
                    if (chapterNav) chapterNav.style.display = 'none';
                    body.innerHTML = `<div class="game-text-container" style="white-space: pre-wrap; padding: 10px;">${this.formatMessageContent(novelModeEntry.content)}</div>`;
                }
                
                // åº”ç”¨èƒŒæ™¯è®¾ç½®
                this.applyNovelBackground();
            } else {
                if (chapterNav) chapterNav.style.display = 'none';
                body.innerHTML = '<p style="text-align:center; color:#8b7355; font-size:12px; padding-top: 20px;">è¯¥åºå·ä¸‹æ²¡æœ‰å°è¯´å†…å®¹ã€‚</p>';
            }

          } catch (error) {
            console.error('è¯»å–"å°è¯´æ¨¡å¼"æ—¶å‡ºé”™:', error);
            if (chapterNav) chapterNav.style.display = 'none';
            body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">è¯»å–å°è¯´æ—¶å‡ºç°é”™è¯¯ï¼š${error.message}</p>`;
          }
        },



// ===æŸ¥çœ‹æå–å†…å®¹æ¨¡å—ç»“æŸ===     




// ã€æœ¬ä¸–å†ç¨‹ã€å¾€ä¸–æ¶Ÿæ¼ªæ•°æ®è§£ææ¨¡å—ã€‘


          parseJourneyEntry(contentString) {
            if (!contentString || typeof contentString !== 'string') return [];
            try {
              const events = [];
              const eventBlocks = contentString
                .trim()
                .split(/åºå·\|/g)
                .slice(1);

              eventBlocks.forEach(block => {
                const fullBlock = `åºå·|${block}`.trim();
                const event = {};
                
                // å®šä¹‰å­—æ®µé¡ºåºï¼Œç”¨äºæ­£ç¡®è§£æå¤šè¡Œå†…å®¹
                const fieldOrder = ['åºå·', 'æ—¥æœŸ', 'æ ‡é¢˜', 'åœ°ç‚¹', 'äººç‰©', 'æè¿°', 'äººç‰©å…³ç³»', 'æ ‡ç­¾', 'é‡è¦ä¿¡æ¯', 'æš—çº¿ä¸ä¼ç¬”', 'è‡ªåŠ¨åŒ–ç³»ç»Ÿ'];
                
                let currentFieldIndex = 0;
                let currentKey = '';
                let currentValue = '';
                
                const lines = fullBlock.split('\n');
                
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  let foundField = false;
                  
                  // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°å­—æ®µçš„å¼€å§‹
                  for (let j = currentFieldIndex; j < fieldOrder.length; j++) {
                    const field = fieldOrder[j];
                    if (line.startsWith(field + '|')) {
                      // ä¿å­˜å‰ä¸€ä¸ªå­—æ®µçš„å€¼
                      if (currentKey && currentValue.trim()) {
                        event[currentKey] = currentValue.trim();
                      }
                      
                      // å¼€å§‹æ–°å­—æ®µ
                      currentKey = field;
                      currentValue = line.substring(field.length + 1);
                      currentFieldIndex = j;
                      foundField = true;
                      break;
                    }
                  }
                  
                  // å¦‚æœä¸æ˜¯æ–°å­—æ®µï¼Œåˆ™è¿½åŠ åˆ°å½“å‰å­—æ®µå€¼
                  if (!foundField && currentKey) {
                    currentValue += '\n' + line;
                  }
                }
                
                // ä¿å­˜æœ€åä¸€ä¸ªå­—æ®µ
                if (currentKey && currentValue.trim()) {
                  event[currentKey] = currentValue.trim();
                }
                
                if (event['åºå·']) {
                  events.push(event);
                }
              });
              return events;
            } catch (e) {
              console.error('è§£ææœ¬ä¸–å†ç¨‹æ¡ç›®å¤±è´¥:', e);
              return [];
            }
          },

          parsePastLifeEntry(contentString) {
            if (!contentString || typeof contentString !== 'string') return {};
            try {
                const data = {};
                // é€šè¿‡å‰ç»æ–­è¨€ (?=...) æŒ‰æ¯ä¸ªå­—æ®µçš„èµ·å§‹æ ‡å¿—è¿›è¡Œåˆ†å‰²ï¼ŒåŒæ—¶ä¿ç•™åˆ†éš”ç¬¦
                const parts = contentString.trim().split(/\n(?=^(?:ç¬¬\d+ä¸–|äº‹ä»¶è„‰ç»œ|æœ¬ä¸–æ¦‚è¿°|æœ¬ä¸–æˆå°±|æœ¬ä¸–è·å¾—ç‰©å“|æœ¬ä¸–äººç‰©å…³ç³»ç½‘|æ­»äº¡åŸå› |æœ¬ä¸–æ€»ç»“|æœ¬ä¸–è¯„ä»·)\|)/m);

                for (const part of parts) {
                    if (!part.trim()) continue;
                    
                    const separatorIndex = part.indexOf('|');
                    if (separatorIndex > 0) {
                        const key = part.substring(0, separatorIndex).trim();
                        const value = part.substring(separatorIndex + 1).trim();
                        data[key] = value;
                    }
                }
                return data;
            } catch (e) {
              console.error('è§£æå¾€ä¸–æ¶Ÿæ¼ªæ¡ç›®å¤±è´¥:', e);
              return {};
            }
          },


// ã€æœ¬ä¸–å†ç¨‹æ˜¾ç¤ºæ¨¡å—ã€‘


          renderJourneyFromContent(entry) {
            if (!entry || !entry.content)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">æ­¤ç”Ÿå°šæœªç•™ä¸‹ä»»ä½•å°è®°ã€‚</p>';

            const events = this.parseJourneyEntry(entry.content);
            if (events.length === 0)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">å†…å®¹æ ¼å¼æœ‰è¯¯ï¼Œæ— æ³•è§£æäº‹ä»¶ã€‚</p>';

            events.sort((a, b) => (parseInt(a.åºå·, 10) || 0) - (parseInt(b.åºå·, 10) || 0));

            let html = '<div class="timeline-container"><div class="timeline-line"></div>';
            events.forEach((eventData, index) => {
              const eventId = `event-${entry.uid}-${index}`;
              const date = eventData['æ—¥æœŸ'] || 'æœªçŸ¥æ—¶é—´';
              const sequence = eventData['åºå·'] || '?';
              const title = eventData['æ ‡é¢˜'] || 'æ— æ ‡é¢˜';
              const displayTitle = `ç¬¬${sequence}ç«  ${title}`;
              const location = eventData['åœ°ç‚¹'] || 'æœªçŸ¥åœ°ç‚¹';
              const description = eventData['æè¿°'] || 'æ— è¯¦ç»†æè¿°ã€‚';
              const characters = eventData['äººç‰©'] || '';
              const relationships = eventData['äººç‰©å…³ç³»'] || '';
              const importantInfo = eventData['é‡è¦ä¿¡æ¯'] || '';
              const hiddenPlot = eventData['æš—çº¿ä¸ä¼ç¬”'] || '';
              const autoSystem = eventData['è‡ªåŠ¨åŒ–ç³»ç»Ÿ'] || '';

              const tagsHtml = (eventData['æ ‡ç­¾'] || '')
                .split('|')
                .map(tag => tag.trim())
                .filter(tag => tag)
                .map(tag => `<span class="tag-item">${tag}</span>`)
                .join('');

              const basicInfo = `
                <div style="display: flex; align-items: baseline; gap: 8px; margin-bottom: 8px;">
                    <div class="timeline-date">${date}</div>
                    <input type="checkbox" class="journey-trim-checkbox" data-sequence-id="${eventData['åºå·']}" style="cursor: pointer;">
                </div>
                <div class="timeline-tags">${tagsHtml}</div>
                <div class="timeline-title">${displayTitle}</div>
                <div class="timeline-location" style="font-size: 12px; color: #8b7355; margin: 5px 0;">åœ°ç‚¹ï¼š${location}</div>
                <div class="timeline-description">${description}</div>
              `;

              // è¯¦ç»†ä¿¡æ¯ï¼ˆéœ€è¦ç‚¹å‡»2æ¬¡æ‰æ˜¾ç¤ºï¼‰
              const detailedInfo = `
                <div class="timeline-detailed-info" id="detailed-${eventId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(201, 170, 113, 0.3);">
                  ${characters ? `<div class="detail-section"><strong>äººç‰©ï¼š</strong>${characters}</div>` : ''}
                  ${relationships ? `<div class="detail-section"><strong>äººç‰©å…³ç³»ï¼š</strong>${relationships}</div>` : ''}
                  ${importantInfo ? `<div class="detail-section"><strong>é‡è¦ä¿¡æ¯ï¼š</strong>${importantInfo}</div>` : ''}
                  ${hiddenPlot ? `<div class="detail-section"><strong>æš—çº¿ä¸ä¼ç¬”ï¼š</strong>${hiddenPlot}</div>` : ''}
                  ${autoSystem ? `<div class="detail-section"><strong>è‡ªåŠ¨åŒ–ç³»ç»Ÿï¼š</strong><pre style="white-space: pre-wrap; font-size: 11px; color: #a09c91;">${autoSystem}</pre></div>` : ''}
                </div>
              `;

              html += `
                <div class="timeline-event" data-event-id="${eventId}" data-click-count="0" style="cursor: pointer;">
                  <div class="timeline-content">
                    ${basicInfo}
                    ${detailedInfo}
                  </div>
                </div>`;
            });
            html += '</div>';
            return html;
          },


// ã€å¾€ä¸–æ¶Ÿæ¼ªæ˜¾ç¤ºæ¨¡å—ã€‘

          renderPastLives(entry) {
            if (!entry || !entry.content || !entry.content.trim())
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">æœªå‘ç°ä»»ä½•å¾€ä¸–çš„ç—•è¿¹ã€‚</p>';

            // ä½¿ç”¨å‰ç»æ–­è¨€æ¥åˆ†å‰²ï¼Œè¿™æ ·ä¸ä¼šæ¶ˆè€—åˆ†éš”ç¬¦ï¼Œå¯ä»¥æ­£ç¡®å¤„ç†æ¯ä¸€ä¸–çš„è®°å½•
            const pastLifeBlocks = entry.content.trim().split(/\n\n?(?=ç¬¬\d+ä¸–\|)/);
            
            if (pastLifeBlocks.length === 0)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">å†…å®¹æ ¼å¼æœ‰è¯¯ï¼Œæ— æ³•è§£æå¾€ä¸–è®°å½•ã€‚</p>';

            let html = '<div class="timeline-container"><div class="timeline-line"></div>';
            pastLifeBlocks.forEach(block => {
              if (!block.trim()) return; // è·³è¿‡å¯èƒ½äº§ç”Ÿçš„ç©ºå—
              const data = this.parsePastLifeEntry(block);
              
              const titleKey = Object.keys(data).find(k => k.startsWith('ç¬¬') && k.endsWith('ä¸–'));
              let title;
              if (titleKey && data.hasOwnProperty(titleKey)) {
                  const titleValue = data[titleKey] || 'æ— é¢˜';
                  title = `${titleKey} | ${titleValue}`;
              } else {
                  title = block.split('\n')[0].trim();
              }
              let detailsHtml = '';
              const fieldOrder = ['äº‹ä»¶è„‰ç»œ', 'æœ¬ä¸–æ¦‚è¿°', 'æœ¬ä¸–æˆå°±', 'æœ¬ä¸–è·å¾—ç‰©å“', 'æœ¬ä¸–äººç‰©å…³ç³»ç½‘', 'æ­»äº¡åŸå› ', 'æœ¬ä¸–æ€»ç»“', 'æœ¬ä¸–è¯„ä»·'];
              fieldOrder.forEach(field => {
                  if (data[field]) {
                      // ä½¿ç”¨<pre>æ ‡ç­¾æ¥ä¿ç•™å¤šè¡Œæ–‡æœ¬çš„æ¢è¡Œå’Œæ ¼å¼
                      const fieldClassMap = {
                        'æ­»äº¡åŸå› ': 'death-reason',
                        'æœ¬ä¸–æˆå°±': 'achievement',
                        'æœ¬ä¸–è·å¾—ç‰©å“': 'items-obtained',
                        'æœ¬ä¸–æ€»ç»“': 'summary-evaluation',
                        'æœ¬ä¸–è¯„ä»·': 'summary-evaluation'
                      };
                      const specificClass = fieldClassMap[field] || '';
                      const itemClass = `detail-item ${specificClass}`.trim();
                      detailsHtml += `<div class="${itemClass}"><strong>${field}:</strong> <pre style="white-space: pre-wrap; font-family: inherit; margin: 0;">${data[field]}</pre></div>`;
                  }
              });

              html += `
                        <div class="timeline-event">
                            <div class="timeline-content">
                                <div class="timeline-title">${title}</div>
                                <div class="past-life-details">
                                    ${detailsHtml || '<div class="detail-item">å†…å®¹ä¸è¯¦</div>'}
                                </div>
                            </div>
                        </div>`;
            });
            html += '</div>';
            return html;
          },

          async renderPastLifeDetails(bookName) {
            const detailsContainer = document.getElementById('past-life-details');
            if (!detailsContainer) return;
            detailsContainer.style.display = 'block';
            detailsContainer.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨è¯»å–æ­¤ä¸–è®°å¿†...</p>';
            try {
              const entries = await TavernHelper.getLorebookEntries(bookName, 'summary');
              if (entries && entries.length > 0) {
                const summaryData = JSON.parse(entries[0].content);
                detailsContainer.innerHTML = `
                            <h4>${bookName} - ç»“å±€æ€»è§ˆ</h4>
                            <p><strong>æœ€ç»ˆå¢ƒç•Œ:</strong> ${summaryData.finalStats.å¢ƒç•Œ}</p>
                            <p><strong>å­˜æ´»æ—¶é—´:</strong> ${summaryData.finalStats.å­˜æ´»æ—¶é—´}</p>
                            <p><strong>ä¸»è¦æˆå°±:</strong> ${summaryData.achievements.join('ã€ ')}</p>
                            <p><strong>æœ€ç»ˆæ‚”æ†¾:</strong> ${summaryData.regrets}</p>
                            <p><strong>å…³é”®äº‹ä»¶:</strong></p>
                            <ul style="padding-left: 20px;">${summaryData.keyEvents
                              .map(e => `<li>${e}</li>`)
                              .join('')}</ul>`;
              } else {
                detailsContainer.innerHTML =
                  '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æœªèƒ½æ‰¾åˆ°æ­¤ä¸–çš„ç»“å±€æ€»è§ˆã€‚</p>';
              }
            } catch (error) {
              console.error(`Error fetching details for ${bookName}:`, error);
              detailsContainer.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">è¯»å–æ­¤ä¸–è®°å¿†æ—¶å‡ºé”™ï¼š${error.message}</p>`;
            }
          },


          bindJourneyListeners() {
            const timelineContainer = document.querySelector('.timeline-container');
            if (timelineContainer) {
              timelineContainer.addEventListener('click', (e) => {
                const timelineEvent = e.target.closest('.timeline-event');
                if (timelineEvent) {
                  this.handleJourneyEventClick(timelineEvent);
                }
              });
            }
          },

// ã€æœ¬ä¸–å†ç¨‹è¯¦ç»†å†…å®¹æ¨¡å—ã€‘
          handleJourneyEventClick(eventElement) {
            const detailedInfo = eventElement.querySelector('.timeline-detailed-info');
            if (detailedInfo && detailedInfo.style.display === 'block') {
              detailedInfo.style.display = 'none';
              eventElement.style.cursor = 'pointer';
              eventElement.dataset.clickCount = '0';
            } else {
              const currentCount = parseInt(eventElement.dataset.clickCount || '0', 10);
              const newCount = currentCount + 1;
              eventElement.dataset.clickCount = newCount;

              // å½“ç‚¹å‡»2æ¬¡æ—¶æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
              if (newCount >= 2) {
                if (detailedInfo) {
                  detailedInfo.style.display = 'block';
                }
                eventElement.style.cursor = 'pointer';
              }
            }
          },



// ===æœ¬ä¸–å†ç¨‹ã€å¾€ä¸–æ¶Ÿæ¼ªæ¸²æŸ“/è§£ææ¨¡å—ç»“æŸ===





// ===æ ¸å¿ƒæ ¼å¼æå–ã€å¤„ç†ã€è§£ææ¨¡å—å¼€å§‹===
// - loadAndDisplayCurrentSceneä»æ¶ˆæ¯ä¸­æå–æ­£æ–‡ã€æœ¬ä¸–å†ç¨‹ã€å¾€ä¸–æ¶Ÿæ¼ªã€å°è¯´æ¨¡å¼ã€è§’è‰²æå–ã€è¡ŒåŠ¨é€‰é¡¹æ ‡ç­¾å†…å®¹ï¼ˆæ ¸å¿ƒæå–å‡½æ•°ï¼‰
// - å†™å…¥æ¨¡å—ã€è½®è¯¢å†™å…¥
// - è‡ªåŠ¨åˆ›å»ºç›¸å…³ä¸–ç•Œä¹¦
// - è¡ŒåŠ¨é€‰é¡¹çš„æ¸²æŸ“



// ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«



          async writeJourneyToLorebook(silent = false) {
            const content = this.lastExtractedJourney;
            await this.writeToLorebook('æœ¬ä¸–å†ç¨‹', content, silent);
          },

          async writePastLivesToLorebook(silent = false) {
            const content = this.lastExtractedPastLives;
            await this.writeToLorebook('å¾€ä¸–æ¶Ÿæ¼ª', content, silent);
          },

          async writeNovelModeToLorebook(silent = false) {
            const novelText = this.lastExtractedNovelText;
            // å¦‚æœæ²¡æœ‰æ­£æ–‡å†…å®¹ï¼Œåˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œ
            if (!novelText || novelText.trim() === '') {
              if (!silent) this.showTemporaryMessage('æ²¡æœ‰å¯å†™å…¥çš„å°è¯´æ­£æ–‡ã€‚');
              return;
            }

            const journeyText = this.lastExtractedJourney;
            let chapterHeader = '';

            // å°è¯•ä»æœ¬ä¸–å†ç¨‹ä¸­æå–ç« èŠ‚ä¿¡æ¯
            if (journeyText) {
              try {
                const events = this.parseJourneyEntry(journeyText);
                if (events.length > 0) {
                  // å‡è®¾æ•°ç»„ä¸­æœ€åä¸€ä¸ªäº‹ä»¶æ˜¯æœ€æ–°çš„
                  const latestEvent = events[events.length - 1];
                  const sequence = this.SafeGetValue(latestEvent, 'åºå·', null);
                  const title = this.SafeGetValue(latestEvent, 'æ ‡é¢˜', null);

                  if (sequence && title) {
                    chapterHeader = `ç¬¬${sequence}ç«  ${title}\n\n`;
                  }
                }
              } catch (e) {
                console.error('ä¸ºå°è¯´æ¨¡å¼è§£æç« èŠ‚æ ‡é¢˜æ—¶å‡ºé”™:', e);
              }
            }

            const finalContent = chapterHeader + novelText;
            await this.writeToLorebook('å°è¯´æ¨¡å¼', finalContent, silent);
          },

          // æ”¯æŒåŠ¨æ€ç´¢å¼•å’Œæ¡ç›®åˆ›å»º
          async writeToLorebook(baseEntryKey, contentToWrite, silent = false) {
            if (!contentToWrite || contentToWrite.trim() === '') {
              if (!silent) this.showTemporaryMessage('æ²¡æœ‰å¯å†™å…¥çš„å†…å®¹ã€‚');
              return;
            }

            // 1. æ ¹æ®åºå·ç”Ÿæˆæœ€ç»ˆçš„æ¡ç›®åç§°
            const index = this.unifiedIndex; // æ‰€æœ‰ç±»å‹éƒ½ä½¿ç”¨ç»Ÿä¸€çš„ä¸–ç•Œä¹¦å†™å…¥åºå·
            const finalEntryKey = index > 1 ? `${baseEntryKey}(${index})` : baseEntryKey;
            const bookName = '1å½’å¢Ÿ';

            let reformattedContent = contentToWrite.trim();
            let buttonId;

            // 2. å†…å®¹æ ¼å¼åŒ– (é€»è¾‘ä¿æŒä¸å˜)
            if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') {
                const parsePastLivesRobust = (text) => {
                    const data = {};
                    const lines = text.trim().split('\n');
                    let currentKey = null;
                    let tempValue = [];
                    const keyRegex = /^(ç¬¬\d+ä¸–|äº‹ä»¶è„‰ç»œ|æœ¬ä¸–æ¦‚è¿°|æœ¬ä¸–æˆå°±|æœ¬ä¸–è·å¾—ç‰©å“|æœ¬ä¸–äººç‰©å…³ç³»ç½‘|æ­»äº¡åŸå› |æœ¬ä¸–æ€»ç»“|æœ¬ä¸–è¯„ä»·)\|/;

                    for (const line of lines) {
                        const match = line.match(keyRegex);
                        if (match) {
                            if (currentKey) {
                                data[currentKey] = tempValue.join('\n').trim();
                            }
                            currentKey = match[1];
                            tempValue = [line.substring(match[0].length)];
                        } else if (currentKey) {
                            tempValue.push(line);
                        }
                    }
                    if (currentKey) {
                        data[currentKey] = tempValue.join('\n').trim();
                    }
                    return data;
                };

                const parsedData = parsePastLivesRobust(contentToWrite);
                if (Object.keys(parsedData).length === 0) {
                    if (!silent) this.showTemporaryMessage(`æ— æ³•è§£æâ€œ${baseEntryKey}â€çš„å†…å®¹ï¼Œå†™å…¥æ“ä½œå·²å–æ¶ˆã€‚`);
                    return;
                }
                
                const dynamicKey = Object.keys(parsedData).find(k => k.startsWith('ç¬¬') && k.endsWith('ä¸–'));
                const fields = [
                    dynamicKey, 'äº‹ä»¶è„‰ç»œ', 'æœ¬ä¸–æ¦‚è¿°', 'æœ¬ä¸–æˆå°±', 'æœ¬ä¸–è·å¾—ç‰©å“',
                    'æœ¬ä¸–äººç‰©å…³ç³»ç½‘', 'æ­»äº¡åŸå› ', 'æœ¬ä¸–æ€»ç»“', 'æœ¬ä¸–è¯„ä»·',
                ].filter(Boolean);

                reformattedContent = fields
                    .map(key => (parsedData[key] ? `${key}|${parsedData[key]}` : null))
                    .filter(Boolean)
                    .join('\n');
                
                buttonId = 'btn-write-past-lives';

            } else if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') {
                const journeyFields = ['åºå·', 'æ—¥æœŸ', 'æ ‡é¢˜', 'æè¿°', 'æ ‡ç­¾'];
                const parseContent = (text, fieldList) => {
                  const data = {};
                  let tempText = text.replace(/\r\n/g, '\n');
                  fieldList.forEach((field, fIndex) => {
                    const nextField = fieldList[fIndex + 1];
                    const startMarker = `${field}|`;
                    const startIndex = tempText.indexOf(startMarker);
                    if (startIndex !== -1) {
                      let endIndex;
                      if (nextField) {
                        const nextMarkerIndex = tempText.indexOf(`${nextField}|`, startIndex);
                        endIndex = nextMarkerIndex !== -1 ? nextMarkerIndex : undefined;
                      }
                      let value = tempText.substring(startIndex + startMarker.length, endIndex);
                      data[field] = value.trim();
                    }
                  });
                  return data;
                };
                const parsedData = parseContent(contentToWrite, journeyFields);
                 if (Object.keys(parsedData).length === 0) {
                    if (!silent) this.showTemporaryMessage(`æ— æ³•è§£æâ€œ${baseEntryKey}â€çš„å†…å®¹ï¼Œå†™å…¥æ“ä½œå·²å–æ¶ˆã€‚`);
                    return;
                }
                reformattedContent = journeyFields
                    .map(key => (parsedData[key] ? `${key}|${parsedData[key]}` : null))
                    .filter(Boolean)
                    .join('\n');
                buttonId = 'btn-write-journey';
            } else if (baseEntryKey === 'å°è¯´æ¨¡å¼') {
              buttonId = 'btn-write-novel-mode';
            }

            const button = document.getElementById(buttonId);
            if (button && !silent) button.textContent = 'å†™å…¥ä¸­...';

            try {
              // 3. æ£€æŸ¥æ¡ç›®æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              let targetEntry = allEntries.find(entry => entry.comment === finalEntryKey);

              if (!targetEntry) {
                if (!silent) this.showTemporaryMessage(`æ¡ç›® "${finalEntryKey}" ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»º...`);
                
                let finalContentToWrite = reformattedContent;
                // æ–°å¢ï¼šå¦‚æœæ˜¯æœ¬ä¸–å†ç¨‹ä¸”å¼€å¯äº†è‡ªåŠ¨ä¿®å‰ªï¼Œåˆ™å¯¹æ–°åˆ›å»ºçš„å†…å®¹ä¹Ÿè¿›è¡Œä¸€æ¬¡æ£€æŸ¥ï¼ˆè™½ç„¶é€šå¸¸æ˜¯ç¬¬ä¸€ä¸ªäº‹ä»¶ï¼Œä½†é€»è¾‘ä¸Šå®Œæ•´ï¼‰
                if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹' && this.isAutoTrimEnabled) {
                    finalContentToWrite = this._getTrimmedJourneyContent(finalContentToWrite);
                }

                const baseEntryTemplate = allEntries.find(entry => entry.comment === baseEntryKey);
                
                // æ„å»ºå®Œæ•´çš„æ¡ç›®æ•°æ®ï¼Œç¡®ä¿æ‰€æœ‰å¿…éœ€çš„å±æ€§éƒ½å­˜åœ¨
                const newEntryData = {
                  comment: finalEntryKey,
                  content: finalContentToWrite, // ä½¿ç”¨å¯èƒ½è¢«ä¿®å‰ªè¿‡çš„å†…å®¹
                  keys: baseEntryTemplate ? [...baseEntryTemplate.keys, finalEntryKey] : [finalEntryKey],
                  enabled: false,
                  // å¤åˆ¶æ¨¡æ¿çš„æ‰€æœ‰å±æ€§ï¼Œå¦‚æœæ²¡æœ‰æ¨¡æ¿åˆ™ä½¿ç”¨é»˜è®¤å€¼ï¼Œä¼˜å…ˆä½¿ç”¨ä¿å­˜çš„è®¾ç½®
                  type: (() => {
                    if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') return this.worldbookSettings?.journey?.type || baseEntryTemplate?.type || 'selective';
                    if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') return this.worldbookSettings?.pastLives?.type || baseEntryTemplate?.type || 'selective';
                    if (baseEntryKey === 'å°è¯´æ¨¡å¼') return this.worldbookSettings?.novel?.type || baseEntryTemplate?.type || 'selective';
                    if (baseEntryKey === 'åˆ†æ®µæ­£æ–‡') return this.worldbookSettings?.segmented?.type || baseEntryTemplate?.type || 'constant';
                    if (baseEntryKey === 'å°æ€»ç»“') return this.worldbookSettings?.smallSummary?.type || baseEntryTemplate?.type || 'constant';
                    if (baseEntryKey === 'å¤§æ€»ç»“') return this.worldbookSettings?.largeSummary?.type || baseEntryTemplate?.type || 'constant';
                    return baseEntryTemplate?.type || 'selective';
                  })(),
                  position: (() => {
                    if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') return this.worldbookSettings?.journey?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') return this.worldbookSettings?.pastLives?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === 'å°è¯´æ¨¡å¼') return this.worldbookSettings?.novel?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === 'åˆ†æ®µæ­£æ–‡') return this.worldbookSettings?.segmented?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === 'å°æ€»ç»“') return this.worldbookSettings?.smallSummary?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === 'å¤§æ€»ç»“') return this.worldbookSettings?.largeSummary?.position || baseEntryTemplate?.position || 'before_character_definition';
                    return baseEntryTemplate?.position || 'before_character_definition';
                  })(),
                  order: (() => {
                    if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') return this.worldbookSettings?.journey?.order || baseEntryTemplate?.order || 20;
                    if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') return this.worldbookSettings?.pastLives?.order || baseEntryTemplate?.order || 19;
                    if (baseEntryKey === 'å°è¯´æ¨¡å¼') return this.worldbookSettings?.novel?.order || baseEntryTemplate?.order || 18;
                    if (baseEntryKey === 'åˆ†æ®µæ­£æ–‡') return this.worldbookSettings?.segmented?.order || baseEntryTemplate?.order || 21;
                    if (baseEntryKey === 'å°æ€»ç»“') return this.worldbookSettings?.smallSummary?.order || baseEntryTemplate?.order || 20;
                    if (baseEntryKey === 'å¤§æ€»ç»“') return this.worldbookSettings?.largeSummary?.order || baseEntryTemplate?.order || 19;
                    return baseEntryTemplate?.order || 20;
                  })(),
                  filters: baseEntryTemplate?.filters || [],
                  scan_depth: baseEntryTemplate?.scan_depth || 'same_as_global',
                  case_sensitive: baseEntryTemplate?.case_sensitive || 'same_as_global',
                  match_whole_words: baseEntryTemplate?.match_whole_words || 'same_as_global',
                  use_group_scoring: baseEntryTemplate?.use_group_scoring || 'same_as_global',
                  probability: baseEntryTemplate?.probability !== undefined ? baseEntryTemplate.probability : 100,
                  exclude_recursion: baseEntryTemplate?.exclude_recursion || false,
                  prevent_recursion: baseEntryTemplate?.prevent_recursion || false,
                  delay_until_recursion: baseEntryTemplate?.delay_until_recursion || false,
                  depth: (() => {
                    const position = (() => {
                      if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') return this.worldbookSettings?.journey?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') return this.worldbookSettings?.pastLives?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === 'å°è¯´æ¨¡å¼') return this.worldbookSettings?.novel?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === 'åˆ†æ®µæ­£æ–‡') return this.worldbookSettings?.segmented?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === 'å°æ€»ç»“') return this.worldbookSettings?.smallSummary?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === 'å¤§æ€»ç»“') return this.worldbookSettings?.largeSummary?.position || baseEntryTemplate?.position || 'before_character_definition';
                      return baseEntryTemplate?.position || 'before_character_definition';
                    })();
                    
                    if (position.startsWith('at_depth')) {
                      if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') return this.worldbookSettings?.journey?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') return this.worldbookSettings?.pastLives?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === 'å°è¯´æ¨¡å¼') return this.worldbookSettings?.novel?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === 'åˆ†æ®µæ­£æ–‡') return this.worldbookSettings?.segmented?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === 'å°æ€»ç»“') return this.worldbookSettings?.smallSummary?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === 'å¤§æ€»ç»“') return this.worldbookSettings?.largeSummary?.depth || baseEntryTemplate?.depth || 1;
                      return baseEntryTemplate?.depth || 1;
                    }
                    return null;
                  })(),
                  automation_id: baseEntryTemplate?.automation_id || null,
                  group: baseEntryTemplate?.group || '',
                  group_prioritized: baseEntryTemplate?.group_prioritized || false,
                  group_weight: baseEntryTemplate?.group_weight || 100,
                  sticky: baseEntryTemplate?.sticky || null,
                  cooldown: baseEntryTemplate?.cooldown || null,
                  delay: baseEntryTemplate?.delay || null
                };

                await TavernHelper.createLorebookEntries(bookName, [newEntryData]);
                if (!silent) this.showTemporaryMessage(`å·²æˆåŠŸåˆ›å»ºå¹¶å†™å…¥åˆ°â€œ${finalEntryKey}â€ã€‚`);
                
                if (this.isAutoToggleLorebookEnabled) {
                    this.updateAutoToggledEntries();
                }

              } else {
                // 4. å¦‚æœæ¡ç›®å­˜åœ¨ï¼Œåˆ™æ ¹æ®ç±»å‹å†³å®šæ˜¯è¿½åŠ è¿˜æ˜¯è¦†ç›–
                let updatedContent;

                if (baseEntryKey === 'å°è¯´æ¨¡å¼') {
                    // å¯¹äºå°è¯´æ¨¡å¼ï¼Œæ£€æŸ¥é‡å¤åè¿½åŠ å†…å®¹
                    const existingContent = targetEntry.content || '';
                    if (existingContent.includes(reformattedContent.trim())) {
                        if (!silent) this.showTemporaryMessage(`å†…å®¹å·²å­˜åœ¨ï¼Œè·³è¿‡å†™å…¥ã€‚`);
                        console.log(`[å½’å¢Ÿ] å†…å®¹é‡å¤ (å°è¯´æ¨¡å¼)ï¼Œè·³è¿‡å†™å…¥: ${finalEntryKey}`);
                        if (button && !silent) {
                            button.textContent = 'å†™å…¥ä¸–ç•Œä¹¦';
                        }
                        return;
                    }
                    updatedContent = existingContent + (existingContent ? '\n\n' : '') + reformattedContent;
                    if (!silent) this.showTemporaryMessage(`å·²æˆåŠŸè¿½åŠ å†…å®¹åˆ°â€œ${finalEntryKey}â€`);
                } else {
                    // å¯¹äºå…¶ä»–ç±»å‹ï¼ˆå¦‚æœ¬ä¸–å†ç¨‹ï¼‰ï¼Œæ£€æŸ¥é‡å¤åè¿½åŠ å†…å®¹
                    const existingContent = targetEntry.content || '';

                    // æ–°å¢ï¼šåŸºäºåºå·çš„æ›´å¯é çš„é‡å¤æ£€æŸ¥ï¼Œä»¥è§£å†³ä¿®å‰ªå†²çª
                    const getSeq = (text) => {
                        if (!text) return null;
                        // Match 'åºå·|' at the very beginning of the block
                        const match = text.match(/^åºå·\|(\d+)/);
                        return match ? match[1] : null;
                    };

                    const newEventSeq = getSeq(reformattedContent.trim());
                    let isDuplicate = false;

                    if (newEventSeq && baseEntryKey === 'æœ¬ä¸–å†ç¨‹') {
                        const existingSequences = (existingContent)
                            .split('\n\n') // Events are separated by double newlines
                            .map(block => getSeq(block.trim()))
                            .filter(seq => seq !== null);
                        
                        if (existingSequences.includes(newEventSeq)) {
                            isDuplicate = true;
                        }
                    } else {
                        // å¦‚æœæ–°å†…å®¹æ²¡æœ‰åºå·ï¼Œæˆ–ä¸æ˜¯â€œæœ¬ä¸–å†ç¨‹â€ï¼Œåˆ™é€€å›æ—§çš„åŸºäºå†…å®¹çš„æ£€æŸ¥
                        isDuplicate = existingContent.includes(reformattedContent.trim());
                    }

                    if (isDuplicate) {
                        const message = newEventSeq ? `äº‹ä»¶ (åºå· ${newEventSeq}) å·²å­˜åœ¨` : 'å†…å®¹å·²å­˜åœ¨';
                        if (!silent) this.showTemporaryMessage(`${message}ï¼Œè·³è¿‡å†™å…¥ã€‚`);
                        console.log(`[å½’å¢Ÿ] å†…å®¹é‡å¤ (${message})ï¼Œè·³è¿‡å†™å…¥: ${finalEntryKey}`);

                        if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') this.lastWrittenJourney = this.lastExtractedJourney;
                        if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') this.lastWrittenPastLives = this.lastExtractedPastLives;

                        if (button && !silent) {
                            button.textContent = 'å†™å…¥ä¸–ç•Œä¹¦';
                        }
                        return; // æå‰é€€å‡ºå‡½æ•°
                    }

                    updatedContent = existingContent + (existingContent ? '\n\n' : '') + reformattedContent;
                    if (!silent) this.showTemporaryMessage(`å·²æˆåŠŸè¿½åŠ å†…å®¹åˆ°â€œ${finalEntryKey}â€`);
                }
                
                // åœ¨åˆå¹¶å†…å®¹åã€å†™å…¥ä¹‹å‰æ‰§è¡Œä¿®å‰ª
                if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹' && this.isAutoTrimEnabled) {
                    console.log('[å½’å¢Ÿ] è‡ªåŠ¨ä¿®å‰ªå·²å¼€å¯ï¼Œæ­£åœ¨å¤„ç†åˆå¹¶åçš„å†…å®¹...');
                    updatedContent = this._getTrimmedJourneyContent(updatedContent);
                }

                await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: updatedContent }]);
              }

              if (button && !silent) {
                button.textContent = 'å†™å…¥æˆåŠŸ';
                setTimeout(() => { button.textContent = 'å†™å…¥ä¸–ç•Œä¹¦'; }, 2000);
              }

            } catch (error) {
              console.error(`å†™å…¥ä¸–ç•Œä¹¦ "${finalEntryKey}" æ—¶å‡ºé”™:`, error);
              if (!silent) {
                this.showTemporaryMessage(`å†™å…¥å¤±è´¥: ${error.message}`);
                if (button) button.textContent = 'å†™å…¥å¤±è´¥';
              }
            } finally {
                if (button && !silent && button.textContent === 'å†™å…¥ä¸­...') {
                    button.textContent = 'å†™å…¥ä¸–ç•Œä¹¦';
                }
            }
          },

          async writeCharacterCardToLorebook() {
            const content = this.lastExtractedCharacterCard;
            if (!content) {
              this.showTemporaryMessage('æ²¡æœ‰å¯å†™å…¥çš„è§’è‰²å†…å®¹ã€‚');
              return;
            }

            const button = document.getElementById('btn-write-character-card');
            if (button) button.textContent = 'å†™å…¥ä¸­...';

            try {
              const lines = content.trim().split('\n');
              const characterData = {};
              lines.forEach(line => {
                const parts = line.split('|');
                if (parts.length >= 2) {
                  const key = parts[0].trim();
                  const value = parts.slice(1).join('|').trim();
                  characterData[key] = value;
                }
              });

              const characterName = characterData['å§“å'];
              if (!characterName) {
                throw new Error('æ— æ³•ä»æå–å†…å®¹ä¸­æ‰¾åˆ°è§’è‰²â€œå§“åâ€ã€‚');
              }

              const bookName = '1å½’å¢Ÿ';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const existingEntry = allEntries.find(entry => entry.comment === characterName);

              if (existingEntry) {
                this.showTemporaryMessage(`è§’è‰²â€œ${characterName}â€å·²å­˜åœ¨ï¼Œè¯·æ‰‹åŠ¨ä¿®æ”¹ã€‚`);
                if (button) button.textContent = 'å†™å…¥ä¸–ç•Œä¹¦';
                return;
              }

              await TavernHelper.createLorebookEntries(bookName, [
                {
                  comment: characterName,
                  keys: [characterName],
                  content: content.trim(),
                  enabled: true,
                },
              ]);

              this.showTemporaryMessage(`å·²æˆåŠŸåˆ›å»ºè§’è‰²â€œ${characterName}â€ã€‚`);
              if (button) button.textContent = 'å†™å…¥æˆåŠŸ';
              setTimeout(() => {
                if (button) button.textContent = 'å†™å…¥ä¸–ç•Œä¹¦';
              }, 2000);
            } catch (error) {
              console.error('å†™å…¥è§’è‰²å¡åˆ°ä¸–ç•Œä¹¦æ—¶å‡ºé”™:', error);
              this.showTemporaryMessage(`å†™å…¥å¤±è´¥: ${error.message}`);
              if (button) button.textContent = 'å†™å…¥å¤±è´¥';
            }
          },

          async updateCurrentSceneLorebook(sceneContent) {
            // å¢åŠ å¥å£®æ€§æ£€æŸ¥ï¼Œé˜²æ­¢å†™å…¥ç©ºå†…å®¹
            if (!sceneContent || sceneContent.trim() === '') {
              console.warn('[å½’å¢Ÿ] å°è¯•å‘â€œå½“å‰åœºæ™¯â€å†™å…¥ç©ºå†…å®¹ï¼Œæ“ä½œå·²å–æ¶ˆã€‚');
              return;
            }
            const bookName = '1å½’å¢Ÿ';
            const sceneKey = 'å½“å‰åœºæ™¯';
            try {
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const sceneEntry = allEntries.find(entry => entry.comment === sceneKey);

              if (!sceneEntry) {
                console.warn(
                  `[å½’å¢Ÿ] æœªæ‰¾åˆ°ä¸–ç•Œä¹¦æ¡ç›® "${sceneKey}"ï¼Œæ— æ³•æ›´æ–°åœºæ™¯æ­£æ–‡ã€‚è¯·åœ¨'${bookName}'ä¸–ç•Œä¹¦ä¸­åˆ›å»ºå®ƒã€‚`,
                );
                // å¦‚æœæ¡ç›®ä¸å­˜åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©åˆ›å»ºä¸€ä¸ª
                await TavernHelper.createLorebookEntries(bookName, [
                  {
                    comment: sceneKey,
                    content: sceneContent,
                    keys: [],
                  },
                ]);
                console.log(`[å½’å¢Ÿ] å·²åˆ›å»ºå¹¶æ›´æ–° "${sceneKey}" å†…å®¹ã€‚`);
                return;
              }

              // ä½¿ç”¨è¦†ç›–å¼æ›´æ–°
              await TavernHelper.setLorebookEntries(bookName, [{ uid: sceneEntry.uid, content: sceneContent }]);
              console.log(`[å½’å¢Ÿ] æˆåŠŸæ›´æ–° "${sceneKey}" å†…å®¹ã€‚`);
            } catch (error) {
              console.error(`[å½’å¢Ÿ] æ›´æ–° "${sceneKey}" æ—¶å‡ºé”™:`, error);
            }
          },

          async loadAndDisplayCurrentScene(messageContent = null) {
            const gameTextDisplay = document.getElementById('game-text-display');
            if (!gameTextDisplay) return;

            try {
              let contentToParse = messageContent;

              // å¦‚æœæ²¡æœ‰ç›´æ¥æä¾›å†…å®¹ï¼Œåˆ™ä»èŠå¤©è®°å½•ä¸­è·å–
              if (contentToParse === null) {
                const messages = await getChatMessages(getCurrentMessageId());
                if (!messages || messages.length === 0) return;
                const lastAiMessage = [...messages].reverse().find(m => m.role === 'assistant');
                if (lastAiMessage) {
                  contentToParse = lastAiMessage.message;
                }
              }

              if (contentToParse) {
                // 1. æ›´æ–°ä¸»ç•Œé¢æ­£æ–‡ (ä½¿ç”¨æ–°çš„å¥å£®çš„æå–å‡½æ•°)
                const displayText = this._getDisplayText(contentToParse);
                const finalHTML = this.formatMessageContent(displayText);
                gameTextDisplay.innerHTML = finalHTML;
                this.updateLiveWordCount(); // æ–°å¢ï¼šè°ƒç”¨å­—æ•°ç»Ÿè®¡å‡½æ•°
                console.groupEnd();
                // 2. åŒæ­¥æå–æ‰€æœ‰æ ‡ç­¾å†…å®¹åˆ°å˜é‡ï¼Œç”¨äºâ€œæŸ¥çœ‹æå–å†…å®¹â€æ¨¡æ€æ¡†
                this.lastExtractedNovelText = this._extractLastTagContent('gametxt', contentToParse);
                this.lastExtractedJourney = this._extractLastTagContent('æœ¬ä¸–å†ç¨‹', contentToParse);
                this.lastExtractedPastLives = this._extractLastTagContent('å¾€ä¸–æ¶Ÿæ¼ª', contentToParse);
                this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', contentToParse, true);
                this.lastExtractedCharacterCard = this._extractLastTagContent('è§’è‰²æå–', contentToParse);
                this.updateVariableChangesReminder();// æ›´æ–°å˜é‡æ”¹å˜æé†’
                // 3. æ–°å¢ï¼šæå–å¹¶æ¸²æŸ“è¡ŒåŠ¨é€‰é¡¹
                let actionOptionsContent = this._extractLastTagContent('è¡ŒåŠ¨é€‰é¡¹', contentToParse);
                if (!actionOptionsContent) {
                   actionOptionsContent = this._extractLastTagContent('action', contentToParse);
                }
                this.renderActionOptions(actionOptionsContent);
              }
            } catch (error) {
              console.error(`[å½’å¢Ÿ] åŠ è½½å¹¶æ˜¾ç¤ºå½“å‰åœºæ™¯æ—¶å‡ºé”™:`, error);
              gameTextDisplay.innerHTML = `<gametxt>åŠ è½½åœºæ™¯æ—¶å‡ºé”™ã€‚</gametxt>`;
              this.updateLiveWordCount(); // æ–°å¢ï¼šè°ƒç”¨å­—æ•°ç»Ÿè®¡å‡½æ•°
            }
          },



// ===è¡ŒåŠ¨é€‰é¡¹æ¸²æŸ“æ¨¡å—å¼€å§‹===



          // è¡ŒåŠ¨é€‰é¡¹æ¸²æŸ“å‡½æ•°
          renderActionOptions(content) {
            const container = document.getElementById('action-options-container');
            if (!container) return;

            container.innerHTML = ''; // æ¸…ç©ºæ—§é€‰é¡¹

            const hasContent = content && typeof content === 'string' && content.trim() !== '';

            // å¦‚æœå¼€å…³å…³é—­æˆ–æ²¡æœ‰æœ‰æ•ˆå†…å®¹ï¼Œåˆ™éšè—å®¹å™¨å¹¶è¿”å›
            if (!this.isActionOptionsEnabled || !hasContent) {
                container.style.display = 'none';
                return;
            }

            // æœ‰å†…å®¹åˆ™æ˜¾ç¤ºå®¹å™¨
            container.style.display = 'block';

            const lines = content.trim().split('\n');
            lines.forEach(line => {
                line = line.trim();
                const match = line.match(/^(?:\d+\.\s*)?(.+)/);
                if (match) {
                    const optionText = match[1].trim();
                    if (optionText) {
                        const btn = document.createElement('button');
                        btn.className = 'action-option-btn';
                        btn.textContent = optionText;
                        btn.dataset.actionText = optionText; // å°†é€‰é¡¹æ–‡æœ¬å­˜å…¥dataå±æ€§
                        btn.style.display = 'block';
                        btn.style.width = '100%';
                        container.appendChild(btn);
                    }
                }
            });
            // å¦‚æœè§£æåæ²¡æœ‰ç”Ÿæˆä»»ä½•æŒ‰é’®ï¼Œä¹Ÿéšè—å®¹å™¨
            if (container.childElementCount === 0) {
                container.style.display = 'none';
            }
          },



// ===è¡ŒåŠ¨é€‰é¡¹æ¸²æŸ“æ¨¡å—å¼€å§‹===




// ===è‡ªåŠ¨å†™å…¥ä¸–ç•Œä¹¦æ¨¡å—å¼€å§‹===
// æ ¹æ®åºå·xï¼Œå†™å…¥ç›¸å…³åºå·çš„æœ¬ä¸–å†ç¨‹ã€å¾€ä¸–æ¶Ÿæ¼ªã€å°è¯´æ¨¡å¼ï¼ˆxï¼‰ä¸–ç•Œä¹¦

          // çŠ¶æ€ä¿å­˜ä¸è‡ªåŠ¨å†™å…¥é€»è¾‘
          saveAutoWriteState(state) {
            try {
              localStorage.setItem('guixu_auto_write_enabled', state);
            } catch (e) {
              console.error('ä¿å­˜è‡ªåŠ¨å†™å…¥çŠ¶æ€å¤±è´¥:', e);
            }
          },

          loadAutoWriteState() {
            try {
              const savedState = localStorage.getItem('guixu_auto_write_enabled');
              // å¦‚æœlocalStorageä¸­æ²¡æœ‰ä¿å­˜è¿‡çŠ¶æ€ï¼Œåˆ™é»˜è®¤ä¸ºtrue (å¼€å¯)
              this.isAutoWriteEnabled = savedState === null ? true : savedState === 'true';
              const checkbox = document.getElementById('auto-write-checkbox');
              if (checkbox) {
                checkbox.checked = this.isAutoWriteEnabled;
              }
              // æ ¹æ®åŠ è½½çš„çŠ¶æ€å†³å®šæ˜¯å¦å¯åŠ¨è½®è¯¢
              if (this.isAutoWriteEnabled) {
                this.startAutoWritePolling();
              }
            } catch (e) {
              console.error('åŠ è½½è‡ªåŠ¨å†™å…¥çŠ¶æ€å¤±è´¥:', e);
              this.isAutoWriteEnabled = false;
            }
          },
          saveNovelModeState(state) {
            try {
              localStorage.setItem('guixu_novel_mode_enabled', state);
            } catch (e) {
              console.error('ä¿å­˜å°è¯´æ¨¡å¼çŠ¶æ€å¤±è´¥:', e);
            }
          },

          loadNovelModeState() {
            try {
              const savedState = localStorage.getItem('guixu_novel_mode_enabled');
              this.isNovelModeEnabled = savedState === 'true';
              const checkbox = document.getElementById('novel-mode-enabled-checkbox');
              if (checkbox) {
                checkbox.checked = this.isNovelModeEnabled;
              }
              // æ ¹æ®åŠ è½½çš„çŠ¶æ€å†³å®šæ˜¯å¦å¯åŠ¨å°è¯´æ¨¡å¼çš„è½®è¯¢
              if (this.isNovelModeEnabled) {
                this.startNovelModeAutoWritePolling();
              }
            } catch (e) {
              console.error('åŠ è½½å°è¯´æ¨¡å¼çŠ¶æ€å¤±è´¥:', e);
              this.isNovelModeEnabled = false;
            }
          },

// ã€æœ¬ä¸–å†ç¨‹ã€å¾€ä¸–æ¶Ÿæ¼ªå†™å…¥ã€‘

          startAutoWritePolling() {
            this.stopAutoWritePolling();
            console.log('[å½’å¢Ÿ] å¯åŠ¨è‡ªåŠ¨å†™å…¥è½®è¯¢ (setTimeoutæ¨¡å¼)...');
            const poll = async () => {
                if (!this.isAutoWriteEnabled) return;
                if (this.lastExtractedJourney && this.lastExtractedJourney !== this.lastWrittenJourney) {
                    await this.writeJourneyToLorebook(true);
                    this.lastWrittenJourney = this.lastExtractedJourney;//æ ‡è®°å·²ç»å†™å…¥
                }
                if (this.lastExtractedPastLives && this.lastExtractedPastLives !== this.lastWrittenPastLives) {
                    await this.writePastLivesToLorebook(true);
                    this.lastWrittenPastLives = this.lastExtractedPastLives; //æ ‡è®°å·²ç»å†™å…¥
                }
                if (this.isAutoWriteEnabled) {
                    this.autoWriteIntervalId = setTimeout(poll, 2000);
                }
            };
            this.autoWriteIntervalId = setTimeout(poll, 2000);
          },        
// ã€å°è¯´æ¨¡å¼å†™å…¥ã€‘
          startNovelModeAutoWritePolling() {
            this.stopNovelModeAutoWritePolling();
            console.log('[å½’å¢Ÿ] å¯åŠ¨å°è¯´æ¨¡å¼è‡ªåŠ¨å†™å…¥è½®è¯¢ (setTimeoutæ¨¡å¼)...');
            const poll = async () => {
                if (!this.isNovelModeEnabled) return;

                // Check for new Novel Mode content
                if (this.lastExtractedNovelText && this.lastExtractedNovelText !== this.lastWrittenNovelText) {
                    await this.writeNovelModeToLorebook(true);
                    this.lastWrittenNovelText = this.lastExtractedNovelText; //æ ‡è®°å·²ç»å†™å…¥
                }

                if (this.isNovelModeEnabled) {
                    this.novelModeAutoWriteIntervalId = setTimeout(poll, 2000);
                }
            };
            this.novelModeAutoWriteIntervalId = setTimeout(poll, 2000);
          },

// åœæ­¢è½®è¯¢å†™å…¥

          stopNovelModeAutoWritePolling() {
            if (this.novelModeAutoWriteIntervalId) {
              clearTimeout(this.novelModeAutoWriteIntervalId); 
              this.novelModeAutoWriteIntervalId = null;
            }
          },

          stopAutoWritePolling() {
            if (this.autoWriteIntervalId) {
              clearTimeout(this.autoWriteIntervalId); 
              this.autoWriteIntervalId = null;
            }
          },


          savePendingActions() {
            try {
              localStorage.setItem('guixu_pending_actions', JSON.stringify(this.pendingActions));
            } catch (e) {
              console.error('ä¿å­˜æŒ‡ä»¤é˜Ÿåˆ—çŠ¶æ€å¤±è´¥:', e);
            }
          },

          loadPendingActions() {
            try {
              const savedActions = localStorage.getItem('guixu_pending_actions');
              if (savedActions) {
                this.pendingActions = JSON.parse(savedActions) || [];
              }
            } catch (e) {
              console.error('åŠ è½½æŒ‡ä»¤é˜Ÿåˆ—çŠ¶æ€å¤±è´¥:', e);
              this.pendingActions = [];
              localStorage.removeItem('guixu_pending_actions');
            }
          },
 
// ç»Ÿä¸€è¯»å†™åºå·å­˜å–

          saveUnifiedIndex() {
            try {
              localStorage.setItem('guixu_unified_index', this.unifiedIndex);
            } catch (e) {
              console.error('ä¿å­˜ç»Ÿä¸€è¯»å†™åºå·å¤±è´¥:', e);
            }
          },
 
          loadUnifiedIndex() {
            try {
              const savedIndex = localStorage.getItem('guixu_unified_index');
              if (savedIndex) {
                this.unifiedIndex = parseInt(savedIndex, 10) || 1;
              }
              const input = document.getElementById('unified-index-input');
              if (input) {
                input.value = this.unifiedIndex;
              }
            } catch (e) {
              console.error('åŠ è½½ç»Ÿä¸€è¯»å†™åºå·å¤±è´¥:', e);
              this.unifiedIndex = 1; // å‡ºé”™æ—¶é‡ç½®ä¸º1
            }
          },

          loadNovelModeIndex() {
           try {
             const savedIndex = localStorage.getItem('guixu_novel_mode_index');
             if (savedIndex) {
               this.novelModeIndex = parseInt(savedIndex, 10) || 1;
             }
             const input = document.getElementById('novel-mode-index-input');
             if (input) {
               input.value = this.novelModeIndex;
             }
           } catch (e) {
             console.error('åŠ è½½å°è¯´æ¨¡å¼è¯»å†™åºå·å¤±è´¥:', e);
             this.novelModeIndex = 1; // å‡ºé”™æ—¶é‡ç½®ä¸º1
           }
          },
// ===è‡ªåŠ¨å†™å…¥ä¸–ç•Œä¹¦æ¨¡å—å¼€å§‹===


// ===æ ¸å¿ƒæ ¼å¼æå–ã€å¤„ç†ã€è§£ææ¨¡å—ç»“æŸ===



// ===å°è¯´æ¨¡å¼æ¨¡å—å¼€å§‹===
          // --- æ–°å¢ï¼šå°è¯´æ¨¡å¼ç« èŠ‚å’Œä¹¦ç­¾åŠŸèƒ½ ---
          novelChapters: [], // å­˜å‚¨è§£æå‡ºçš„ç« èŠ‚ä¿¡æ¯
          novelBookmarks: [], // å­˜å‚¨ä¹¦ç­¾ä¿¡æ¯
          currentChapterIndex: 0, // å½“å‰ç« èŠ‚ç´¢å¼•
          novelDisplayMode: 'single', // æ˜¾ç¤ºæ¨¡å¼ï¼šsingle(å•ç« èŠ‚) æˆ– continuous(è¿è´¯æ˜¾ç¤º)
          novelBackgroundEnabled: false, // å°è¯´æ¨¡å¼èƒŒæ™¯å›¾å¼€å…³
          novelBackgroundOpacity: 0.3, // å°è¯´æ¨¡å¼èƒŒæ™¯é€æ˜åº¦
          novelBackgroundImage: '', // å°è¯´æ¨¡å¼èƒŒæ™¯å›¾ç‰‡URL

          // è§£æå°è¯´å†…å®¹ä¸­çš„ç« èŠ‚
          parseNovelChapters(content) {
            if (!content) return [];
            
            const chapters = [];
            const lines = content.split('\n');
            let currentChapter = null;
            let chapterContent = [];
            let lineIndex = 0;

            for (const line of lines) {
              // åŒ¹é…ç« èŠ‚æ ‡é¢˜ï¼šç¬¬xç«  æˆ– ç¬¬xå› ç­‰æ ¼å¼
              const chapterMatch = line.match(/^\s*(ç¬¬\s*[é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒä¸‡\d]+\s*[ç« å›èŠ‚éƒ¨å·ç¯‡].*?)$/);
              
              if (chapterMatch) {
                // ä¿å­˜ä¸Šä¸€ç« èŠ‚
                if (currentChapter) {
                  currentChapter.content = chapterContent.join('\n');
                  currentChapter.endLine = lineIndex - 1;
                  chapters.push(currentChapter);
                }
                
                // å¼€å§‹æ–°ç« èŠ‚
                currentChapter = {
                  title: chapterMatch[1].trim(),
                  startLine: lineIndex,
                  endLine: -1,
                  content: ''
                };
                chapterContent = [line];
              } else if (currentChapter) {
                chapterContent.push(line);
              } else {
                // æ²¡æœ‰ç« èŠ‚æ ‡é¢˜çš„å†…å®¹ï¼Œå½’å…¥"åºç« "
                if (chapters.length === 0) {
                  chapters.push({
                    title: 'åºç« ',
                    startLine: 0,
                    endLine: -1,
                    content: ''
                  });
                  currentChapter = chapters[0];
                  chapterContent = [];
                }
                chapterContent.push(line);
              }
              lineIndex++;
            }

            // ä¿å­˜æœ€åä¸€ç« 
            if (currentChapter) {
              currentChapter.content = chapterContent.join('\n');
              currentChapter.endLine = lineIndex - 1;
              if (!chapters.includes(currentChapter)) {
                chapters.push(currentChapter);
              }
            }

            return chapters;
          },

          // ä¿å­˜ä¹¦ç­¾
          saveNovelBookmarks() {
            try {
              const key = `guixu_novel_bookmarks_${this.unifiedIndex}`;
              localStorage.setItem(key, JSON.stringify(this.novelBookmarks));
            } catch (e) {
              console.error('ä¿å­˜å°è¯´ä¹¦ç­¾å¤±è´¥:', e);
            }
          },

          // åŠ è½½ä¹¦ç­¾
          loadNovelBookmarks() {
            try {
              const key = `guixu_novel_bookmarks_${this.unifiedIndex}`;
              const saved = localStorage.getItem(key);
              this.novelBookmarks = saved ? JSON.parse(saved) : [];
            } catch (e) {
              console.error('åŠ è½½å°è¯´ä¹¦ç­¾å¤±è´¥:', e);
              this.novelBookmarks = [];
            }
          },

          // æ·»åŠ ä¹¦ç­¾
          addNovelBookmark() {
            const chapterSelect = document.getElementById('chapter-select');
            const currentChapter = chapterSelect.value;
            
            if (!currentChapter) {
              this.showTemporaryMessage('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªç« èŠ‚', 'error');
              return;
            }

            const chapterTitle = chapterSelect.options[chapterSelect.selectedIndex].text;
            const timestamp = new Date().toLocaleString('zh-CN');
            
            const bookmark = {
              id: Date.now(),
              chapterIndex: parseInt(currentChapter),
              chapterTitle: chapterTitle,
              timestamp: timestamp,
              note: `${chapterTitle} - ${timestamp}`
            };

            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒç« èŠ‚çš„ä¹¦ç­¾
            const existingIndex = this.novelBookmarks.findIndex(b => b.chapterIndex === bookmark.chapterIndex);
            if (existingIndex >= 0) {
              this.novelBookmarks[existingIndex] = bookmark;
              this.showTemporaryMessage('ä¹¦ç­¾å·²æ›´æ–°');
            } else {
              this.novelBookmarks.push(bookmark);
              this.showTemporaryMessage('ä¹¦ç­¾å·²æ·»åŠ ');
            }

            this.saveNovelBookmarks();
            this.updateBookmarkSelect();
          },

          // æ›´æ–°ä¹¦ç­¾é€‰æ‹©å™¨
          updateBookmarkSelect() {
            const select = document.getElementById('bookmark-select');
            if (!select) return;

            select.innerHTML = '<option value="">é€‰æ‹©ä¹¦ç­¾...</option>';
            
            this.novelBookmarks.forEach(bookmark => {
              const option = document.createElement('option');
              option.value = bookmark.chapterIndex;
              option.textContent = bookmark.note;
              select.appendChild(option);
            });
          },

          // è·³è½¬åˆ°ä¹¦ç­¾
          gotoBookmark() {
            const bookmarkSelect = document.getElementById('bookmark-select');
            const chapterIndex = parseInt(bookmarkSelect.value);
            
            if (isNaN(chapterIndex)) {
              this.showTemporaryMessage('è¯·é€‰æ‹©ä¸€ä¸ªä¹¦ç­¾', 'error');
              return;
            }

            this.showNovelChapter(chapterIndex);
            this.showTemporaryMessage('å·²è·³è½¬åˆ°ä¹¦ç­¾ä½ç½®');
          },

          // åˆ é™¤ä¹¦ç­¾
          deleteBookmark() {
            const bookmarkSelect = document.getElementById('bookmark-select');
            const chapterIndex = parseInt(bookmarkSelect.value);
            
            if (isNaN(chapterIndex)) {
              this.showTemporaryMessage('è¯·é€‰æ‹©è¦åˆ é™¤çš„ä¹¦ç­¾', 'error');
              return;
            }

            const bookmarkIndex = this.novelBookmarks.findIndex(b => b.chapterIndex === chapterIndex);
            if (bookmarkIndex >= 0) {
              this.novelBookmarks.splice(bookmarkIndex, 1);
              this.saveNovelBookmarks();
              this.updateBookmarkSelect();
              this.showTemporaryMessage('ä¹¦ç­¾å·²åˆ é™¤');
            }
          },

          // æ˜¾ç¤ºæŒ‡å®šç« èŠ‚
          showNovelChapter(chapterIndex) {
            if (!this.novelChapters || chapterIndex >= this.novelChapters.length) return;

            const chapter = this.novelChapters[chapterIndex];
            const body = document.getElementById('novel-mode-modal-body');
            
            if (body && chapter) {
              // ä½¿ç”¨æ ¼å¼åŒ–å†…å®¹æ˜¾ç¤ºç« èŠ‚
              const formattedContent = this.formatMessageContent(chapter.content);
              
              // åˆ›å»ºç« èŠ‚å†…å®¹å®¹å™¨
              const chapterContainer = document.createElement('div');
              chapterContainer.className = 'single-chapter-container';
              chapterContainer.style.cssText = 'position: relative; min-height: 100%;';
              
              // æ·»åŠ ç« èŠ‚å†…å®¹
              chapterContainer.innerHTML = `
                <div class="game-text-container" style="white-space: pre-wrap; padding: 10px; padding-bottom: 80px;">
                  ${formattedContent}
                </div>
              `;
              
              // æ·»åŠ åº•éƒ¨å¯¼èˆªï¼ˆä»…åœ¨å•ç« èŠ‚æ¨¡å¼ä¸‹ï¼‰
              if (this.novelDisplayMode === 'single' && this.novelChapters.length > 1) {
                const bottomNav = this.createBottomChapterNav(chapterIndex);
                chapterContainer.appendChild(bottomNav);
              }
              
              body.innerHTML = '';
              body.appendChild(chapterContainer);
              
              // æ›´æ–°ç« èŠ‚é€‰æ‹©å™¨
              const chapterSelect = document.getElementById('chapter-select');
              if (chapterSelect) {
                chapterSelect.value = chapterIndex;
              }
              
              this.currentChapterIndex = chapterIndex;
              this.updateChapterNavButtons();
            }
          },

          // åˆ›å»ºåº•éƒ¨ç« èŠ‚å¯¼èˆª
          createBottomChapterNav(currentIndex) {
            const nav = document.createElement('div');
            nav.className = 'bottom-chapter-nav';
            nav.style.cssText = `
              position: absolute;
              bottom: 0;
              left: 0;
              right: 0;
              background: rgba(15, 15, 35, 0.7);
              backdrop-filter: blur(5px);
              border-top: 1px solid rgba(139, 115, 85, 0.3);
              padding: 10px 20px;
              display: flex;
              justify-content: space-between;
              align-items: center;
              opacity: 0.8;
              transition: opacity 0.3s ease;
            `;
            
            // é¼ æ ‡æ‚¬åœæ—¶å¢åŠ ä¸é€æ˜åº¦
            nav.addEventListener('mouseenter', () => {
              nav.style.opacity = '1';
            });
            nav.addEventListener('mouseleave', () => {
              nav.style.opacity = '0.8';
            });
            
            // ä¸Šä¸€ç« æŒ‰é’®
            const prevBtn = document.createElement('button');
            prevBtn.innerHTML = 'â† ä¸Šä¸€ç« ';
            prevBtn.style.cssText = `
              background: rgba(139, 115, 85, 0.8);
              color: #c9aa71;
              border: none;
              padding: 8px 16px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
              transition: background 0.3s ease;
            `;
            
            if (currentIndex <= 0) {
              prevBtn.disabled = true;
              prevBtn.style.opacity = '0.5';
              prevBtn.style.cursor = 'not-allowed';
            } else {
              prevBtn.addEventListener('click', () => this.prevChapter());
              prevBtn.addEventListener('mouseenter', () => {
                prevBtn.style.background = 'rgba(139, 115, 85, 1)';
              });
              prevBtn.addEventListener('mouseleave', () => {
                prevBtn.style.background = 'rgba(139, 115, 85, 0.8)';
              });
            }
            
            // ç« èŠ‚ä¿¡æ¯
            const chapterInfo = document.createElement('span');
            chapterInfo.textContent = `${currentIndex + 1} / ${this.novelChapters.length}`;
            chapterInfo.style.cssText = `
              color: #8b7355;
              font-size: 11px;
              user-select: none;
            `;
            
            // ä¸‹ä¸€ç« æŒ‰é’®
            const nextBtn = document.createElement('button');
            nextBtn.innerHTML = 'ä¸‹ä¸€ç«  â†’';
            nextBtn.style.cssText = `
              background: rgba(139, 115, 85, 0.8);
              color: #c9aa71;
              border: none;
              padding: 8px 16px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
              transition: background 0.3s ease;
            `;
            
            if (currentIndex >= this.novelChapters.length - 1) {
              nextBtn.disabled = true;
              nextBtn.style.opacity = '0.5';
              nextBtn.style.cursor = 'not-allowed';
            } else {
              nextBtn.addEventListener('click', () => this.nextChapter());
              nextBtn.addEventListener('mouseenter', () => {
                nextBtn.style.background = 'rgba(139, 115, 85, 1)';
              });
              nextBtn.addEventListener('mouseleave', () => {
                nextBtn.style.background = 'rgba(139, 115, 85, 0.8)';
              });
            }
            
            nav.appendChild(prevBtn);
            nav.appendChild(chapterInfo);
            nav.appendChild(nextBtn);
            
            return nav;
          },

          // æ›´æ–°ç« èŠ‚å¯¼èˆªæŒ‰é’®çŠ¶æ€
          updateChapterNavButtons() {
            const prevBtn = document.getElementById('prev-chapter-btn');
            const nextBtn = document.getElementById('next-chapter-btn');
            
            if (prevBtn) {
              prevBtn.disabled = this.currentChapterIndex <= 0;
              prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
            }
            
            if (nextBtn) {
              nextBtn.disabled = this.currentChapterIndex >= this.novelChapters.length - 1;
              nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';
            }
          },

          // ä¸Šä¸€ç« 
          prevChapter() {
            if (this.currentChapterIndex > 0) {
              this.showNovelChapter(this.currentChapterIndex - 1);
            }
          },

          // ä¸‹ä¸€ç« 
          nextChapter() {
            if (this.currentChapterIndex < this.novelChapters.length - 1) {
              this.showNovelChapter(this.currentChapterIndex + 1);
            }
          },

          // åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼
          switchNovelDisplayMode(mode) {
            this.novelDisplayMode = mode;
            this.saveNovelDisplayMode();
            
            // æ›´æ–°å¯¼èˆªæ§ä»¶çš„æ˜¾ç¤ºçŠ¶æ€
            this.updateNovelNavControls(mode);
            
            if (mode === 'continuous') {
              this.showAllChaptersContinuous();
            } else {
              this.showNovelChapter(this.currentChapterIndex);
            }
          },

          // æ›´æ–°å°è¯´å¯¼èˆªæ§ä»¶çŠ¶æ€
          updateNovelNavControls(mode) {
            const chapterSelect = document.getElementById('chapter-select');
            const prevBtn = document.getElementById('prev-chapter-btn');
            const nextBtn = document.getElementById('next-chapter-btn');
            
            if (mode === 'continuous') {
              // è¿è´¯æ¨¡å¼ï¼šç¦ç”¨ç« èŠ‚å¯¼èˆªæ§ä»¶
              if (chapterSelect) chapterSelect.disabled = true;
              if (prevBtn) {
                prevBtn.disabled = true;
                prevBtn.style.opacity = '0.5';
              }
              if (nextBtn) {
                nextBtn.disabled = true;
                nextBtn.style.opacity = '0.5';
              }
            } else {
              // å•ç« èŠ‚æ¨¡å¼ï¼šå¯ç”¨ç« èŠ‚å¯¼èˆªæ§ä»¶
              if (chapterSelect) chapterSelect.disabled = false;
              this.updateChapterNavButtons(); // æ ¹æ®å½“å‰ç« èŠ‚æ›´æ–°æŒ‰é’®çŠ¶æ€
            }
          },

          // è¿è´¯æ˜¾ç¤ºæ‰€æœ‰ç« èŠ‚
          showAllChaptersContinuous() {
            const body = document.getElementById('novel-mode-modal-body');
            if (!body || !this.novelChapters.length) return;

            let allContent = '';
            this.novelChapters.forEach((chapter, index) => {
              // æ·»åŠ ç« èŠ‚æ ‡é¢˜é”šç‚¹ï¼Œç”¨äºä¹¦ç­¾è·³è½¬
              allContent += `<div id="chapter-anchor-${index}" class="chapter-section">`;
              
              // åœ¨è¿è´¯æ¨¡å¼ä¸‹å§‹ç»ˆæ˜¾ç¤ºç« èŠ‚æ ‡é¢˜ï¼ˆé™¤äº†åºç« ï¼‰
              if (chapter.title && chapter.title !== 'åºç« ') {
                allContent += `<h3 class="novel-chapter-title" style="
                  margin-top: ${index > 0 ? '3em' : '1em'};
                  margin-bottom: 1em;
                  border-bottom: 2px solid #8b7355;
                  padding-bottom: 0.8em;
                  color: #c9aa71;
                  font-weight: bold;
                  font-size: 18px;
                  text-align: center;
                  position: relative;
                ">${chapter.title}</h3>`;
              } else if (chapter.title === 'åºç« ') {
                // åºç« ä¹Ÿæ˜¾ç¤ºæ ‡é¢˜ï¼Œä½†æ ·å¼ç¨æœ‰ä¸åŒ
                allContent += `<h3 class="novel-chapter-title" style="
                  margin-top: ${index > 0 ? '2em' : '0.5em'};
                  margin-bottom: 1em;
                  border-bottom: 1px solid #8b7355;
                  padding-bottom: 0.5em;
                  color: #a0926d;
                  font-weight: normal;
                  font-size: 16px;
                  text-align: center;
                  font-style: italic;
                ">${chapter.title}</h3>`;
              }
              
              // æ£€æŸ¥å†…å®¹ç¬¬ä¸€è¡Œæ˜¯å¦é‡å¤äº†æ ‡é¢˜
              const contentLines = chapter.content.split('\n');
              const firstLine = contentLines[0]?.trim();
              const hasTitle = firstLine && chapter.title && firstLine.includes(chapter.title);
              
              // å¦‚æœå†…å®¹ç¬¬ä¸€è¡Œé‡å¤äº†æ ‡é¢˜ï¼Œåˆ™è·³è¿‡ç¬¬ä¸€è¡Œ
              const contentToShow = hasTitle ? contentLines.slice(1).join('\n') : chapter.content;
              
              // æ·»åŠ ç« èŠ‚å†…å®¹ï¼Œå¹¶åœ¨ç« èŠ‚é—´å¢åŠ é€‚å½“é—´è·
              allContent += `<div class="chapter-content" style="
                line-height: 1.8;
                margin-bottom: ${index < this.novelChapters.length - 1 ? '4em' : '2em'};
                text-indent: 2em;
              ">`;
              allContent += this.formatMessageContent(contentToShow);
              allContent += '</div>';
              allContent += '</div>';
            });

            body.innerHTML = `<div class="game-text-container continuous-reading" style="
              white-space: pre-wrap;
              padding: 20px;
              max-width: 800px;
              margin: 0 auto;
              font-size: 14px;
              line-height: 1.6;
            ">${allContent}</div>`;
            
            // æ›´æ–°å¯¼èˆªæ§ä»¶çŠ¶æ€
            this.updateNovelNavControls('continuous');
          },

          // ä¿å­˜æ˜¾ç¤ºæ¨¡å¼
          saveNovelDisplayMode() {
            try {
              localStorage.setItem('guixu_novel_display_mode', this.novelDisplayMode);
            } catch (e) {
              console.error('ä¿å­˜å°è¯´æ˜¾ç¤ºæ¨¡å¼å¤±è´¥:', e);
            }
          },

          // åŠ è½½æ˜¾ç¤ºæ¨¡å¼
          loadNovelDisplayMode() {
            try {
              const saved = localStorage.getItem('guixu_novel_display_mode');
              this.novelDisplayMode = saved || 'single';
              
              // æ›´æ–°UI
              const radios = document.querySelectorAll('input[name="novel-display-mode"]');
              radios.forEach(radio => {
                radio.checked = radio.value === this.novelDisplayMode;
              });
            } catch (e) {
              console.error('åŠ è½½å°è¯´æ˜¾ç¤ºæ¨¡å¼å¤±è´¥:', e);
              this.novelDisplayMode = 'single';
            }
          },

          // å°è¯´æ¨¡å¼èƒŒæ™¯è®¾ç½®
          async showNovelBackgroundSettings() {
            console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] æ‰“å¼€èƒŒæ™¯è®¾ç½®é¢æ¿ - ä½¿ç”¨é€šç”¨å›¾åº“ç»„ä»¶');
            
            // å…ˆåŠ è½½å½“å‰è®¾ç½®
            this.loadNovelBackgroundSettings();
            
            // ä½¿ç”¨é€šç”¨å›¾åº“ç»„ä»¶
            await this.showUnifiedGalleryPicker({
              title: 'å°è¯´æ¨¡å¼èƒŒæ™¯è®¾ç½®',
              mode: 'novel',
              allowEmpty: true,
              enablePagination: true,
              pageSize: 20,
              enableSourceSwitch: true,
              enableLazyLoad: true,
              extraControlsHtml: `
                <!-- èƒŒæ™¯å¼€å…³ -->
                <div style="padding: 10px; border-bottom: 1px solid rgba(201, 170, 113, 0.3);">
                  <label style="display: flex; align-items: center; gap: 8px; color: #c9aa71; font-size: 14px;">
                    <input type="checkbox" id="novel-bg-enabled" ${this.novelBackgroundEnabled ? 'checked' : ''}>
                    å¯ç”¨å°è¯´æ¨¡å¼èƒŒæ™¯å›¾
                  </label>
                </div>
                
                <!-- é€æ˜åº¦è®¾ç½® -->
                <div style="padding: 10px; border-bottom: 1px solid rgba(201, 170, 113, 0.3);">
                  <label style="color: #c9aa71; font-size: 12px; display: block; margin-bottom: 5px;">
                    èƒŒæ™¯é€æ˜åº¦: <span id="novel-bg-opacity-value">${this.novelBackgroundOpacity || 0.3}</span>
                  </label>
                  <input type="range" id="novel-bg-opacity" min="0.0" max="1.0" step="0.05" value="${this.novelBackgroundOpacity || 0.3}"
                         style="width: 100%; accent-color: #8b7355;">
                </div>
              `,
              onSelect: (imageData) => {
                console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] é€‰æ‹©èƒŒæ™¯:', imageData);
                
                // å¤„ç†é€‰æ‹©çš„å›¾ç‰‡
                if (imageData.source === 'empty') {
                  this.novelBackgroundImage = '';
                  console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] é€‰æ‹©äº†æ— èƒŒæ™¯');
                } else {
                  this.novelBackgroundImage = imageData.dataUrl;
                  console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] é€‰æ‹©äº†èƒŒæ™¯å›¾:', imageData.name);
                }
                
                // ä¿å­˜è®¾ç½®å¹¶åº”ç”¨èƒŒæ™¯
                this.saveNovelBackgroundSettings();
                this.applyNovelBackground();
                
                // æ˜¾ç¤ºé€‰æ‹©åé¦ˆ
                this.showTemporaryMessage(`å·²é€‰æ‹©èƒŒæ™¯: ${imageData.source === 'empty' ? 'æ— èƒŒæ™¯' : imageData.name}`);
                console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] èƒŒæ™¯é€‰æ‹©å®Œæˆå¹¶å·²å®æ—¶åº”ç”¨');
              },
              onClose: () => {
                console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] å…³é—­èƒŒæ™¯è®¾ç½®é¢æ¿');
              }
            });
            
            // ç»‘å®šé¢å¤–æ§ä»¶çš„äº‹ä»¶ï¼ˆåœ¨æ¨¡æ€æ¡†åˆ›å»ºåï¼‰
            setTimeout(() => {
              const enabledCheckbox = document.getElementById('novel-bg-enabled');
              const opacitySlider = document.getElementById('novel-bg-opacity');
              const opacityValue = document.getElementById('novel-bg-opacity-value');
              
              // å®æ—¶å“åº”ï¼šèƒŒæ™¯å¼€å…³åˆ‡æ¢äº‹ä»¶
              enabledCheckbox?.addEventListener('change', (e) => {
                this.novelBackgroundEnabled = e.target.checked;
                this.saveNovelBackgroundSettings();
                this.applyNovelBackground();
                console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] å®æ—¶åˆ‡æ¢èƒŒæ™¯å¼€å…³:', this.novelBackgroundEnabled);
              });

              // å®æ—¶å“åº”ï¼šé€æ˜åº¦æ»‘å—äº‹ä»¶
              opacitySlider?.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                opacityValue.textContent = value.toFixed(2);
                this.novelBackgroundOpacity = value;
                this.saveNovelBackgroundSettings();
                this.applyNovelBackground();
                console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] å®æ—¶è°ƒæ•´é€æ˜åº¦:', value);
              });
            }, 100);
          },

          // åŠ è½½å°è¯´æ¨¡å¼èƒŒæ™¯å›¾ç½‘æ ¼
          loadNovelBackgroundGrid() {
            const grid = document.getElementById('novel-bg-grid');
            if (!grid) return;

            // å…ˆåŠ è½½èƒŒæ™¯å›¾æ•°æ®
            this.loadBackgroundSettings();

            // æ¸…ç©ºç½‘æ ¼
            grid.innerHTML = '';

            // æ·»åŠ "æ— èƒŒæ™¯"é€‰é¡¹
            const noneOption = document.createElement('div');
            noneOption.className = 'novel-bg-option';
            noneOption.dataset.bgId = '';
            noneOption.style.cssText = `
              width: 100%;
              height: 80px;
              border: 2px solid ${this.novelBackgroundImage === '' ? '#c9aa71' : '#8b7355'};
              border-radius: 4px;
              display: flex;
              align-items: center;
              justify-content: center;
              cursor: pointer;
              background: rgba(26, 26, 46, 0.8);
              color: #8b7355;
              font-size: 11px;
              transition: border-color 0.3s ease;
            `;
            noneOption.textContent = 'æ— èƒŒæ™¯';
            noneOption.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              this.selectNovelBackground('');
            });
            grid.appendChild(noneOption);

            // æ·»åŠ ç°æœ‰èƒŒæ™¯å›¾
            if (this.backgroundImages && this.backgroundImages.length > 0) {
              this.backgroundImages.forEach(bg => {
                const option = document.createElement('div');
                option.className = 'novel-bg-option';
                option.dataset.bgId = bg.id;
                option.dataset.bgUrl = bg.dataUrl || bg.url;
                option.style.cssText = `
                  width: 100%;
                  height: 80px;
                  border: 2px solid ${this.novelBackgroundImage === (bg.dataUrl || bg.url) ? '#c9aa71' : '#8b7355'};
                  border-radius: 4px;
                  background-image: url("${bg.dataUrl || bg.url}");
                  background-size: cover;
                  background-position: center;
                  cursor: pointer;
                  position: relative;
                  transition: border-color 0.3s ease;
                `;
                
                // æ·»åŠ æ ‡é¢˜è¦†ç›–å±‚
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                  position: absolute;
                  bottom: 0;
                  left: 0;
                  right: 0;
                  background: rgba(0, 0, 0, 0.7);
                  color: #fff;
                  font-size: 10px;
                  padding: 2px 4px;
                  text-align: center;
                  border-radius: 0 0 2px 2px;
                  pointer-events: none;
                `;
                overlay.textContent = bg.name || `èƒŒæ™¯ ${bg.id}`;
                option.appendChild(overlay);
                
                option.addEventListener('click', (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  this.selectNovelBackground(bg.dataUrl || bg.url);
                });
                grid.appendChild(option);
              });
            }

            // å¦‚æœæ²¡æœ‰èƒŒæ™¯å›¾ï¼Œæ˜¾ç¤ºæç¤º
            if (!this.backgroundImages || this.backgroundImages.length === 0) {
              const emptyTip = document.createElement('div');
              emptyTip.style.cssText = `
                grid-column: 1 / -1;
                text-align: center;
                color: #8b7355;
                font-size: 12px;
                padding: 20px;
              `;
              emptyTip.textContent = 'æš‚æ— å¯ç”¨èƒŒæ™¯å›¾ï¼Œè¯·å…ˆåœ¨èƒŒæ™¯è®¾ç½®ä¸­æ·»åŠ èƒŒæ™¯å›¾';
              grid.appendChild(emptyTip);
            }
          },

          // é€‰æ‹©å°è¯´èƒŒæ™¯
          selectNovelBackground(bgUrl) {
            console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] é€‰æ‹©èƒŒæ™¯:', bgUrl);
            this.novelBackgroundImage = bgUrl;
            
            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            const options = document.querySelectorAll('.novel-bg-option');
            options.forEach(option => {
              const isSelected = (bgUrl === '' && option.dataset.bgId === '') ||
                               (bgUrl !== '' && option.dataset.bgUrl === bgUrl);
              option.style.borderColor = isSelected ? '#c9aa71' : '#8b7355';
              option.style.boxShadow = isSelected ? '0 0 10px rgba(201, 170, 113, 0.5)' : '';
            });
            
            // å®æ—¶å“åº”ï¼šç«‹å³ä¿å­˜è®¾ç½®å¹¶åº”ç”¨èƒŒæ™¯
            this.saveNovelBackgroundSettings();
            this.applyNovelBackground();
            
            // æ˜¾ç¤ºé€‰æ‹©åé¦ˆ
            this.showTemporaryMessage(`å·²é€‰æ‹©èƒŒæ™¯: ${bgUrl === '' ? 'æ— èƒŒæ™¯' : 'èƒŒæ™¯å›¾'}`);
            console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] èƒŒæ™¯é€‰æ‹©å®Œæˆå¹¶å·²å®æ—¶åº”ç”¨');
          },

          // ç»‘å®šå°è¯´èƒŒæ™¯é¢æ¿äº‹ä»¶
          bindNovelBackgroundPanelEvents(panel) {
            const enabledCheckbox = panel.querySelector('#novel-bg-enabled');
            const opacitySlider = panel.querySelector('#novel-bg-opacity');
            const opacityValue = panel.querySelector('#novel-bg-opacity-value');
            const cancelBtn = panel.querySelector('#novel-bg-cancel');

            // å®æ—¶å“åº”ï¼šèƒŒæ™¯å¼€å…³åˆ‡æ¢äº‹ä»¶
            enabledCheckbox?.addEventListener('change', (e) => {
              this.novelBackgroundEnabled = e.target.checked;
              this.saveNovelBackgroundSettings();
              this.applyNovelBackground();
              console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] å®æ—¶åˆ‡æ¢èƒŒæ™¯å¼€å…³:', this.novelBackgroundEnabled);
            });

            // å®æ—¶å“åº”ï¼šé€æ˜åº¦æ»‘å—äº‹ä»¶
            opacitySlider?.addEventListener('input', (e) => {
              const value = parseFloat(e.target.value);
              opacityValue.textContent = value.toFixed(2);
              this.novelBackgroundOpacity = value;
              this.saveNovelBackgroundSettings();
              this.applyNovelBackground();
              console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] å®æ—¶è°ƒæ•´é€æ˜åº¦:', value);
            });

            // å…³é—­æŒ‰é’®
            cancelBtn?.addEventListener('click', () => {
              panel.remove();
            });
          },

          // åŠ è½½å°è¯´æ¨¡å¼èƒŒæ™¯é€‰é¡¹
          loadNovelBackgroundOptions() {
            try {
              const settings = JSON.parse(localStorage.getItem('guixu_background_settings') || '{}');
              const novelSettings = JSON.parse(localStorage.getItem('guixu_novel_background_settings') || '{}');
              const select = document.getElementById('novel-bg-select');
              if (!select) return;

              // æ¸…ç©ºç°æœ‰é€‰é¡¹ï¼ˆä¿ç•™é»˜è®¤é€‰é¡¹ï¼‰
              const defaultOptions = select.querySelectorAll('option[value=""], option[value="random"]');
              select.innerHTML = '';
              defaultOptions.forEach(option => select.appendChild(option));

              // æ·»åŠ å¯ç”¨èƒŒæ™¯å›¾
              if (settings.backgrounds && settings.backgrounds.length > 0) {
                settings.backgrounds.forEach((bg, index) => {
                  const option = document.createElement('option');
                  option.value = bg;
                  option.textContent = `èƒŒæ™¯å›¾ ${index + 1}`;
                  select.appendChild(option);
                });
              }

              // è®¾ç½®å½“å‰é€‰ä¸­çš„èƒŒæ™¯
              if (novelSettings.image) {
                select.value = novelSettings.image;
              }
            } catch (e) {
              console.error('åŠ è½½èƒŒæ™¯é€‰é¡¹å¤±è´¥:', e);
            }
          },

          // ç»‘å®šå°è¯´èƒŒæ™¯è®¾ç½®äº‹ä»¶
          bindNovelBackgroundEvents(panel) {
            const enabledCheckbox = panel.querySelector('#novel-bg-enabled');
            const opacitySlider = panel.querySelector('#novel-bg-opacity');
            const opacityValue = panel.querySelector('#novel-bg-opacity-value');
            const bgSelect = panel.querySelector('#novel-bg-select');
            const preview = panel.querySelector('#novel-bg-preview');
            const applyBtn = panel.querySelector('#novel-bg-apply');
            const cancelBtn = panel.querySelector('#novel-bg-cancel');

            // é€æ˜åº¦æ»‘å—äº‹ä»¶
            opacitySlider?.addEventListener('input', (e) => {
              const value = parseFloat(e.target.value);
              opacityValue.textContent = value;
              this.updateNovelBackgroundPreview(preview, bgSelect.value, value);
            });

            // èƒŒæ™¯é€‰æ‹©äº‹ä»¶
            bgSelect?.addEventListener('change', (e) => {
              this.updateNovelBackgroundPreview(preview, e.target.value, parseFloat(opacitySlider.value));
            });

            // åº”ç”¨æŒ‰é’®
            applyBtn?.addEventListener('click', () => {
              this.novelBackgroundEnabled = enabledCheckbox.checked;
              this.novelBackgroundOpacity = parseFloat(opacitySlider.value);
              this.novelBackgroundImage = bgSelect.value;
              
              this.saveNovelBackgroundSettings();
              this.applyNovelBackground();
              
              panel.remove();
              this.showTemporaryMessage('å°è¯´èƒŒæ™¯è®¾ç½®å·²åº”ç”¨');
            });

            // å–æ¶ˆæŒ‰é’®
            cancelBtn?.addEventListener('click', () => {
              panel.remove();
            });

            // åˆå§‹é¢„è§ˆ
            this.updateNovelBackgroundPreview(preview, bgSelect.value, parseFloat(opacitySlider.value));
          },

          // æ›´æ–°èƒŒæ™¯é¢„è§ˆ
          updateNovelBackgroundPreview(preview, bgValue, opacity) {
            if (!preview) return;

            if (!bgValue || bgValue === '') {
              preview.style.backgroundImage = '';
              preview.textContent = 'æ— èƒŒæ™¯';
              return;
            }

            if (bgValue === 'random') {
              preview.style.backgroundImage = '';
              preview.textContent = 'éšæœºèƒŒæ™¯ï¼ˆåº”ç”¨æ—¶éšæœºé€‰æ‹©ï¼‰';
              return;
            }

            preview.style.backgroundImage = `url(${bgValue})`;
            preview.style.opacity = opacity;
            preview.textContent = '';
          },

          // åº”ç”¨å°è¯´æ¨¡å¼èƒŒæ™¯
          applyNovelBackground() {
            const novelModal = document.getElementById('novel-mode-modal');
            if (!novelModal) return;

            console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] åº”ç”¨èƒŒæ™¯è®¾ç½®:', {
              enabled: this.novelBackgroundEnabled,
              image: this.novelBackgroundImage,
              opacity: this.novelBackgroundOpacity
            });

            if (this.novelBackgroundEnabled && this.novelBackgroundImage) {
              // åº”ç”¨èƒŒæ™¯å›¾åˆ°æ¨¡æ€æ¡†
              novelModal.style.backgroundImage = `url(${this.novelBackgroundImage})`;
              novelModal.style.backgroundSize = 'cover';
              novelModal.style.backgroundPosition = 'center';
              novelModal.style.backgroundRepeat = 'no-repeat';
              novelModal.style.backgroundAttachment = 'fixed';
              const opacity = this.novelBackgroundOpacity || 0.3;
              const modalContent = novelModal.querySelector('.modal-content');
              if (modalContent) {
                const contentOpacity = Math.max(0.7, 1 - opacity);
                modalContent.style.backgroundColor = `rgba(15, 15, 35, ${contentOpacity})`;
                modalContent.style.backdropFilter = 'blur(1px)';
                console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] è®¾ç½®å†…å®¹é€æ˜åº¦:', contentOpacity);
              }
              const existingOverlay = novelModal.querySelector('.novel-bg-overlay');
              if (existingOverlay) {
                existingOverlay.remove();
              }              
              const overlay = document.createElement('div');
              overlay.className = 'novel-bg-overlay';
              overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, ${0.3 - opacity * 0.2});
                pointer-events: none;
                z-index: 1;
              `;
              novelModal.appendChild(overlay);
              
              console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] èƒŒæ™¯å›¾å·²åº”ç”¨');
            } else {
              // ç§»é™¤èƒŒæ™¯
              novelModal.style.backgroundImage = '';
              novelModal.style.backgroundAttachment = '';
              const modalContent = novelModal.querySelector('.modal-content');
              if (modalContent) {
                modalContent.style.backgroundColor = '';
                modalContent.style.backdropFilter = '';
              }
              
              // ç§»é™¤èƒŒæ™¯é®ç½©
              const existingOverlay = novelModal.querySelector('.novel-bg-overlay');
              if (existingOverlay) {
                existingOverlay.remove();
              }
              
              console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] èƒŒæ™¯å›¾å·²ç§»é™¤');
            }
          },

          // è·å–éšæœºå°è¯´èƒŒæ™¯
          getRandomNovelBackground() {
            try {
              const settings = JSON.parse(localStorage.getItem('guixu_background_settings') || '{}');
              if (settings.backgrounds && settings.backgrounds.length > 0) {
                const randomIndex = Math.floor(Math.random() * settings.backgrounds.length);
                return settings.backgrounds[randomIndex];
              }
            } catch (e) {
              console.error('è·å–éšæœºèƒŒæ™¯å¤±è´¥:', e);
            }
            return null;
          },

          // ä¿å­˜å°è¯´èƒŒæ™¯è®¾ç½®
          saveNovelBackgroundSettings() {
            try {
              const settings = {
                enabled: this.novelBackgroundEnabled,
                opacity: this.novelBackgroundOpacity || 0.3,
                image: this.novelBackgroundImage || ''
              };
              localStorage.setItem('guixu_novel_background_settings', JSON.stringify(settings));
            } catch (e) {
              console.error('ä¿å­˜å°è¯´èƒŒæ™¯è®¾ç½®å¤±è´¥:', e);
            }
          },

          // åŠ è½½å°è¯´èƒŒæ™¯è®¾ç½®
          loadNovelBackgroundSettings() {
            try {
              const saved = localStorage.getItem('guixu_novel_background_settings');
              if (saved) {
                const settings = JSON.parse(saved);
                this.novelBackgroundEnabled = settings.enabled || false;
                this.novelBackgroundOpacity = settings.opacity || 0.3;
                this.novelBackgroundImage = settings.image || '';
              } else {
                // å…¼å®¹æ—§ç‰ˆæœ¬è®¾ç½®
                const oldSaved = localStorage.getItem('guixu_novel_background_enabled');
                this.novelBackgroundEnabled = oldSaved === 'true';
                this.novelBackgroundOpacity = 0.3;
                this.novelBackgroundImage = '';
              }
            } catch (e) {
              console.error('åŠ è½½å°è¯´èƒŒæ™¯è®¾ç½®å¤±è´¥:', e);
              this.novelBackgroundEnabled = false;
              this.novelBackgroundOpacity = 0.3;
              this.novelBackgroundImage = '';
            }
          },
 // ===å°è¯´æ¨¡å¼æ¨¡å—ç»“æŸ===




// ===ä¸–ç•Œä¹¦é«˜çº§è®¾ç½®/è‡ªåŠ¨å¼€å…³/åˆ›å»ºæ¨¡å—å¼€å§‹===   



// ä¸–ç•Œä¹¦é«˜çº§è®¾ç½®å­˜å–
           saveWorldbookSettings() {
             try {
               const settings = {
                 journey: {
                   position: document.getElementById('journey-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('journey-order')?.value) || 17,
                   depth: parseInt(document.getElementById('journey-depth')?.value) || 1,
                   type: document.getElementById('journey-type')?.value || 'selective',
                   enabled: document.getElementById('journey-enabled')?.checked || false
                 },
                 pastLives: {
                   position: document.getElementById('past-lives-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('past-lives-order')?.value) || 16,
                   depth: parseInt(document.getElementById('past-lives-depth')?.value) || 1,
                   type: document.getElementById('past-lives-type')?.value || 'selective',
                   enabled: document.getElementById('past-lives-enabled')?.checked || false
                 },
                 novel: {
                   position: document.getElementById('novel-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('novel-order')?.value) || 18,
                   depth: parseInt(document.getElementById('novel-depth')?.value) || 1,
                   type: document.getElementById('novel-type')?.value || 'selective',
                   enabled: document.getElementById('novel-enabled')?.checked || false
                 },
                 segmented: {
                   position: document.getElementById('segmented-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('segmented-order')?.value) || 21,
                   depth: parseInt(document.getElementById('segmented-depth')?.value) || 1,
                   type: document.getElementById('segmented-type')?.value || 'constant',
                   enabled: document.getElementById('segmented-enabled')?.checked || false
                 },
                 largeSummary: {
                   position: document.getElementById('large-summary-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('large-summary-order')?.value) || 19,
                   depth: parseInt(document.getElementById('large-summary-depth')?.value) || 1,
                   type: document.getElementById('large-summary-type')?.value || 'constant',
                   enabled: document.getElementById('large-summary-enabled')?.checked || false
                 },
                 smallSummary: {
                   position: document.getElementById('small-summary-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('small-summary-order')?.value) || 20,
                   depth: parseInt(document.getElementById('small-summary-depth')?.value) || 1,
                   type: document.getElementById('small-summary-type')?.value || 'constant',
                   enabled: document.getElementById('small-summary-enabled')?.checked || false
                 }
               };
               
               localStorage.setItem('guixu_worldbook_settings', JSON.stringify(settings));
               this.worldbookSettings = settings;
             } catch (e) {
               console.error('ä¿å­˜ä¸–ç•Œä¹¦è®¾ç½®å¤±è´¥:', e);
             }
           },

           loadWorldbookSettings() {
             try {
               const savedSettings = localStorage.getItem('guixu_worldbook_settings');
               if (savedSettings) {
                 this.worldbookSettings = JSON.parse(savedSettings);
               } else {
                 // é»˜è®¤è®¾ç½®
                 this.worldbookSettings = {
                   journey: { position: 'before_character_definition', order: 17, depth: 1, type: 'selective', enabled: false },
                   pastLives: { position: 'before_character_definition', order: 16, depth: 1, type: 'constant', enabled: false },
                   novel: { position: 'before_character_definition', order: 18, depth: 1, type: 'selective', enabled: false },
                   segmented: { position: 'at_depth_as_system', order: 3, depth: 4, type: 'constant', enabled: true },
                   largeSummary: { position: 'at_depth_as_system', order: 1, depth: 4, type: 'constant', enabled: true },
                   smallSummary: { position: 'at_depth_as_system', order: 2, depth: 4, type: 'constant', enabled: true },
                 };
               }
               
               // æ›´æ–°UI
               if (document.getElementById('journey-position')) {
                 document.getElementById('journey-position').value = this.worldbookSettings.journey.position;
                 document.getElementById('journey-order').value = this.worldbookSettings.journey.order;
                 document.getElementById('journey-depth').value = this.worldbookSettings.journey.depth;
                 document.getElementById('journey-type').value = this.worldbookSettings.journey.type;
                 document.getElementById('journey-enabled').checked = this.worldbookSettings.journey.enabled;
                 
                 document.getElementById('past-lives-position').value = this.worldbookSettings.pastLives.position;
                 document.getElementById('past-lives-order').value = this.worldbookSettings.pastLives.order;
                 document.getElementById('past-lives-depth').value = this.worldbookSettings.pastLives.depth;
                 document.getElementById('past-lives-type').value = this.worldbookSettings.pastLives.type;
                 document.getElementById('past-lives-enabled').checked = this.worldbookSettings.pastLives.enabled;
                 
                 document.getElementById('novel-position').value = this.worldbookSettings.novel.position;
                 document.getElementById('novel-order').value = this.worldbookSettings.novel.order;
                 document.getElementById('novel-depth').value = this.worldbookSettings.novel.depth;
                 document.getElementById('novel-type').value = this.worldbookSettings.novel.type;
                 document.getElementById('novel-enabled').checked = this.worldbookSettings.novel.enabled;

                 if(document.getElementById('segmented-position') && this.worldbookSettings.segmented) {
                   document.getElementById('segmented-position').value = this.worldbookSettings.segmented.position;
                   document.getElementById('segmented-order').value = this.worldbookSettings.segmented.order;
                   document.getElementById('segmented-depth').value = this.worldbookSettings.segmented.depth;
                   document.getElementById('segmented-type').value = this.worldbookSettings.segmented.type;
                   document.getElementById('segmented-enabled').checked = this.worldbookSettings.segmented.enabled;
                 }

                 if(document.getElementById('large-summary-position') && this.worldbookSettings.largeSummary) {
                   document.getElementById('large-summary-position').value = this.worldbookSettings.largeSummary.position;
                   document.getElementById('large-summary-order').value = this.worldbookSettings.largeSummary.order;
                   document.getElementById('large-summary-depth').value = this.worldbookSettings.largeSummary.depth;
                   document.getElementById('large-summary-type').value = this.worldbookSettings.largeSummary.type;
                   document.getElementById('large-summary-enabled').checked = this.worldbookSettings.largeSummary.enabled;
                 }

                 if(document.getElementById('small-summary-position') && this.worldbookSettings.smallSummary) {
                   document.getElementById('small-summary-position').value = this.worldbookSettings.smallSummary.position;
                   document.getElementById('small-summary-order').value = this.worldbookSettings.smallSummary.order;
                   document.getElementById('small-summary-depth').value = this.worldbookSettings.smallSummary.depth;
                   document.getElementById('small-summary-type').value = this.worldbookSettings.smallSummary.type;
                   document.getElementById('small-summary-enabled').checked = this.worldbookSettings.smallSummary.enabled;
                 }
                 
                 // æ›´æ–°æ·±åº¦è¾“å…¥æ¡†çš„æ˜¾ç¤ºçŠ¶æ€
                 ['journey', 'past-lives', 'novel', 'segmented', 'large-summary', 'small-summary'].forEach(type => {
                   const positionSelect = document.getElementById(`${type}-position`);
                   const depthContainer = document.getElementById(`${type}-depth-container`);
                   if (positionSelect && depthContainer) {
                     depthContainer.style.display = positionSelect.value.startsWith('at_depth') ? 'contents' : 'none';
                   }
                 });
               }
             } catch (e) {
               console.error('åŠ è½½ä¸–ç•Œä¹¦è®¾ç½®å¤±è´¥:', e);
               this.worldbookSettings = {
                 journey: { position: 'before_character_definition', order: 17, depth: 1, logic: 'and_any' },
                 pastLives: { position: 'before_character_definition', order: 16, depth: 1, logic: 'and_any' },
                 novel: { position: 'before_character_definition', order: 18, depth: 1, logic: 'and_any' },
               };
             }
           },

           resetWorldbookSettings() {
             try {
               localStorage.removeItem('guixu_worldbook_settings');
               this.worldbookSettings = {
                   journey: { position: 'before_character_definition', order: 17, depth: 1, type: 'selective', enabled: false },
                   pastLives: { position: 'before_character_definition', order: 16, depth: 1, type: 'constant', enabled: false },
                   novel: { position: 'before_character_definition', order: 18, depth: 1, type: 'selective', enabled: false },
                   segmented: { position: 'at_depth_as_system', order: 3, depth: 4, type: 'constant', enabled: true },
                   largeSummary: { position: 'at_depth_as_system', order: 1, depth: 4, type: 'constant', enabled: true },
                   smallSummary: { position: 'at_depth_as_system', order: 2, depth: 4, type: 'constant', enabled: true },
               };
             } catch (e) {
               console.error('é‡ç½®ä¸–ç•Œä¹¦è®¾ç½®å¤±è´¥:', e);
             }
           },

// è‡ªåŠ¨å¼€å…³ä¸–ç•Œä¹¦è½®è¯¢é€»è¾‘ (æ¡ç›®è‡ªåŠ¨åˆ›å»º) 
          async updateAutoToggledEntries(andDisableAll = false) {
            const bookName = '1å½’å¢Ÿ';
            const index = this.unifiedIndex;
            const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';
            const pastLivesKey = index > 1 ? `å¾€ä¸–æ¶Ÿæ¼ª(${index})` : 'å¾€ä¸–æ¶Ÿæ¼ª';
            const segmentedKey = index > 1 ? `åˆ†æ®µæ­£æ–‡(${index})` : 'åˆ†æ®µæ­£æ–‡';
            const smallSummaryKey = index > 1 ? `å°æ€»ç»“(${index})` : 'å°æ€»ç»“';
            const largeSummaryKey = index > 1 ? `å¤§æ€»ç»“(${index})` : 'å¤§æ€»ç»“';
            try {
                let allEntries = await TavernHelper.getLorebookEntries(bookName);
                const entriesToCreate = [];

                // æ£€æŸ¥å¹¶åˆ›å»ºç¼ºå¤±çš„æ¡ç›® 
                const targetJourneyEntry = allEntries.find(e => e.comment === journeyKey);
                if (!targetJourneyEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === 'æœ¬ä¸–å†ç¨‹');
                    if (baseTemplate) {
                        // å®Œæ•´å¤åˆ¶æ¨¡æ¿å±æ€§ï¼Œç¡®ä¿æ‰€æœ‰å¿…éœ€å­—æ®µéƒ½å­˜åœ¨
                        const newJourneyEntry = { ...baseTemplate };
                        delete newJourneyEntry.uid;
                        delete newJourneyEntry.display_index;
                        newJourneyEntry.comment = journeyKey;
                        newJourneyEntry.content = '';
                        newJourneyEntry.keys = [...(baseTemplate.keys || []), journeyKey];
                        const journeySettings = this.worldbookSettings?.journey || { position: 'before_character_definition', order: 17, depth: 1, type: 'selective', enabled: false };
                        newJourneyEntry.enabled = journeySettings.enabled;
                        // ç¡®ä¿è®¾ç½®æ‰€æœ‰å¿…éœ€çš„å±æ€§ï¼Œä½¿ç”¨ä¿å­˜çš„è®¾ç½®
                        newJourneyEntry.type = journeySettings.type;
                        newJourneyEntry.position = journeySettings.position;
                        newJourneyEntry.order = journeySettings.order;
                        newJourneyEntry.depth = journeySettings.position.startsWith('at_depth') ? journeySettings.depth : null;
                        newJourneyEntry.scan_depth = baseTemplate.scan_depth || 'same_as_global';
                        newJourneyEntry.case_sensitive = baseTemplate.case_sensitive || 'same_as_global';
                        newJourneyEntry.match_whole_words = baseTemplate.match_whole_words || 'same_as_global';
                        newJourneyEntry.use_group_scoring = baseTemplate.use_group_scoring || 'same_as_global';
                        newJourneyEntry.probability = baseTemplate.probability !== undefined ? baseTemplate.probability : 100;
                        newJourneyEntry.exclude_recursion = baseTemplate.exclude_recursion || false;
                        newJourneyEntry.prevent_recursion = baseTemplate.prevent_recursion || false;
                        newJourneyEntry.delay_until_recursion = baseTemplate.delay_until_recursion || false;
                        entriesToCreate.push(newJourneyEntry);
                    } else {
                        // å¦‚æœæ²¡æœ‰æ¨¡æ¿ï¼Œåˆ›å»ºä¸€ä¸ªå…¨æ–°çš„æ¡ç›®
                        console.warn('[å½’å¢Ÿè‡ªåŠ¨å¼€å…³] æœªæ‰¾åˆ°"æœ¬ä¸–å†ç¨‹"åŸºç¡€æ¨¡æ¿ï¼Œå°†åˆ›å»ºé»˜è®¤æ¡ç›®');
                        entriesToCreate.push({
                            comment: journeyKey,
                            content: '',
                            keys: [journeyKey],
                            enabled: this.worldbookSettings?.journey?.enabled || false, // æœ¬ä¸–å†ç¨‹é»˜è®¤å…³é—­
                            type: this.worldbookSettings?.journey?.type || 'selective',
                            position: this.worldbookSettings?.journey?.position || 'before_character_definition',
                            order: this.worldbookSettings?.journey?.order || 17,
                            depth: (this.worldbookSettings?.journey?.position || '').startsWith('at_depth') ? (this.worldbookSettings?.journey?.depth || 1) : null,
                            scan_depth: 'same_as_global',
                            case_sensitive: 'same_as_global',
                            match_whole_words: 'same_as_global',
                            use_group_scoring: 'same_as_global',
                            probability: 100,
                            exclude_recursion: false,
                            prevent_recursion: false,
                            delay_until_recursion: false,
                            filters: [],
                            depth: null,
                            automation_id: null,
                            group: '',
                            group_prioritized: false,
                            group_weight: 100,
                            sticky: null,
                            cooldown: null,
                            delay: null
                        });
                    }
                }

                const targetPastLivesEntry = allEntries.find(e => e.comment === pastLivesKey);
                if (!targetPastLivesEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === 'å¾€ä¸–æ¶Ÿæ¼ª');
                    if (baseTemplate) {
                        // å®Œæ•´å¤åˆ¶æ¨¡æ¿å±æ€§ï¼Œç¡®ä¿æ‰€æœ‰å¿…éœ€å­—æ®µéƒ½å­˜åœ¨
                        const newPastLivesEntry = { ...baseTemplate };
                        delete newPastLivesEntry.uid;
                        delete newPastLivesEntry.display_index;
                        newPastLivesEntry.comment = pastLivesKey;
                        newPastLivesEntry.content = '';
                        newPastLivesEntry.keys = [...(baseTemplate.keys || []), pastLivesKey];
                        const pastLivesSettings = this.worldbookSettings?.pastLives || { position: 'before_character_definition', order: 16, depth: 1, type: 'selective', enabled: true };
                        newPastLivesEntry.enabled = pastLivesSettings.enabled;
                        // ç¡®ä¿è®¾ç½®æ‰€æœ‰å¿…éœ€çš„å±æ€§ï¼Œä½¿ç”¨ä¿å­˜çš„è®¾ç½®
                        newPastLivesEntry.type = pastLivesSettings.type;
                        newPastLivesEntry.position = pastLivesSettings.position;
                        newPastLivesEntry.order = pastLivesSettings.order;
                        newPastLivesEntry.depth = pastLivesSettings.position.startsWith('at_depth') ? pastLivesSettings.depth : null;
                        newPastLivesEntry.scan_depth = baseTemplate.scan_depth || 'same_as_global';
                        newPastLivesEntry.case_sensitive = baseTemplate.case_sensitive || 'same_as_global';
                        newPastLivesEntry.match_whole_words = baseTemplate.match_whole_words || 'same_as_global';
                        newPastLivesEntry.use_group_scoring = baseTemplate.use_group_scoring || 'same_as_global';
                        newPastLivesEntry.probability = baseTemplate.probability !== undefined ? baseTemplate.probability : 100;
                        newPastLivesEntry.exclude_recursion = baseTemplate.exclude_recursion || false;
                        newPastLivesEntry.prevent_recursion = baseTemplate.prevent_recursion || false;
                        newPastLivesEntry.delay_until_recursion = baseTemplate.delay_until_recursion || false;
                        entriesToCreate.push(newPastLivesEntry);
                    } else {
                        // å¦‚æœæ²¡æœ‰æ¨¡æ¿ï¼Œåˆ›å»ºä¸€ä¸ªå…¨æ–°çš„æ¡ç›®
                        console.warn('[å½’å¢Ÿè‡ªåŠ¨å¼€å…³] æœªæ‰¾åˆ°"å¾€ä¸–æ¶Ÿæ¼ª"åŸºç¡€æ¨¡æ¿ï¼Œå°†åˆ›å»ºé»˜è®¤æ¡ç›®');
                        entriesToCreate.push({
                            comment: pastLivesKey,
                            content: '',
                            keys: [pastLivesKey],
                            enabled: this.worldbookSettings?.pastLives?.enabled || true,
                            type: this.worldbookSettings?.pastLives?.type || 'selective',
                            position: this.worldbookSettings?.pastLives?.position || 'before_character_definition',
                            order: this.worldbookSettings?.pastLives?.order || 16,
                            depth: (this.worldbookSettings?.pastLives?.position || '').startsWith('at_depth') ? (this.worldbookSettings?.pastLives?.depth || 1) : null,
                            scan_depth: 'same_as_global',
                            case_sensitive: 'same_as_global',
                            match_whole_words: 'same_as_global',
                            use_group_scoring: 'same_as_global',
                            probability: 100,
                            exclude_recursion: false,
                            prevent_recursion: false,
                            delay_until_recursion: false,
                            filters: [],
                            automation_id: null,
                            group: '',
                            group_prioritized: false,
                            group_weight: 100,
                            sticky: null,
                            cooldown: null,
                            delay: null
                        });
                    }
                }

               const targetSegmentedEntry = allEntries.find(e => e.comment === segmentedKey);
               if (!targetSegmentedEntry) {
                   const baseTemplate = allEntries.find(e => e.comment === 'åˆ†æ®µæ­£æ–‡');
                   const segmentedSettings = this.worldbookSettings?.segmented || { position: 'before_character_definition', order: 21, depth: 1, type: 'constant' };
                   
                   let newEntry;
                   if (baseTemplate) {
                       newEntry = { ...baseTemplate };
                       delete newEntry.uid;
                       delete newEntry.display_index;
                   } else {
                       newEntry = {
                           keys: [],
                           scan_depth: 'same_as_global',
                           case_sensitive: 'same_as_global',
                           match_whole_words: 'same_as_global',
                           use_group_scoring: 'same_as_global',
                           probability: 100,
                           exclude_recursion: false,
                           prevent_recursion: false,
                           delay_until_recursion: false,
                           filters: [],
                           automation_id: null,
                           group: '',
                           group_prioritized: false,
                           group_weight: 100,
                           sticky: null,
                           cooldown: null,
                           delay: null
                       };
                   }

                   Object.assign(newEntry, {
                       comment: segmentedKey,
                       content: '',
                       enabled: segmentedSettings.enabled,
                       type: segmentedSettings.type,
                       position: segmentedSettings.position,
                       order: segmentedSettings.order,
                       depth: segmentedSettings.position.startsWith('at_depth') ? segmentedSettings.depth : null,
                   });

                   entriesToCreate.push(newEntry);
               }

                // æ£€æŸ¥å¹¶åˆ›å»ºå°æ€»ç»“
                const targetSmallSummaryEntry = allEntries.find(e => e.comment === smallSummaryKey);
                if (!targetSmallSummaryEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === 'å°æ€»ç»“');
                    const smallSummarySettings = this.worldbookSettings?.smallSummary || { position: 'before_character_definition', order: 20, depth: 1, type: 'constant' };
                    let newEntry;
                    if (baseTemplate) {
                        newEntry = { ...baseTemplate };
                        delete newEntry.uid;
                        delete newEntry.display_index;
                    } else {
                        newEntry = { keys: [], scan_depth: 'same_as_global', case_sensitive: 'same_as_global', match_whole_words: 'same_as_global', use_group_scoring: 'same_as_global', probability: 100, exclude_recursion: false, prevent_recursion: false, delay_until_recursion: false, filters: [], automation_id: null, group: '', group_prioritized: false, group_weight: 100, sticky: null, cooldown: null, delay: null };
                    }
                    Object.assign(newEntry, {
                        comment: smallSummaryKey,
                        content: '',
                        enabled: smallSummarySettings.enabled,
                        type: smallSummarySettings.type,
                        position: smallSummarySettings.position,
                        order: smallSummarySettings.order,
                        depth: smallSummarySettings.position.startsWith('at_depth') ? smallSummarySettings.depth : null,
                    });
                    entriesToCreate.push(newEntry);
                }

                // æ£€æŸ¥å¹¶åˆ›å»ºå¤§æ€»ç»“
                const targetLargeSummaryEntry = allEntries.find(e => e.comment === largeSummaryKey);
                if (!targetLargeSummaryEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === 'å¤§æ€»ç»“');
                    const largeSummarySettings = this.worldbookSettings?.largeSummary || { position: 'before_character_definition', order: 19, depth: 1, type: 'constant' };
                    let newEntry;
                    if (baseTemplate) {
                        newEntry = { ...baseTemplate };
                        delete newEntry.uid;
                        delete newEntry.display_index;
                    } else {
                        newEntry = { keys: [], scan_depth: 'same_as_global', case_sensitive: 'same_as_global', match_whole_words: 'same_as_global', use_group_scoring: 'same_as_global', probability: 100, exclude_recursion: false, prevent_recursion: false, delay_until_recursion: false, filters: [], automation_id: null, group: '', group_prioritized: false, group_weight: 100, sticky: null, cooldown: null, delay: null };
                    }
                    Object.assign(newEntry, {
                        comment: largeSummaryKey,
                        content: '',
                        enabled: largeSummarySettings.enabled,
                        type: largeSummarySettings.type,
                        position: largeSummarySettings.position,
                        order: largeSummarySettings.order,
                        depth: largeSummarySettings.position.startsWith('at_depth') ? largeSummarySettings.depth : null,
                    });
                    entriesToCreate.push(newEntry);
                }

                if (entriesToCreate.length > 0) {
                    await TavernHelper.createLorebookEntries(bookName, entriesToCreate);
                    console.log(`[å½’å¢Ÿè‡ªåŠ¨å¼€å…³] å·²è‡ªåŠ¨åˆ›å»º ${entriesToCreate.length} ä¸ªæ–°ä¸–ç•Œä¹¦æ¡ç›®ã€‚`);
                    // é‡æ–°è·å–æ‰€æœ‰æ¡ç›®ï¼Œä»¥åŒ…å«æ–°åˆ›å»ºçš„æ¡ç›®
                    allEntries = await TavernHelper.getLorebookEntries(bookName);
                }

                const entriesToUpdate = allEntries
                    .filter(entry => entry.comment.startsWith('æœ¬ä¸–å†ç¨‹') || entry.comment.startsWith('å¾€ä¸–æ¶Ÿæ¼ª') || entry.comment.startsWith('åˆ†æ®µæ­£æ–‡') || entry.comment.startsWith('å°æ€»ç»“') || entry.comment.startsWith('å¤§æ€»ç»“') || entry.comment.startsWith('å°è¯´æ¨¡å¼'))
                    .map(entry => {
                        let shouldBeEnabled;
                        if (andDisableAll) {
                            shouldBeEnabled = false;
                        } else {
                            // æ ¹æ®comment keyä»settingsä¸­æ‰¾åˆ°å¯¹åº”çš„é…ç½®å†³å®šæ˜¯å¦å¯ç”¨
                            if (entry.comment === journeyKey) shouldBeEnabled = this.worldbookSettings.journey.enabled;
                            else if (entry.comment === pastLivesKey) shouldBeEnabled = this.worldbookSettings.pastLives.enabled;
                            else if (entry.comment === segmentedKey) shouldBeEnabled = this.worldbookSettings.segmented.enabled;
                            else if (entry.comment === smallSummaryKey) shouldBeEnabled = this.worldbookSettings.smallSummary.enabled;
                            else if (entry.comment === largeSummaryKey) shouldBeEnabled = this.worldbookSettings.largeSummary.enabled;
                            else if (entry.comment === (index > 1 ? `å°è¯´æ¨¡å¼(${index})` : 'å°è¯´æ¨¡å¼')) shouldBeEnabled = this.worldbookSettings.novel.enabled;
                            else shouldBeEnabled = false; // é»˜è®¤ä¸å¯ç”¨æœªçŸ¥æ¡ç›®
                        }

                        // åªåœ¨çŠ¶æ€éœ€è¦æ”¹å˜æ—¶æ‰åŠ å…¥æ›´æ–°é˜Ÿåˆ—
                        if (entry.enabled !== shouldBeEnabled) {
                            return { uid: entry.uid, enabled: shouldBeEnabled };
                        }
                        return null;
                    }).filter(Boolean); // è¿‡æ»¤æ‰nullçš„é¡¹

                if (entriesToUpdate.length > 0) {
                    await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
                    console.log(`[å½’å¢Ÿè‡ªåŠ¨å¼€å…³] æ›´æ–°äº† ${entriesToUpdate.length} ä¸ªä¸–ç•Œä¹¦æ¡ç›®çŠ¶æ€ã€‚`);
                }
            } catch (error) {
                console.error('[å½’å¢Ÿè‡ªåŠ¨å¼€å…³] æ›´æ–°ä¸–ç•Œä¹¦æ¡ç›®çŠ¶æ€æ—¶å‡ºé”™:', error);
            }
          },

          startAutoTogglePolling() {
              this.stopAutoTogglePolling(false); // å…ˆåœæ­¢ä»»ä½•å¯èƒ½å­˜åœ¨çš„æ—§è½®è¯¢, ä½†ä¸ç¦ç”¨æ¡ç›®
              console.log('[å½’å¢Ÿ] å¯åŠ¨ä¸–ç•Œä¹¦è‡ªåŠ¨å¼€å…³è½®è¯¢...');
              this.updateAutoToggledEntries(); // ç«‹å³æ‰§è¡Œä¸€æ¬¡
              this.autoToggleIntervalId = setInterval(() => this.updateAutoToggledEntries(), 5000); // æ¯5ç§’è½®è¯¢ä¸€æ¬¡
          },

          stopAutoTogglePolling(disableEntries = true) {
              if (this.autoToggleIntervalId) {
                  console.log('[å½’å¢Ÿ] åœæ­¢ä¸–ç•Œä¹¦è‡ªåŠ¨å¼€å…³è½®è¯¢ã€‚');
                  clearInterval(this.autoToggleIntervalId);
                  this.autoToggleIntervalId = null;
              }
              if (disableEntries) {
                  // åœæ­¢æ—¶ï¼Œç¡®ä¿æ‰€æœ‰ç›¸å…³æ¡ç›®éƒ½è¢«ç¦ç”¨
                  this.updateAutoToggledEntries(true);
              }
          },
// ===ä¸–ç•Œä¹¦é«˜çº§è®¾ç½®/è‡ªåŠ¨å¼€å…³/åˆ›å»ºæ¨¡å—ç»“æŸ===   




// ===èƒŒæ™¯å›¾åº”ç”¨æ¨¡å—å¼€å§‹===
           applyRandomBackground() {
             const container = document.querySelector('.guixu-root-container');
             if (!container) {
               console.warn('[å½’å¢ŸèƒŒæ™¯] æ‰¾ä¸åˆ°æ ¹å®¹å™¨ï¼Œæ— æ³•åº”ç”¨èƒŒæ™¯å›¾');
               return;
             }
             console.log('[å½’å¢ŸèƒŒæ™¯] åº”ç”¨èƒŒæ™¯å›¾ï¼Œæ¨¡å¼:', this.backgroundMode, 'å›¾ç‰‡æ•°é‡:', this.backgroundImages.length);
             if (this.backgroundImages.length > 0) {
               let backgroundToApply;
               
               if (this.backgroundMode === 'fixed' && this.selectedBackgroundId) {
// 1.ã€å›ºå®šæ¨¡å¼ï¼šä½¿ç”¨é€‰ä¸­çš„èƒŒæ™¯å›¾ã€‘
                 backgroundToApply = this.backgroundImages.find(bg => bg.id === this.selectedBackgroundId);
               } else if (this.backgroundMode === 'random') {
// 2.ã€éšæœºæ¨¡å¼ï¼šéšæœºé€‰æ‹©ä¸€å¼ èƒŒæ™¯å›¾ã€‘
                 backgroundToApply = this.backgroundImages[Math.floor(Math.random() * this.backgroundImages.length)];
               }
               if (backgroundToApply && backgroundToApply.dataUrl) {
                 const isObjectUrl = backgroundToApply.dataUrl.startsWith('blob:');
                 const isUrlImage = backgroundToApply.isUrlImage;                 
                 if (isObjectUrl) {
                   const img = new Image();
                   img.onload = () => {
                     container.style.backgroundImage = `url('${backgroundToApply.dataUrl}')`;
                   };
                   img.onerror = () => {
                     this.handleInvalidBackground(backgroundToApply);
                   };
                   img.src = backgroundToApply.dataUrl;
                 } else if (isUrlImage) {
                   const img = new Image();
                   img.onload = () => {
                     container.style.backgroundImage = `url('${backgroundToApply.dataUrl}')`;
                   };
                   img.onerror = () => {
                     this.handleInvalidBackground(backgroundToApply);
                   };
                   img.crossOrigin = 'anonymous';
                   img.src = backgroundToApply.dataUrl;
                 } else {
                   container.style.backgroundImage = `url('${backgroundToApply.dataUrl}')`;
                 }
                 return;
               }
             }

             // å¦‚æœæ²¡æœ‰ç”¨æˆ·èƒŒæ™¯å›¾ï¼Œä½¿ç”¨é»˜è®¤èƒŒæ™¯
             const defaultBackgrounds = [
               'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png',
               'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png',
             ];
             const bgUrl = defaultBackgrounds[Math.floor(Math.random() * defaultBackgrounds.length)];
             container.style.backgroundImage = `url('${bgUrl}')`;
           },

           // æ–°å¢ï¼šå¤„ç†æ— æ•ˆèƒŒæ™¯çš„å‡½æ•°
           handleInvalidBackground(invalidBackground) {
             const bgType = invalidBackground.isUrlImage ? 'å¤–é“¾å›¾ç‰‡' :
                           invalidBackground.dataUrl.startsWith('blob:') ? 'Object URLå›¾ç‰‡' : 'æœ¬åœ°å›¾ç‰‡';
             console.warn(`[å½’å¢ŸèƒŒæ™¯] å¤„ç†æ— æ•ˆèƒŒæ™¯: ${invalidBackground.name} (${bgType})`);
             
             // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„æç¤ºä¿¡æ¯
             if (invalidBackground.isUrlImage) {
               this.showTemporaryMessage(`å¤–é“¾å›¾ç‰‡"${invalidBackground.name}"æ— æ³•è®¿é—®ï¼Œå·²è‡ªåŠ¨ç§»é™¤`, 4000);
             }
             
             // ä»èƒŒæ™¯åˆ—è¡¨ä¸­ç§»é™¤æ— æ•ˆèƒŒæ™¯
             const index = this.backgroundImages.findIndex(bg => bg.id === invalidBackground.id);
             if (index !== -1) {
               this.backgroundImages.splice(index, 1);
               this.saveBackgroundSettings();
               console.log(`[å½’å¢ŸèƒŒæ™¯] å·²ç§»é™¤æ— æ•ˆèƒŒæ™¯: ${invalidBackground.name}`);
               
               // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é€‰ä¸­çš„èƒŒæ™¯ï¼Œæ¸…é™¤é€‰æ‹©
               if (this.selectedBackgroundId === invalidBackground.id) {
                 this.selectedBackgroundId = null;
                 this.backgroundMode = 'random'; // åˆ‡æ¢åˆ°éšæœºæ¨¡å¼
                 this.saveBackgroundSettings();
               }
               if (this.backgroundImages.length > 0) {
                 this.applyRandomBackground();
               } else {
                 const container = document.querySelector('.guixu-root-container');
                 if (container) {
                   const defaultBackgrounds = [
                     'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png',
                     'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png',
                   ];
                   const bgUrl = defaultBackgrounds[Math.floor(Math.random() * defaultBackgrounds.length)];
                   container.style.backgroundImage = `url('${bgUrl}')`;
                 }
               }
               
               // åˆ·æ–°èƒŒæ™¯åˆ—è¡¨æ˜¾ç¤º
               if (document.getElementById('background-settings-modal') &&
                   document.getElementById('background-settings-modal').style.display === 'flex') {
                 this.renderBackgroundList();
                 this.updateBackgroundModeUI(); // æ›´æ–°æ¨¡å¼UI
               }
             }
           },

          // åˆå§‹åŒ–èƒŒæ™¯å›¾ç³»ç»Ÿ
          async initBackgroundSystem() {
            console.log('[å½’å¢ŸèƒŒæ™¯] åˆå§‹åŒ–èƒŒæ™¯å›¾ç³»ç»Ÿ...');
            
          
            this.loadBackgroundSettings();  // èƒŒæ™¯å›¾è®¾ç½®
            this.loadOpacitySettings();// é€æ˜åº¦è®¾ç½®
            // é¢„è®¾èƒŒæ™¯å›¾
            if (this.backgroundImages.length === 0) {
              this.backgroundImages = [
                {
                  id: 'preset1',
                  name: 'ä»™å¢ƒäº‘æµ·',
                  dataUrl: 'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png',
                  isPreset: true
                },
                {
                  id: 'preset2',
                  name: 'å¤é£å±±æ°´',
                  dataUrl: 'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png',
                  isPreset: true
                }
              ];
              this.saveBackgroundSettings();
            }
            // åº”ç”¨èƒŒæ™¯å›¾
            this.applyRandomBackground();
          },
// ===èƒŒæ™¯å›¾åº”ç”¨æ¨¡å—ç»“æŸ===



// ===æç¤ºè¯æ„å»ºå’Œç”Ÿæˆå›å¤æ¨¡å—å¼€å§‹===


// 1.ã€å‘é€ä¿å­˜è¾“å…¥å†å²ã€‘
          async executeQuickSend() {
            const input = document.getElementById('quick-send-input');
            if (!input) return;
            const userMessage = input.value.trim();

            if (userMessage) {
                this.saveInputToHistory(userMessage); // å‘é€æ—¶ä¿å­˜åˆ°å†å²
            }

            await this.handleAction(userMessage);
          },

          // å¤„ç†æ‰€æœ‰åŠ¨ä½œçš„æ ¸å¿ƒå‡½æ•°

          async handleAction(userMessage = '') {
              const gameTextDisplay = document.getElementById('game-text-display');
              if (gameTextDisplay) {
                  this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
              }
              const thinkingDisplay = document.getElementById('thinking-content-display');
              if (thinkingDisplay) {
                  thinkingDisplay.style.display = 'none';
              }
              this.lastExtractedThinking = null;
              this.saveLastThinking(); // æ¸…é™¤æŒä¹…åŒ–å­˜å‚¨
              this.updateThinkingButtonVisibility();
              this.updateCurrentLifeButtonVisibility(); // æ–°å¢:æ›´æ–°æœ¬ä¸–å†ç¨‹æŒ‰é’®æ˜¾ç¤º
              this.updatePastLivesButtonVisibility(); // æ–°å¢:æ›´æ–°å¾€ä¸–æ¶Ÿæ¼ªæŒ‰é’®æ˜¾ç¤º
              document.getElementById('action-options-container').innerHTML = ''; // éšè—è¡ŒåŠ¨é€‰é¡¹
              this.hideVariableChangesReminder(); // éšè—å˜é‡æ”¹å˜æé†’
              this.isStreamingGametxt = false; // é‡ç½®æµå¼çŠ¶æ€

              // éšè—ä¸Šä¸€æ¬¡çš„ç« èŠ‚æ ‡é¢˜å’Œå†å²æ­£æ–‡
              const titleContainer = document.getElementById('current-chapter-title');
              if (titleContainer) {
                  titleContainer.style.display = 'none';
              }
              const historicalTextContainer = document.getElementById('historical-text-container');
              if (historicalTextContainer) {
                  historicalTextContainer.style.display = 'none';
              }

              // æç®€åŒ–å¤„ç†ï¼šç›´æ¥æ‹¼æ¥æ‰€æœ‰æŒ‡ä»¤æ–‡æœ¬
              let commandText = '';
              if (this.pendingActions.length > 0) {
                  commandText += '[æœ¬è½®è¡ŒåŠ¨æŒ‡ä»¤]\n';
                  this.pendingActions.forEach(command => {
                      if (command) {
                          commandText += command + '\n';
                      }
                  });
                  // æ¸…ç©ºæŒ‡ä»¤é˜Ÿåˆ—
                  this.pendingActions = [];
              }

              if (!userMessage && !commandText) {
                  this.showTemporaryMessage('è¯·è¾“å…¥å›å¤æˆ–æ·»åŠ æŒ‡ä»¤åå‘é€ã€‚');
                  return;
              }

// 2. ã€æ£€æŸ¥ç”Ÿæˆæ¨¡å¼å¹¶åˆ†å‘ã€‘
              const generationMode = this.generationMode || 'once';
              console.log(`[å½’å¢Ÿ] å½“å‰ç”Ÿæˆæ¨¡å¼: ${generationMode}`);

              if (generationMode === 'stepwise') {
                  // æ­¥è¿›å¼å˜é‡æ›´æ–°æ¨¡å¼
                  await this.handleStepwiseGeneration(userMessage, commandText);
              } else {
                  // ä¸€æ¬¡æ€§ç”Ÿæˆæ¨¡å¼ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
                  await this.handleOnceGeneration(userMessage, commandText);
              }
           },

           // ä¸€æ¬¡æ€§ç”Ÿæˆæ¨¡å¼å¤„ç†å‡½æ•°
           async handleOnceGeneration(userMessage, commandText) {
              console.log('[å½’å¢Ÿ] æ‰§è¡Œä¸€æ¬¡æ€§ç”Ÿæˆæ¨¡å¼');

// 2. ã€æ„å»ºæç¤ºè¯ã€‘
              const generateConfig = {
                  injects: [],
                  should_stream: this.isStreamingEnabled, // ä¿®æ”¹ï¼šä½¿ç”¨çŠ¶æ€å˜é‡
              };

              // å°†ç”¨æˆ·è¾“å…¥å’ŒæŒ‡ä»¤åˆå¹¶ä¸ºä¸€ä¸ª user-role æ³¨å…¥
              let combinedContent = '';
              if (commandText) {
                  combinedContent += commandText + '\n'; // æŒ‡ä»¤åœ¨å‰
              }
              if (userMessage) {
                  combinedContent += `<è¡ŒåŠ¨é€‰æ‹©>\n${userMessage}\n</è¡ŒåŠ¨é€‰æ‹©>`;
              }

              if (combinedContent) {
                  generateConfig.injects.push({
                      role: 'user',
                      content: combinedContent,
                      position: 'in_chat', // æ’å…¥åˆ°èŠå¤©è®°å½•ä¸­
                      depth: 0,
                      should_scan: true, // å…è®¸æ‰«æå…³é”®å­—
                  });
              }

              this.lastSentPrompt = combinedContent; // æ›´æ–°è°ƒè¯•ä¿¡æ¯


// æ§åˆ¶å°å‘é€å†…å®¹æŠ¥å‘Š
              console.group('[å½’å¢Ÿ] æœ¬æ¬¡å‘é€å†…å®¹æŠ¥å‘Š');
              console.log('å‘é€æ—¶é—´:', new Date().toLocaleString('zh-CN'));
              console.log('ç”Ÿæˆæ¨¡å¼:', 'ä¸€æ¬¡æ€§ç”Ÿæˆ');
              console.log('æµå¼æ¨¡å¼:', this.isStreamingEnabled ? 'å¼€å¯' : 'å…³é—­');
              
              if (commandText) {
                  console.log('âš¡ æŒ‡ä»¤å†…å®¹:');
                  console.log(commandText);
              }
              
              if (userMessage) {
                  console.log('ğŸ’¬ ç”¨æˆ·è¾“å…¥:');
                  console.log(userMessage);
              }
              
              console.log('ğŸ“‹ å®Œæ•´å‘é€å†…å®¹:');
              console.log(combinedContent);
              
              console.log('ğŸ”§ GenerateConfig:');
              console.log(generateConfig);
              console.groupEnd();
              
              this.showWaitingMessage();

              try {
// 3. ã€è°ƒç”¨ generateï¼Œåç»­å¤„ç†ç§»è‡³ handleStreamEndã€‘
                  this.generationStep = 0; // é‡ç½®ç”Ÿæˆæ­¥éª¤
                  await TavernHelper.generate(generateConfig);
                  
              } catch (error) {
                  console.error('å¤„ç†åŠ¨ä½œæ—¶å‡ºé”™:', error);
                  this.showTemporaryMessage(`å’Œä¼Ÿå¤§æ¢¦æ˜Ÿæ²Ÿé€šå¤±è´¥: ${error.message}`);
                  this.hideWaitingMessage(); // ç¡®ä¿éšè—ç­‰å¾…æ¶ˆæ¯
              }
           },

           // æ­¥è¿›å¼å˜é‡æ›´æ–°æ¨¡å¼å¤„ç†å‡½æ•°
           async handleStepwiseGeneration(userMessage, commandText) {
              console.log('[å½’å¢Ÿ] æ‰§è¡Œæ­¥è¿›å¼å˜é‡æ›´æ–°æ¨¡å¼');
              
              // æ­¥éª¤1ï¼šç”Ÿæˆä¸»å†…å®¹ï¼ˆä¸å«å˜é‡ï¼‰
              this.generationStep = 1;
              this.cachedMainContent = null;
              
              // æ˜¾ç¤ºç­‰å¾…æ¶ˆæ¯
              this.showWaitingMessage();
              
              // ç¬¬ä¸€æ­¥åªå‘é€ã€onlyå‰§æƒ…ã€‘å’Œæ— å‰ç¼€çš„æ¡ç›®
              this.isStepwiseFirstStep = true;
              this.isStepwiseSecondStep = false;
              const generateConfig = {
                  injects: [],
                  should_stream: this.isStreamingEnabled,
              };

              // æ„å»ºä¸»å†…å®¹ç”Ÿæˆçš„prompt
              let combinedContent = '';
              if (commandText) {
                  combinedContent += commandText + '\n';
              }
              if (userMessage) {
                  combinedContent += `<è¡ŒåŠ¨é€‰æ‹©>\n${userMessage}\n</è¡ŒåŠ¨é€‰æ‹©>`;
              }
              if (combinedContent) {
                  generateConfig.injects.push({
                      role: 'user',
                      content: combinedContent,
                      position: 'in_chat',
                      depth: 0,
                      should_scan: true,
                  });
              }

              this.lastSentPrompt = combinedContent;

              console.group('[å½’å¢Ÿ] æ­¥è¿›å¼ç”Ÿæˆ - ç¬¬ä¸€æ­¥');
              console.log('å‘é€æ—¶é—´:', new Date().toLocaleString('zh-CN'));
              console.log('ç”Ÿæˆæ¨¡å¼:', 'æ­¥è¿›å¼å˜é‡æ›´æ–° - æ­¥éª¤1ï¼ˆä¸»å†…å®¹ï¼‰');
              console.log('æµå¼æ¨¡å¼:', this.isStreamingEnabled ? 'å¼€å¯' : 'å…³é—­');
              console.log('ğŸ“‹ å®Œæ•´å‘é€å†…å®¹:');
              console.log(combinedContent);
              console.groupEnd();
              try {
                  await TavernHelper.generate(generateConfig);
                  // ç¬¬äºŒæ­¥å°†åœ¨handleStreamEndä¸­è§¦å‘
              } catch (error) {
                  console.error('[å½’å¢Ÿ] æ­¥è¿›å¼ç”Ÿæˆç¬¬ä¸€æ­¥å‡ºé”™:', error);
                  this.showTemporaryMessage(`ç”Ÿæˆä¸»å†…å®¹å¤±è´¥: ${error.message}`);
                  this.hideWaitingMessage();
                  this.generationStep = 0;
              }
           },

          // ===æ­¥è¿›å¼æ–‡æœ¬å¤„ç†æ¨¡å—å¼€å§‹===

          // ã€æ¥å£å‡½æ•°ã€‘å¤„ç†ç¬¬ä¸€æ­¥å®Œæ•´æ–‡æœ¬ï¼Œæå–éœ€è¦å‘é€ç»™ç¬¬äºŒæ­¥çš„å†…å®¹
          _processFirstStepTextForSecondStep(firstStepFullText) {
              const gametxtContent = this._extractLastTagContent('gametxt', firstStepFullText);
              if (gametxtContent) {
                  // å°†æå–çš„å†…å®¹åŒ…è£¹åœ¨<æœ¬æ¬¡æ­£æ–‡>æ ‡ç­¾ä¸­ï¼Œå¹¶æ·»åŠ æç¤ºæ–‡å­—
                  return `éœ€è¦æ ¹æ®ä»¥ä¸‹æ–‡æœ¬ï¼Œè¿›è¡Œå˜é‡æ›´æ–°çš„æŒ‡ä»¤ï¼š\n\n<æœ¬æ¬¡æ­£æ–‡>\n${gametxtContent}\n</æœ¬æ¬¡æ­£æ–‡>`;
              }
              // å¦‚æœæ²¡æœ‰gametxtæ ‡ç­¾ï¼Œè¿”å›ç©ºæ–‡æœ¬
              return '';
          },

          // ã€æ¥å£å‡½æ•°ã€‘å¤„ç†ç¬¬äºŒæ­¥è¿”å›çš„æ–‡æœ¬ï¼Œæå–éœ€è¦åˆå¹¶çš„å†…å®¹
          _processSecondStepResponse(secondStepFullText) {
               
              const updateVarContent = this._extractLastTagContent('UpdateVariable', secondStepFullText);
              if (updateVarContent) {
                  return '<UpdateVariable>\n' + updateVarContent + '\n</UpdateVariable>';
              }
              // å¦‚æœæ²¡æœ‰UpdateVariableæ ‡ç­¾ï¼Œè¿”å›ç©ºæ–‡æœ¬
              return '';
          },
          
           //ã€æ¥å£å‡½æ•°ã€‘åˆå¹¶ç¬¬ä¸€æ­¥å’Œç¬¬äºŒæ­¥çš„æ–‡æœ¬
          _mergeStepwiseTexts(firstStepFullText, processedSecondStepText) {
              return firstStepFullText + '\n\n' + processedSecondStepText;
          },

          async generateVariablesStep(mainContent) {
              this.generationStep = 2;
              this.isStepwiseAppendMode = true;
              this.isStepwiseFirstStep = false;
              this.isStepwiseSecondStep = true;
              this.updateWaitingMessage('åˆ†æ­¥å˜é‡æ›´æ–°ing');
              // å¤„ç†ç¬¬ä¸€æ­¥æ–‡æœ¬ï¼Œæå–éœ€è¦å‘é€çš„å†…å®¹
              const processedContent = this._processFirstStepTextForSecondStep(mainContent);
              console.log('[å½’å¢Ÿ] ğŸ“‹ å¤„ç†åå‘é€ç»™ç¬¬äºŒæ­¥çš„å†…å®¹é¢„è§ˆ:', processedContent);

              const config = this.stepwiseConfig || {};
              const useCustomApi = (config.modelSource === 'è‡ªå®šä¹‰');
              const auxSettings = this.auxModelSettings;
              const useAuxModel = useCustomApi && auxSettings && auxSettings.isEnabled;
              const generateConfig = {
                  user_input: processedContent,
                  should_stream: useAuxModel ? auxSettings.isStreaming : this.isStreamingEnabled,
                  injects: [{ role: 'user', content: '', position: 'in_chat', depth: 0, should_scan: true }],
                  max_chat_history: 0,  // ç¬¬äºŒæ­¥ä¸åŒ…å«èŠå¤©å†å²
              };

              if (useAuxModel && auxSettings.apiUrl && auxSettings.modelName) {
                  generateConfig.custom_api = {
                      apiurl: auxSettings.apiUrl,
                      key: auxSettings.apiKey,
                      model: auxSettings.modelName,
                      source: auxSettings.source || 'openai'
                  };
              }

              console.groupCollapsed('[å½’å¢Ÿ] ğŸ“Š æ­¥è¿›å¼ç”Ÿæˆ - ç¬¬äºŒæ­¥ï¼ˆå˜é‡ç”Ÿæˆï¼‰');
              console.log('ğŸ”Œ ä½¿ç”¨API:', useAuxModel ? 'ç¬¬äºŒAPI' : 'ä¸»æ’å¤´');    
              console.groupEnd();
              
              try {
                  await TavernHelper.generate(generateConfig);
              } catch (error) {
                  console.error('[å½’å¢Ÿ] âŒ æ­¥è¿›å¼ç”Ÿæˆç¬¬äºŒæ­¥è°ƒç”¨å‡ºé”™:', error);
                  this.showTemporaryMessage(`ç”Ÿæˆå˜é‡å¤±è´¥: ${error.message}`);
                  this.hideWaitingMessage();
                  this.generationStep = 0;
              }
           },

          // ===æ­¥è¿›å¼æ–‡æœ¬å¤„ç†æ¨¡å—ç»“æŸ===


// ===æç¤ºè¯æ„å»ºå’Œç”Ÿæˆå›å¤æ¨¡å—ç»“æŸ===




// ===æŒ‡ä»¤ä¸­å¿ƒæ¨¡å—å¼€å§‹===



           // å¿«é€ŸæŒ‡ä»¤åˆ—è¡¨ç›¸å…³å‡½æ•°
           toggleQuickCommands() {
             const popup = document.getElementById('quick-command-popup');
            if (!popup) return;

            if (popup.style.display === 'block') {
              this.hideQuickCommands();
            } else {
              this.showQuickCommands();
            }
          },

          // æç®€åŒ–æŒ‡ä»¤ä¸­å¿ƒï¼šç»Ÿä¸€çš„æ·»åŠ æŒ‡ä»¤æ¥å£
          addCommand(commandText) {
              if (!commandText || typeof commandText !== 'string') {
                  console.warn('æŒ‡ä»¤æ–‡æœ¬ä¸èƒ½ä¸ºç©ºæˆ–éå­—ç¬¦ä¸²ç±»å‹');
                  return;
              }              
              this.pendingActions.push(commandText.trim());
              this.savePendingActions();
          },

          // å…¼å®¹æ€§ï¼šæ—§çš„æ ¼å¼åŒ–å‡½æ•°ç°åœ¨ç›´æ¥è¿”å›æ–‡æœ¬
          _formatActionText(cmd) {
              // å¦‚æœå·²ç»æ˜¯å­—ç¬¦ä¸²ï¼Œç›´æ¥è¿”å›
              if (typeof cmd === 'string') {
                  return cmd;
              }
              if (!cmd) return '';
              if (cmd.text) return cmd.text;
              if (cmd.command) return cmd.command;
              switch (cmd.action) {
                  case 'equip': return `è£…å¤‡ [${cmd.itemName}] åˆ° [${cmd.category}] æ§½ä½ã€‚`;
                  case 'unequip': return `å¸ä¸‹ [${cmd.itemName}] ä» [${cmd.category}] æ§½ä½ã€‚`;
                  case 'use': return `ä½¿ç”¨ ${cmd.quantity} ä¸ª [${cmd.itemName}]ã€‚`;
                  case 'discard': return `ä¸¢å¼ƒ ${cmd.quantity ? cmd.quantity + ' ä¸ª ' : ''}[${cmd.itemName}]ã€‚`;
                  case 'travel': return `[è¡ŒåŠ¨] "æˆ‘"åŠ¨èº«å‰å¾€ã€${cmd.locationName}ã€‘ã€‚`;
                  case 'do_action': return cmd.text || '[è¡ŒåŠ¨]';
                  case 'variable_update': return cmd.command || cmd.text || '[å˜é‡æ›´æ–°]';
                  case 'send_as_is': return cmd.command || cmd.text || '[æŒ‡ä»¤]';
                  case 'join_world': return `[è§’è‰²åŠ å…¥] ${cmd.itemName}`;
                  default: return `[æŒ‡ä»¤] ${cmd.action || 'æœªçŸ¥æ“ä½œ'}`;
              }
          },
          showQuickCommands() {
              const popup = document.getElementById('quick-command-popup');
              if (!popup) return;
              if (this.pendingActions.length === 0) {
                  popup.innerHTML = '<div class="quick-command-empty">æš‚æ— å¾…æ‰§è¡Œçš„æŒ‡ä»¤</div>';
              } else {
                  let listHtml = '<ul class="quick-command-list">';
                  this.pendingActions.forEach(commandText => {
                      if (commandText) {
                          listHtml += `<li class="quick-command-item">${commandText}</li>`;
                      }
                  });
                  listHtml += '</ul>';
                  popup.innerHTML = listHtml;
              }
              popup.style.display = 'block';
          },

          hideQuickCommands() {
            const popup = document.getElementById('quick-command-popup');
            if (popup) {
              popup.style.display = 'none';
            }
          },
// ===æŒ‡ä»¤ä¸­å¿ƒæ¨¡å—ç»“æŸ===


      

// ===mvuæ•°æ®ä¿®å¤æ¨¡å—å¼€å§‹===        
// æ·±åº¦æ£€æµ‹å’Œä¿®å¤MVUçŠ¶æ€æ•°æ®
          _deepFixMvuState(mvuState) {
              if (!mvuState || typeof mvuState !== 'object') {
                  return mvuState;
              }              
          },

// å®‰å…¨çš„æ•°æ®åŠ è½½å’Œä¿®å¤
          _safeLoadMvuData(rawData) {
              if (!rawData) return null;              
              try {
                  // é¦–å…ˆè¿›è¡Œæ·±åº¦ä¿®å¤
                  const fixedData = this._deepFixMvuState(rawData);                  
                  // éªŒè¯å…³é”®æ•°æ®ç»“æ„
                  if (fixedData && fixedData.stat_data) {
                      return fixedData;
                  } else {
                      return rawData;
                  }
              } catch (error) {
                  return rawData;
              }
          },

// ===mvuæ•°æ®ä¿®å¤æ¨¡å—ç»“æŸ===


// ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«
// ===å‰ç«¯MVUå¤„ç†å™¨å¼€å§‹===
// _applyUpdateFallback å…³é”®mvuå¤„ç†å‡½æ•°
// å‰ç«¯å®æ—¶ä¿®æ”¹mvuçš„å…³é”®
          _applyUpdateFallback(script, currentMvuState) {
              if (!script || !currentMvuState) return null;
              
              const newState = currentMvuState; // ç›´æ¥ä¿®æ”¹ï¼Œç§»é™¤æ·±æ‹·è´
              let modified = false;

              const commands = this._extractCommands(script);

              for (const command of commands) {
                  try {
                      const path = this._trimQuotes(command.args[0]);
                      
                      switch (command.command) {
                          case 'set': {
                              const newValueStr = command.args.length >= 2 ? command.args[1] : undefined;
                              if(newValueStr === undefined) continue;
                              let newValue = this._parseCommandValue(newValueStr);
                              
                              if (newValue instanceof Date) newValue = newValue.toISOString();

                              _.set(newState.stat_data, path, newValue);
                              modified = true;
                              break;
                          }
                          case 'add': {
                              const value = _.get(newState.stat_data, path);
                              const delta = this._parseCommandValue(command.args[1]);
                              if (typeof value === 'number' && typeof delta === 'number') {
                                  _.set(newState.stat_data, path, value + delta);
                                  modified = true;
                              }
                              break;
                          }
                          case 'remove': {
                              _.unset(newState.stat_data, path);
                              modified = true;
                              break;
                          }
                          case 'assign':
                          case 'insert': {
                              if (command.args.length === 2) {
                                  // Handles _.assign('path', value)
                                  const valueToAssign = this._parseCommandValue(command.args[1]);
                                  const parentCollection = _.get(newState.stat_data, path);

                                  // Special handling for our [data_array, "description"] structure
                                  if (Array.isArray(parentCollection) && parentCollection.length === 2 && Array.isArray(parentCollection[0]) && typeof parentCollection[1] === 'string') {
                                      const innerArray = parentCollection[0];
                                      const description = parentCollection[1];
                                      const newInnerArray = innerArray.concat(Array.isArray(valueToAssign) ? valueToAssign : [valueToAssign]);
                                      const newParentArray = [newInnerArray, description];
                                      _.set(newState.stat_data, path, newParentArray);
                                      modified = true;
                                  } else if (Array.isArray(parentCollection)) {
                                      // Standard immutable update for regular arrays
                                      const newCollection = parentCollection.concat(Array.isArray(valueToAssign) ? valueToAssign : [valueToAssign]);
                                      _.set(newState.stat_data, path, newCollection);
                                      modified = true;
                                  } else if (_.isObject(parentCollection)) {
                                      // ä¿®å¤ï¼šä½¿ç”¨å®‰å…¨çš„å¯¹è±¡åˆå¹¶ï¼Œé¿å…é‡å¤åµŒå¥—
                                      const safeValueToAssign = this._sanitizeAssignValue(valueToAssign, path);
                                      const mergedObject = this._safeMergeObjects(parentCollection, safeValueToAssign, path);
                                      _.set(newState.stat_data, path, mergedObject);
                                      modified = true;
                                  } else {
                                      // If path doesn't exist, just set it
                                      _.set(newState.stat_data, path, valueToAssign);
                                      modified = true;
                                  }
                              } else if (command.args.length >= 3) {
                                  // Handles _.assign('path', key, value)
                                  const keyOrIndex = this._parseCommandValue(command.args[1]);
                                  const valueToAssign = this._parseCommandValue(command.args[2]);
                                  let collection = _.get(newState.stat_data, path);

                                  if (Array.isArray(collection)) {
                                      if (typeof keyOrIndex === 'number') {
                                          const newCollection = [...collection]; // Create a shallow copy for immutability
                                          newCollection.splice(keyOrIndex, 0, valueToAssign);
                                          _.set(newState.stat_data, path, newCollection);
                                          modified = true;
                                      }
                                  } else if (_.isObject(collection)) {
                                      // ä¿®å¤ï¼šä½¿ç”¨å®‰å…¨çš„é”®å€¼è®¾ç½®ï¼Œé¿å…é‡å¤åµŒå¥—
                                      const safeValue = this._sanitizeAssignValue(valueToAssign, `${path}.${keyOrIndex}`);
                                      _.set(collection, String(keyOrIndex), safeValue);
                                      modified = true;
                                  } else {
                                      // If collection doesn't exist, create it
                                      const newCollection = {};
                                      const safeValue = this._sanitizeAssignValue(valueToAssign, `${path}.${keyOrIndex}`);
                                      _.set(newCollection, String(keyOrIndex), safeValue);
                                      _.set(newState.stat_data, path, newCollection);
                                      modified = true;
                                  }
                              }
                              break;
                          }
                      }
                  } catch (e) {
                      console.error(`[å½’å¢Ÿ-å¤‡ç”¨æ–¹æ¡ˆ] å¤„ç†æŒ‡ä»¤å¤±è´¥:`, command, e);
                  }
              }

              return modified ? newState : null;
          },

          _trimQuotes(str) {
              if (typeof str !== 'string') return str;
              return str.replace(/^['"` ]*(.*?)['"` ]*$/, '$1');
          },
          
          _parseCommandValue(valStr) {
              if (typeof valStr !== 'string') return valStr;
              const trimmed = valStr.trim();
              if (trimmed === 'true') return true;
              if (trimmed === 'false') return false;
              if (trimmed === 'null') return null;
              if (trimmed === 'undefined') return undefined;
              try {
                  return JSON.parse(trimmed);
              } catch (e) {
                  if ((trimmed.startsWith('{') && trimmed.endsWith('}')) || (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
                      try {
                          return new Function(`return ${trimmed};`)();
                      } catch (err) { /* continue */ }
                  }
              }
              return this._trimQuotes(valStr);
          },

          _extractCommands(inputText) {
              const results = [];
              let i = 0;
              while (i < inputText.length) {
                  const match = inputText.substring(i).match(/_\.(set|assign|remove|add|insert)\(/);
                  if (!match || match.index === undefined) break;
                  
                  const commandType = match[1];
                  const start = i + match.index;
                  const openParen = start + match[0].length;
                  const closeParen = this._findMatchingCloseParen(inputText, openParen);
                  
                  if (closeParen === -1) {
                      i = openParen;
                      continue;
                  }
                  
                  let endPos = closeParen + 1;
                  if (endPos >= inputText.length || inputText[endPos] !== ';') {
                      i = closeParen + 1;
                      continue;
                  }
                  endPos++;
                  
                  const paramsString = inputText.substring(openParen, closeParen);
                  const params = this._parseParameters(paramsString);
                  
                  results.push({ command: commandType, args: params });
                  i = endPos;
              }
              return results;
          },

          _findMatchingCloseParen(str, startPos) {
              let parenCount = 1;
              let inQuote = false;
              let quoteChar = '';
              for (let i = startPos; i < str.length; i++) {
                  const char = str[i];
                  if ((char === '"' || char === "'" || char === '`') && str[i - 1] !== '\\') {
                      if (!inQuote) {
                          inQuote = true;
                          quoteChar = char;
                      } else if (char === quoteChar) {
                          inQuote = false;
                      }
                  }
                  if (!inQuote) {
                      if (char === '(') parenCount++;
                      else if (char === ')') {
                          parenCount--;
                          if (parenCount === 0) return i;
                      }
                  }
              }
              return -1;
          },

          _parseParameters(paramsString) {
              const params = [];
              let currentParam = '';
              let inQuote = false;
              let quoteChar = '';
              let bracketCount = 0;
              let braceCount = 0;
              let parenCount = 0;
              for (let i = 0; i < paramsString.length; i++) {
                  const char = paramsString[i];
                  if ((char === '"' || char === "'" || char === '`') && (i === 0 || paramsString[i - 1] !== '\\')) {
                      if (!inQuote) {
                          inQuote = true;
                          quoteChar = char;
                      } else if (char === quoteChar) {
                          inQuote = false;
                      }
                  }
                  if (!inQuote) {
                      if (char === '(') parenCount++;
                      if (char === ')') parenCount--;
                      if (char === '[') bracketCount++;
                      if (char === ']') bracketCount--;
                      if (char === '{') braceCount++;
                      if (char === '}') braceCount--;
                  }
                  if (char === ',' && !inQuote && parenCount === 0 && bracketCount === 0 && braceCount === 0) {
                      params.push(currentParam.trim());
                      currentParam = '';
                      continue;
                  }
                  currentParam += char;
              }
              if (currentParam.trim()) {
                  params.push(currentParam.trim());
              }
              return params;
          },
// ===å‰ç«¯MVUå¤„ç†å™¨ç»“æŸ===
// ã€HTMLè½¬ä¹‰è¾…åŠ©å‡½æ•°ã€‘
          escapeHtml(text) {
            if (typeof text !== 'string') return text;
            return text
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
          },




// ===æ­£æ–‡/æ–‡æœ¬æå–å’Œå¤„ç†æ¨¡å—å¼€å§‹===
// ä¼˜å…ˆæå– <gametxt> çš„å†…å®¹
// æŸ“è‰²çš„é€»è¾‘å®Œå…¨äº¤ç»™ formatMessageContent å¤„ç†ã€‚
// ç§»é™¤HTMLæ³¨é‡Šï¼Œä¿®å¤å› æ³¨é‡Šå¯¼è‡´çš„å­˜æ¡£é€»è¾‘å´©æºƒé—®é¢˜

          _getDisplayText(aiResponse) {
            try {
              if (!aiResponse || typeof aiResponse !== 'string') return '';
              
              const gameText = this._extractLastTagContent('gametxt', aiResponse);
              if (gameText !== null) {

                  return gameText.replace(/<!--[\s\S]*?-->/g, '').trim();
              }
              return aiResponse.trim();
            } catch (e) {
              console.error("è§£ææ˜¾ç¤ºæ–‡æœ¬æ—¶å‡ºé”™:", e, "åŸå§‹è¾“å…¥:", aiResponse);
              return "[æ‘˜è¦è§£æå¤±è´¥]";
            }
          },

// ã€å·¥å…·ï¼šå¯é‡ç”¨çš„ã€å¥å£®çš„æ ‡ç­¾æå–å‡½æ•°ã€‘
           _extractLastTagContent(tagName, text, ignoreCase = false) {
               if (!text || typeof text !== 'string') return null;
               const flags = ignoreCase ? 'gi' : 'g';
               const regex = new RegExp(`<${tagName}>([\\s\\S]*?)<\\/${tagName}>`, flags);             
               const matches = [...text.matchAll(regex)];             
               if (matches.length > 0) {
                   return matches[matches.length - 1][1].trim();
               }
               return null;
           },



// ===æ­£æ–‡/æ–‡æœ¬æå–å’Œå¤„ç†æ¨¡å—ç»“æŸ===




// ===mvuè¯­æ³•ä¸­æ–‡è½¬ä¹‰æ¨¡å—å¼€å§‹===



           parseMvuCommands(mvuText) {
               if (!mvuText || typeof mvuText !== 'string') return [];
               const changes = [];
               const lines = mvuText.split('\n');
               const commandRegex = /_\.(set|add|assign|remove)\s*\(([^)]+)\);?/;

               for (const line of lines) {
                   const trimmedLine = line.trim();
                   const match = trimmedLine.match(commandRegex);

                   if (match) {
                       const [, type, argsString] = match;
                       const args = this._parseParameters(argsString);
                       if (args.length === 0) continue;

                       const path = args[0];
                       let description = '';

                       switch (type) {
                           case 'set':
                               if (args.length >= 2) {
                                   const value = this.formatValue(args[args.length - 1]);
                                   description = `<b>${this.translatePath(path)}</b> è®¾ç½®ä¸º <i>${value}</i>`;
                               }
                               break;
                           case 'add':
                               if (args.length >= 2) {
                                   const value = this.formatValue(args[1]);
                                   description = `<b>${this.translatePath(path)}</b> å¢åŠ äº† <i>${value}</i>`;
                               }
                               break;
                           case 'assign':
                               if (args.length === 2) {
                                   const value = this.formatValue(args[1]);
                                   description = `åœ¨ <b>${this.translatePath(path)}</b> ä¸­æ·»åŠ äº† <i>${value}</i>`;
                               } else if (args.length >= 3) {
                                   const key = this.formatValue(args[1]);
                                   const value = this.formatValue(args[2]);
                                   description = `åœ¨ <b>${this.translatePath(path)}</b> ä¸­ï¼Œå°† <i>${key}</i> è®¾ç½®ä¸º <i>${value}</i>`;
                               }
                               break;
                           case 'remove':
                               description = `ç§»é™¤äº† <b>${this.translatePath(path)}</b>`;
                               break;
                       }
                       
                       if (description) {
                           changes.push({
                               type: type,
                               path: path,
                               description: description
                           });
                       }
                   }
               }
               return changes;
           },

// è·¯å¾„ç¿»è¯‘ï¼šå°†è‹±æ–‡è·¯å¾„è½¬æ¢ä¸ºä¸­æ–‡æè¿°
           translatePath(path) {
               const translations = {
                   'å½“å‰å¢ƒç•Œ': 'å½“å‰å¢ƒç•Œ',
                   'å¢ƒç•Œæ˜ å°„': 'å¢ƒç•Œæ˜ å°„',
                   'ä¿®ä¸ºè¿›åº¦': 'ä¿®ä¸ºè¿›åº¦',
                   'ä¿®ä¸ºç“¶é¢ˆ': 'ä¿®ä¸ºç“¶é¢ˆ',
                   'æ³•åŠ›': 'æ³•åŠ›ä¸Šé™',
                   'å½“å‰æ³•åŠ›': 'å½“å‰æ³•åŠ›',
                   'ç¥æµ·': 'ç¥æµ·ä¸Šé™',
                   'å½“å‰ç¥æµ·': 'å½“å‰ç¥æµ·',
                   'é“å¿ƒ': 'é“å¿ƒä¸Šé™',
                   'å½“å‰é“å¿ƒ': 'å½“å‰é“å¿ƒ',
                   'ç©ºé€Ÿ': 'ç©ºé€Ÿä¸Šé™',
                   'å½“å‰ç©ºé€Ÿ': 'å½“å‰ç©ºé€Ÿ',
                   'æ°”è¿': 'æ°”è¿',
                   'ç”Ÿç†å¹´é¾„': 'ç”Ÿç†å¹´é¾„',
                   'å¿ƒç†å¹´é¾„': 'å¿ƒç†å¹´é¾„',
                   'å½“å‰æ—¶é—´çºªå¹´': 'å½“å‰æ—¶é—´',
                   'å½’çœŸæ•°': 'å½’çœŸæ•°',
                   'å¤©èµ‹åˆ—è¡¨': 'å¤©èµ‹',
                   'çµæ ¹åˆ—è¡¨': 'çµæ ¹',
                   'æ­¦å™¨åˆ—è¡¨': 'æ­¦å™¨',
                   'é˜²å…·åˆ—è¡¨': 'é˜²å…·',
                   'é¥°å“åˆ—è¡¨': 'é¥°å“',
                   'æ³•å®åˆ—è¡¨': 'æ³•å®',
                   'ä¸¹è¯åˆ—è¡¨': 'ä¸¹è¯',
                   'å…¶ä»–åˆ—è¡¨': 'å…¶ä»–ç‰©å“',
                   'äººç‰©å…³ç³»åˆ—è¡¨': 'äººç‰©å…³ç³»',
                   'å½“å‰çŠ¶æ€': 'çŠ¶æ€æ•ˆæœ',
                   'å½“å‰ä½ç½®': 'å½“å‰ä½ç½®'
               };
               let translatedPath = path.replace(/\[0\]/g, '');
               const segments = translatedPath.split('.');
               const translatedSegments = segments.map(segment => {
                   return translations[segment] || segment;
               });
               
               return translatedSegments.join(' â†’ ');
           },
           formatValue(value) {
               if (typeof value === 'string') {
                   const cleaned = value.replace(/^['"`]|['"`]$/g, '');
                   return cleaned;
               }
               return String(value);
           },
           updateVariableChangesReminder() {
               if (!this.lastExtractedVariables) {
                   this.hideVariableChangesReminder();
                   return;
               }

               const changes = this.parseMvuCommands(this.lastExtractedVariables);
               if (changes.length === 0) {
                   this.hideVariableChangesReminder();
                   return;
               }

               this.showVariableChangesReminder(changes);
           },

           showVariableChangesReminder(changes) {
               const reminder = document.getElementById('variable-changes-reminder');
               const count = document.getElementById('variable-changes-count');
               const content = document.getElementById('variable-changes-content');
               if (!reminder || !count || !content) return;
               count.textContent = changes.length;
               const changesHtml = changes.map(change => {
                   const typeText = {
                       'set': 'è®¾ç½®',
                       'add': 'å¢åŠ ',
                       'assign': 'æ·»åŠ ',
                       'remove': 'åˆ é™¤'
                   }[change.type] || change.type;

                   return `
                       <div class="variable-change-item">
                           <div class="variable-change-type-icon ${change.type}">${typeText}</div>
                           <div class="variable-change-description">
                               ${change.description}
                           </div>
                       </div>
                   `;
               }).join('');

               content.innerHTML = changesHtml;
               reminder.style.display = 'block';
           },

           hideVariableChangesReminder() {
               const reminder = document.getElementById('variable-changes-reminder');
               if (reminder) {
                   reminder.style.display = 'none';
               }
           },

           _parseParameters(argsString) {
               const params = [];
               let currentParam = '';
               let inQuotes = false;
               let quoteChar = '';
               let depth = 0;

               for (let i = 0; i < argsString.length; i++) {
                   const char = argsString[i];

                   if (inQuotes) {
                       if (char === quoteChar) {
                           inQuotes = false;
                       }
                       currentParam += char;
                   } else {
                       if (char === '"' || char === "'" || char === '`') {
                           inQuotes = true;
                           quoteChar = char;
                           currentParam += char;
                       } else if (char === '{' || char === '[') {
                           depth++;
                           currentParam += char;
                       } else if (char === '}' || char === ']') {
                           depth--;
                           currentParam += char;
                       } else if (char === ',' && depth === 0) {
                           params.push(currentParam.trim());
                           currentParam = '';
                       } else {
                           currentParam += char;
                       }
                   }
               }
               if (currentParam) {
                   params.push(currentParam.trim());
               }
               return params;
           },
            toggleVariableChanges() {
                const content = document.getElementById('variable-changes-content');
                const icon = document.getElementById('variable-changes-icon');
 
                if (!content || !icon) return;
 
                const isExpanded = content.classList.contains('expanded');
                
                if (isExpanded) {
                    content.classList.remove('expanded');
                    icon.classList.add('collapsed');
                    icon.textContent = 'â–¶';
                } else {
                    content.classList.add('expanded');
                    icon.classList.remove('collapsed');
                    icon.textContent = 'â–¼';
                }
            },
 
            _parseParameters(argsString) {
                const params = [];
                let currentParam = '';
                let inQuotes = false;
                let quoteChar = '';
                let depth = 0;
 
                for (let i = 0; i < argsString.length; i++) {
                    const char = argsString[i];
 
                    if (inQuotes) {
                        if (char === quoteChar) {
                            inQuotes = false;
                        }
                        currentParam += char;
                    } else {
                        if (char === '"' || char === "'" || char === '`') {
                            inQuotes = true;
                            quoteChar = char;
                            currentParam += char;
                        } else if (char === '{' || char === '[') {
                            depth++;
                            currentParam += char;
                        } else if (char === '}' || char === ']') {
                            depth--;
                            currentParam += char;
                        } else if (char === ',' && depth === 0) {
                            params.push(currentParam.trim());
                            currentParam = '';
                        } else {
                            currentParam += char;
                        }
                    }
                }
                if (currentParam) {
                    params.push(currentParam.trim());
                }
                return params;
            },
 // ===mvuä¸­æ–‡è½¬ä¹‰æ¨¡å—ç»“æŸ===




// ===å†å²æ­£æ–‡æ˜¾ç¤º/éšè—æ¨¡å—å¼€å§‹===
             toggleHistoricalTextDisplay() {
                const content = document.getElementById('historical-text-content');
                const icon = document.getElementById('historical-text-icon');
                const container = document.getElementById('historical-text-container');
                
                if (content && icon) {
                    const isCurrentlyHidden = content.style.display === 'none' || !content.style.display;
                    
                    if (isCurrentlyHidden) {
                        content.style.display = 'block';
                        icon.textContent = 'â–¼';
                        if (container) container.style.maxHeight = '400px';
                    } else {
                        content.style.display = 'none';
                        icon.textContent = 'â–¶';
                        if (container) container.style.maxHeight = 'auto';
                    }
                }
             },

             // æ›´æ–°å†å²æ­£æ–‡å†…å®¹
             async updateHistoricalText() {
                const container = document.getElementById('historical-text-container');
                const titleContainer = document.getElementById('current-chapter-title');
                if (!container) return;

                // å¦‚æœè®¾ç½®ä¸º0ï¼Œéšè—æ•´ä¸ªå®¹å™¨
                if (this.historicalTextCount === 0) {
                    container.style.display = 'none';
                    if (titleContainer) titleContainer.style.display = 'none';
                    return;
                }

                try {
                    // ä»å°è¯´æ¨¡å¼ä¸–ç•Œä¹¦è¯»å–å†…å®¹
                    const bookName = '1å½’å¢Ÿ';
                    const index = this.unifiedIndex;
                    const novelModeKey = index > 1 ? `å°è¯´æ¨¡å¼(${index})` : 'å°è¯´æ¨¡å¼';
                    const allEntries = await TavernHelper.getLorebookEntries(bookName);
                    const novelEntry = allEntries.find(entry => entry.comment === novelModeKey);

                    if (!novelEntry || !novelEntry.content) {
                        container.style.display = 'none';
                        if (titleContainer) titleContainer.style.display = 'none';
                        return;
                    }

                    // è§£æå°è¯´æ¨¡å¼å†…å®¹ï¼ŒæŒ‰ç« èŠ‚åˆ†å‰²
                    const novelContent = novelEntry.content;
                    const chapters = this.parseNovelChapters(novelContent);

                    if (chapters.length <= 1) { // å¦‚æœåªæœ‰ä¸€ç« æˆ–æ²¡æœ‰ï¼Œåˆ™ä¸æ˜¾ç¤ºå†å²
                        container.style.display = 'none';
                        if (titleContainer) titleContainer.style.display = 'none';
                        return;
                    }
                    
                    // æ˜¾ç¤ºæœ€æ–°ç« èŠ‚æ ‡é¢˜(å½“å‰æ­£æ–‡çš„æ ‡é¢˜)
                    if (titleContainer && chapters.length > 0) {
                        const currentChapter = chapters[chapters.length - 1]; // è·å–æœ€åä¸€ç« (æœ€æ–°ç« èŠ‚)
                        titleContainer.textContent = currentChapter.title;
                        titleContainer.style.display = 'block';
                        console.log('[å½’å¢Ÿæ ‡é¢˜] æ˜¾ç¤ºæœ€æ–°ç« èŠ‚æ ‡é¢˜:', currentChapter.title);
                    }

                    // æ ¹æ®è®¾ç½®å†³å®šæ˜¾ç¤ºå¤šå°‘ç« èŠ‚
                    let chaptersToShow = [];
                    const historicalChapters = chapters.slice(0, -1);

                    if (this.historicalTextCount === -1) {
                        chaptersToShow = historicalChapters;
                    } else if (this.historicalTextCount > 0) {
                        const startIndex = Math.max(0, historicalChapters.length - this.historicalTextCount);
                        chaptersToShow = historicalChapters.slice(startIndex);
                    }

                    if (chaptersToShow.length === 0) {
                        container.style.display = 'none';
                        return;
                    }

                    // æ¸²æŸ“å†å²æ­£æ–‡
                    let html = '';
                    chaptersToShow.forEach((chapter, index) => {
                        html += this.formatMessageContent(chapter.content);
                        // åœ¨ç« èŠ‚ä¹‹é—´æ·»åŠ åˆ†éš”
                        if (index < chaptersToShow.length - 1) {
                            html += '<div style="width: 100%; text-align: center; margin: 20px 0;"><span style="color: #8b7355; font-size: 12px;">...</span></div>';
                        }
                    });

                    container.innerHTML = html;
                    container.style.display = 'block';

                    // æ›´æ–°ç« èŠ‚å¯¼èˆªçŠ¶æ€
                    if (typeof this.updateChapterNavigation === 'function') {
                        this.updateChapterNavigation();
                    }

                } catch (error) {
                    console.error('æ›´æ–°å†å²æ­£æ–‡æ—¶å‡ºé”™:', error);
                    container.style.display = 'none';
                }
             },

             

             // åŠ è½½å†å²æ­£æ–‡è®¾ç½®
             loadHistoricalTextSettings() {
                try {
                    const savedCount = localStorage.getItem('guixu_historical_text_count');
                    if (savedCount !== null) {
                        this.historicalTextCount = parseInt(savedCount);
                    }
                    const input = document.getElementById('historical-text-count');
                    if (input) input.value = this.historicalTextCount;
                    
                    // ç«‹å³æ›´æ–°ä¸€æ¬¡å†å²æ­£æ–‡
                    this.updateHistoricalText();
                } catch (error) {
                    console.error('åŠ è½½å†å²æ­£æ–‡è®¾ç½®å¤±è´¥:', error);
                }
             },

             // ä¿å­˜å†å²æ­£æ–‡è®¾ç½®
             saveHistoricalTextSettings() {
                try {
                    localStorage.setItem('guixu_historical_text_count', this.historicalTextCount.toString());
                } catch (error) {
                    console.error('ä¿å­˜å†å²æ­£æ–‡è®¾ç½®å¤±è´¥:', error);
                }
             },
// ===å†å²æ­£æ–‡æ˜¾ç¤º/éšè—æ¨¡å—ç»“æŸ===

// ===æ€ç»´è¿‡ç¨‹æ˜¾ç¤º/éšè—æ¨¡å—å¼€å§‹===
             toggleThinkingDisplay() {
                const content = document.getElementById('thinking-process-content');
                const icon = document.getElementById('thinking-process-icon');

                if (!content || !icon) return;

                const isExpanded = content.classList.contains('expanded');

                if (isExpanded) {
                    content.classList.remove('expanded');
                    icon.classList.add('collapsed');
                    icon.textContent = 'â–¶';
                } else {
                    if (this.lastExtractedThinking) {
                        try {
                            if (typeof formatAsDisplayedMessage === 'function') {
                                const cleanedContent = this.lastExtractedThinking
                                    .replace(/<thinking>/g, '')
                                    .replace(/<\/thinking>/g, '');
                                content.innerHTML = formatAsDisplayedMessage(cleanedContent);
                            } else {
                                content.innerHTML = this.simpleMarkdownParse(this.lastExtractedThinking);
                            }
                        } catch (error) {
                            console.error('Error formatting thinking content:', error);
                            content.textContent = this.lastExtractedThinking;
                        }
                        content.classList.add('expanded');
                        icon.classList.remove('collapsed');
                        icon.textContent = 'â–¼';
                    }
                }
            },

            // ===æœ¬ä¸–å†ç¨‹æ˜¾ç¤º/éšè—æ¨¡å—å¼€å§‹===
            toggleCurrentLifeDisplay() {
                const content = document.getElementById('current-life-content');
                const icon = document.getElementById('current-life-icon');

                if (!content || !icon) return;

                const isExpanded = content.classList.contains('expanded');

                if (isExpanded) {
                    content.classList.remove('expanded');
                    icon.classList.add('collapsed');
                    icon.textContent = 'â–¶';
                } else {
                    if (this.lastExtractedJourney) {
                        try {
                            if (typeof formatAsDisplayedMessage === 'function') {
                                content.innerHTML = formatAsDisplayedMessage(this.lastExtractedJourney);
                            } else {
                                content.innerHTML = this.simpleMarkdownParse(this.lastExtractedJourney);
                            }
                        } catch (error) {
                            console.error('Error formatting current life content:', error);
                            content.textContent = this.lastExtractedJourney;
                        }
                        content.classList.add('expanded');
                        icon.classList.remove('collapsed');
                        icon.textContent = 'â–¼';
                    }
                }
            },

            updateCurrentLifeButtonVisibility() {
                const container = document.getElementById('current-life-container');
                if (container) {
                    if (this.lastExtractedJourney && this.lastExtractedJourney.trim() !== '') {
                        container.style.display = 'block';
                    } else {
                        container.style.display = 'none';
                    }
                }
            },
            // ===æœ¬ä¸–å†ç¨‹æ˜¾ç¤º/éšè—æ¨¡å—ç»“æŸ===

            // ===å¾€ä¸–æ¶Ÿæ¼ªæ˜¾ç¤º/éšè—æ¨¡å—å¼€å§‹===
            togglePastLivesDisplay() {
                const content = document.getElementById('past-lives-content');
                const icon = document.getElementById('past-lives-icon');

                if (!content || !icon) return;

                const isExpanded = content.classList.contains('expanded');

                if (isExpanded) {
                    content.classList.remove('expanded');
                    icon.classList.add('collapsed');
                    icon.textContent = 'â–¶';
                } else {
                    if (this.lastExtractedPastLives) {
                        try {
                            if (typeof formatAsDisplayedMessage === 'function') {
                                content.innerHTML = formatAsDisplayedMessage(this.lastExtractedPastLives);
                            } else {
                                content.innerHTML = this.simpleMarkdownParse(this.lastExtractedPastLives);
                            }
                        } catch (error) {
                            console.error('Error formatting past lives content:', error);
                            content.textContent = this.lastExtractedPastLives;
                        }
                        content.classList.add('expanded');
                        icon.classList.remove('collapsed');
                        icon.textContent = 'â–¼';
                    }
                }
            },

            updatePastLivesButtonVisibility() {
                const container = document.getElementById('past-lives-container');
                if (container) {
                    if (this.lastExtractedPastLives && this.lastExtractedPastLives.trim() !== '') {
                        container.style.display = 'block';
                    } else {
                        container.style.display = 'none';
                    }
                }
            },
            // ===å¾€ä¸–æ¶Ÿæ¼ªæ˜¾ç¤º/éšè—æ¨¡å—ç»“æŸ===

            updateThinkingButtonVisibility() {
                const container = document.getElementById('thinking-process-container');
                if (container) {
                    if (this.lastExtractedThinking && this.lastExtractedThinking.trim() !== '') {
                        container.style.display = 'block';
                    } else {
                        container.style.display = 'none';
                    }
                }
            },
//æ€ç»´è¿‡ç¨‹æŒä¹…åŒ–
            saveLastThinking() {
                try {
                    if (this.lastExtractedThinking) {
                        localStorage.setItem('guixu_last_thinking', this.lastExtractedThinking);
                    } else {
                        localStorage.removeItem('guixu_last_thinking');
                    }
                } catch (e) {
                    console.error('ä¿å­˜æ€ç»´è¿‡ç¨‹å¤±è´¥:', e);
                }
            },

            loadLastThinking() {
                try {
                    this.lastExtractedThinking = localStorage.getItem('guixu_last_thinking') || null;
                } catch (e) {
                    console.error('åŠ è½½æ€ç»´è¿‡ç¨‹å¤±è´¥:', e);
                    this.lastExtractedThinking = null;
                }
            },
// ===æ€ç»´è¿‡ç¨‹æ˜¾ç¤º/éšè—æ¨¡å—ç»“æŸ===



//===å­˜æ¡£æ¨¡å—å¼€å§‹===
          async showNewSaveLoadManager() {
            this.openModal('save-load-modal');
            
            // åº”ç”¨å…¨å±æ ·å¼
            const rootContainer = document.querySelector('.guixu-root-container');
            const modalContent = document.querySelector('#save-load-modal .modal-content');
            if (rootContainer && modalContent) {
                const rect = rootContainer.getBoundingClientRect();
                modalContent.style.setProperty('width', `${rect.width}px`, 'important');
                modalContent.style.setProperty('height', `${rect.height}px`, 'important');
                modalContent.style.setProperty('top', `${rect.top}px`, 'important');
                modalContent.style.setProperty('left', `${rect.left}px`, 'important');
                modalContent.style.setProperty('max-width', 'none', 'important');
                modalContent.style.setProperty('max-height', 'none', 'important');
            }
            
            // åˆå§‹åŒ–ç³»åˆ—é€‰æ‹©å™¨
            this.initializeSeriesSelector();
            
            // å½“å‰é€‰ä¸­çš„ç³»åˆ—(é»˜è®¤ä¸ºç©ºå­—ç¬¦ä¸²ä»£è¡¨"æ— ç³»åˆ—")
            if (!this.activeSeries) {
                this.activeSeries = '';
            }
            
            // æ¸²æŸ“ç³»åˆ—åˆ—è¡¨(å·¦ä¾§tabs)
            this.renderSeriesTabs();
            
            // æ¸²æŸ“å­˜æ¡£åˆ—è¡¨(å³ä¾§å†…å®¹)
            await this.renderSavesForSeries(this.activeSeries);
          },
          
          // æ¸²æŸ“ç³»åˆ—æ ‡ç­¾é¡µ
          renderSeriesTabs() {
              const tabsContainer = document.getElementById('series-tabs');
              if (!tabsContainer) return;
              
              const allSeries = this.loadSeriesList();
              
              let html = '';
              
              // "æ— ç³»åˆ—"é€‰é¡¹å¡
              html += `
                  <div class="series-tab ${this.activeSeries === '' ? 'active' : ''}" data-series-id="">
                      æ— ç³»åˆ—
                  </div>
              `;
              
              // å…¶ä»–ç³»åˆ—é€‰é¡¹å¡
              allSeries.forEach(series => {
                  html += `
                      <div class="series-tab ${this.activeSeries === series.seriesId ? 'active' : ''}" data-series-id="${series.seriesId}">
                          ${series.name}
                      </div>
                  `;
              });
              
              tabsContainer.innerHTML = html;
              
              // ç»‘å®šç‚¹å‡»äº‹ä»¶
              tabsContainer.querySelectorAll('.series-tab').forEach(tab => {
                  tab.addEventListener('click', async () => {
                      const seriesId = tab.getAttribute('data-series-id');
                      this.activeSeries = seriesId;
                      this.renderSeriesTabs();
                      await this.renderSavesForSeries(seriesId);
                  });
              });
          },
          
          // æ¸²æŸ“æŒ‡å®šç³»åˆ—çš„å­˜æ¡£åˆ—è¡¨
          async renderSavesForSeries(seriesId) {
              const container = document.getElementById('new-save-load-container');
              if (!container) return;
              
              container.innerHTML = '<div class="loader">æ­£åœ¨åŠ è½½å­˜æ¡£...</div>';
              
              const allSaves = await this.getAllGameSaves();
              
              // ç­›é€‰å‡ºå±äºå½“å‰ç³»åˆ—çš„å­˜æ¡£(å…¼å®¹æ—§ç‰ˆæœ¬:æ²¡æœ‰serieså­—æ®µçš„å­˜æ¡£ç®—ä½œ"æ— ç³»åˆ—")
              const filteredSaves = allSaves.filter(save => {
                  const saveSeries = save.series || '';
                  return saveSeries === seriesId;
              });
              
              if (filteredSaves.length === 0) {
                  container.innerHTML = '<div class="empty-save-list">è¯¥ç³»åˆ—æš‚æ— å­˜æ¡£</div>';
                  return;
              }
              
              let html = '<div class="accordion">';
              filteredSaves.forEach(save => {
                  const date = new Date(save.timestamp).toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' });
                  const saveType = save.auto_generated ? 'è‡ªåŠ¨' : 'æ‰‹åŠ¨';
                  const saveColor = save.auto_generated ? '#8b7355' : '#c9aa71';
                  const novelContent = save.worldbook_contents?.novel_mode || '';
                  const summary = novelContent ? (novelContent.length > 50 ? '...' : '') + novelContent.substring(novelContent.length - 50) : 'æš‚æ— æ‘˜è¦';

                  html += `
                      <div class="accordion-item" data-save-id="${save.id}">
                          <div class="accordion-header">
                              <div class="save-header-info">
                                  <div class="save-header-top">
                                      <span class="save-name" style="color: ${saveColor};">${save.name}</span>
                                      <span class="save-time">${date}</span>
                                      <span class="save-type">[${saveType}]</span>
                                  </div>
                                  <div class="save-summary">${summary}</div>
                              </div>
                              <div class="save-header-actions">
                                  <button class="btn-load-new">è¯»æ¡£</button>
                                  <button class="btn-rename-new">å‘½å</button>
                                  <button class="btn-delete-new">åˆ é™¤</button>
                                  <button class="btn-export-new">å¯¼å‡º</button>
                              </div>
                          </div>
                          <div class="accordion-content">
                  `;

                  const contentMap = [
                      { key: 'novel_mode', title: 'å°è¯´æ¨¡å¼', content: save.worldbook_contents?.novel_mode || '', charLimit: 50 },
                      { key: 'journey', title: 'æœ¬ä¸–å†ç¨‹', content: save.worldbook_contents?.journey || '', charLimit: 200 },
                      { key: 'past_lives', title: 'å¾€ä¸–æ¶Ÿæ¼ª', content: save.worldbook_contents?.past_lives || '', charLimit: 200 },
                      { key: 'segmented_content', title: 'åˆ†æ®µæ­£æ–‡', content: save.worldbook_contents?.segmented_content || '', charLimit: 200 },
                      { key: 'large_summary', title: 'å¤§æ€»ç»“', content: save.worldbook_contents?.large_summary || '', charLimit: 200 },
                      { key: 'small_summary', title: 'å°æ€»ç»“', content: save.worldbook_contents?.small_summary || '', charLimit: 200 }
                  ];

                  html += '<div class="content-grid" style="display: none;">';
                  contentMap.forEach(item => {
                      const content = item.content || '';
                      const summary = content ? (content.length > item.charLimit ? '...' : '') + content.substring(content.length - item.charLimit) : 'æ— å†…å®¹';
                      html += `
                          <details class="content-preview">
                              <summary>${item.title} <span class="char-count">(${item.content.length}å­—)</span></summary>
                              <div class="content-full">${item.content.replace(/\n/g, '<br>')}</div>
                          </details>
                      `;
                  });
                  html += '</div>';

                  html += '</div></div>';
              });
              html += '</div>';

              container.innerHTML = html;
          },
          
          // æ˜¾ç¤ºç³»åˆ—ç®¡ç†ç•Œé¢
          showSeriesManager() {
              this.openModal('series-manager-modal', true); // ä¿æŒå­˜æ¡£ç•Œé¢æ‰“å¼€
              this.renderSeriesManagerList();
              
              // ç»‘å®šæ·»åŠ ç³»åˆ—æŒ‰é’®äº‹ä»¶
              const addBtn = document.getElementById('btn-add-series');
              if (addBtn && !addBtn.hasAttribute('data-bound')) {
                  addBtn.setAttribute('data-bound', 'true');
                  addBtn.addEventListener('click', () => {
                      this.promptAddSeries();
                  });
              }
          },
          
          // å…³é—­ç³»åˆ—ç®¡ç†ç•Œé¢,è¿”å›å­˜æ¡£ç•Œé¢
          closeSeriesManager() {
              this.closeModal('series-manager-modal');
              this.showNewSaveLoadManager(); // åˆ·æ–°å­˜æ¡£ç•Œé¢ä»¥æ˜¾ç¤ºæ›´æ–°åçš„ç³»åˆ—
          },
          
          // æ¸²æŸ“ç³»åˆ—ç®¡ç†åˆ—è¡¨
          renderSeriesManagerList() {
              const container = document.getElementById('series-list');
              if (!container) return;
              
              const allSeries = this.loadSeriesList();
              
              if (allSeries.length === 0) {
                  container.innerHTML = '<div class="empty-save-list">æš‚æ— ç³»åˆ—</div>';
                  return;
              }
              
              let html = '';
              allSeries.forEach(series => {
                  html += `
                      <div class="series-item" data-series-id="${series.seriesId}">
                          <div class="series-item-name">${series.name}</div>
                          <div class="series-item-actions">
                              <button class="btn-rename-series" data-series-id="${series.seriesId}">é‡å‘½å</button>
                              <button class="btn-delete-series" data-series-id="${series.seriesId}">åˆ é™¤</button>
                          </div>
                      </div>
                  `;
              });
              
              container.innerHTML = html;
              
              // ç»‘å®šé‡å‘½åæŒ‰é’®äº‹ä»¶
              container.querySelectorAll('.btn-rename-series').forEach(btn => {
                  btn.addEventListener('click', (e) => {
                      const seriesId = e.target.getAttribute('data-series-id');
                      const series = allSeries.find(s => s.seriesId === seriesId);
                      if (series) {
                          this.promptRenameSeries(seriesId, series.name);
                      }
                  });
              });
              
              // ç»‘å®šåˆ é™¤æŒ‰é’®äº‹ä»¶
              container.querySelectorAll('.btn-delete-series').forEach(btn => {
                  btn.addEventListener('click', async (e) => {
                      const seriesId = e.target.getAttribute('data-series-id');
                      const series = allSeries.find(s => s.seriesId === seriesId);
                      if (series) {
                          this.showCustomConfirm(
                              `ç¡®å®šè¦åˆ é™¤ç³»åˆ—"${series.name}"å—?è¯¥ç³»åˆ—ä¸‹çš„æ‰€æœ‰å­˜æ¡£å°†å˜ä¸º"æ— ç³»åˆ—"ã€‚`,
                              async () => {
                                  await this.deleteSeries(seriesId);
                                  this.renderSeriesManagerList();
                              },
                              null,
                              true
                          );
                      }
                  });
              });
          },
          // æç¤ºç”¨æˆ·è¾“å…¥æ–°ç³»åˆ—åç§°
          async promptAddSeries() {
              const name = await this.promptForSeriesName('æ·»åŠ æ–°ç³»åˆ—');
              if (name) {
                  const result = this.addSeries(name);
                  if (result) {
                      this.renderSeriesManagerList();
                      this.initializeSeriesSelector(); // æ›´æ–°é€‰æ‹©å™¨
                  }
              }
          },
          
          // æç¤ºç”¨æˆ·é‡å‘½åç³»åˆ—
          async promptRenameSeries(seriesId, oldName) {
              const newName = await this.promptForSeriesName('é‡å‘½åç³»åˆ—', oldName);
              if (newName && newName !== oldName) {
                  if (this.renameSeries(seriesId, newName)) {
                      this.renderSeriesManagerList();
                      this.initializeSeriesSelector(); // æ›´æ–°é€‰æ‹©å™¨
                  }
              }
          },
          // æç¤ºç”¨æˆ·è¾“å…¥ç³»åˆ—åç§°ï¼ˆè‡ªå®šä¹‰æ¨¡æ€æ¡†ï¼‰
          async promptForSeriesName(title, defaultValue = '') {
            return new Promise((resolve) => {
              const modal = document.getElementById('series-name-modal');
              const titleEl = document.getElementById('series-name-modal-title');
              const inputEl = document.getElementById('series-name-input');
              const confirmBtn = document.getElementById('series-name-confirm-btn');
              const cancelBtn = document.getElementById('series-name-cancel-btn');
              const closeBtn = modal.querySelector('.modal-close-btn');
              titleEl.textContent = title;
              inputEl.value = defaultValue;

              const cleanup = () => {
                this.closeModal('series-name-modal');
                // è¿”å›åˆ°å­˜æ¡£ç•Œé¢
                this.showNewSaveLoadManager();
                confirmBtn.replaceWith(confirmBtn.cloneNode(true));
                cancelBtn.replaceWith(cancelBtn.cloneNode(true));
                closeBtn.replaceWith(closeBtn.cloneNode(true));
              };

              confirmBtn.onclick = () => {
                const value = inputEl.value.trim();
                if (value) {
                  cleanup();
                  resolve(value);
                } else {
                  this.showTemporaryMessage('åç§°ä¸èƒ½ä¸ºç©º');
                }
              };

              cancelBtn.onclick = () => {
                cleanup();
                resolve(null);
              };

              closeBtn.onclick = () => {
                cleanup();
                resolve(null);
              };

              this.openModal('series-name-modal', true);
              
              // è®¾ç½®æ¨¡æ€æ¡†å°ºå¯¸ - ä½¿å…¶æ›´å°æ›´ç¬¦åˆç›´è§‰
              const modalContent = modal.querySelector('.modal-content');
              if (modalContent) {
                modalContent.style.setProperty('width', '350px', 'important');
                modalContent.style.setProperty('max-width', '90%', 'important');
                modalContent.style.setProperty('height', 'auto', 'important');
              }
              
              setTimeout(() => inputEl.focus(), 100);
            });
          },
                
          // æç¤ºç”¨æˆ·é‡å‘½åç³»åˆ—
          promptRenameSeries(seriesId, oldName) {
              const newName = prompt(`è¯·è¾“å…¥æ–°çš„ç³»åˆ—åç§°:`, oldName);
              if (newName && newName.trim() && newName.trim() !== oldName) {
                  if (this.renameSeries(seriesId, newName.trim())) {
                      this.renderSeriesManagerList();
                      this.initializeSeriesSelector(); // æ›´æ–°é€‰æ‹©å™¨
                  }
              }
          },
          getSavesFromStorage() {
            try {
              const saves = localStorage.getItem('guixu_multi_save_data');
              return saves ? JSON.parse(saves) : {};
            } catch (e) {
              console.error("è·å–å­˜æ¡£å¤±è´¥:", e);
              return {};
            }
          },

          async saveGame(isAutoSave = false, customName = null) {
            try {
              console.log('[å½’å¢Ÿå­˜æ¡£] å¼€å§‹æ–°ç‰ˆå­˜æ¡£æµç¨‹ï¼Œè‡ªåŠ¨å­˜æ¡£:', isAutoSave);

              // è·å–å½“å‰MVUæ•°æ®å’Œæ¶ˆæ¯å†…å®¹
              let currentMvuData = this.currentMvuState;
              let currentMessageContent = '';
              
              if (!currentMvuData) {
                console.log('[å½’å¢Ÿå­˜æ¡£] ç¼“å­˜çŠ¶æ€ä¸ºç©ºï¼Œå°è¯•ä»æ¶ˆæ¯è·å–...');
                const messages = await getChatMessages(getCurrentMessageId());
                if (!messages || messages.length === 0) {
                  this.showTemporaryMessage('é”™è¯¯ï¼šæ— æ³•è·å–å½“å‰æ¶ˆæ¯æ•°æ®ï¼Œæ— æ³•å­˜æ¡£ã€‚');
                  return false;
                }
                currentMvuData = messages[0].data;
                currentMessageContent = messages[0].message || '';
              } else {
                // å¦‚æœæœ‰ç¼“å­˜çŠ¶æ€ï¼Œä¹Ÿå°è¯•è·å–å½“å‰æ¶ˆæ¯å†…å®¹
                try {
                  const messages = await getChatMessages(getCurrentMessageId());
                  if (messages && messages.length > 0) {
                    currentMessageContent = messages[0].message || '';
                  }
                } catch (e) {
                  console.warn('[å½’å¢Ÿå­˜æ¡£] è·å–æ¶ˆæ¯å†…å®¹å¤±è´¥ï¼Œä½¿ç”¨ç©ºå†…å®¹:', e);
                }
              }
              
              if (!currentMvuData || !currentMvuData.stat_data) {
                this.showTemporaryMessage('é”™è¯¯ï¼šMVUæ•°æ®ä¸å®Œæ•´ï¼Œæ— æ³•å­˜æ¡£ã€‚è¯·å…ˆè¿›è¡Œä¸€æ¬¡æ¸¸æˆæ“ä½œã€‚');
                return false;
              }

              // è·å–å…­å¤§æ ¸å¿ƒä¸–ç•Œä¹¦æ¡ç›®çš„å†…å®¹
              const bookName = '1å½’å¢Ÿ';
              const index = this.unifiedIndex;
              const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';
              const pastLivesKey = index > 1 ? `å¾€ä¸–æ¶Ÿæ¼ª(${index})` : 'å¾€ä¸–æ¶Ÿæ¼ª';
              const novelModeKey = index > 1 ? `å°è¯´æ¨¡å¼(${index})` : 'å°è¯´æ¨¡å¼';
              const segmentedKey = index > 1 ? `åˆ†æ®µæ­£æ–‡(${index})` : 'åˆ†æ®µæ­£æ–‡';
              const largeSummaryKey = index > 1 ? `å¤§æ€»ç»“(${index})` : 'å¤§æ€»ç»“';
              const smallSummaryKey = index > 1 ? `å°æ€»ç»“(${index})` : 'å°æ€»ç»“';

              let worldbookContents = {
                journey: '',
                past_lives: '',
                novel_mode: '',
                segmented_content: '',
                large_summary: '',
                small_summary: ''
              };

              try {
                const allEntries = await TavernHelper.getLorebookEntries(bookName);
                const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);
                const pastLivesEntry = allEntries.find(entry => entry.comment === pastLivesKey);
                const novelModeEntry = allEntries.find(entry => entry.comment === novelModeKey);
                const segmentedEntry = allEntries.find(entry => entry.comment === segmentedKey);
                const largeSummaryEntry = allEntries.find(entry => entry.comment === largeSummaryKey);
                const smallSummaryEntry = allEntries.find(entry => entry.comment === smallSummaryKey);

                worldbookContents.journey = journeyEntry?.content || '';
                worldbookContents.past_lives = pastLivesEntry?.content || '';
                worldbookContents.novel_mode = novelModeEntry?.content || '';
                worldbookContents.segmented_content = segmentedEntry?.content || '';
                worldbookContents.large_summary = largeSummaryEntry?.content || '';
                worldbookContents.small_summary = smallSummaryEntry?.content || '';

                console.log('[å½’å¢Ÿå­˜æ¡£] ä¸–ç•Œä¹¦å†…å®¹è·å–å®Œæˆï¼Œå„æ¡ç›®é•¿åº¦:');
                console.log('- æœ¬ä¸–å†ç¨‹:', worldbookContents.journey.length);
                console.log('- å¾€ä¸–æ¶Ÿæ¼ª:', worldbookContents.past_lives.length);
                console.log('- å°è¯´æ¨¡å¼:', worldbookContents.novel_mode.length);
                console.log('- åˆ†æ®µæ­£æ–‡:', worldbookContents.segmented_content.length);
                console.log('- å¤§æ€»ç»“:', worldbookContents.large_summary.length);
                console.log('- å°æ€»ç»“:', worldbookContents.small_summary.length);

              } catch (e) {
                console.error("è·å–ä¸–ç•Œä¹¦å†…å®¹æ—¶å‡ºé”™:", e);
                this.showTemporaryMessage("è­¦å‘Šï¼šè·å–ä¸–ç•Œä¹¦å†…å®¹å¤±è´¥ï¼Œå­˜æ¡£å¯èƒ½ä¸å®Œæ•´ã€‚");
              }

              // ç¡®å®šå­˜æ¡£åç§°
              let saveName;
              let defaultName = '';
              const chapters = this.parseNovelChapters(worldbookContents.novel_mode);
              if (chapters.length > 0) {
                defaultName = chapters[chapters.length - 1].title;
              }

              if (isAutoSave) {
                saveName = defaultName || `è‡ªåŠ¨å­˜æ¡£ ${new Date().toLocaleString('zh-CN', {month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit'})}`;
              } else {
                // æ‰‹åŠ¨å­˜æ¡£
                saveName = await this.promptForSaveName(defaultName);
                if (!saveName) {
                  this.showTemporaryMessage('å­˜æ¡£å·²å–æ¶ˆ');
                  return false;
                }
              }

              // æ„å»ºæ–°çš„å­˜æ¡£æ•°æ®ç»“æ„
              const saveData = {
                id: this.generateSaveId(),
                name: saveName,
                timestamp: new Date().toISOString(),
                auto_generated: isAutoSave,
                series: this.currentSeries || '', // æ·»åŠ ç³»åˆ—å­—æ®µ
                
                // ä¿æŒåŸæœ‰æ•°æ®ç»“æ„
                message_content: currentMessageContent,
                mvu_data: _.cloneDeep({
                  stat_data: currentMvuData.stat_data,
                  schema: currentMvuData.schema,
                  initialized_lorebooks: currentMvuData.initialized_lorebooks,
                  display_data: currentMvuData.display_data,
                  delta_data: currentMvuData.delta_data,
                }),
                gacha_data: {
                  state: _.cloneDeep(this.gachaState),
                  collection: _.cloneDeep(this.gachaCollection),
                  history: _.cloneDeep(this.gachaHistory)
                },
                
                // ä¸–ç•Œä¹¦å†…å®¹ç›´æ¥å­˜æ¡£
                worldbook_contents: _.cloneDeep(worldbookContents)
              };

              // å»é‡æ£€æŸ¥
              if (await this.isDuplicateSave(saveData)) {
                console.log('[å½’å¢Ÿå­˜æ¡£] æ£€æµ‹åˆ°é‡å¤å­˜æ¡£ï¼Œè·³è¿‡ä¿å­˜');
                if (!isAutoSave) {
                  this.showTemporaryMessage('æ£€æµ‹åˆ°ä¸æœ€è¿‘å­˜æ¡£å†…å®¹ç›¸åŒï¼Œè·³è¿‡ä¿å­˜');
                }
                return false;
              }
              // ä¿å­˜åˆ°å­˜å‚¨
              const success = await this.saveGameToStorage(saveData);    
              if (success) {
                const saveTypeText = isAutoSave ? 'è‡ªåŠ¨å­˜æ¡£' : 'æ‰‹åŠ¨å­˜æ¡£';
                this.showTemporaryMessage(`${saveTypeText}"${saveName}"ä¿å­˜æˆåŠŸ`);
                if (document.getElementById('save-load-modal').style.display !== 'none') {
                  this.showNewSaveLoadManager();
                }
                console.log(`[å½’å¢Ÿå­˜æ¡£] ${saveTypeText}æˆåŠŸ:`, saveName);
                return true;
              } else {
                this.showTemporaryMessage('å­˜æ¡£ä¿å­˜å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
                return false;
              }
            } catch (error) {
              console.error('[å½’å¢Ÿå­˜æ¡£] å­˜æ¡£è¿‡ç¨‹å‡ºé”™:', error);
              this.showTemporaryMessage(`å­˜æ¡£å¤±è´¥: ${error.message}`);
              return false;
            }
          },
          async loadGame(saveId) {
            try {
              // å…¼å®¹æ–°æ—§å­˜æ¡£æ ¼å¼
              let saveData;              
              // æ£€æŸ¥æ˜¯å¦ä¸ºæ–°æ ¼å¼å­˜æ¡£ID
              if (saveId.startsWith('save_')) {
                // æ–°æ ¼å¼ï¼šä»æ–°å­˜å‚¨ç³»ç»Ÿè·å–
                const allSaves = await this.getAllGameSaves();
                saveData = allSaves.find(save => save.id === saveId);
              } else {
                // æ—§æ ¼å¼ï¼šä»æ—§å­˜å‚¨ç³»ç»Ÿè·å–
                const allSaves = this.getSavesFromStorage();
                saveData = allSaves[saveId];
              }
              
              if (!saveData) {
                this.showTemporaryMessage('æ²¡æœ‰æ‰¾åˆ°å­˜æ¡£æ–‡ä»¶ã€‚');
                return false;
              }

              const saveName = saveData.name || saveData.save_name || `å­˜æ¡£${saveId}`;
              
              this.showCustomConfirm(`ç¡®å®šè¦è¯»å–å­˜æ¡£"${saveName}"å—ï¼Ÿå½“å‰æ‰€æœ‰æœªä¿å­˜çš„è¿›åº¦å°†ä¼šè¢«è¦†ç›–ã€‚`, async () => {
                try {
                  console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] å¼€å§‹è¯»å–å­˜æ¡£"${saveName}"`);          
                  const messages = await getChatMessages(getCurrentMessageId());
                  if (!messages || messages.length === 0) {
                    this.hideWaitingMessage();
                    this.showTemporaryMessage('é”™è¯¯ï¼šæ— æ³•è·å–å½“å‰æ¶ˆæ¯ï¼Œæ— æ³•è¯»æ¡£ã€‚');
                    return;
                  }                
                  const messageZero = messages[0];
                  const loadedData = saveData.mvu_data;
                  const loadedMessageContent = saveData.message_content || '';

                  // 1. æ›´æ–°æ¶ˆæ¯æ•°æ®ï¼ˆä½¿ç”¨æ— åˆ·æ–°æ¨¡å¼ï¼‰
                  messageZero.data = loadedData;
                  messageZero.message = loadedMessageContent;

                  // 2. æ¢å¤ä¸–ç•Œä¹¦æ•°æ®
                  this.updateWaitingMessage('æ­£åœ¨æ¢å¤ä¸–ç•Œä¹¦æ•°æ®...');
                  
                  if (saveData.worldbook_contents) {
                    // æ–°æ ¼å¼ï¼šä»åµŒå…¥çš„ä¸–ç•Œä¹¦å†…å®¹æ¢å¤
                    await this.restoreWorldbookFromEmbedded(saveData.worldbook_contents);
                  } else if (saveData.lorebook_entries) {
                    // æ—§æ ¼å¼ï¼šä»ç‹¬ç«‹ä¸–ç•Œä¹¦æ¡ç›®æ¢å¤
                    await this.restoreWorldbookFromEntries(saveData.lorebook_entries);
                  }
                  // 3. æ— ç¼æ›´æ–°æ¶ˆæ¯æ•°æ®ï¼ˆå…³é”®ï¼šä½¿ç”¨ refresh: 'none'ï¼‰
                  this.updateWaitingMessage('æ­£åœ¨æ›´æ–°ç•Œé¢æ•°æ®...');
                  await TavernHelper.setChatMessages([messageZero], { refresh: 'none' });                
                  // 4. ç›´æ¥æ›´æ–°MVUçŠ¶æ€å’ŒUIï¼ˆæ— éœ€é‡æ–°åˆå§‹åŒ–ï¼‰
                  this.currentMvuState = this._safeLoadMvuData(loadedData);                  
                  // æ¢å¤GachaçŠ¶æ€åˆ°å†…å­˜
                  if (saveData.gacha_data) {
                    this._loadGachaDataFromSave(saveData);
                  }                  
                  // 5. ç›´æ¥æ›´æ–°æ¸¸æˆæ–‡æœ¬æ˜¾ç¤º
                  const gameTextDisplay = document.getElementById('game-text-display');
                  if (gameTextDisplay && loadedMessageContent) {
                    const displayText = this._getDisplayText(loadedMessageContent);
                    gameTextDisplay.innerHTML = this.formatMessageContent(displayText);
                    this.updateLiveWordCount();                    
                    // æ›´æ–°æœ‰æ•ˆå†…å®¹ç¼“å­˜ï¼Œæ”¯æŒåç»­å›é€€åŠŸèƒ½
                    this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
                  }                
                  // 6. æ›´æ–°UIæ˜¾ç¤ºï¼ˆåªæ›´æ–°å¿…è¦éƒ¨åˆ†ï¼Œä¿æŒå…¶ä»–çŠ¶æ€ï¼‰
                  this.renderUI(this.currentMvuState.stat_data);                  
                  // 7. æå–å¹¶æ›´æ–°ç›¸å…³å†…å®¹
                  if (loadedMessageContent) {
                    this.lastExtractedNovelText = this._extractLastTagContent('gametxt', loadedMessageContent);
                    this.lastExtractedJourney = this._extractLastTagContent('æœ¬ä¸–å†ç¨‹', loadedMessageContent);
                    this.lastExtractedPastLives = this._extractLastTagContent('å¾€ä¸–æ¶Ÿæ¼ª', loadedMessageContent);
                    this.lastExtractedThinking = this._extractLastTagContent('thinking', loadedMessageContent, true);
                    this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', loadedMessageContent, true);
                    
                    // ğŸ”§ ä¿®å¤ï¼šæå–å¹¶æ¸²æŸ“è¡ŒåŠ¨é€‰é¡¹
                    let actionOptionsContent = this._extractLastTagContent('è¡ŒåŠ¨é€‰é¡¹', loadedMessageContent);
                    if (!actionOptionsContent) {
                      actionOptionsContent = this._extractLastTagContent('action', loadedMessageContent);
                    }
                    this.renderActionOptions(actionOptionsContent);
                    
                    // ğŸ”§ ä¿®å¤ï¼šå¦‚æœæ€ç»´é“¾å·²å±•å¼€,ç«‹å³æ¸²æŸ“æ–°å†…å®¹åˆ°DOM
                    const thinkingContent = document.getElementById('thinking-process-content');
                    if (thinkingContent && thinkingContent.classList.contains('expanded') && this.lastExtractedThinking) {
                      try {
                        if (typeof formatAsDisplayedMessage === 'function') {
                          const cleanedContent = this.lastExtractedThinking
                            .replace(/<thinking>/g, '')
                            .replace(/<\/thinking>/g, '');
                          thinkingContent.innerHTML = formatAsDisplayedMessage(cleanedContent);
                        } else {
                          thinkingContent.innerHTML = this.simpleMarkdownParse(this.lastExtractedThinking);
                        }
                      } catch (error) {
                        console.error('Error formatting thinking content:', error);
                        thinkingContent.textContent = this.lastExtractedThinking;
                      }
                    }
                    
                    // æ›´æ–°ç›¸å…³UIç»„ä»¶
                    this.updateThinkingButtonVisibility();
                    this.updateCurrentLifeButtonVisibility(); // æ–°å¢:æ›´æ–°æœ¬ä¸–å†ç¨‹æŒ‰é’®æ˜¾ç¤º
                    this.updatePastLivesButtonVisibility(); // æ–°å¢:æ›´æ–°å¾€ä¸–æ¶Ÿæ¼ªæŒ‰é’®æ˜¾ç¤º
                    this.updateVariableChangesReminder();
                  }
                  // 8. æ›´æ–°å†å²æ­£æ–‡å’Œç« èŠ‚æ ‡é¢˜
                  await this.updateHistoricalText();
                  
                  // 9. è§¦å‘åˆ†æ®µè®°å¿†æ›´æ–°
                  if (this.isSegmentedMemoryAutoGenerateEnabled) {
                      console.log('[å½’å¢Ÿ] è¯»æ¡£å®Œæˆï¼Œè§¦å‘åˆ†æ®µè®°å¿†æ›´æ–°...');
                      await this.generateSegmentedMemory(false);
                  }
                  this.hideWaitingMessage();
                  this.showTemporaryMessage(`æ— ç¼è¯»æ¡£"${saveName}"æˆåŠŸï¼`);                
                  // 9. è¯»æ¡£å®Œæˆåå…³é—­å­˜æ¡£ç•Œé¢ï¼Œæ˜¾ç¤ºä¸»ç•Œé¢
                  this.closeAllModals();                
                  return true;
                } catch (error) {
                  console.error('æ— ç¼è¯»æ¡£å¤±è´¥:', error);
                  this.hideWaitingMessage();
                  this.showTemporaryMessage(`è¯»æ¡£å¤±è´¥: ${error.message}`);
                  return false;
                }
              });              
            } catch (error) {
              console.error('[å½’å¢Ÿè¯»æ¡£] è¯»æ¡£è¿‡ç¨‹å‡ºé”™:', error);
              this.showTemporaryMessage(`è¯»æ¡£å¤±è´¥: ${error.message}`);
              return false;
            }
          },
          // ä»åµŒå…¥çš„ä¸–ç•Œä¹¦å†…å®¹æ¢å¤ï¼ˆæ–°æ ¼å¼ï¼‰
          async restoreWorldbookFromEmbedded(worldbookContents) {
            try {
              const bookName = '1å½’å¢Ÿ';
              const index = this.unifiedIndex;              
              const worldbookKeys = {
                journey: index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹',
                past_lives: index > 1 ? `å¾€ä¸–æ¶Ÿæ¼ª(${index})` : 'å¾€ä¸–æ¶Ÿæ¼ª',
                novel_mode: index > 1 ? `å°è¯´æ¨¡å¼(${index})` : 'å°è¯´æ¨¡å¼',
                segmented_content: index > 1 ? `åˆ†æ®µæ­£æ–‡(${index})` : 'åˆ†æ®µæ­£æ–‡',
                large_summary: index > 1 ? `å¤§æ€»ç»“(${index})` : 'å¤§æ€»ç»“',
                small_summary: index > 1 ? `å°æ€»ç»“(${index})` : 'å°æ€»ç»“'
              };
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const entriesToUpdate = [];
              const entriesToCreate = [];
              // å¤„ç†å…­ä¸ªæ ¸å¿ƒæ¡ç›®
              for (const [contentKey, entryKey] of Object.entries(worldbookKeys)) {
                const contentToRestore = worldbookContents[contentKey] || '';
                const existingEntry = allEntries.find(entry => entry.comment === entryKey);

                if (existingEntry) {
                  entriesToUpdate.push({
                    uid: existingEntry.uid,
                    content: contentToRestore
                  });
                  console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] æ›´æ–°${entryKey}æ¡ç›®ï¼Œå†…å®¹é•¿åº¦: ${contentToRestore.length}`);
                } else {
                  // åˆ›å»ºæ–°æ¡ç›®
                  const newEntry = {
                    comment: entryKey,
                    content: contentToRestore,
                    keys: [entryKey],
                    enabled: contentKey === 'novel_mode' ? false : true, // å°è¯´æ¨¡å¼é»˜è®¤ç¦ç”¨
                    position: 'before_character_definition',
                    order: this.getEntryOrder(contentKey)
                  };
                  entriesToCreate.push(newEntry);
                  console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] åˆ›å»º${entryKey}æ¡ç›®ï¼Œå†…å®¹é•¿åº¦: ${contentToRestore.length}`);
                }
              }
              // æ‰¹é‡æ›´æ–°å’Œåˆ›å»º
              if (entriesToUpdate.length > 0) {
                await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
              }
              if (entriesToCreate.length > 0) {
                await TavernHelper.createLorebookEntries(bookName, entriesToCreate);
              }

              console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] ä¸–ç•Œä¹¦å†…å®¹æ¢å¤å®Œæˆï¼Œæ›´æ–°${entriesToUpdate.length}ä¸ªï¼Œåˆ›å»º${entriesToCreate.length}ä¸ªæ¡ç›®`);

            } catch (e) {
              console.error("ä»åµŒå…¥å†…å®¹æ¢å¤ä¸–ç•Œä¹¦æ•°æ®æ—¶å‡ºé”™:", e);
              this.showTemporaryMessage("è­¦å‘Šï¼šæ¢å¤ä¸–ç•Œä¹¦æ•°æ®å¤±è´¥ï¼Œä½†ä¸»æ•°æ®å·²æ¢å¤ã€‚");
            }
          },

          // ä»ç‹¬ç«‹æ¡ç›®æ¢å¤ï¼ˆæ—§æ ¼å¼å…¼å®¹ï¼‰
          async restoreWorldbookFromEntries(lorebookEntries) {
            try {
              const bookName = '1å½’å¢Ÿ';
              const currentIndex = this.unifiedIndex;
              const currentJourneyKey = currentIndex > 1 ? `æœ¬ä¸–å†ç¨‹(${currentIndex})` : 'æœ¬ä¸–å†ç¨‹';
              const currentPastLivesKey = currentIndex > 1 ? `å¾€ä¸–æ¶Ÿæ¼ª(${currentIndex})` : 'å¾€ä¸–æ¶Ÿæ¼ª';
              const currentNovelModeKey = currentIndex > 1 ? `å°è¯´æ¨¡å¼(${currentIndex})` : 'å°è¯´æ¨¡å¼';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const saveJourneyEntry = allEntries.find(entry => entry.comment === lorebookEntries.journey_entry_name);
              const savePastLivesEntry = allEntries.find(entry => entry.comment === lorebookEntries.past_lives_entry_name);
              const saveNovelModeEntry = allEntries.find(entry => entry.comment === lorebookEntries.novel_mode_entry_name);          
              const currentJourneyEntry = allEntries.find(entry => entry.comment === currentJourneyKey);
              const currentPastLivesEntry = allEntries.find(entry => entry.comment === currentPastLivesKey);
              const currentNovelModeEntry = allEntries.find(entry => entry.comment === currentNovelModeKey);          
              const entriesToUpdate = [];
              if (saveJourneyEntry) {
                const contentToRestore = saveJourneyEntry.content || '';
                if (currentJourneyEntry) {
                  entriesToUpdate.push({
                    uid: currentJourneyEntry.uid,
                    content: contentToRestore
                  });
                } else {
                  await TavernHelper.createLorebookEntries(bookName, [{
                    comment: currentJourneyKey,
                    content: contentToRestore,
                    keys: [currentJourneyKey],
                    enabled: true,
                    position: 'before_character_definition',
                    order: 20
                  }]);
                }
              }
              
              if (savePastLivesEntry) {
                const contentToRestore = savePastLivesEntry.content || '';
                if (currentPastLivesEntry) {
                  entriesToUpdate.push({
                    uid: currentPastLivesEntry.uid,
                    content: contentToRestore
                  });
                } else {
                  await TavernHelper.createLorebookEntries(bookName, [{
                    comment: currentPastLivesKey,
                    content: contentToRestore,
                    keys: [currentPastLivesKey],
                    enabled: true,
                    position: 'before_character_definition',
                    order: 19
                  }]);
                }
              }

              if (saveNovelModeEntry) {
                const contentToRestore = saveNovelModeEntry.content || '';
                if (currentNovelModeEntry) {
                  entriesToUpdate.push({
                    uid: currentNovelModeEntry.uid,
                    content: contentToRestore
                  });
                } else {
                  await TavernHelper.createLorebookEntries(bookName, [{
                    comment: currentNovelModeKey,
                    content: contentToRestore,
                    keys: [currentNovelModeKey],
                    enabled: false,
                    position: 'before_character_definition',
                    order: 18
                  }]);
                }
              }              
              if (entriesToUpdate.length > 0) {
                await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
              }            
            } catch (e) {
              this.showTemporaryMessage("è­¦å‘Šï¼šæ¢å¤ä¸–ç•Œä¹¦æ•°æ®å¤±è´¥ï¼Œä½†ä¸»æ•°æ®å·²æ¢å¤ã€‚");
            }
          },
          getEntryOrder(contentKey) {
            const orderMap = {
              journey: 20,
              past_lives: 19,
              novel_mode: 18,
              segmented_content: 17,
              large_summary: 16,
              small_summary: 15
            };
            return orderMap[contentKey] || 10;
          },
          async renameSave(saveId) {
            const allSaves = await this.getAllGameSaves();
            const saveData = allSaves.find(save => save.id === saveId);
            if (!saveData) {
                this.showTemporaryMessage('æœªæ‰¾åˆ°å­˜æ¡£ï¼Œæ— æ³•é‡å‘½åã€‚');
                return;
            }
            const newName = await this.promptForSaveName(saveData.name, 'é‡å‘½åå­˜æ¡£');
            if (newName && newName !== saveData.name) {
                saveData.name = newName;
                await this.saveGameToStorage(saveData);
                this.showTemporaryMessage('å­˜æ¡£å·²é‡å‘½åã€‚');
                this.showNewSaveLoadManager();
            }
          },
          async deleteGameSave(saveId) {
            try {
                if (this.dbAvailable && this.db) {
                    await this.db.game_saves.delete(saveId);
                } else {
                    const allSaves = this.getLocalStorageGameSaves();
                    delete allSaves[saveId];
                    localStorage.setItem('guixu_new_save_data', JSON.stringify(allSaves));
                }
                 return true;
            } catch (error) {
                console.error('[å½’å¢Ÿå­˜æ¡£] åˆ é™¤å­˜æ¡£å¤±è´¥:', error);
                return false;
            }
          },
          async deleteAllSaves() {
            try {
                if (this.dbAvailable && this.db) {
                    await this.db.game_saves.clear();
                } else {
                    localStorage.removeItem('guixu_new_save_data');
                }
                return true;
            } catch (error) {
                console.error('[å½’å¢Ÿå­˜æ¡£] æ¸…é™¤æ‰€æœ‰å­˜æ¡£å¤±è´¥:', error);
                return false;
            }
          },
          clearAllSaves() {
            this.showCustomConfirm(`ä½ ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å­˜æ¡£å—ï¼Ÿè¿™ä¸ªæ“ä½œä¸å¯æ¢å¤ã€‚`, () => {
              try {
                localStorage.removeItem('guixu_multi_save_data');
                this.showTemporaryMessage(`æ‰€æœ‰å­˜æ¡£å·²æ¸…é™¤ã€‚`);
                this.showSaveLoadManager(); 
              } catch (error) {
                console.error('æ¸…é™¤æ‰€æœ‰å­˜æ¡£å¤±è´¥:', error);
                this.showTemporaryMessage(`æ¸…é™¤å­˜æ¡£å¤±è´¥: ${error.message}`);
              }
            });
          },
          // å­˜æ¡£å‘½åè¾“å…¥æ¡†
          async promptForSaveName(defaultName = '', title = 'å­˜æ¡£å‘½å') {
            return new Promise((resolve) => {
              try {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.display = 'flex';
                modal.style.zIndex = '2000';
                modal.innerHTML = `
                  <div class="modal-content" style="width: 400px; height: auto; max-height: none;">
                    <div class="modal-header">
                      <h2 class="modal-title">${title}</h2>
                    </div>
                    <div class="modal-body" style="padding: 20px;">
                      <p style="margin-bottom: 15px; color: #c9aa71;">è¯·è¾“å…¥å­˜æ¡£åç§°ï¼š</p>
                      <input type="text" id="save-name-input" value="${defaultName}" placeholder="ä¾‹å¦‚ï¼šçªç ´é‡‘ä¸¹æœŸ"
                             style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355;
                                    color: #e0dcd1; border-radius: 4px; font-size: 14px; margin-bottom: 15px;">
                      <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="save-name-cancel" class="interaction-btn">å–æ¶ˆ</button>
                        <button id="save-name-confirm" class="interaction-btn primary-btn">ç¡®è®¤</button>
                      </div>
                    </div>
                  </div>
                `;

                const container = document.querySelector('.guixu-root-container');
                if (!container) {
                  console.error('[å½’å¢Ÿå­˜æ¡£] æ‰¾ä¸åˆ°æ ¹å®¹å™¨');
                  resolve(null);
                  return;
                }
                container.appendChild(modal);

                const input = modal.querySelector('#save-name-input');
                const confirmBtn = modal.querySelector('#save-name-confirm');
                const cancelBtn = modal.querySelector('#save-name-cancel');

                if (!input || !confirmBtn || !cancelBtn) {
                  console.error('[å½’å¢Ÿå­˜æ¡£] æ¨¡æ€æ¡†å…ƒç´ åˆ›å»ºå¤±è´¥');
                  modal.remove();
                  resolve(null);
                  return;
                }
                confirmBtn.addEventListener('click', () => {
                  const saveName = input.value.trim();
                  if (!saveName) {
                    this.showTemporaryMessage('è¯·è¾“å…¥å­˜æ¡£åç§°');
                    return;
                  }
                  console.log('[å½’å¢Ÿå­˜æ¡£] ç”¨æˆ·è¾“å…¥å­˜æ¡£åç§°:', saveName);
                  modal.remove();
                  resolve(saveName);
                });
                cancelBtn.addEventListener('click', () => {
                  modal.remove();
                  resolve(null);
                });
                input.addEventListener('keypress', (e) => {
                  if (e.key === 'Enter') {
                    confirmBtn.click();
                  }
                });
                setTimeout(() => {
                  try {
                    input.focus();
                  } catch (e) {
                    console.warn('[å½’å¢Ÿå­˜æ¡£] è‡ªåŠ¨èšç„¦å¤±è´¥:', e);
                  }
                }, 100);

              } catch (error) {
                console.error('[å½’å¢Ÿå­˜æ¡£] åˆ›å»ºå­˜æ¡£å‘½åå¯¹è¯æ¡†æ—¶å‡ºé”™:', error);
                resolve(null);
              }
            });
          },

// ã€è‡ªåŠ¨å­˜æ¡£æ ¸å¿ƒæ¨¡å—ã€‘
          saveAutoSaveState() {
            try {
              localStorage.setItem('guixu_auto_save_enabled', this.isAutoSaveEnabled);
            } catch (e) {
              console.error('ä¿å­˜è‡ªåŠ¨å­˜æ¡£çŠ¶æ€å¤±è´¥:', e);
            }
          },
          loadAutoSaveState() {
            try {
              const savedState = localStorage.getItem('guixu_auto_save_enabled');
              this.isAutoSaveEnabled = savedState === 'true'; // é»˜è®¤ä¸º true
              const checkbox = document.getElementById('auto-save-checkbox');
              if (checkbox) {
                checkbox.checked = this.isAutoSaveEnabled;
              }
            } catch (e) {
              console.error('åŠ è½½è‡ªåŠ¨å­˜æ¡£çŠ¶æ€å¤±è´¥:', e);
              this.isAutoSaveEnabled = false;
            }
          },
          async performAutoSave() {
            try {
              if (!this.isAutoSaveEnabled) {
                console.log('[å½’å¢Ÿè‡ªåŠ¨å­˜æ¡£] è‡ªåŠ¨å­˜æ¡£å·²ç¦ç”¨ï¼Œè·³è¿‡');
                return;
              }
              console.log('[å½’å¢Ÿ] æ‰§è¡Œè‡ªåŠ¨å­˜æ¡£...');
              const success = await this.saveGame(true);
              if (success) {
                  console.log('[å½’å¢Ÿ] è‡ªåŠ¨å­˜æ¡£å®Œæˆã€‚');
                  this.showTemporaryMessage('å·²è‡ªåŠ¨å­˜æ¡£');
              }
            } catch (error) {
                console.error('è‡ªåŠ¨å­˜æ¡£å¤±è´¥:', error);
                this.showTemporaryMessage('è‡ªåŠ¨å­˜æ¡£å¤±è´¥');
            }
          },

// ã€å­˜æ¡£å¯¼å…¥/å¯¼å‡ºæ¨¡å—ã€‘
          async exportSave(saveId) {
            this.showTemporaryMessage('æ­£åœ¨å‡†å¤‡å¯¼å‡ºæ•°æ®...', 2000);
            try {
                const allSaves = await this.getAllGameSaves();
                const saveData = allSaves.find(save => save.id === saveId);
                if (!saveData) {
                    this.showTemporaryMessage('é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¦å¯¼å‡ºçš„å­˜æ¡£æ•°æ®ã€‚');
                    return;
                }
                // æ·»åŠ å¯¼å‡ºæ ¼å¼æ ‡è¯†ï¼Œä¾¿äºéªŒè¯
                const exportData = {
                    exportVersion: '2.0',
                    exportTime: new Date().toISOString(),
                    saveData: saveData
                };
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);                
                const a = document.createElement('a');
                a.href = url;
                const safeSaveName = (saveData.name || saveId).replace(/[^a-z0-9_\-\u4e00-\u9fa5]/gi, '_');
                a.download = `å½’å¢Ÿå­˜æ¡£_${safeSaveName}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.showTemporaryMessage('å­˜æ¡£å·²æˆåŠŸå¯¼å‡ºï¼');
                console.log('[å½’å¢Ÿå¯¼å‡º] å­˜æ¡£å¯¼å‡ºæˆåŠŸ:', saveData.name);
            } catch (error) {
                console.error('[å½’å¢Ÿå¯¼å‡º] å¯¼å‡ºå­˜æ¡£æ—¶å‡ºé”™:', error);
                this.showTemporaryMessage(`å¯¼å‡ºå¤±è´¥: ${error.message}`);
            }
          },
          async handleFileImport(event) {
              const file = event.target.files[0];
              if (!file) return;
              this.showTemporaryMessage('æ­£åœ¨å¯¼å…¥å­˜æ¡£...', 3000);
              const reader = new FileReader();
              reader.onload = async (e) => {
                  try {
                      const importData = JSON.parse(e.target.result);
                      let saveData;
                      // éªŒè¯å¯¼å…¥æ•°æ®æ ¼å¼
                      if (importData.exportVersion === '2.0' && importData.saveData) {
                          saveData = importData.saveData;
                          console.log('[å½’å¢Ÿå¯¼å…¥] æ£€æµ‹åˆ°æ–°ç‰ˆå­˜æ¡£æ ¼å¼ v2.0');
                      } else if (importData.exportVersion === '1.0' && importData.saveData) {
                          saveData = importData.saveData;
                          console.log('[å½’å¢Ÿå¯¼å…¥] æ£€æµ‹åˆ°æ—§ç‰ˆå­˜æ¡£æ ¼å¼ v1.0ï¼Œè¿›è¡Œå…¼å®¹å¤„ç†');
                      } else if (importData.id && importData.name && importData.mvu_data) {
                          saveData = importData;
                          console.log('[å½’å¢Ÿå¯¼å…¥] æ£€æµ‹åˆ°ç›´æ¥å­˜æ¡£æ•°æ®æ ¼å¼');
                      } else {
                          throw new Error('å­˜æ¡£æ–‡ä»¶æ ¼å¼æ— æ•ˆæˆ–å·²æŸåã€‚è¯·ç¡®ä¿å¯¼å…¥çš„æ˜¯æœ‰æ•ˆçš„å½’å¢Ÿå­˜æ¡£æ–‡ä»¶ã€‚');
                      }
                      if (!saveData.mvu_data || !saveData.worldbook_contents) {
                          throw new Error('å­˜æ¡£æ•°æ®ä¸å®Œæ•´ï¼Œç¼ºå°‘å¿…è¦çš„æ¸¸æˆæ•°æ®æˆ–ä¸–ç•Œä¹¦å†…å®¹ã€‚');
                      }
                      // ç”Ÿæˆæ–°çš„å­˜æ¡£IDå’Œæ›´æ–°ä¿¡æ¯
                      const newSaveData = _.cloneDeep(saveData);
                      newSaveData.id = this.generateSaveId();
                      newSaveData.name = `${saveData.name} (å¯¼å…¥)`;
                      newSaveData.timestamp = new Date().toISOString();
                      newSaveData.auto_generated = false;
                      const success = await this.saveGameToStorage(newSaveData);
                      if (success) {
                          this.showTemporaryMessage(`å­˜æ¡£"${newSaveData.name}"å·²æˆåŠŸå¯¼å…¥åˆ°å­˜æ¡£åˆ—è¡¨ï¼`);
                          if (document.getElementById('save-load-modal').style.display !== 'none') {
                              this.showNewSaveLoadManager();
                          }                          
                          console.log('[å½’å¢Ÿå¯¼å…¥] å­˜æ¡£å¯¼å…¥æˆåŠŸ:', newSaveData.name);
                      } else {
                          throw new Error('ä¿å­˜å¯¼å…¥çš„å­˜æ¡£åˆ°å­˜å‚¨å¤±è´¥');
                      }
                  } catch (error) {
                      console.error('[å½’å¢Ÿå¯¼å…¥] å¯¼å…¥å­˜æ¡£æ—¶å‡ºé”™:', error);
                      this.showTemporaryMessage(`å¯¼å…¥å¤±è´¥: ${error.message}`);
                  } finally {
                      // æ¸…ç©ºfile inputçš„å€¼ï¼Œä»¥ä¾¿å¯ä»¥å†æ¬¡é€‰æ‹©åŒä¸€ä¸ªæ–‡ä»¶
                      event.target.value = '';
                  }
              };
              reader.readAsText(file);
          },
//===å­˜æ¡£æ¨¡å—ç»“æŸ===


// ã€è¾…åŠ©æ¨¡å‹è®¾ç½®æ¨¡å—ã€‘
          saveAuxModelSettings() {
            try {
              const settings = {
                isEnabled: this.auxModelSettings?.isEnabled || false,
                apiUrl: this.auxModelSettings?.apiUrl || '',
                apiKey: this.auxModelSettings?.apiKey || '',
                modelName: this.auxModelSettings?.modelName || '',
                source: this.auxModelSettings?.source || 'openai',
                isStreaming: this.auxModelSettings?.isStreaming !== false // é»˜è®¤ä¸ºtrue
              };
              AppStorage.saveData('aux-model-settings', settings);
              console.log('[å½’å¢Ÿ] è¾…åŠ©æ¨¡å‹è®¾ç½®å·²ä¿å­˜:', settings);
            } catch (e) {
              console.error('[å½’å¢Ÿ] ä¿å­˜è¾…åŠ©æ¨¡å‹è®¾ç½®å¤±è´¥:', e);
            }
          },

          loadAuxModelSettings() {
            try {
              const settings = AppStorage.loadData('aux-model-settings', {
                isEnabled: false,
                apiUrl: '',
                apiKey: '',
                modelName: '',
                source: 'openai',
                isStreaming: true
              });
              this.auxModelSettings = settings;
              
              // æ›´æ–°UI
              const enableToggle = document.getElementById('toggle-aux-model-enabled');
              const apiUrlInput = document.getElementById('aux-model-api-url');
              const apiKeyInput = document.getElementById('aux-model-api-key');
              const modelNameInput = document.getElementById('aux-model-name');
              const sourceSelect = document.getElementById('aux-model-source');
              const streamingToggle = document.getElementById('toggle-aux-model-streaming');
              const configSection = document.getElementById('aux-model-config-section');
              
              if (enableToggle) enableToggle.checked = settings.isEnabled;
              if (apiUrlInput) apiUrlInput.value = settings.apiUrl;
              if (apiKeyInput) apiKeyInput.value = settings.apiKey;
              if (modelNameInput) modelNameInput.value = settings.modelName;
              if (sourceSelect) sourceSelect.value = settings.source;
              if (streamingToggle) streamingToggle.checked = settings.isStreaming;
              if (configSection) {
                configSection.style.display = settings.isEnabled ? 'block' : 'none';
              }
              
              console.log('[å½’å¢Ÿ] è¾…åŠ©æ¨¡å‹è®¾ç½®å·²åŠ è½½:', settings);
            } catch (e) {
              console.error('[å½’å¢Ÿ] åŠ è½½è¾…åŠ©æ¨¡å‹è®¾ç½®å¤±è´¥:', e);
              this.auxModelSettings = {
                isEnabled: false,
                apiUrl: '',
                apiKey: '',
                modelName: '',
                source: 'openai',
                isStreaming: true
              };
            }
          },

          // åˆ‡æ¢ä¸–ç•Œä¹¦æ¡ç›®çš„å¯ç”¨çŠ¶æ€
          async toggleWorldbookEntriesByMode(mode) {
            const bookNames = ['1å½’å¢Ÿ'];
            const globalBooks = TavernHelper.getGlobalWorldbookNames?.() || [];
            bookNames.push(...globalBooks.filter(name => name.startsWith('ã€å½’å¢Ÿæ‰©å±•ã€‘')));

            for (const bookName of bookNames) {
              await TavernHelper.updateWorldbookWith(bookName, (entries) => {
                return entries.map(entry => {
                  if (mode === 'once') {
                    if (entry.name.includes('ã€noå•æ¬¡ã€‘')) entry.enabled = false;
                    if (entry.name.includes('ã€yeså•æ¬¡ã€‘')) entry.enabled = true;
                  } else {
                    if (entry.name.includes('ã€noå•æ¬¡ã€‘')) entry.enabled = true;
                    if (entry.name.includes('ã€yeså•æ¬¡ã€‘')) entry.enabled = false;
                  }
                  return entry;
                });
              });
            }
          },

          // åˆ†æ­¥å˜é‡æ›´æ–°è®¾ç½®
          async saveMvuUpdateMode() {
            const settings = {
              mvuUpdateMode: this.mvuUpdateMode || 'éšAIè¾“å‡º',
              generationMode: this.generationMode || 'once',
              stepwiseConfig: {
                modelSource: this.stepwiseConfig?.modelSource || 'ä¸æ’å¤´ç›¸åŒ'
              }
            };
            
            AppStorage.saveData('stepwise-variable-settings', settings);
            await this.toggleWorldbookEntriesByMode(this.generationMode);
          },

          loadMvuUpdateMode() {
            try {
              const settings = AppStorage.loadData('stepwise-variable-settings', {
                mvuUpdateMode: 'éšAIè¾“å‡º',
                generationMode: 'once',
                stepwiseConfig: {
                  modelSource: 'ä¸æ’å¤´ç›¸åŒ',
                  worldbookFilterMode: 'auto'
                }
              });
              
              // åŠ è½½è®¾ç½®
              this.mvuUpdateMode = settings.mvuUpdateMode;
              this.generationMode = settings.generationMode;
              this.stepwiseConfig = settings.stepwiseConfig;
              
              // åŒæ­¥UI
              const withAiRadio = document.getElementById('mvu-mode-with-ai');
              const stepwiseRadio = document.getElementById('mvu-mode-stepwise');
              const stepwiseConfigSection = document.getElementById('stepwise-config-section');
              const sourceSameRadio = document.getElementById('stepwise-source-same');
              const sourceCustomRadio = document.getElementById('stepwise-source-custom');
              const worldbookFilterSelect = document.getElementById('worldbook-filter-mode');

              if (withAiRadio) withAiRadio.checked = (this.mvuUpdateMode === 'éšAIè¾“å‡º');
              if (stepwiseRadio) stepwiseRadio.checked = (this.mvuUpdateMode === 'åˆ†æ­¥å˜é‡æ›´æ–°');
              if (stepwiseConfigSection) {
                stepwiseConfigSection.style.display = (this.mvuUpdateMode === 'åˆ†æ­¥å˜é‡æ›´æ–°') ? 'block' : 'none';
              }
              if (sourceSameRadio) sourceSameRadio.checked = (this.stepwiseConfig.modelSource === 'ä¸æ’å¤´ç›¸åŒ');
              if (sourceCustomRadio) sourceCustomRadio.checked = (this.stepwiseConfig.modelSource === 'è‡ªå®šä¹‰');
              if (worldbookFilterSelect) worldbookFilterSelect.value = this.stepwiseConfig.worldbookFilterMode;
              
              console.log('[å½’å¢Ÿ-åˆ†æ­¥å˜é‡] è®¾ç½®å·²ä»LocalStorageåŠ è½½:', settings);
            } catch (e) {
              console.error('[å½’å¢Ÿ-åˆ†æ­¥å˜é‡] åŠ è½½è®¾ç½®å¤±è´¥:', e);
              this.mvuUpdateMode = 'éšAIè¾“å‡º';
              this.generationMode = 'once';
              this.stepwiseConfig = {
                modelSource: 'ä¸æ’å¤´ç›¸åŒ',
                worldbookFilterMode: 'auto'
              };
            }
          },

          // è¿æ¥ç¬¬äºŒAPIå¹¶è·å–æ¨¡å‹åˆ—è¡¨
          async connectAndFetchModels() {
            console.log('[å½’å¢Ÿ] è¿æ¥ç¬¬äºŒAPIå¹¶è·å–æ¨¡å‹åˆ—è¡¨');
            
            const auxSettings = this.auxModelSettings;
            if (!auxSettings || !auxSettings.apiUrl) {
              this.showTemporaryMessage('è¯·å…ˆé…ç½®API URLï¼', 3000);
              return;
            }

            this.showWaitingMessage('æ­£åœ¨è¿æ¥å¹¶è·å–æ¨¡å‹åˆ—è¡¨...');

            try {
              // æ„é€ è·å–æ¨¡å‹åˆ—è¡¨çš„APIç«¯ç‚¹
              let modelsEndpoint = auxSettings.apiUrl;
              // ç§»é™¤æœ«å°¾çš„ /v1 æˆ– /v1/
              modelsEndpoint = modelsEndpoint.replace(/\/v1\/?$/, '');
              if (!modelsEndpoint.endsWith('/')) {
                modelsEndpoint += '/';
              }
              modelsEndpoint += 'v1/models';

              console.log('[å½’å¢Ÿ] è¯·æ±‚æ¨¡å‹åˆ—è¡¨ç«¯ç‚¹:', modelsEndpoint);

              // å‘èµ·fetchè¯·æ±‚
              const response = await fetch(modelsEndpoint, {
                method: 'GET',
                headers: {
                  'Authorization': `Bearer ${auxSettings.apiKey}`,
                  'Content-Type': 'application/json'
                }
              });

              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }

              const data = await response.json();
              console.log('[å½’å¢Ÿ] æ¨¡å‹åˆ—è¡¨æ•°æ®:', data);

              // è§£ææ¨¡å‹åˆ—è¡¨ï¼ˆOpenAIæ ¼å¼ï¼‰
              let modelNames = [];
              if (data.data && Array.isArray(data.data)) {
                modelNames = data.data.map(m => m.id || m.model || m.name).filter(Boolean);
              } else if (Array.isArray(data)) {
                // æŸäº›APIç›´æ¥è¿”å›æ•°ç»„
                modelNames = data.map(m => m.id || m.model || m.name || m).filter(Boolean);
              }

              if (modelNames.length === 0) {
                throw new Error('æœªæ‰¾åˆ°ä»»ä½•æ¨¡å‹');
              }

              this.hideWaitingMessage();
              
              // æ›´æ–°ä¸‹æ‹‰æ¡†
              const selectElement = document.getElementById('aux-model-name');
              if (selectElement) {
                selectElement.innerHTML = modelNames.map(name =>
                  `<option value="${name}">${name}</option>`
                ).join('');
                
                // å¦‚æœä¹‹å‰æœ‰é€‰ä¸­çš„æ¨¡å‹ï¼Œä¿æŒé€‰ä¸­
                if (auxSettings.modelName && modelNames.includes(auxSettings.modelName)) {
                  selectElement.value = auxSettings.modelName;
                } else if (modelNames.length > 0) {
                  // å¦åˆ™é€‰ä¸­ç¬¬ä¸€ä¸ª
                  selectElement.value = modelNames[0];
                  this.auxModelSettings.modelName = modelNames[0];
                  this.saveAuxModelSettings();
                }
              }
              
              this.showTemporaryMessage(`âœ… è¿æ¥æˆåŠŸï¼æ‰¾åˆ° ${modelNames.length} ä¸ªæ¨¡å‹`, 3000);
              console.log('[å½’å¢Ÿ] æ‰€æœ‰å¯ç”¨æ¨¡å‹:', modelNames);

            } catch (error) {
              this.hideWaitingMessage();
              this.showTemporaryMessage(`âŒ è¿æ¥å¤±è´¥: ${error.message}`, 5000);
              console.error('[å½’å¢Ÿ] è¿æ¥å¤±è´¥:', error);
            }
          },

          // æµ‹è¯•ç¬¬äºŒAPIï¼ˆå®Œå…¨ç‹¬ç«‹ï¼Œä½¿ç”¨çº¯fetchï¼Œä¸è§¦å‘SillyTavernä»»ä½•æµç¨‹ï¼‰
          async testAuxModel() {
            console.log('[å½’å¢Ÿ] æµ‹è¯•ç¬¬äºŒAPI');
            
            const auxSettings = this.auxModelSettings;
            if (!auxSettings || !auxSettings.apiUrl || !auxSettings.modelName) {
              this.showTemporaryMessage('è¯·å…ˆè¿æ¥å¹¶é€‰æ‹©æ¨¡å‹ï¼', 3000);
              return;
            }

            this.showWaitingMessage('æ­£åœ¨æµ‹è¯•APIå“åº”...');

            try {
              // ä½¿ç”¨çº¯fetchè°ƒç”¨ï¼Œå®Œå…¨ç»•è¿‡SillyTavern
              let apiEndpoint = auxSettings.apiUrl;
              // ç§»é™¤æœ«å°¾çš„ /v1 æˆ– /v1/
              apiEndpoint = apiEndpoint.replace(/\/v1\/?$/, '');
              if (!apiEndpoint.endsWith('/')) {
                apiEndpoint += '/';
              }
              apiEndpoint += 'v1/chat/completions';

              const requestBody = {
                model: auxSettings.modelName,
                messages: [
                  { role: 'user', content: 'è¯·å›å¤"æµ‹è¯•æˆåŠŸ"ï¼ˆ4ä¸ªå­—ï¼‰' }
                ],
                temperature: 0.7,
                max_tokens: 50
              };

              console.log('[å½’å¢Ÿ] æµ‹è¯•è¯·æ±‚:', { endpoint: apiEndpoint, body: requestBody });

              const response = await fetch(apiEndpoint, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${auxSettings.apiKey}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
              });

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
              }

              const data = await response.json();
              console.log('[å½’å¢Ÿ] æµ‹è¯•å“åº”æ•°æ®:', data);

              // è§£æå“åº”ï¼ˆOpenAIæ ¼å¼ï¼‰
              let responseText = '';
              if (data.choices && data.choices.length > 0) {
                responseText = data.choices[0].message?.content || data.choices[0].text || '';
              }

              if (!responseText) {
                throw new Error('æœªèƒ½ä»å“åº”ä¸­æå–å†…å®¹');
              }

              this.hideWaitingMessage();
              
              // æ˜¾ç¤ºå“åº”å†…å®¹
              const preview = responseText.length > 100 ? responseText.substring(0, 100) + '...' : responseText;
              this.showTemporaryMessage(`âœ… æµ‹è¯•æˆåŠŸï¼\n\nå“åº”å†…å®¹:\n${preview}`, 8000);
              console.log('[å½’å¢Ÿ] ç¬¬äºŒAPIæµ‹è¯•æˆåŠŸï¼Œå®Œæ•´å“åº”:', responseText);

            } catch (error) {
              this.hideWaitingMessage();
              this.showTemporaryMessage(`âŒ æµ‹è¯•å¤±è´¥: ${error.message}`, 5000);
              console.error('[å½’å¢Ÿ] ç¬¬äºŒAPIæµ‹è¯•å¤±è´¥:', error);
            }
          },

// ===åŠŸèƒ½çŠ¶æ€è¯»å–æ¨¡å—å¼€å§‹===



// 1.ã€è¡ŒåŠ¨é€‰é¡¹çŠ¶æ€å­˜å–ã€‘
           saveActionOptionsState() {
             try {
               localStorage.setItem('guixu_action_options_enabled', this.isActionOptionsEnabled);
             } catch (e) {
               console.error('ä¿å­˜è¡ŒåŠ¨é€‰é¡¹çŠ¶æ€å¤±è´¥:', e);
             }
         },
// 2.ã€è¡ŒåŠ¨é€‰é¡¹è‡ªåŠ¨å‘é€çŠ¶æ€å­˜å–ã€‘
         saveActionAutoSendState() {
           try {
             localStorage.setItem('guixu_action_auto_send_enabled', this.isActionAutoSend);
           } catch (e) {
             console.error('ä¿å­˜è¡ŒåŠ¨é€‰é¡¹è‡ªåŠ¨å‘é€çŠ¶æ€å¤±è´¥:', e);
           }
         },
         loadActionAutoSendState() {
           try {
             const savedState = localStorage.getItem('guixu_action_auto_send_enabled');
             this.isActionAutoSend = savedState === null ? true : savedState === 'true';
             const checkbox = document.getElementById('auto-send-action-checkbox');
             if (checkbox) {
               checkbox.checked = this.isActionAutoSend;
             }
           } catch (e) {
             console.error('åŠ è½½è¡ŒåŠ¨é€‰é¡¹è‡ªåŠ¨å‘é€çŠ¶æ€å¤±è´¥:', e);
             this.isActionAutoSend = true;
           }
         },

           loadActionOptionsState() {
             try {
               const savedState = localStorage.getItem('guixu_action_options_enabled');
               this.isActionOptionsEnabled = savedState === null ? true : savedState === 'true';
               const checkbox = document.getElementById('action-options-enabled-checkbox');
               if (checkbox) {
                 checkbox.checked = this.isActionOptionsEnabled;
               }
             } catch (e) {
               console.error('åŠ è½½è¡ŒåŠ¨é€‰é¡¹çŠ¶æ€å¤±è´¥:', e);
               this.isActionOptionsEnabled = true;
             }
           },
// 3.ã€æµå¼å¼€å…³çŠ¶æ€å­˜å–ã€‘
         saveStreamingState() {
             try {
                 localStorage.setItem('guixu_streaming_enabled', this.isStreamingEnabled);
             } catch (e) {
                 console.error('ä¿å­˜æµå¼çŠ¶æ€å¤±è´¥:', e);
             }
         },
         loadStreamingState() {
             try {
                 const savedState = localStorage.getItem('guixu_streaming_enabled');
                 // é»˜è®¤ä¸º true (å¼€å¯)
                 this.isStreamingEnabled = savedState === null ? true : savedState === 'true';
                 const checkbox = document.getElementById('streaming-enabled-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isStreamingEnabled;
                 }
             } catch (e) {
                 console.error('åŠ è½½æµå¼çŠ¶æ€å¤±è´¥:', e);
                 this.isStreamingEnabled = true;
             }
         },

// 4.ã€æ ¼å¼å®¡æŸ¥çŠ¶æ€å­˜å–ã€‘
         saveFormatValidationState() {
             try {
                 localStorage.setItem('guixu_format_validation_enabled', this.isFormatValidationEnabled);
             } catch (e) {
                 console.error('ä¿å­˜æ ¼å¼å®¡æŸ¥çŠ¶æ€å¤±è´¥:', e);
             }
         },
         loadFormatValidationState() {
             try {
                 const savedState = localStorage.getItem('guixu_format_validation_enabled');
                 // é»˜è®¤ä¸º true (å¼€å¯)
                 this.isFormatValidationEnabled = savedState === null ? true : savedState === 'true';
                 const checkbox = document.getElementById('format-validation-enabled-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isFormatValidationEnabled;
                 }
             } catch (e) {
                 console.error('åŠ è½½æ ¼å¼å®¡æŸ¥çŠ¶æ€å¤±è´¥:', e);
                 this.isFormatValidationEnabled = true;
             }
         },

// 5.ã€å›è½¦å‘é€çŠ¶æ€å­˜å–ã€‘
         saveEnterSendState() {
             try {
                 localStorage.setItem('guixu_enter_send_enabled', this.isEnterSendEnabled);
             } catch (e) {
                 console.error('ä¿å­˜å›è½¦å‘é€çŠ¶æ€å¤±è´¥:', e);
             }
         },
         loadEnterSendState() {
             try {
                 const savedState = localStorage.getItem('guixu_enter_send_enabled');
                 this.isEnterSendEnabled = savedState === 'true';
                 const checkbox = document.getElementById('enter-send-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isEnterSendEnabled;
                 }
             } catch (e) {
                 console.error('åŠ è½½å›è½¦å‘é€çŠ¶æ€å¤±è´¥:', e);
                 this.isEnterSendEnabled = false;
             }
         },

// 6.ã€é”®ç›˜å¿«æ·é”®çŠ¶æ€å­˜å–ã€‘
         saveKeyboardShortcutsState() {
             try {
                 localStorage.setItem('guixu_keyboard_shortcuts_enabled', this.isKeyboardShortcutsEnabled);
             } catch (e) {
                 console.error('ä¿å­˜é”®ç›˜å¿«æ·é”®çŠ¶æ€å¤±è´¥:', e);
             }
         },
         loadKeyboardShortcutsState() {
             try {
                 const savedState = localStorage.getItem('guixu_keyboard_shortcuts_enabled');
                 this.isKeyboardShortcutsEnabled = savedState !== 'false';
                 const checkbox = document.getElementById('keyboard-shortcuts-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isKeyboardShortcutsEnabled;
                 }
             } catch (e) {
                 console.error('åŠ è½½é”®ç›˜å¿«æ·é”®çŠ¶æ€å¤±è´¥:', e);
                 this.isKeyboardShortcutsEnabled = true;
             }
         },

// 7.ã€æ‰‹æœºè¾“å…¥æ¡†é€‚é…çŠ¶æ€å­˜å–ã€‘
         saveMobileInputAdaptState() {
             try {
                 localStorage.setItem('guixu_mobile_input_adapt_enabled', this.isMobileInputAdaptEnabled);
             } catch (e) {
                 console.error('ä¿å­˜æ‰‹æœºè¾“å…¥æ¡†é€‚é…çŠ¶æ€å¤±è´¥:', e);
             }
         },
         loadMobileInputAdaptState() {
             try {
                 const savedState = localStorage.getItem('guixu_mobile_input_adapt_enabled');
                 this.isMobileInputAdaptEnabled = savedState === 'true';
                 const checkbox = document.getElementById('mobile-input-adapt-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isMobileInputAdaptEnabled;
                 }
             } catch (e) {
                 console.error('åŠ è½½æ‰‹æœºè¾“å…¥æ¡†é€‚é…çŠ¶æ€å¤±è´¥:', e);
                 this.isMobileInputAdaptEnabled = false;
             }
         },
//8.ã€è‡ªåŠ¨å¼€å…³ä¸–ç•Œä¹¦çŠ¶æ€å­˜å–ã€‘
           saveAutoToggleState() {
             try {
               localStorage.setItem('guixu_auto_toggle_enabled', this.isAutoToggleLorebookEnabled);
             } catch (e) {
               console.error('ä¿å­˜è‡ªåŠ¨å¼€å…³çŠ¶æ€å¤±è´¥:', e);
             }
           },
 
           loadAutoToggleState() {
             try {
               const savedState = localStorage.getItem('guixu_auto_toggle_enabled');
               this.isAutoToggleLorebookEnabled = savedState === 'true';
               const checkbox = document.getElementById('auto-toggle-lorebook-checkbox');
               if (checkbox) {
                 checkbox.checked = this.isAutoToggleLorebookEnabled;
               }
               // æ ¹æ®åŠ è½½çš„çŠ¶æ€å†³å®šæ˜¯å¦å¯åŠ¨è½®è¯¢
                if (this.isAutoToggleLorebookEnabled) {
                    this.startAutoTogglePolling();
                }
             } catch (e) {
               console.error('åŠ è½½è‡ªåŠ¨å¼€å…³çŠ¶æ€å¤±è´¥:', e);
               this.isAutoToggleLorebookEnabled = false;
             }
           },

// 8.ã€åˆ†æ®µè®°å¿†ä¿ç•™æ•°å­˜å–ã€‘
          saveSegmentedMemoryCounts() {
              try {
                  const segmentedCount = document.getElementById('segmented-memory-count')?.value || '3';
                  const smallSummaryCount = document.getElementById('small-summary-count')?.value || '25';
                  localStorage.setItem('guixu_segmented_memory_count', segmentedCount);
                  localStorage.setItem('guixu_small_summary_count', smallSummaryCount);
              } catch (e) {
                  console.error('ä¿å­˜åˆ†æ®µè®°å¿†ä¿ç•™æ•°å¤±è´¥:', e);
              }
          },

//9.ã€å°è¯´æ¨¡å¼ç‹¬ç«‹è¯»å†™åºå·å­˜å–ã€‘
          saveNovelModeIndex() {
           try {
             localStorage.setItem('guixu_novel_mode_index', this.novelModeIndex);
           } catch (e) {
             console.error('ä¿å­˜å°è¯´æ¨¡å¼è¯»å†™åºå·å¤±è´¥:', e);
           }
          },

// ===åŠŸèƒ½çŠ¶æ€è¯»å–æ¨¡å—ç»“æŸ===


         
// ===ä¿®å‰ªæ§åˆ¶å°æ¨¡å—å¼€å§‹===
          reconstructJourneyEntry(events) {
            if (!Array.isArray(events)) return '';

            const fieldOrder = ['åºå·', 'æ—¥æœŸ', 'æ ‡é¢˜', 'åœ°ç‚¹', 'äººç‰©', 'æè¿°', 'äººç‰©å…³ç³»', 'æ ‡ç­¾', 'é‡è¦ä¿¡æ¯', 'æš—çº¿ä¸ä¼ç¬”', 'è‡ªåŠ¨åŒ–ç³»ç»Ÿ'];

            return events.map(event => {
                return fieldOrder
                    .map(key => {
                        if (event[key] !== undefined && event[key] !== null) {
                            return `${key}|${String(event[key]).trim()}`;
                        }
                        return null;
                    })
                    .filter(Boolean) 
                    .join('\n');
            }).join('\n\n');
          },
          async handlePreciseTrim() {
            // 1. è·å–è¦æ“ä½œçš„æ¡ç›®
            const checkedBoxes = document.querySelectorAll('#history-modal-body .journey-trim-checkbox:checked');
            if (checkedBoxes.length === 0) {
                this.showTemporaryMessage('è¯·å…ˆåœ¨ä¸‹æ–¹å†ç¨‹ä¸­å‹¾é€‰éœ€è¦ä¿®å‰ªçš„æ¡ç›®ã€‚');
                return;
            }
            const sequenceIdsToTrim = Array.from(checkedBoxes).map(box => box.dataset.sequenceId);

            // 2. è·å–è¦åˆ é™¤çš„å­—æ®µ
            const fieldsToRemove = Array.from(document.querySelectorAll('.trim-field-checkbox:checked')).map(cb => cb.value);
            if (fieldsToRemove.length === 0) {
                this.showTemporaryMessage('è¯·å…ˆåœ¨ä¸Šæ–¹æ§åˆ¶å°å‹¾é€‰éœ€è¦ä¿®å‰ªçš„å­—æ®µã€‚');
                return;
            }

            // 3. å¼¹å‡ºç¡®è®¤æ¡†
            this.showCustomConfirm(
                `ä½ ç¡®å®šè¦ä»é€‰ä¸­çš„ ${checkedBoxes.length} ä¸ªæ¡ç›®ä¸­ï¼Œåˆ é™¤ã€${fieldsToRemove.join('ã€')}ã€‘å­—æ®µå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`,
                async () => {
                    this.showTemporaryMessage('æ­£åœ¨è¿›è¡Œç²¾ç¡®ä¿®å‰ª...');
                    const bookName = '1å½’å¢Ÿ';
                    const index = this.unifiedIndex;
                    const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';

                    try {
                        const allEntries = await TavernHelper.getLorebookEntries(bookName);
                        const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

                        if (!journeyEntry || !journeyEntry.content) {
                            this.showTemporaryMessage('é”™è¯¯ï¼šæ‰¾ä¸åˆ°â€œæœ¬ä¸–å†ç¨‹â€å†…å®¹ã€‚');
                            return;
                        }

                        let events = this.parseJourneyEntry(journeyEntry.content);
                        let trimCount = 0;

                        events.forEach(event => {
                            if (sequenceIdsToTrim.includes(event['åºå·'])) {
                                let trimmedThisEvent = false;
                                fieldsToRemove.forEach(field => {
                                    if (event.hasOwnProperty(field)) {
                                        delete event[field];
                                        trimmedThisEvent = true;
                                    }
                                });
                                if (trimmedThisEvent) trimCount++;
                            }
                        });

                        if (trimCount === 0) {
                            this.showTemporaryMessage('é€‰ä¸­çš„æ¡ç›®ä¸­æ²¡æœ‰å¯ä¿®å‰ªçš„å†…å®¹ã€‚');
                            return;
                        }

                        const newContent = this.reconstructJourneyEntry(events);
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]);
                        this.showTemporaryMessage(`ä¿®å‰ªæˆåŠŸï¼å·²å¤„ç† ${trimCount} ä¸ªæ¡ç›®ã€‚`, 3000);
                        this.showJourney(); // åˆ·æ–°è§†å›¾

                    } catch (error) {
                        console.error('ç²¾ç¡®ä¿®å‰ªå¤±è´¥:', error);
                        this.showTemporaryMessage(`ä¿®å‰ªå¤±è´¥: ${error.message}`, 3000);
                    }
                },
                true // keepCurrentModal
            );
          },

          async handleAutoTrim() {
            // 1. è·å–è¦åˆ é™¤çš„å­—æ®µ
            const fieldsToRemove = Array.from(document.querySelectorAll('.trim-field-checkbox:checked')).map(cb => cb.value);
            if (fieldsToRemove.length === 0) {
                this.showTemporaryMessage('è¯·å…ˆåœ¨ä¸Šæ–¹æ§åˆ¶å°å‹¾é€‰éœ€è¦ä¿®å‰ªçš„å­—æ®µã€‚');
                return;
            }

            // 2. è·å–ä¿ç•™æ•°é‡
            const keepCountInput = document.getElementById('trim-keep-count');
            const keepCount = parseInt(keepCountInput.value, 10);
            if (isNaN(keepCount) || keepCount < 0) {
                this.showTemporaryMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„ä¿ç•™æ•°é‡ã€‚');
                return;
            }

            // 3. å¼¹å‡ºç¡®è®¤æ¡†
            this.showCustomConfirm(
                `ä½ ç¡®å®šè¦ä¿ç•™æœ€æ–°çš„ ${keepCount} ä¸ªæ¡ç›®ï¼Œå¹¶ä»æ‰€æœ‰æ›´æ—©çš„æ¡ç›®ä¸­åˆ é™¤ã€${fieldsToRemove.join('ã€')}ã€‘å­—æ®µå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`,
                async () => {
                    this.showTemporaryMessage('æ­£åœ¨è¿›è¡Œè‡ªåŠ¨ä¿®å‰ª...');
                    const bookName = '1å½’å¢Ÿ';
                    const index = this.unifiedIndex;
                    const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';

                    try {
                        const allEntries = await TavernHelper.getLorebookEntries(bookName);
                        const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

                        if (!journeyEntry || !journeyEntry.content) {
                            this.showTemporaryMessage('é”™è¯¯ï¼šæ‰¾ä¸åˆ°â€œæœ¬ä¸–å†ç¨‹â€å†…å®¹ã€‚');
                            return;
                        }

                        let events = this.parseJourneyEntry(journeyEntry.content);
                        if (events.length <= keepCount) {
                            this.showTemporaryMessage('æ— éœ€ä¿®å‰ªï¼Œå½“å‰æ¡ç›®æ•°æœªè¶…è¿‡ä¿ç•™æ•°é‡ã€‚');
                            return;
                        }

                        let trimCount = 0;
                        const eventsToTrimCount = events.length - keepCount;

                        events.forEach((event, idx) => {
                            if (idx < eventsToTrimCount) {
                                let trimmedThisEvent = false;
                                fieldsToRemove.forEach(field => {
                                    if (event.hasOwnProperty(field)) {
                                        delete event[field];
                                        trimmedThisEvent = true;
                                    }
                                });
                                if (trimmedThisEvent) trimCount++;
                            }
                        });

                        if (trimCount === 0) {
                            this.showTemporaryMessage('æ²¡æœ‰å¯ä¿®å‰ªçš„å†…å®¹ã€‚');
                            return;
                        }

                        const newContent = this.reconstructJourneyEntry(events);
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]);
                        this.showTemporaryMessage(`è‡ªåŠ¨ä¿®å‰ªæˆåŠŸï¼å·²å¤„ç† ${trimCount} ä¸ªæ—§æ¡ç›®ã€‚`, 3000);
                        this.showJourney();

                    } catch (error) {
                        console.error('è‡ªåŠ¨ä¿®å‰ªå¤±è´¥:', error);
                        this.showTemporaryMessage(`ä¿®å‰ªå¤±è´¥: ${error.message}`, 3000);
                    }
                },
                true
            );
          },

          async handleFullTrim() {
            const keepCountInput = document.getElementById('trim-keep-count');
            const keepCount = parseInt(keepCountInput.value, 10);
            if (isNaN(keepCount) || keepCount < 0) {
                this.showTemporaryMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„ä¿ç•™æ•°é‡ã€‚');
                return;
            }

            this.showCustomConfirm(
                `ã€é«˜å±æ“ä½œã€‘ä½ ç¡®å®šè¦æ°¸ä¹…åˆ é™¤é™¤æœ€è¿‘ ${keepCount} æ¡å¤–çš„æ‰€æœ‰å†ç¨‹è®°å½•å—ï¼Ÿæ­¤æ“ä½œå°†å½»åº•åˆ é™¤æ•°æ®ï¼Œä¸å¯æ¢å¤ï¼`,
                async () => {
                    this.showTemporaryMessage('æ­£åœ¨è¿›è¡Œå®Œæ•´åˆ é™¤...');
                    const bookName = '1å½’å¢Ÿ';
                    const index = this.unifiedIndex;
                    const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';

                    try {
                        const allEntries = await TavernHelper.getLorebookEntries(bookName);
                        const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

                        if (!journeyEntry || !journeyEntry.content) {
                            this.showTemporaryMessage('é”™è¯¯ï¼šæ‰¾ä¸åˆ°â€œæœ¬ä¸–å†ç¨‹â€å†…å®¹ã€‚');
                            return;
                        }

                        let events = this.parseJourneyEntry(journeyEntry.content);
                        if (events.length <= keepCount) {
                            this.showTemporaryMessage('æ— éœ€åˆ é™¤ï¼Œå½“å‰æ¡ç›®æ•°æœªè¶…è¿‡ä¿ç•™æ•°é‡ã€‚');
                            return;
                        }
                        const deletedCount = events.length - keepCount;
                        const keptEvents = events.slice(deletedCount);
                        
                        const newContent = this.reconstructJourneyEntry(keptEvents);
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]);
                        this.showTemporaryMessage(`å®Œæ•´åˆ é™¤æˆåŠŸï¼å·²åˆ é™¤ ${deletedCount} ä¸ªæ—§æ¡ç›®ã€‚`, 3000);
                        this.showJourney();

                    } catch (error) {
                        console.error('å®Œæ•´åˆ é™¤å¤±è´¥:', error);
                        this.showTemporaryMessage(`åˆ é™¤å¤±è´¥: ${error.message}`, 3000);
                    }
                },
                true
            );
          },

          // ä¿®å‰ªå­—æ®µçŠ¶æ€çš„ä¿å­˜ä¸åŠ è½½
          saveTrimFieldsState() {
              const checkboxes = document.querySelectorAll('.trim-field-checkbox');
              const state = {};
              checkboxes.forEach(cb => {
                  state[cb.value] = cb.checked;
              });
              this.trimFieldsState = state;
              try {
                  localStorage.setItem('guixu_trim_fields_state', JSON.stringify(state));
              } catch (e) {
                  console.error('ä¿å­˜ä¿®å‰ªå­—æ®µçŠ¶æ€å¤±è´¥:', e);
              }
          },

          loadTrimFieldsState() {
              try {
                  const savedState = localStorage.getItem('guixu_trim_fields_state');
                  if (savedState) {
                      this.trimFieldsState = JSON.parse(savedState);
                  } else {
                      this.saveTrimFieldsState();
                      return;
                  }
              } catch (e) {
                  console.error('åŠ è½½ä¿®å‰ªå­—æ®µçŠ¶æ€å¤±è´¥:', e);
                  this.trimFieldsState = {}; // å‡ºé”™æ—¶é‡ç½®
              }
              const checkboxes = document.querySelectorAll('.trim-field-checkbox');
              checkboxes.forEach(cb => {
                  // å¦‚æœçŠ¶æ€å¯¹è±¡ä¸­æœ‰è¿™ä¸ªå€¼ï¼Œåˆ™ä½¿ç”¨å®ƒï¼›å¦åˆ™ä¿æŒé»˜è®¤
                  if (this.trimFieldsState.hasOwnProperty(cb.value)) {
                      cb.checked = this.trimFieldsState[cb.value];
                  }
              });
           },
// ===ä¿®å‰ªæ§åˆ¶å°æ¨¡å—ç»“æŸ===



// ===è¾“å…¥ç¼“å­˜/å†å²è®°å½•æ¨¡å—å¼€å§‹===
            getInputHistory() {
                try {
                    const history = localStorage.getItem('guixu_input_history');
                    return history ? JSON.parse(history) : [];
                } catch (e) {
                    return [];
                }
            },

            saveInputToHistory(content) {
                if (!content) return;
                try {
                    let history = this.getInputHistory();
                    if (history[0] === content) return;
                    history.unshift(content);
                    // é™åˆ¶å†å²è®°å½•æ•°é‡
                    if (history.length > 100) {
                        history.pop();
                    }
                    localStorage.setItem('guixu_input_history', JSON.stringify(history));
                } catch (e) {
                }
            },

            showInputCacheModal() {
                const history = this.getInputHistory();
                const recentListEl = document.getElementById('recent-inputs-list');
                const allListEl = document.getElementById('all-inputs-list');

                if (!recentListEl || !allListEl) return;

                recentListEl.innerHTML = '';
                allListEl.innerHTML = '';

                if (history.length === 0) {
                    recentListEl.innerHTML = '<li class="empty-category-text">æš‚æ— è®°å½•</li>';
                    allListEl.innerHTML = '<li class="empty-category-text">æš‚æ— è®°å½•</li>';
                } else {
                    // å¡«å……æœ€è¿‘ä¸¤æ¬¡è¾“å…¥
                    history.slice(0, 2).forEach((item, index) => {
                        const li = document.createElement('li');
                        li.className = 'input-cache-item';
                        li.dataset.content = item;
                        li.innerHTML = `<span class="item-index">${index + 1}.</span>${item}`;
                        recentListEl.appendChild(li);
                    });

                    // å¡«å……æ‰€æœ‰å†å²è®°å½•
                    history.forEach((item, index) => {
                        const li = document.createElement('li');
                        li.className = 'input-cache-item';
                        li.dataset.content = item;
                        li.innerHTML = `<span class="item-index">${index + 1}.</span>${item}`;
                        allListEl.appendChild(li);
                    });
                }
                
                this.openModal('input-cache-modal');
            },

            applyInputFromHistory(content) {
                const inputEl = document.getElementById('quick-send-input');
                if (inputEl) {
                    inputEl.value = content;
                    this.closeModal('input-cache-modal');
                    this.showTemporaryMessage('å·²åº”ç”¨å†å²è¾“å…¥ã€‚');
                }
            },
// ===è¾“å…¥ç¼“å­˜/å†å²è®°å½•æ¨¡å—ç»“æŸ===



// ===åˆ†æ®µè®°å¿†æ¨¡å—å¼€å§‹===
          // æ–°å¢ï¼šæ˜¾ç¤ºåˆ†æ®µè®°å¿†æ¨¡æ€æ¡†
          async showSegmentedMemoryModal() {
            this.loadSegmentedMemoryCounts(); // æ–°å¢ï¼šåŠ è½½ä¿ç•™æ•°è®¾ç½®
            this.updateUnifiedSummaryDisplay(); // åœ¨æ‰“å¼€æ¨¡æ€æ¡†æ—¶æ›´æ–°ç»Ÿä¸€é¢„è§ˆ
            const modal = document.getElementById('segmented-memory-modal');
            if (!modal) {
                this.showTemporaryMessage('åˆ†æ®µè®°å¿†æ¨¡æ€æ¡†åŠ è½½å¤±è´¥', 'error');
                return;
            }
            this.openModal('segmented-memory-modal', true); // ç¡®ä¿åœ¨è®¾ç½®ä¹‹ä¸Š

            // æ›´æ–°ç»Ÿä¸€é¢„è§ˆ
            this.updateUnifiedSummaryDisplay();

            // åˆå§‹åŒ–UIçŠ¶æ€
            const autoGenerateCheckbox = document.getElementById('auto-segmented-memory-checkbox');
            if(autoGenerateCheckbox) autoGenerateCheckbox.checked = this.isSegmentedMemoryAutoGenerateEnabled; // ä¸»å¼€å…³çš„çŠ¶æ€

            // ç”±äºå…¶ä»–å¼€å…³å·²ç§»é™¤ï¼Œä¸å†éœ€è¦å•ç‹¬åˆå§‹åŒ–å®ƒä»¬

            // ç»‘å®šæ¨¡æ€æ¡†å†…éƒ¨äº‹ä»¶
            const closeBtn = modal.querySelector('.modal-close-btn');
            closeBtn?.addEventListener('click', () => {
                this.closeModal('segmented-memory-modal');
                if (this.isFromSettingsModal) {
                    this.showSettings();
                    this.isFromSettingsModal = false; // é‡ç½®æ ‡å¿—ä½
                }
            });
            
            modal.addEventListener('click', (event) => {
                if (event.target === modal) {
                    this.closeModal('segmented-memory-modal');
                    if (this.isFromSettingsModal) {
                        this.showSettings();
                        this.isFromSettingsModal = false; // é‡ç½®æ ‡å¿—ä½
                    }
                }
            });

            const generateBtn = document.getElementById('btn-generate-segmented-memory');
            generateBtn?.addEventListener('click', async () => {
                // ä¾æ¬¡è°ƒç”¨ä¸‰ä¸ªç”Ÿæˆå‡½æ•°
                await this.generateSegmentedMemory();
                await this.generateSmallSummary();
                await this.generateLargeSummary();

                // åœ¨æ‰‹åŠ¨ç”Ÿæˆåï¼Œå¦‚æœæ¨¡æ€æ¡†æ˜¯æ‰“å¼€çš„ï¼Œåˆ™åˆ·æ–°ç»Ÿä¸€é¢„è§ˆ
                const modal = document.getElementById('segmented-memory-modal');
                if (modal && modal.style.display !== 'none') {
                    this.updateUnifiedSummaryDisplay();
                }
            });

            // æ–°å¢ï¼šä¸ºé¢„è§ˆåˆ—è¡¨æ·»åŠ ç‚¹å‡»å±•å¼€/æŠ˜å äº‹ä»¶ (ä¼˜åŒ–ç‰ˆ)
            const displayEl = document.getElementById('unified-summary-display');
            if (displayEl && !displayEl.dataset.listenerAttached) {
                displayEl.dataset.listenerAttached = 'true';
                displayEl.addEventListener('click', (e) => {
                    const header = e.target.closest('.summary-header');
                    if (header) {
                        const item = header.closest('.summary-item');
                        item.classList.toggle('expanded');
                    }
                });
            }

            const segmentedCountInput = document.getElementById('segmented-memory-count');
            const smallSummaryCountInput = document.getElementById('small-summary-count');

            segmentedCountInput?.addEventListener('input', () => {
                this.updateUnifiedSummaryDisplay();
                this.saveSegmentedMemoryCounts();
            });
            smallSummaryCountInput?.addEventListener('input', () => {
                this.updateUnifiedSummaryDisplay();
                this.saveSegmentedMemoryCounts();
            });

            autoGenerateCheckbox?.addEventListener('change', (e) => {
               const isEnabled = e.target.checked;
               this.isSegmentedMemoryAutoGenerateEnabled = isEnabled;
               this.isSmallSummaryAutoOn = isEnabled;
               this.isLargeSummaryAutoOn = isEnabled;

               this.saveSegmentedMemoryState();
               this.saveSmallSummaryState();
               this.saveLargeSummaryState();

               this.showTemporaryMessage(`åˆ†æ®µè®°å¿†è‡ªåŠ¨ç”Ÿæˆå·²${isEnabled ? 'å¼€å¯' : 'å…³é—­'}`);

               if (isEnabled) {
                   this.startSegmentedMemoryPolling();
                   // æ³¨æ„ï¼šå°æ€»ç»“å’Œå¤§æ€»ç»“çš„è½®è¯¢é€»è¾‘å¯èƒ½éœ€è¦å•ç‹¬çš„è®¡æ—¶å™¨æˆ–åœ¨åˆ†æ®µè®°å¿†è½®è¯¢ä¸­è§¦å‘
               } else {
                   this.stopSegmentedMemoryPolling();
                   // åŒæ ·éœ€è¦åœæ­¢å°æ€»ç»“å’Œå¤§æ€»ç»“çš„è½®è¯¢
               }
            });

            // --- æ•´åˆåçš„äº‹ä»¶ç»‘å®š ---
            document.getElementById('edit-small-summary-btn')?.addEventListener('click', () => this.showSummaryEditorModal('small'));
            document.getElementById('edit-large-summary-btn')?.addEventListener('click', () => this.showSummaryEditorModal('large'));
const generateSummariesBtn = document.getElementById('btn-generate-summaries');
generateSummariesBtn?.addEventListener('click', async () => {
    const statusEl = document.getElementById('summaries-status');
    if (generateSummariesBtn) {
        generateSummariesBtn.disabled = true;
        generateSummariesBtn.textContent = 'æ­£åœ¨ç”Ÿæˆ...';
    }
    
    try {
        await this.generateSmallSummary();
        await this.generateLargeSummary();
        if (statusEl) statusEl.textContent = 'ç”Ÿæˆå®Œæˆï¼';
        this.showTemporaryMessage('å°ç»“ä¸æ€»ç»“å·²æ›´æ–°', 'success');
        // ç”Ÿæˆååˆ·æ–°ç»Ÿä¸€é¢„è§ˆ
        this.updateUnifiedSummaryDisplay();
    } catch (e) {
        // é”™è¯¯å·²åœ¨å„è‡ªå‡½æ•°ä¸­å¤„ç†å’Œæ˜¾ç¤º
    } finally {
        if (generateSummariesBtn) {
            generateSummariesBtn.disabled = false;
            generateSummariesBtn.textContent = 'ç«‹å³ç”Ÿæˆå°ç»“ä¸æ€»ç»“';
        }
        setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 3000);
    }
});
},
// --- æ–°å¢ï¼šæ€»ç»“ç¼–è¾‘å™¨ ---
async showSummaryEditorModal(summaryType) {
    const modal = document.getElementById('summary-editor-modal');
    const titleEl = document.getElementById('summary-editor-title');
    const textarea = document.getElementById('summary-editor-textarea');
    if (!modal || !titleEl || !textarea) return;

    const bookName = '1å½’å¢Ÿ';
    const index = this.unifiedIndex;
    const entryName = summaryType === 'small'
        ? (index > 1 ? `å°æ€»ç»“(${index})` : 'å°æ€»ç»“')
        : (index > 1 ? `å¤§æ€»ç»“(${index})` : 'å¤§æ€»ç»“');
    
    titleEl.textContent = `ç¼–è¾‘${summaryType === 'small' ? 'å°æ€»ç»“' : 'å¤§æ€»ç»“'}`;
    textarea.value = 'æ­£åœ¨åŠ è½½...';
    this.openModal('summary-editor-modal', true);

    try {
        const allEntries = await TavernHelper.getLorebookEntries(bookName);
        const entry = allEntries.find(e => e.comment === entryName);
        textarea.value = entry ? entry.content : '';
    } catch (error) {
        textarea.value = `åŠ è½½å¤±è´¥: ${error.message}`;
    }

    // ç»‘å®šäº‹ä»¶
    modal.querySelector('.modal-close-btn').onclick = () => this.closeModal('summary-editor-modal');
    modal.querySelector('#summary-editor-cancel').onclick = () => this.closeModal('summary-editor-modal');
    
    const saveBtn = modal.querySelector('#summary-editor-save');
    saveBtn.onclick = async () => {
        const newContent = textarea.value;
        saveBtn.textContent = 'ä¿å­˜ä¸­...';
        saveBtn.disabled = true;

        try {
            // åå‘æ›´æ–°æœ¬ä¸–å†ç¨‹
            await this.updateJourneyFromSummary(newContent, summaryType);
            
            // é‡æ–°ç”Ÿæˆæ€»ç»“
            await this.generateSmallSummary();
            await this.generateLargeSummary();

            this.showTemporaryMessage('ä¿å­˜å¹¶æ›´æ–°æˆåŠŸï¼', 'success');
            this.closeModal('summary-editor-modal');

            // åˆ·æ–°ä¸»æ¨¡æ€æ¡†çš„æ˜¾ç¤º
            this.updateSmallSummaryDisplay();
            this.updateLargeSummaryDisplay();

        } catch (error) {
            console.error('ä¿å­˜æ€»ç»“å¤±è´¥:', error);
            this.showTemporaryMessage(`ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
        } finally {
            saveBtn.textContent = 'ä¿å­˜æ›´æ”¹';
            saveBtn.disabled = false;
        }
    };
},

async updateJourneyFromSummary(summaryContent, summaryType) {
    const bookName = '1å½’å¢Ÿ';
    const index = this.unifiedIndex;
    const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';
    
    const allEntries = await TavernHelper.getLorebookEntries(bookName);
    const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);
    if (!journeyEntry) throw new Error('æ‰¾ä¸åˆ°â€œæœ¬ä¸–å†ç¨‹â€ä¸–ç•Œä¹¦ã€‚');
    
    let journeyEvents = this.parseJourneyEntry(journeyEntry.content);
    const summaryEvents = summaryType === 'small'
        ? summaryContent.split('\n\n').filter(Boolean)
        : summaryContent.split('\n').filter(Boolean);

    if (journeyEvents.length < summaryEvents.length) {
        console.warn('æ€»ç»“ä¸­çš„äº‹ä»¶æ•°é‡å¤šäºæœ¬ä¸–å†ç¨‹ï¼Œå¯èƒ½å¯¼è‡´éƒ¨åˆ†æ›´æ–°ä¸¢å¤±ã€‚');
    }

    // ä»åå¾€å‰åŒ¹é…å’Œæ›´æ–°
    const journeyLen = journeyEvents.length;
    const summaryLen = summaryEvents.length;
    for (let i = 0; i < summaryLen; i++) {
        const journeyIndex = journeyLen - 1 - i;
        const summaryIndex = summaryLen - 1 - i;
        if (journeyIndex < 0) break;

        const journeyEvent = journeyEvents[journeyIndex];
        const summaryText = summaryEvents[summaryIndex];

        if (summaryType === 'small') {
            const lines = summaryText.split('\n');
            const firstLineContent = lines[0].replace(/^.+?ï¼Œ/, '').trim();
            journeyEvent['é‡è¦ä¿¡æ¯'] = firstLineContent;
            delete journeyEvent['æš—çº¿ä¸ä¼ç¬”'];
            delete journeyEvent['è‡ªåŠ¨åŒ–ç³»ç»Ÿ'];
            lines.slice(1).forEach(line => {
                const parts = line.split('|');
                if (parts.length === 2) {
                    if (parts[0] === 'æš—çº¿ä¸ä¼ç¬”') journeyEvent['æš—çº¿ä¸ä¼ç¬”'] = parts[1];
                    if (parts[0] === 'è‡ªåŠ¨åŒ–ç³»ç»Ÿ') journeyEvent['è‡ªåŠ¨åŒ–ç³»ç»Ÿ'] = parts[1];
                }
            });
        } else { // large
            const contentWithoutDate = summaryText.replace(/^.+?ï¼Œ/, '').trim();
            journeyEvent['æè¿°'] = contentWithoutDate;
        }
    }
    
    const newJourneyContent = this.reconstructJourneyEntry(journeyEvents);
    await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newJourneyContent }]);
},
// æ–°å¢ï¼šæ›´æ–°åˆ†æ®µè®°å¿†æ¨¡æ€æ¡†ä¸­çš„ç« èŠ‚æ˜¾ç¤º
async updateUnifiedSummaryDisplay() {
    const displayEl = document.getElementById('unified-summary-display');
    if (!displayEl) return;

    displayEl.innerHTML = '<div style="color: #8b7355; text-align: center;">æ­£åœ¨åŠ è½½...</div>';

    try {
        const bookName = '1å½’å¢Ÿ';
        const currentIndex = this.unifiedIndex;

        // 1. å¹¶è¡Œè·å–æ‰€æœ‰éœ€è¦çš„æ•°æ®æº
        const entryNames = [
            currentIndex > 1 ? `æœ¬ä¸–å†ç¨‹(${currentIndex})` : 'æœ¬ä¸–å†ç¨‹',
            currentIndex > 1 ? `åˆ†æ®µæ­£æ–‡(${currentIndex})` : 'åˆ†æ®µæ­£æ–‡',
            currentIndex > 1 ? `å°æ€»ç»“(${currentIndex})` : 'å°æ€»ç»“',
            currentIndex > 1 ? `å¤§æ€»ç»“(${currentIndex})` : 'å¤§æ€»ç»“'
        ];

        const allEntries = await TavernHelper.getLorebookEntries(bookName);
        const [journeyEntry, segmentedEntry, smallSummaryEntry, largeSummaryEntry] = entryNames.map(name =>
            allEntries.find(entry => entry.comment === name)
        );

        console.log('[å½’å¢Ÿ-é¢„è§ˆç³»ç»Ÿ] æ•°æ®æºè·å–æƒ…å†µ:', {
            'æœ¬ä¸–å†ç¨‹': journeyEntry ? 'âœ…' : 'âŒ',
            'åˆ†æ®µæ­£æ–‡': segmentedEntry ? 'âœ…' : 'âŒ',
            'å°æ€»ç»“': smallSummaryEntry ? 'âœ…' : 'âŒ',
            'å¤§æ€»ç»“': largeSummaryEntry ? 'âœ…' : 'âŒ',
        });
        console.log('[å½’å¢Ÿ-é¢„è§ˆç³»ç»Ÿ] åŸå§‹æ•°æ®:', { journeyEntry, segmentedEntry, smallSummaryEntry, largeSummaryEntry });


        if (!journeyEntry || !journeyEntry.content) {
            displayEl.innerHTML = '<div class="modal-display-placeholder">â€œæœ¬ä¸–å†ç¨‹â€å†…å®¹ä¸ºç©º</div>';
            return;
        }

        const journeyEvents = this.parseJourneyEntry(journeyEntry.content);
        if (journeyEvents.length === 0) {
            displayEl.innerHTML = '<div class="modal-display-placeholder">æ— äº‹ä»¶å¯ä¾›é¢„è§ˆ</div>';
            return;
        }

        // 2. è§£æä¸‰å¤§äº§ç‰©çš„å†…å®¹
        const segmentedContent = segmentedEntry ? segmentedEntry.content.split('\nâ€”â€”\n') : [];
        const smallSummaryContent = smallSummaryEntry ? smallSummaryEntry.content.split('\nâ€”â€”\n') : [];
        const largeSummaryContent = largeSummaryEntry ? largeSummaryEntry.content.split('\nâ€”â€”\n') : [];

        console.log('[å½’å¢Ÿ-é¢„è§ˆç³»ç»Ÿ] è§£æåå†…å®¹:', {
            journeyEvents,
            segmentedContent,
            smallSummaryContent,
            largeSummaryContent
        });

        const segmentedCount = parseInt(document.getElementById('segmented-memory-count').value, 10) || 0;
        const smallSummaryCount = parseInt(document.getElementById('small-summary-count').value, 10) || 0;
        const totalEvents = journeyEvents.length;
        const segmentedStartIndex = Math.max(0, totalEvents - segmentedCount);
        const smallSummaryStartIndex = Math.max(0, totalEvents - segmentedCount - smallSummaryCount);

        const reversedEvents = journeyEvents.slice().reverse();
        const html = reversedEvents.map((event, reversedIndex) => {
            const originalIndex = totalEvents - 1 - reversedIndex; // è·å–åŸå§‹ç´¢å¼•
            let tag = '';
            let tagColor = '';
            let contentToShow = '<div class="summary-detail-placeholder">æ— å¯¹åº”å†…å®¹</div>';

            // 3. æ ¹æ®åŸå§‹ç´¢å¼•è¿›è¡Œæ¸…æ™°çš„åˆ¤æ–­
            if (originalIndex >= segmentedStartIndex) {
                tag = 'åˆ†æ®µæ­£æ–‡';
                tagColor = '#C9AA71';
                const contentIndex = originalIndex - segmentedStartIndex;
                if (segmentedContent[contentIndex]) {
                    contentToShow = `<div class="summary-detail-content text-language">${_.escape(segmentedContent[contentIndex]).replace(/\n/g, '<br>')}</div>`;
                }
            } else if (originalIndex >= smallSummaryStartIndex) {
                tag = 'å°æ€»ç»“';
                tagColor = '#A9C971';
                const contentIndex = originalIndex - smallSummaryStartIndex;
                if (smallSummaryContent[contentIndex]) {
                    contentToShow = `<div class="summary-detail-content text-psychology">${_.escape(smallSummaryContent[contentIndex]).replace(/\n/g, '<br>')}</div>`;
                }
            } else {
                tag = 'å¤§æ€»ç»“';
                tagColor = '#71A9C9';
                const contentIndex = originalIndex;
                if (largeSummaryContent[contentIndex]) {
                    contentToShow = `<div class="summary-detail-content text-scenery">${_.escape(largeSummaryContent[contentIndex]).replace(/\n/g, '<br>')}</div>`;
                }
            }
            
            const chapterNumber = event['åºå·'] || (originalIndex + 1);
            const chapterTitle = event['æ ‡é¢˜'] || 'æ— æ ‡é¢˜';
            const title = `ç¬¬${chapterNumber}ç«  ${chapterTitle}`;

            // 4. æ„å»ºUIï¼Œå†…å®¹é»˜è®¤å±•å¼€
            return `
                <div class="summary-item">
                    <div class="summary-header">
                        <span class="summary-arrow">â–¶</span>
                        <span class="summary-title">${_.escape(title)}</span>
                        <span class="summary-tag" style="background-color: ${tagColor};">${tag}</span>
                    </div>
                    <div class="summary-details" style="display: none;">
                        ${contentToShow}
                    </div>
                </div>
            `;
        }).join('');

        displayEl.innerHTML = html;
    } catch (error) {
        console.error('æ›´æ–°åˆ†æ®µè®°å¿†é¢„è§ˆå¤±è´¥:', error);
        displayEl.innerHTML = `<div style="color: #ff6b6b; text-align: center;">åŠ è½½å¤±è´¥: ${error.message}</div>`;
    }
},

          // æ–°å¢ï¼šç”Ÿæˆ/æ›´æ–°åˆ†æ®µè®°å¿†çš„æ ¸å¿ƒé€»è¾‘
          async generateSegmentedMemory(isPolling = false) {
            const statusEl = document.getElementById('segmented-memory-status');
            const countInput = document.getElementById('segmented-memory-count');
            const generateBtn = document.getElementById('btn-generate-segmented-memory');

            if (!statusEl || !countInput || !generateBtn) {
                this.showTemporaryMessage('UIå…ƒç´ ç¼ºå¤±ï¼Œæ“ä½œä¸­æ–­', 'error');
                return;
            }

            try {
                if (!isPolling) {
                    generateBtn.disabled = true;
                    generateBtn.textContent = 'æ­£åœ¨ç”Ÿæˆ...';
                    statusEl.textContent = 'æ­£åœ¨è¯»å–å°è¯´æ¨¡å¼æ•°æ®...';
                }

                const count = parseInt(countInput.value, 10);
                if (isNaN(count) || count < 0) {
                    throw new Error('è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„éè´Ÿæ•´æ•°');
                }

                const bookName = '1å½’å¢Ÿ';
                const allEntries = await TavernHelper.getLorebookEntries(bookName);

                if (!allEntries || allEntries.length === 0) {
                    throw new Error(`ä¸–ç•Œä¹¦ "${bookName}" ä¸­æ²¡æœ‰æ¡ç›®ã€‚`);
                }

                // æ ¹æ®å½“å‰è¯»å†™åºå·ï¼Œç²¾ç¡®å®šä½æºâ€œå°è¯´æ¨¡å¼â€æ¡ç›®
                const currentIndex = this.unifiedIndex;
                const sourceEntryName = currentIndex > 1 ? `å°è¯´æ¨¡å¼(${currentIndex})` : 'å°è¯´æ¨¡å¼';
                const sourceEntry = allEntries.find(entry => entry.comment === sourceEntryName);

                if (!sourceEntry || !sourceEntry.content) {
                    throw new Error(`æœªæ‰¾åˆ°æˆ–å†…å®¹ä¸ºç©ºçš„æºæ¡ç›®: "${sourceEntryName}"`);
                }

                // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åˆ†å‰²ç« èŠ‚
                const chapters = sourceEntry.content.split(/(?=ç¬¬\d+ç« \s+.*)/g).filter(c => c.trim() !== '');

                // ä»ç« èŠ‚æœ«å°¾æå–æœ€æ–°çš„Xä¸ª
                // ä¿®å¤ï¼šå½“countä¸º0æ—¶ï¼Œslice(0)ä¼šè¿”å›æ•´ä¸ªæ•°ç»„ï¼Œè€Œä¸æ˜¯ç©ºæ•°ç»„
                const latestChapters = count === 0 ? [] : chapters.slice(-count);

                // åˆå¹¶å†…å®¹
                const combinedContent = latestChapters.join('\nâ€”â€”\n');

                if (!isPolling) {
                    statusEl.textContent = 'æ­£åœ¨å†™å…¥â€œåˆ†æ®µæ­£æ–‡â€...';
                }

                // æ ¹æ®ç»Ÿä¸€åºå·ç”Ÿæˆç›®æ ‡æ¡ç›®åç§°
                const targetEntryName = currentIndex > 1 ? `åˆ†æ®µæ­£æ–‡(${currentIndex})` : 'åˆ†æ®µæ­£æ–‡';

                // æŸ¥æ‰¾ç°æœ‰çš„â€œåˆ†æ®µæ­£æ–‡â€æ¡ç›®
                const existingEntry = allEntries.find(entry => entry.comment === targetEntryName);

                if (existingEntry) {
                    // ä»…åœ¨å†…å®¹æœ‰å˜åŒ–æ—¶æ‰æ›´æ–°ï¼Œé¿å…ä¸å¿…è¦çš„å†™å…¥
                    if (existingEntry.content !== combinedContent) {
                        await TavernHelper.setLorebookEntries(bookName, [{
                            uid: existingEntry.uid,
                            content: combinedContent,
                        }]);
                    }
                } else {
                    // åˆ›å»ºæ–°æ¡ç›®
                    await TavernHelper.createLorebookEntries(bookName, [{
                        comment: targetEntryName,
                        content: combinedContent,
                        keys: [], // ä½œä¸ºä¸€ä¸ªå¸¸é‡æ¡ç›®ï¼Œä¸éœ€è¦å…³é”®è¯
                        type: 'constant',
                        enabled: true,
                    }]);
                }

                const successMsg = `åˆ†æ®µè®°å¿†å·²æ›´æ–°ï¼Œå…±èšåˆ ${latestChapters.length} ä¸ªæœ€æ–°ç« èŠ‚ã€‚`;
                if (!isPolling) {
                    statusEl.textContent = successMsg;
                    this.showTemporaryMessage(successMsg, 'success');
                } else {
                    console.log(`[å½’å¢Ÿ-åˆ†æ®µè®°å¿†] è‡ªåŠ¨æ›´æ–°æˆåŠŸï¼Œèšåˆ ${latestChapters.length} ä¸ªç« èŠ‚ã€‚`);
                }

                // æ–°å¢ï¼šå¦‚æœåˆ†æ®µè®°å¿†çª—å£æ˜¯æ‰“å¼€çš„ï¼Œåˆ™é™é»˜åˆ·æ–°ç« èŠ‚åˆ—è¡¨æ˜¾ç¤º
                const modal = document.getElementById('segmented-memory-modal');
                if (modal && modal.style.display !== 'none') {
                    this.updateUnifiedSummaryDisplay();
                }

            } catch (error) {
                console.error('ç”Ÿæˆåˆ†æ®µè®°å¿†æ—¶å‡ºé”™:', error);
                if (!isPolling) {
                    const errorMsg = `é”™è¯¯: ${error.message}`;
                    statusEl.textContent = errorMsg;
                    this.showTemporaryMessage(errorMsg, 'error', 5000);
                }
            } finally {
                if (!isPolling) {
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'ç«‹å³ç”Ÿæˆ/æ›´æ–°';
                }
            }
          },

          // æ–°å¢ï¼šç”Ÿæˆ/æ›´æ–°å°æ€»ç»“çš„æ ¸å¿ƒé€»è¾‘
          async generateSmallSummary(isPolling = false) {
            const statusEl = document.getElementById('segmented-memory-status');
            const smallSummaryCountInput = document.getElementById('small-summary-count');
            const segmentedCountInput = document.getElementById('segmented-memory-count'); // è·å–åˆ†æ®µæ­£æ–‡çš„æ•°é‡è¾“å…¥æ¡†

            if (!smallSummaryCountInput || !segmentedCountInput) {
                this.showTemporaryMessage('UIå…ƒç´ ç¼ºå¤±ï¼Œæ“ä½œä¸­æ–­', 'error');
                return;
            }

            try {
                if (!isPolling && statusEl) {
                    statusEl.textContent = 'æ­£åœ¨è¯»å–(å°æ€»ç»“)...';
                }

                const smallSummaryCount = parseInt(smallSummaryCountInput.value, 10);
                const segmentedCount = parseInt(segmentedCountInput.value, 10); // è·å–åˆ†æ®µæ­£æ–‡çš„æ•°é‡

                if (isNaN(smallSummaryCount) || smallSummaryCount < 0 || isNaN(segmentedCount) || segmentedCount < 0) {
                    throw new Error('è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„éè´Ÿæ•´æ•°');
                }

                const bookName = '1å½’å¢Ÿ';
                const allEntries = await TavernHelper.getLorebookEntries(bookName);

                if (!allEntries || allEntries.length === 0) {
                    throw new Error(`ä¸–ç•Œä¹¦ "${bookName}" ä¸­æ²¡æœ‰æ¡ç›®ã€‚`);
                }

                const currentIndex = this.unifiedIndex;
                const sourceEntryName = currentIndex > 1 ? `æœ¬ä¸–å†ç¨‹(${currentIndex})` : 'æœ¬ä¸–å†ç¨‹';
                const sourceEntry = allEntries.find(entry => entry.comment === sourceEntryName);

                if (!sourceEntry || !sourceEntry.content) {
                    throw new Error(`æœªæ‰¾åˆ°æˆ–å†…å®¹ä¸ºç©ºçš„æºæ¡ç›®: "${sourceEntryName}"`);
                }

                const journeyEvents = this.parseJourneyEntry(sourceEntry.content);
                
                // æ–°çš„åˆ‡ç‰‡é€»è¾‘ï¼šæ›´ç¨³å¥ã€æ›´æ¸…æ™°
                const totalEvents = journeyEvents.length;
                let startIndex = totalEvents - segmentedCount - smallSummaryCount;
                let endIndex = totalEvents - segmentedCount;

                // è¾¹ç•Œæ¡ä»¶æ£€æŸ¥ï¼Œç¡®ä¿ç´¢å¼•ä¸ä¼šå°äº0
                if (startIndex < 0) startIndex = 0;
                if (endIndex < 0) endIndex = 0;
                
                const latestEvents = smallSummaryCount === 0 ? [] : journeyEvents.slice(startIndex, endIndex);


                const formattedEvents = latestEvents.map(event => {
                    const parts = [];
                    // æ ¼å¼ï¼šxxxï¼ˆæ—¥æœŸï¼‰ï¼Œxxxï¼ˆé‡è¦ä¿¡æ¯ï¼‰
                    if (event['æ—¥æœŸ'] && event['é‡è¦ä¿¡æ¯']) {
                        parts.push(`${event['æ—¥æœŸ']}ï¼Œ${event['é‡è¦ä¿¡æ¯']}`);
                    } else if (event['æ—¥æœŸ']) {
                        parts.push(event['æ—¥æœŸ']);
                    } else if (event['é‡è¦ä¿¡æ¯']) {
                        parts.push(event['é‡è¦ä¿¡æ¯']);
                    }

                    // æ ¼å¼ï¼šæš—çº¿ä¸ä¼ç¬”|xxx
                    if (event['æš—çº¿ä¸ä¼ç¬”']) {
                        parts.push(`æš—çº¿ä¸ä¼ç¬”|${event['æš—çº¿ä¸ä¼ç¬”']}`);
                    }
                    // æ ¼å¼ï¼šè‡ªåŠ¨åŒ–ç³»ç»Ÿ|xxx
                    if (event['è‡ªåŠ¨åŒ–ç³»ç»Ÿ']) {
                        parts.push(`è‡ªåŠ¨åŒ–ç³»ç»Ÿ|${event['è‡ªåŠ¨åŒ–ç³»ç»Ÿ']}`);
                    }
                    return parts.join('\n');
                }).filter(Boolean); // è¿‡æ»¤æ‰å¯èƒ½ä¸ºç©ºçš„äº‹ä»¶å­—ç¬¦ä¸²
                const combinedContent = formattedEvents.join('\nâ€”â€”\n'); // ä½¿ç”¨æ–°çš„åˆ†éš”ç¬¦
                
                if (!isPolling) {
                    statusEl.textContent = 'æ­£åœ¨å†™å…¥â€œå°æ€»ç»“â€...';
                }

                const targetEntryName = currentIndex > 1 ? `å°æ€»ç»“(${currentIndex})` : 'å°æ€»ç»“';
                const existingEntry = allEntries.find(entry => entry.comment === targetEntryName);

                if (existingEntry) {
                    if (existingEntry.content !== combinedContent) {
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: existingEntry.uid, content: combinedContent }]);
                    }
                } else {
                    await TavernHelper.createLorebookEntries(bookName, [{
                        comment: targetEntryName,
                        content: combinedContent,
                        keys: [],
                        type: 'constant',
                        enabled: true,
                    }]);
                }

                const successMsg = `å°æ€»ç»“å·²æ›´æ–°ï¼Œå…±èšåˆ ${latestEvents.length} ä¸ªæœ€æ–°äº‹ä»¶ã€‚`;
                if (!isPolling) {
                    statusEl.textContent = successMsg;
                    this.showTemporaryMessage(successMsg, 'success');
                } else {
                    console.log(`[å½’å¢Ÿ-å°æ€»ç»“] è‡ªåŠ¨æ›´æ–°æˆåŠŸï¼Œèšåˆ ${latestEvents.length} ä¸ªäº‹ä»¶ã€‚`);
                }

            } catch (error) {
                console.error('ç”Ÿæˆå°æ€»ç»“æ—¶å‡ºé”™:', error);
                if (!isPolling) {
                    const errorMsg = `é”™è¯¯: ${error.message}`;
                    statusEl.textContent = errorMsg;
                    this.showTemporaryMessage(errorMsg, 'error', 5000);
                }
            } finally {
                // æŒ‰é’®çŠ¶æ€ç®¡ç†å·²ç§»è‡³è°ƒç”¨å¤„
            }
          },

          // æ–°å¢ï¼šç”Ÿæˆ/æ›´æ–°å¤§æ€»ç»“çš„æ ¸å¿ƒé€»è¾‘
          async generateLargeSummary(isPolling = false) {
            const statusEl = document.getElementById('segmented-memory-status');
            const smallSummaryCountInput = document.getElementById('small-summary-count');
            const segmentedCountInput = document.getElementById('segmented-memory-count');

            try {
                if (!isPolling && statusEl) {
                    statusEl.textContent = 'æ­£åœ¨è¯»å–(å¤§æ€»ç»“)...';
                }

                const smallSummaryCount = parseInt(smallSummaryCountInput.value, 10);
                const segmentedCount = parseInt(segmentedCountInput.value, 10);

                if (isNaN(smallSummaryCount) || smallSummaryCount < 0 || isNaN(segmentedCount) || segmentedCount < 0) {
                    throw new Error('è·å–çš„æ•°å€¼æ— æ•ˆ');
                }

                const bookName = '1å½’å¢Ÿ';
                const allEntries = await TavernHelper.getLorebookEntries(bookName);

                if (!allEntries || allEntries.length === 0) {
                    throw new Error(`ä¸–ç•Œä¹¦ "${bookName}" ä¸­æ²¡æœ‰æ¡ç›®ã€‚`);
                }

                const currentIndex = this.unifiedIndex;
                const sourceEntryName = currentIndex > 1 ? `æœ¬ä¸–å†ç¨‹(${currentIndex})` : 'æœ¬ä¸–å†ç¨‹';
                const sourceEntry = allEntries.find(entry => entry.comment === sourceEntryName);

                if (!sourceEntry || !sourceEntry.content) {
                    throw new Error(`æœªæ‰¾åˆ°æˆ–å†…å®¹ä¸ºç©ºçš„æºæ¡ç›®: "${sourceEntryName}"`);
                }

                const journeyEvents = this.parseJourneyEntry(sourceEntry.content);
                
                // æ–°çš„åˆ‡ç‰‡é€»è¾‘
                const end = -(segmentedCount + smallSummaryCount);
                const largeSummaryEvents = journeyEvents.slice(0, end < 0 ? end : undefined);

                const formattedEvents = largeSummaryEvents.map(event => {
                    // æ ¼å¼ï¼šxxxï¼ˆæ—¥æœŸï¼‰ï¼Œxxxï¼ˆæè¿°ï¼‰
                    if (event['æ—¥æœŸ'] && event['æè¿°']) {
                        return `${event['æ—¥æœŸ']}ï¼Œ${event['æè¿°']}`;
                    }
                    return null; // å¦‚æœç¼ºå°‘ä»»ä¸€å­—æ®µï¼Œåˆ™å¿½ç•¥æ­¤äº‹ä»¶
                }).filter(Boolean); // è¿‡æ»¤æ‰ä¸ºnullçš„äº‹ä»¶
                const combinedContent = formattedEvents.join('\nâ€”â€”\n'); // ä½¿ç”¨æ–°çš„åˆ†éš”ç¬¦
                
                if (!isPolling) {
                    statusEl.textContent = 'æ­£åœ¨å†™å…¥â€œå¤§æ€»ç»“â€...';
                }

                const targetEntryName = currentIndex > 1 ? `å¤§æ€»ç»“(${currentIndex})` : 'å¤§æ€»ç»“';
                const existingEntry = allEntries.find(entry => entry.comment === targetEntryName);

                if (existingEntry) {
                    if (existingEntry.content !== combinedContent) {
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: existingEntry.uid, content: combinedContent }]);
                    }
                } else {
                    await TavernHelper.createLorebookEntries(bookName, [{
                        comment: targetEntryName,
                        content: combinedContent,
                        keys: [],
                        type: 'constant',
                        enabled: true,
                    }]);
                }

                const successMsg = `å¤§æ€»ç»“å·²æ›´æ–°ï¼Œå…±èšåˆ ${journeyEvents.length} ä¸ªäº‹ä»¶ã€‚`;
                if (!isPolling) {
                    statusEl.textContent = successMsg;
                    this.showTemporaryMessage(successMsg, 'success');
                } else {
                    console.log(`[å½’å¢Ÿ-å¤§æ€»ç»“] è‡ªåŠ¨æ›´æ–°æˆåŠŸï¼Œèšåˆ ${journeyEvents.length} ä¸ªäº‹ä»¶ã€‚`);
                }

            } catch (error) {
                console.error('ç”Ÿæˆå¤§æ€»ç»“æ—¶å‡ºé”™:', error);
                if (!isPolling) {
                    const errorMsg = `é”™è¯¯: ${error.message}`;
                    statusEl.textContent = errorMsg;
                    this.showTemporaryMessage(errorMsg, 'error', 5000);
                }
            } finally {
                // æŒ‰é’®çŠ¶æ€ç®¡ç†å·²ç§»è‡³è°ƒç”¨å¤„
            }
          },

          // --- æ–°å¢ï¼šåˆ†æ®µè®°å¿†è‡ªåŠ¨ç”Ÿæˆç›¸å…³ ---
          startSegmentedMemoryPolling() {
              this.stopSegmentedMemoryPolling();
              this.segmentedMemoryIntervalId = setInterval(async () => {
                  await this.generateSegmentedMemory(true);
                  if (this.isSmallSummaryAutoOn) {
                      await this.generateSmallSummary(true);
                  }
                  if (this.isLargeSummaryAutoOn) {
                      await this.generateLargeSummary(true);
                  }
                  console.log('[å½’å¢Ÿ] è½®è¯¢æ›´æ–°å®Œæˆã€‚');
              }, 60000); // æ¯60ç§’æ£€æŸ¥ä¸€æ¬¡
          },

          stopSegmentedMemoryPolling() {
              if (this.segmentedMemoryIntervalId) {
                  clearInterval(this.segmentedMemoryIntervalId);
                  this.segmentedMemoryIntervalId = null;
              }
          },

          saveSegmentedMemoryState() {
              try {
                  localStorage.setItem('guixu_segmented_memory_enabled', this.isSegmentedMemoryAutoGenerateEnabled);
              } catch (e) {
                  console.error('ä¿å­˜åˆ†æ®µè®°å¿†çŠ¶æ€å¤±è´¥:', e);
              }
          },

          loadSegmentedMemoryState() {
              try {
                  const savedState = localStorage.getItem('guixu_segmented_memory_enabled');
                  this.isSegmentedMemoryAutoGenerateEnabled = savedState === 'true';
                  if (this.isSegmentedMemoryAutoGenerateEnabled) {
                      this.startSegmentedMemoryPolling();
                  }
              } catch (e) {
                  console.error('åŠ è½½åˆ†æ®µè®°å¿†çŠ¶æ€å¤±è´¥:', e);
                  this.isSegmentedMemoryAutoGenerateEnabled = false;
              }
          },

          saveSmallSummaryState() {
              try {
                  localStorage.setItem('guixu_small_summary_enabled', this.isSmallSummaryAutoOn);
              } catch (e) {
                  console.error('ä¿å­˜å°æ€»ç»“çŠ¶æ€å¤±è´¥:', e);
              }
          },

          loadSegmentedMemoryCounts() {
              try {
                  const segmentedCount = localStorage.getItem('guixu_segmented_memory_count');
                  const smallSummaryCount = localStorage.getItem('guixu_small_summary_count');
                  
                  const segmentedCountInput = document.getElementById('segmented-memory-count');
                  if (segmentedCountInput && segmentedCount !== null) {
                      segmentedCountInput.value = segmentedCount;
                  }

                  const smallSummaryCountInput = document.getElementById('small-summary-count');
                  if (smallSummaryCountInput && smallSummaryCount !== null) {
                      smallSummaryCountInput.value = smallSummaryCount;
                  }
              } catch (e) {
                  console.error('åŠ è½½åˆ†æ®µè®°å¿†ä¿ç•™æ•°å¤±è´¥:', e);
              }
          },
          loadSegmentedMemoryCounts() {
              try {
                  const segmentedCount = localStorage.getItem('guixu_segmented_memory_count');
                  const smallSummaryCount = localStorage.getItem('guixu_small_summary_count');
                  
                  const segmentedCountInput = document.getElementById('segmented-memory-count');
                  if (segmentedCountInput && segmentedCount !== null) {
                      segmentedCountInput.value = segmentedCount;
                  }

                  const smallSummaryCountInput = document.getElementById('small-summary-count');
                  if (smallSummaryCountInput && smallSummaryCount !== null) {
                      smallSummaryCountInput.value = smallSummaryCount;
                  }
              } catch (e) {
                  console.error('åŠ è½½åˆ†æ®µè®°å¿†ä¿ç•™æ•°å¤±è´¥:', e);
              }
          },

          loadSmallSummaryState() {
              try {
                  const savedState = localStorage.getItem('guixu_small_summary_enabled');
                  this.isSmallSummaryAutoOn = savedState === 'true';
              } catch (e) {
                  console.error('åŠ è½½å°æ€»ç»“çŠ¶æ€å¤±è´¥:', e);
                  this.isSmallSummaryAutoOn = false;
              }
          },

          saveLargeSummaryState() {
              try {
                  localStorage.setItem('guixu_large_summary_enabled', this.isLargeSummaryAutoOn);
              } catch (e) {
                  console.error('ä¿å­˜å¤§æ€»ç»“çŠ¶æ€å¤±è´¥:', e);
              }
          },

          loadLargeSummaryState() {
              try {
                  const savedState = localStorage.getItem('guixu_large_summary_enabled');
                  this.isLargeSummaryAutoOn = savedState === 'true';
              } catch (e) {
                  console.error('åŠ è½½å¤§æ€»ç»“çŠ¶æ€å¤±è´¥:', e);
                  this.isLargeSummaryAutoOn = false;
              }
          },
// ===åˆ†æ®µè®°å¿†æ¨¡å—ç»“æŸ===



// ===ä¸–ç•Œä¹¦ç®¡ç†æ¨¡å—å¼€å§‹===
          // æ˜¾ç¤ºä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
          showWorldbookManager() {
            console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å¼€å§‹æ˜¾ç¤ºä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢');
            
            // å…ˆæ‰“å¼€æ¨¡æ€æ¡†
            this.openModal('worldbook-manager-modal');
            
            // æ£€æŸ¥æ¨¡æ€æ¡†æ˜¯å¦æ­£ç¡®æ˜¾ç¤º
            const modal = document.getElementById('worldbook-manager-modal');
            if (!modal) {
              console.error('[ä¸–ç•Œä¹¦ç®¡ç†] æ‰¾ä¸åˆ°ä¸–ç•Œä¹¦ç®¡ç†æ¨¡æ€æ¡†');
              this.showTemporaryMessage('ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢åŠ è½½å¤±è´¥');
              return;
            }
            
            console.log('[ä¸–ç•Œä¹¦ç®¡ç†] æ¨¡æ€æ¡†æ˜¾ç¤ºçŠ¶æ€:', modal.style.display);
            
            // åˆå§‹åŒ–ç•Œé¢çŠ¶æ€
            this.worldbookManagerState = {
              allEntries: [],
              filteredEntries: [],
              currentFilter: 'all',
              currentPrefix: ''
            };
            
            // å»¶è¿Ÿç»‘å®šäº‹ä»¶ç›‘å¬å™¨å’ŒåŠ è½½æ•°æ®ï¼Œç¡®ä¿æ¨¡æ€æ¡†å·²å®Œå…¨æ˜¾ç¤º
            setTimeout(() => {
              console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å¼€å§‹ç»‘å®šäº‹ä»¶ç›‘å¬å™¨');
              this.bindWorldbookManagerEvents();
              
              console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å¼€å§‹åŠ è½½ä¸–ç•Œä¹¦æ¡ç›®');
              this.loadWorldbookEntries();
            }, 100);
          },

          // åŠ è½½ä¸–ç•Œä¹¦æ¡ç›®
          async loadWorldbookEntries() {
            console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å¼€å§‹åŠ è½½ä¸–ç•Œä¹¦æ¡ç›®');
            
            const listContainer = document.getElementById('worldbook-entries-list');
            if (!listContainer) {
              console.error('[ä¸–ç•Œä¹¦ç®¡ç†] æ‰¾ä¸åˆ°æ¡ç›®åˆ—è¡¨å®¹å™¨ worldbook-entries-list');
              return;
            }
            
            console.log('[ä¸–ç•Œä¹¦ç®¡ç†] æ‰¾åˆ°æ¡ç›®åˆ—è¡¨å®¹å™¨');
            
            try {
              listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #8b7355;"><div style="font-size: 24px; margin-bottom: 10px;">â³</div>æ­£åœ¨åŠ è½½ä¸–ç•Œä¹¦æ¡ç›®...</div>';
              
              const bookName = '1å½’å¢Ÿ';
              console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å¼€å§‹è°ƒç”¨ TavernHelper.getLorebookEntriesï¼Œä¹¦å:', bookName);
              
              const entries = await TavernHelper.getLorebookEntries(bookName);
              console.log('[ä¸–ç•Œä¹¦ç®¡ç†] è·å–åˆ°æ¡ç›®æ•°é‡:', entries ? entries.length : 0);
              
              if (!entries || entries.length === 0) {
                console.log('[ä¸–ç•Œä¹¦ç®¡ç†] æ²¡æœ‰æ‰¾åˆ°ä¸–ç•Œä¹¦æ¡ç›®');
                listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #8b7355;"><div style="font-size: 48px; margin-bottom: 10px;">ğŸ“š</div>æš‚æ— ä¸–ç•Œä¹¦æ¡ç›®</div>';
                this.updateWorldbookStats([], []);
                return;
              }
              
              // ä¿å­˜æ‰€æœ‰æ¡ç›®
              this.worldbookManagerState.allEntries = entries;
              console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å·²ä¿å­˜æ¡ç›®åˆ°çŠ¶æ€ç®¡ç†');
              
              // åº”ç”¨å½“å‰ç­›é€‰
              console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å¼€å§‹åº”ç”¨ç­›é€‰');
              this.applyWorldbookFilter();
              
            } catch (error) {
              console.error('[ä¸–ç•Œä¹¦ç®¡ç†] åŠ è½½ä¸–ç•Œä¹¦æ¡ç›®å¤±è´¥:', error);
              listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #ff6b6b;"><div style="font-size: 48px; margin-bottom: 10px;">âŒ</div>åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•<br><small>é”™è¯¯: ' + error.message + '</small></div>';
              this.updateWorldbookStats([], []);
            }
          },

          // åº”ç”¨ç­›é€‰æ¡ä»¶
          applyWorldbookFilter() {
            if (!this.worldbookManagerState) return;
            
            const filterType = document.getElementById('worldbook-filter-type')?.value || 'all';
            const prefixFilter = document.getElementById('worldbook-prefix-filter')?.value.trim() || '';
            
            let filtered = [...this.worldbookManagerState.allEntries];
            
            // æŒ‰ç±»å‹ç­›é€‰
            switch (filterType) {
              case 'journey':
                filtered = filtered.filter(entry =>
                  entry.comment && (entry.comment.includes('æœ¬ä¸–å†ç¨‹') || entry.comment.includes('å†ç¨‹'))
                );
                break;
              case 'pastlife':
                filtered = filtered.filter(entry =>
                  entry.comment && (entry.comment.includes('å¾€ä¸–æ¶Ÿæ¼ª') || entry.comment.includes('æ¶Ÿæ¼ª'))
                );
                break;
              case 'bracket':
                filtered = filtered.filter(entry =>
                  entry.comment && entry.comment.includes('ã€') && entry.comment.includes('ã€‘')
                );
                break;
              case 'enabled':
                filtered = filtered.filter(entry => entry.enabled);
                break;
              case 'disabled':
                filtered = filtered.filter(entry => !entry.enabled);
                break;
              case 'all':
              default:
                // ä¸ç­›é€‰
                break;
            }
            
            // æŒ‰å‰ç¼€ç­›é€‰
            if (prefixFilter) {
              filtered = filtered.filter(entry =>
                entry.comment && entry.comment.includes(prefixFilter)
              );
            }
            
            this.worldbookManagerState.filteredEntries = filtered;
            this.worldbookManagerState.currentFilter = filterType;
            this.worldbookManagerState.currentPrefix = prefixFilter;
            
            // æ¸²æŸ“ç­›é€‰åçš„æ¡ç›®
            this.renderWorldbookEntries(filtered);
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            this.updateWorldbookStats(this.worldbookManagerState.allEntries, filtered);
          },

          // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
          updateWorldbookStats(allEntries, filteredEntries) {
            const totalCount = allEntries.length;
            const enabledCount = allEntries.filter(e => e.enabled).length;
            const disabledCount = totalCount - enabledCount;
            const filteredCount = filteredEntries.length;
            
            document.getElementById('stats-total').textContent = totalCount;
            document.getElementById('stats-enabled').textContent = enabledCount;
            document.getElementById('stats-disabled').textContent = disabledCount;
            document.getElementById('stats-filtered').textContent = filteredCount;
          },

          // æ¸²æŸ“ä¸–ç•Œä¹¦æ¡ç›®åˆ—è¡¨
          renderWorldbookEntries(entries) {
            const listContainer = document.getElementById('worldbook-entries-list');
            if (!listContainer) return;
            
            if (!entries || entries.length === 0) {
              listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #8b7355;"><div style="font-size: 48px; margin-bottom: 10px;">ğŸ”</div>æ²¡æœ‰ç¬¦åˆç­›é€‰æ¡ä»¶çš„æ¡ç›®</div>';
              return;
            }
            
            listContainer.innerHTML = '';
            
            entries.forEach((entry, index) => {
              const entryDiv = document.createElement('div');
              entryDiv.className = 'worldbook-entry-item';
              entryDiv.style.cssText = `
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 12px;
                margin: 8px;
                background: rgba(26, 26, 46, 0.4);
                border-radius: 6px;
                border: 1px solid ${entry.enabled ? '#4a9eff' : '#8b7355'};
                transition: all 0.2s ease;
              `;
              
              // é¼ æ ‡æ‚¬æµ®æ•ˆæœ
              entryDiv.addEventListener('mouseenter', () => {
                entryDiv.style.background = 'rgba(26, 26, 46, 0.6)';
                entryDiv.style.borderColor = entry.enabled ? '#5ba0ff' : '#c9aa71';
              });
              entryDiv.addEventListener('mouseleave', () => {
                entryDiv.style.background = 'rgba(26, 26, 46, 0.4)';
                entryDiv.style.borderColor = entry.enabled ? '#4a9eff' : '#8b7355';
              });
              
              // å·¦ä¾§ä¿¡æ¯åŒºåŸŸ
              const infoDiv = document.createElement('div');
              infoDiv.style.cssText = 'flex: 1; min-width: 0; margin-right: 15px;';
              
              // åºå·å’Œæ ‡é¢˜
              const titleDiv = document.createElement('div');
              titleDiv.style.cssText = 'display: flex; align-items: center; margin-bottom: 4px;';
              
              const indexSpan = document.createElement('span');
              indexSpan.style.cssText = `
                display: inline-block;
                width: 30px;
                height: 20px;
                line-height: 20px;
                text-align: center;
                background: ${entry.enabled ? '#4a9eff' : '#8b7355'};
                color: white;
                font-size: 10px;
                border-radius: 10px;
                margin-right: 8px;
                font-weight: bold;
              `;
              indexSpan.textContent = (index + 1).toString();
              
              const titleSpan = document.createElement('span');
              titleSpan.style.cssText = `
                color: ${entry.enabled ? '#4a9eff' : '#c9aa71'};
                font-size: 13px;
                font-weight: bold;
                flex: 1;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
              `;
              titleSpan.textContent = entry.comment || 'æœªå‘½åæ¡ç›®';
              titleSpan.title = entry.comment || 'æœªå‘½åæ¡ç›®';
              
              titleDiv.appendChild(indexSpan);
              titleDiv.appendChild(titleSpan);
              
              // çŠ¶æ€å’Œç±»å‹ä¿¡æ¯
              const metaDiv = document.createElement('div');
              metaDiv.style.cssText = 'display: flex; align-items: center; gap: 8px;';
              
              const statusSpan = document.createElement('span');
              statusSpan.style.cssText = `
                color: ${entry.enabled ? '#90ee90' : '#ff6b6b'};
                font-size: 11px;
                font-weight: bold;
              `;
              statusSpan.textContent = entry.enabled ? 'âœ“ å·²å¯ç”¨' : 'âœ— å·²ç¦ç”¨';
              
              // æ¡ç›®ç±»å‹æ ‡ç­¾
              const typeSpan = document.createElement('span');
              let typeText = 'æ™®é€š';
              let typeColor = '#888';
              
              if (entry.comment) {
                if (entry.comment.includes('æœ¬ä¸–å†ç¨‹') || entry.comment.includes('å†ç¨‹')) {
                  typeText = 'æœ¬ä¸–å†ç¨‹';
                  typeColor = '#007bff';
                } else if (entry.comment.includes('å¾€ä¸–æ¶Ÿæ¼ª') || entry.comment.includes('æ¶Ÿæ¼ª')) {
                  typeText = 'å¾€ä¸–æ¶Ÿæ¼ª';
                  typeColor = '#9932cc';
                } else if (entry.comment.includes('ã€') && entry.comment.includes('ã€‘')) {
                  const match = entry.comment.match(/ã€([^ã€‘]+)ã€‘/);
                  if (match) {
                    typeText = `ã€${match[1]}ã€‘`;
                    typeColor = '#28a745';
                  }
                }
              }
              
              typeSpan.style.cssText = `
                background: rgba(${typeColor === '#007bff' ? '0, 123, 255' :
                                  typeColor === '#9932cc' ? '153, 50, 204' :
                                  typeColor === '#28a745' ? '40, 167, 69' : '136, 136, 136'}, 0.2);
                color: ${typeColor};
                font-size: 10px;
                padding: 2px 6px;
                border-radius: 10px;
                border: 1px solid ${typeColor};
              `;
              typeSpan.textContent = typeText;
              
              metaDiv.appendChild(statusSpan);
              metaDiv.appendChild(typeSpan);
              
              infoDiv.appendChild(titleDiv);
              infoDiv.appendChild(metaDiv);
              
              // å³ä¾§æ“ä½œæŒ‰é’®åŒºåŸŸ
              const actionsDiv = document.createElement('div');
              actionsDiv.style.cssText = 'display: flex; gap: 6px; flex-shrink: 0;';
              
              // å¼€å¯/å…³é—­æŒ‰é’®
              const toggleBtn = document.createElement('button');
              toggleBtn.className = 'interaction-btn';
              toggleBtn.style.cssText = `
                padding: 4px 8px;
                font-size: 11px;
                border: 1px solid ${entry.enabled ? '#ff6b6b' : '#90ee90'};
                background: ${entry.enabled ? 'rgba(255, 107, 107, 0.2)' : 'rgba(144, 238, 144, 0.2)'};
                color: ${entry.enabled ? '#ff6b6b' : '#90ee90'};
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
              `;
              toggleBtn.textContent = entry.enabled ? 'å…³é—­' : 'å¼€å¯';
              toggleBtn.onclick = () => this.toggleWorldbookEntry(entry.uid, !entry.enabled);
              
              // åˆ é™¤æŒ‰é’®
              const deleteBtn = document.createElement('button');
              deleteBtn.className = 'interaction-btn';
              deleteBtn.style.cssText = `
                padding: 4px 8px;
                font-size: 11px;
                border: 1px solid #ff6b6b;
                background: rgba(255, 107, 107, 0.2);
                color: #ff6b6b;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
              `;
              deleteBtn.textContent = 'åˆ é™¤';
              deleteBtn.onclick = () => this.deleteWorldbookEntry(entry.uid, entry.comment);
              
              actionsDiv.appendChild(toggleBtn);
              actionsDiv.appendChild(deleteBtn);
              
              entryDiv.appendChild(infoDiv);
              entryDiv.appendChild(actionsDiv);
              
              listContainer.appendChild(entryDiv);
            });
          },

          // æ‰¹é‡å¯ç”¨ç­›é€‰é¡¹
          async enableFilteredEntries() {
            if (!this.worldbookManagerState?.filteredEntries) return;
            
            const entries = this.worldbookManagerState.filteredEntries.filter(e => !e.enabled);
            if (entries.length === 0) {
              this.showTemporaryMessage('æ²¡æœ‰éœ€è¦å¯ç”¨çš„æ¡ç›®');
              return;
            }

            this.showConfirmModal(
              'æ‰¹é‡å¯ç”¨ç¡®è®¤',
              `ç¡®å®šè¦å¯ç”¨ ${entries.length} ä¸ªæ¡ç›®å—ï¼Ÿ`,
              async () => {
                try {
                  const bookName = '1å½’å¢Ÿ';
                  const updates = entries.map(entry => ({ uid: entry.uid, enabled: true }));
                  await TavernHelper.setLorebookEntries(bookName, updates);
                  this.showTemporaryMessage(`å·²å¯ç”¨ ${entries.length} ä¸ªæ¡ç›®`);
                  this.loadWorldbookEntries();
                } catch (error) {
                  console.error('æ‰¹é‡å¯ç”¨å¤±è´¥:', error);
                  this.showTemporaryMessage('æ‰¹é‡å¯ç”¨å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
              }
            );
          },

          // æ‰¹é‡ç¦ç”¨ç­›é€‰é¡¹
          async disableFilteredEntries() {
            if (!this.worldbookManagerState?.filteredEntries) return;
            
            const entries = this.worldbookManagerState.filteredEntries.filter(e => e.enabled);
            if (entries.length === 0) {
              this.showTemporaryMessage('æ²¡æœ‰éœ€è¦ç¦ç”¨çš„æ¡ç›®');
              return;
            }
            
            this.showConfirmModal(
              'æ‰¹é‡ç¦ç”¨ç¡®è®¤',
              `ç¡®å®šè¦ç¦ç”¨ ${entries.length} ä¸ªæ¡ç›®å—ï¼Ÿ`,
              async () => {
                try {
                  const bookName = '1å½’å¢Ÿ';
                  const updates = entries.map(entry => ({ uid: entry.uid, enabled: false }));
                  await TavernHelper.setLorebookEntries(bookName, updates);
                  this.showTemporaryMessage(`å·²ç¦ç”¨ ${entries.length} ä¸ªæ¡ç›®`);
                  this.loadWorldbookEntries();
                } catch (error) {
                  console.error('æ‰¹é‡ç¦ç”¨å¤±è´¥:', error);
                  this.showTemporaryMessage('æ‰¹é‡ç¦ç”¨å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
              }
            );
          },

          // æ˜¾ç¤ºåˆ é™¤ç¡®è®¤æ¨¡æ€æ¡†
          showDeleteConfirmModal(deleteType, deleteData) {
            // å­˜å‚¨åˆ é™¤ç›¸å…³æ•°æ®
            this.deleteConfirmState = {
              type: deleteType, // 'single' æˆ– 'batch'
              data: deleteData, // å•ä¸ªæ¡ç›®çš„ {uid, comment} æˆ–æ‰¹é‡æ¡ç›®æ•°ç»„
              step: 1 // å½“å‰ç¡®è®¤æ­¥éª¤
            };

            // æ›´æ–°æ¨¡æ€æ¡†å†…å®¹
            this.updateDeleteConfirmContent();
            
            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            this.openModal('worldbook-delete-confirm-modal');
            
            // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
            setTimeout(() => {
              this.bindDeleteConfirmEvents();
            }, 100);
          },

          // æ›´æ–°åˆ é™¤ç¡®è®¤æ¨¡æ€æ¡†å†…å®¹
          updateDeleteConfirmContent() {
            const state = this.deleteConfirmState;
            if (!state) return;

            // ä½¿ç”¨ç°æœ‰HTMLç»“æ„ä¸­çš„å…ƒç´ ID
            const step1El = document.getElementById('delete-step-1');
            const step2El = document.getElementById('delete-step-2');
            const deleteItemDetailsEl = document.getElementById('delete-item-details');
            const confirmationInputEl = document.getElementById('delete-confirmation-input');

            if (!step1El || !step2El) {
              console.error('åˆ é™¤ç¡®è®¤æ¨¡æ€æ¡†å…ƒç´ æœªæ‰¾åˆ°');
              return;
            }

            if (state.step === 1) {
              // æ˜¾ç¤ºç¬¬ä¸€æ­¥
              step1El.style.display = 'block';
              step2El.style.display = 'none';
              
              if (deleteItemDetailsEl) {
                if (state.type === 'single') {
                  const { comment } = state.data;
                  deleteItemDetailsEl.innerHTML = `å•ä¸ªæ¡ç›®: <strong>"${comment}"</strong>`;
                } else if (state.type === 'batch') {
                  const entries = state.data;
                  deleteItemDetailsEl.innerHTML = `æ‰¹é‡åˆ é™¤: <strong>${entries.length} ä¸ªæ¡ç›®</strong>`;
                }
              }
            } else {
              // æ˜¾ç¤ºç¬¬äºŒæ­¥
              step1El.style.display = 'none';
              step2El.style.display = 'block';
              
              // æ¸…ç©ºè¾“å…¥æ¡†
              if (confirmationInputEl) {
                confirmationInputEl.value = '';
              }
            }
          },

          // å¤„ç†åˆ é™¤ç¡®è®¤çš„ä¸‹ä¸€æ­¥
          proceedDeleteConfirm() {
            if (!this.deleteConfirmState) return;

            if (this.deleteConfirmState.step === 1) {
              // è¿›å…¥ç¬¬äºŒæ­¥ç¡®è®¤
              this.deleteConfirmState.step = 2;
              this.updateDeleteConfirmContent();
            }
          },

          // æ‰§è¡Œæœ€ç»ˆåˆ é™¤æ“ä½œ
          async executeDelete() {
            const state = this.deleteConfirmState;
            if (!state || state.step !== 2) return;

            // ä¸´æ—¶é˜»æ­¢è‡ªåŠ¨è¿”å›è®¾ç½®ç•Œé¢
            const originalFromSettings = this.isFromSettingsModal;
            this.isFromSettingsModal = false;

            // éªŒè¯è¾“å…¥ - ä½¿ç”¨æ­£ç¡®çš„å…ƒç´ ID
            const inputEl = document.getElementById('delete-confirmation-input');
            if (!inputEl) {
              console.error('åˆ é™¤ç¡®è®¤è¾“å…¥æ¡†æœªæ‰¾åˆ°');
              return;
            }
            
            const input = inputEl.value.trim();
            if (input !== 'ç¡®è®¤åˆ é™¤') {
              this.showTemporaryMessage('è¾“å…¥ä¸æ­£ç¡®ï¼Œè¯·è¾“å…¥"ç¡®è®¤åˆ é™¤"');
              // æ˜¾ç¤ºé”™è¯¯æç¤º
              const errorEl = document.getElementById('delete-input-error');
              if (errorEl) {
                errorEl.style.display = 'block';
                setTimeout(() => {
                  errorEl.style.display = 'none';
                }, 3000);
              }
              // æ¢å¤åŸå§‹çŠ¶æ€
              this.isFromSettingsModal = originalFromSettings;
              return;
            }

            try {
              const bookName = '1å½’å¢Ÿ';
              
              // åœ¨åˆ é™¤å‰è·å–å®Œæ•´çš„æ¡ç›®æ•°æ®ç”¨äºç¼“å­˜
              let entriesToCache = [];
              
              if (state.type === 'single') {
                const { uid } = state.data;
                // ä»å½“å‰åŠ è½½çš„æ¡ç›®ä¸­æ‰¾åˆ°å®Œæ•´æ•°æ®
                const fullEntry = this.worldbookManagerState?.allEntries?.find(entry => entry.uid === uid);
                if (fullEntry) {
                  entriesToCache = [fullEntry];
                }
                await TavernHelper.deleteLorebookEntries(bookName, [uid]);
                this.showTemporaryMessage('ä¸–ç•Œä¹¦æ¡ç›®å·²åˆ é™¤');
              } else if (state.type === 'batch') {
                const uids = state.data.map(entry => entry.uid);
                // è·å–æ‰€æœ‰è¦åˆ é™¤æ¡ç›®çš„å®Œæ•´æ•°æ®
                entriesToCache = state.data.slice(); // å¤åˆ¶æ•°ç»„
                await TavernHelper.deleteLorebookEntries(bookName, uids);
                this.showTemporaryMessage(`å·²åˆ é™¤ ${state.data.length} ä¸ªæ¡ç›®`);
              }

              // å°†åˆ é™¤çš„æ¡ç›®æ·»åŠ åˆ°ç¼“å­˜
              if (entriesToCache.length > 0) {
                this.addToDeleteCache(entriesToCache, state.type);
              }

              // å…³é—­ç¡®è®¤æ¨¡æ€æ¡†
              this.closeModal('worldbook-delete-confirm-modal');
              this.deleteConfirmState = null;
              
              // æ¢å¤åŸå§‹çš„isFromSettingsModalçŠ¶æ€
              this.isFromSettingsModal = originalFromSettings;

              // ä¿®å¤ï¼šè¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢ï¼Œè€Œä¸æ˜¯ä¸»ç•Œé¢
              this.showWorldbookManager();
              
            } catch (error) {
              console.error('åˆ é™¤æ“ä½œå¤±è´¥:', error);
              this.showTemporaryMessage('åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•');
              // æ¢å¤åŸå§‹çŠ¶æ€
              this.isFromSettingsModal = originalFromSettings;
            }
          },

          // å–æ¶ˆåˆ é™¤æ“ä½œ
          cancelDelete() {
            this.closeModal('worldbook-delete-confirm-modal');
            this.deleteConfirmState = null;
            this.showTemporaryMessage('åˆ é™¤æ“ä½œå·²å–æ¶ˆ');
            // è¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
            this.showWorldbookManager();
          },

          // --- åˆ é™¤ç¼“å­˜ç®¡ç†åŠŸèƒ½ ---
          
          // æ·»åŠ æ¡ç›®åˆ°åˆ é™¤ç¼“å­˜
          addToDeleteCache(entries, deleteType) {
            try {
              // è·å–ç°æœ‰ç¼“å­˜
              let deleteCache = this.getDeleteCache();
              
              // åˆ›å»ºç¼“å­˜æ¡ç›®
              const cacheEntry = {
                id: Date.now() + Math.random(), // å”¯ä¸€ID
                timestamp: new Date().toISOString(),
                type: deleteType, // 'single' æˆ– 'batch'
                count: entries.length,
                entries: entries.map(entry => {
                  // ä¿å­˜å®Œæ•´çš„æ¡ç›®æ•°æ®ä»¥ç¡®ä¿æ— æŸæ¢å¤ï¼Œä½¿ç”¨æ­£ç¡®çš„APIå­—æ®µç»“æ„
                  const savedEntry = { ...entry }; // å®Œæ•´å¤åˆ¶åŸå§‹æ¡ç›®
                  
                  // ç¡®ä¿å…³é”®å­—æ®µå­˜åœ¨
                  if (!savedEntry.keys) savedEntry.keys = [];
                  if (!savedEntry.filters) savedEntry.filters = [];
                  if (typeof savedEntry.enabled !== 'boolean') savedEntry.enabled = true;
                  if (!savedEntry.type) savedEntry.type = 'selective';
                  if (!savedEntry.position) savedEntry.position = 'after_character_definition';
                  if (!savedEntry.logic) savedEntry.logic = 'and_any';
                  if (typeof savedEntry.probability !== 'number') savedEntry.probability = 100;
                  if (typeof savedEntry.order !== 'number') savedEntry.order = 0;
                  
                  // ç¡®ä¿æ‰«æå’ŒåŒ¹é…è®¾ç½®å­˜åœ¨
                  if (savedEntry.scan_depth === undefined) savedEntry.scan_depth = 'same_as_global';
                  if (savedEntry.case_sensitive === undefined) savedEntry.case_sensitive = 'same_as_global';
                  if (savedEntry.match_whole_words === undefined) savedEntry.match_whole_words = 'same_as_global';
                  if (savedEntry.use_group_scoring === undefined) savedEntry.use_group_scoring = 'same_as_global';
                  
                  // ç¡®ä¿é€’å½’æ§åˆ¶å­—æ®µå­˜åœ¨
                  if (typeof savedEntry.exclude_recursion !== 'boolean') savedEntry.exclude_recursion = false;
                  if (typeof savedEntry.prevent_recursion !== 'boolean') savedEntry.prevent_recursion = false;
                  if (savedEntry.delay_until_recursion === undefined) savedEntry.delay_until_recursion = false;
                  
                  // ç¡®ä¿åˆ†ç»„å’Œå…¶ä»–é«˜çº§å­—æ®µå­˜åœ¨
                  if (!savedEntry.group) savedEntry.group = '';
                  if (typeof savedEntry.group_prioritized !== 'boolean') savedEntry.group_prioritized = false;
                  if (typeof savedEntry.group_weight !== 'number') savedEntry.group_weight = 100;
                  
                  // ç¡®ä¿å¯ä¸ºnullçš„å­—æ®µæ­£ç¡®å¤„ç†
                  if (savedEntry.sticky === undefined) savedEntry.sticky = null;
                  if (savedEntry.cooldown === undefined) savedEntry.cooldown = null;
                  if (savedEntry.delay === undefined) savedEntry.delay = null;
                  if (savedEntry.automation_id === undefined) savedEntry.automation_id = null;
                  if (savedEntry.depth === undefined) savedEntry.depth = null;
                  
                  // ç¡®ä¿åŸºç¡€å­—ç¬¦ä¸²å­—æ®µå­˜åœ¨
                  if (!savedEntry.comment) savedEntry.comment = '';
                  if (!savedEntry.content) savedEntry.content = '';
                  
                  console.log('[åˆ é™¤ç¼“å­˜] ä¿å­˜çš„å®Œæ•´å­—æ®µ:', Object.keys(savedEntry));
                  console.log('[åˆ é™¤ç¼“å­˜] å­—æ®µè¯¦æƒ…:', {
                    uid: savedEntry.uid,
                    display_index: savedEntry.display_index,
                    comment: savedEntry.comment,
                    enabled: savedEntry.enabled,
                    type: savedEntry.type,
                    position: savedEntry.position,
                    depth: savedEntry.depth,
                    order: savedEntry.order,
                    probability: savedEntry.probability,
                    keys: savedEntry.keys,
                    logic: savedEntry.logic,
                    filters: savedEntry.filters,
                    scan_depth: savedEntry.scan_depth,
                    case_sensitive: savedEntry.case_sensitive,
                    match_whole_words: savedEntry.match_whole_words,
                    use_group_scoring: savedEntry.use_group_scoring,
                    automation_id: savedEntry.automation_id,
                    exclude_recursion: savedEntry.exclude_recursion,
                    prevent_recursion: savedEntry.prevent_recursion,
                    delay_until_recursion: savedEntry.delay_until_recursion,
                    content: savedEntry.content,
                    group: savedEntry.group,
                    group_prioritized: savedEntry.group_prioritized,
                    group_weight: savedEntry.group_weight,
                    sticky: savedEntry.sticky,
                    cooldown: savedEntry.cooldown,
                    delay: savedEntry.delay
                  });
                  
                  return savedEntry;
                })
              };
              
              // æ·»åŠ åˆ°ç¼“å­˜å¼€å¤´
              deleteCache.unshift(cacheEntry);
              
              // ä¿æŒæœ€å¤š10ä¸ªç¼“å­˜æ¡ç›®
              if (deleteCache.length > 10) {
                deleteCache = deleteCache.slice(0, 10);
              }
              
              // ä¿å­˜åˆ°localStorage
              localStorage.setItem('guixu_worldbook_delete_cache', JSON.stringify(deleteCache));
              
              console.log(`[åˆ é™¤ç¼“å­˜] å·²ç¼“å­˜ ${entries.length} ä¸ªæ¡ç›®ï¼Œç¼“å­˜æ€»æ•°: ${deleteCache.length}`);
              
            } catch (error) {
              console.error('ä¿å­˜åˆ é™¤ç¼“å­˜å¤±è´¥:', error);
            }
          },

          // è·å–åˆ é™¤ç¼“å­˜
          getDeleteCache() {
            try {
              const cache = localStorage.getItem('guixu_worldbook_delete_cache');
              return cache ? JSON.parse(cache) : [];
            } catch (error) {
              console.error('è¯»å–åˆ é™¤ç¼“å­˜å¤±è´¥:', error);
              return [];
            }
          },

          // ä»ç¼“å­˜ä¸­æ¢å¤æ¡ç›®
          async restoreFromCache(cacheId) {
            // ä¸´æ—¶é˜»æ­¢è‡ªåŠ¨è¿”å›è®¾ç½®ç•Œé¢
            const originalFromSettings = this.isFromSettingsModal;
            this.isFromSettingsModal = false;
            
            try {
              const deleteCache = this.getDeleteCache();
              const cacheEntry = deleteCache.find(entry => entry.id === cacheId);
              
              if (!cacheEntry) {
                this.showTemporaryMessage('ç¼“å­˜æ¡ç›®ä¸å­˜åœ¨');
                // æ¢å¤åŸå§‹çŠ¶æ€
                this.isFromSettingsModal = originalFromSettings;
                return;
              }

              const bookName = '1å½’å¢Ÿ';
              
              console.log('[æ¢å¤ç¼“å­˜] å¼€å§‹æ¢å¤æ¡ç›®:', cacheEntry);
              
              // å‡†å¤‡è¦æ¢å¤çš„æ¡ç›®æ•°æ®ï¼Œåªç§»é™¤uidå’Œdisplay_indexè®©ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆï¼Œä¿ç•™æ‰€æœ‰å…¶ä»–å­—æ®µ
              const entriesToRestore = cacheEntry.entries.map(entry => {
                const newEntry = { ...entry }; // å®Œæ•´å¤åˆ¶ç¼“å­˜çš„æ¡ç›®æ•°æ®
                
                // åªç§»é™¤è¿™ä¸¤ä¸ªå­—æ®µï¼Œè®©APIè‡ªåŠ¨ç”Ÿæˆ
                delete newEntry.uid;
                delete newEntry.display_index;
                
                // éªŒè¯æ‰€æœ‰APIè¦æ±‚çš„å­—æ®µéƒ½å­˜åœ¨ï¼Œç¡®ä¿æ•°æ®å®Œæ•´æ€§
                const requiredFields = [
                  'comment', 'enabled', 'type', 'position', 'depth', 'order', 'probability',
                  'keys', 'logic', 'filters', 'scan_depth', 'case_sensitive', 'match_whole_words',
                  'use_group_scoring', 'automation_id', 'exclude_recursion', 'prevent_recursion',
                  'delay_until_recursion', 'content', 'group', 'group_prioritized', 'group_weight',
                  'sticky', 'cooldown', 'delay'
                ];
                
                // æ£€æŸ¥æ˜¯å¦æœ‰ç¼ºå¤±çš„å­—æ®µ
                const missingFields = requiredFields.filter(field => !(field in newEntry));
                if (missingFields.length > 0) {
                  console.warn('[æ¢å¤ç¼“å­˜] å‘ç°ç¼ºå¤±å­—æ®µ:', missingFields);
                }
                
                // éªŒè¯å­—æ®µç±»å‹å’Œå€¼çš„æ­£ç¡®æ€§
                console.log('[æ¢å¤ç¼“å­˜] æ¢å¤æ¡ç›®çš„å®Œæ•´å­—æ®µéªŒè¯:', {
                  comment: typeof newEntry.comment + ' = ' + JSON.stringify(newEntry.comment),
                  enabled: typeof newEntry.enabled + ' = ' + newEntry.enabled,
                  type: typeof newEntry.type + ' = ' + newEntry.type,
                  position: typeof newEntry.position + ' = ' + newEntry.position,
                  depth: typeof newEntry.depth + ' = ' + newEntry.depth,
                  order: typeof newEntry.order + ' = ' + newEntry.order,
                  probability: typeof newEntry.probability + ' = ' + newEntry.probability,
                  keys: Array.isArray(newEntry.keys) + ' = ' + JSON.stringify(newEntry.keys),
                  logic: typeof newEntry.logic + ' = ' + newEntry.logic,
                  filters: Array.isArray(newEntry.filters) + ' = ' + JSON.stringify(newEntry.filters),
                  scan_depth: typeof newEntry.scan_depth + ' = ' + newEntry.scan_depth,
                  case_sensitive: typeof newEntry.case_sensitive + ' = ' + newEntry.case_sensitive,
                  match_whole_words: typeof newEntry.match_whole_words + ' = ' + newEntry.match_whole_words,
                  use_group_scoring: typeof newEntry.use_group_scoring + ' = ' + newEntry.use_group_scoring,
                  automation_id: typeof newEntry.automation_id + ' = ' + newEntry.automation_id,
                  exclude_recursion: typeof newEntry.exclude_recursion + ' = ' + newEntry.exclude_recursion,
                  prevent_recursion: typeof newEntry.prevent_recursion + ' = ' + newEntry.prevent_recursion,
                  delay_until_recursion: typeof newEntry.delay_until_recursion + ' = ' + newEntry.delay_until_recursion,
                  content: typeof newEntry.content + ' = ' + JSON.stringify(newEntry.content?.substring(0, 50) + '...'),
                  group: typeof newEntry.group + ' = ' + JSON.stringify(newEntry.group),
                  group_prioritized: typeof newEntry.group_prioritized + ' = ' + newEntry.group_prioritized,
                  group_weight: typeof newEntry.group_weight + ' = ' + newEntry.group_weight,
                  sticky: typeof newEntry.sticky + ' = ' + newEntry.sticky,
                  cooldown: typeof newEntry.cooldown + ' = ' + newEntry.cooldown,
                  delay: typeof newEntry.delay + ' = ' + newEntry.delay
                });
                
                console.log('[æ¢å¤ç¼“å­˜] æ¢å¤æ¡ç›®å­—æ®µæ€»æ•°:', Object.keys(newEntry).length);
                console.log('[æ¢å¤ç¼“å­˜] æ¢å¤æ¡ç›®æ‰€æœ‰å­—æ®µ:', Object.keys(newEntry).sort());
                
                return newEntry;
              });

              console.log('[æ¢å¤ç¼“å­˜] å‡†å¤‡æ¢å¤çš„æ¡ç›®:', entriesToRestore);

              // ä½¿ç”¨createLorebookEntries APIåˆ›å»ºæ–°æ¡ç›®
              const result = await TavernHelper.createLorebookEntries(bookName, entriesToRestore);
              console.log('[æ¢å¤ç¼“å­˜] æ¢å¤ç»“æœ:', result);

              if (result && result.new_uids && result.new_uids.length > 0) {
                // ä»ç¼“å­˜ä¸­ç§»é™¤å·²æ¢å¤çš„æ¡ç›®
                const updatedCache = deleteCache.filter(entry => entry.id !== cacheId);
                localStorage.setItem('guixu_worldbook_delete_cache', JSON.stringify(updatedCache));
                
                this.showTemporaryMessage(`æˆåŠŸæ¢å¤ ${result.new_uids.length} ä¸ªæ¡ç›®`);
                
                // åˆ·æ–°ä¸–ç•Œä¹¦åˆ—è¡¨
                this.loadWorldbookEntries();
                
                // å¦‚æœåˆ é™¤å†å²ç•Œé¢æ˜¯æ‰“å¼€çš„ï¼Œä¹Ÿåˆ·æ–°å®ƒ
                if (document.getElementById('worldbook-delete-history-modal')?.style.display !== 'none') {
                  this.renderDeleteHistory();
                }
                
                // æ¢å¤åŸå§‹çš„isFromSettingsModalçŠ¶æ€
                this.isFromSettingsModal = originalFromSettings;
                
              } else {
                console.error('[æ¢å¤ç¼“å­˜] æ¢å¤å¤±è´¥ï¼ŒAPIè¿”å›ç»“æœå¼‚å¸¸:', result);
                this.showTemporaryMessage('æ¢å¤å¤±è´¥ï¼šAPIè°ƒç”¨å¼‚å¸¸');
              }
              
            } catch (error) {
              console.error('[æ¢å¤ç¼“å­˜] æ¢å¤æ¡ç›®å¤±è´¥:', error);
              this.showTemporaryMessage(`æ¢å¤å¤±è´¥: ${error.message}`);
            }
          },

          // æ˜¾ç¤ºé€šç”¨ç¡®è®¤æ¨¡æ€æ¡†
          showConfirmModal(title, message, onConfirm, onCancel = null) {
            const modal = document.getElementById('worldbook-confirm-modal');
            const titleEl = document.getElementById('confirm-modal-title');
            const messageEl = document.getElementById('confirm-modal-message');
            const confirmBtn = document.getElementById('confirm-modal-confirm');
            const cancelBtn = document.getElementById('confirm-modal-cancel');

            if (!modal || !titleEl || !messageEl || !confirmBtn || !cancelBtn) {
              console.error('ç¡®è®¤æ¨¡æ€æ¡†å…ƒç´ æœªæ‰¾åˆ°');
              return;
            }

            titleEl.textContent = title;
            messageEl.innerHTML = message;

            // æ¸…é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            // æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
            newConfirmBtn.addEventListener('click', () => {
              this.closeModal('worldbook-confirm-modal');
              if (onConfirm) onConfirm();
            });

            newCancelBtn.addEventListener('click', () => {
              this.closeModal('worldbook-confirm-modal');
              if (onCancel) onCancel();
            });

            this.openModal('worldbook-confirm-modal');
          },

          // æ˜¾ç¤ºæ¢å¤ç¡®è®¤æ¨¡æ€æ¡†
          showRestoreConfirmModal(message, onConfirm, onCancel = null) {
            const modal = document.getElementById('worldbook-restore-confirm-modal');
            const messageEl = document.getElementById('restore-confirm-message');
            const confirmBtn = document.getElementById('restore-confirm-confirm');
            const cancelBtn = document.getElementById('restore-confirm-cancel');

            if (!modal || !messageEl || !confirmBtn || !cancelBtn) {
              console.error('æ¢å¤ç¡®è®¤æ¨¡æ€æ¡†å…ƒç´ æœªæ‰¾åˆ°');
              return;
            }

            messageEl.innerHTML = message;

            // æ¸…é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            // æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
            newConfirmBtn.addEventListener('click', () => {
              this.closeModal('worldbook-restore-confirm-modal');
              if (onConfirm) onConfirm();
              // è¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
              this.showWorldbookManager();
            });

            newCancelBtn.addEventListener('click', () => {
              this.closeModal('worldbook-restore-confirm-modal');
              if (onCancel) onCancel();
              // è¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
              this.showWorldbookManager();
            });

            this.openModal('worldbook-restore-confirm-modal');
          },

          // æ˜¾ç¤ºç§»é™¤å†å²ç¡®è®¤æ¨¡æ€æ¡†
          showRemoveHistoryConfirmModal(message, onConfirm, onCancel = null) {
            const modal = document.getElementById('worldbook-remove-history-confirm-modal');
            const messageEl = document.getElementById('remove-history-confirm-message');
            const confirmBtn = document.getElementById('remove-history-confirm-confirm');
            const cancelBtn = document.getElementById('remove-history-confirm-cancel');

            if (!modal || !messageEl || !confirmBtn || !cancelBtn) {
              console.error('ç§»é™¤å†å²ç¡®è®¤æ¨¡æ€æ¡†å…ƒç´ æœªæ‰¾åˆ°');
              return;
            }

            messageEl.innerHTML = message;

            // æ¸…é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            // æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
            newConfirmBtn.addEventListener('click', () => {
              this.closeModal('worldbook-remove-history-confirm-modal');
              if (onConfirm) onConfirm();
              // è¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
              this.showWorldbookManager();
            });

            newCancelBtn.addEventListener('click', () => {
              this.closeModal('worldbook-remove-history-confirm-modal');
              if (onCancel) onCancel();
              // è¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
              this.showWorldbookManager();
            });

            this.openModal('worldbook-remove-history-confirm-modal');
          },

          // æ¸…ç©ºåˆ é™¤ç¼“å­˜
          clearDeleteCache() {
            try {
              localStorage.removeItem('guixu_worldbook_delete_cache');
              this.showTemporaryMessage('åˆ é™¤ç¼“å­˜å·²æ¸…ç©º');
              
              // å¦‚æœåˆ é™¤å†å²ç•Œé¢æ˜¯æ‰“å¼€çš„ï¼Œåˆ·æ–°å®ƒ
              if (document.getElementById('worldbook-delete-history-modal')?.style.display !== 'none') {
                this.renderDeleteHistory();
              }
            } catch (error) {
              console.error('æ¸…ç©ºåˆ é™¤ç¼“å­˜å¤±è´¥:', error);
            }
          },

          // ä»ç¼“å­˜ä¸­ç§»é™¤æŒ‡å®šæ¡ç›®
          removeFromCache(cacheId) {
            try {
              const deleteCache = this.getDeleteCache();
              const updatedCache = deleteCache.filter(entry => entry.id !== cacheId);
              localStorage.setItem('guixu_worldbook_delete_cache', JSON.stringify(updatedCache));
              
              // å¦‚æœåˆ é™¤å†å²ç•Œé¢æ˜¯æ‰“å¼€çš„ï¼Œåˆ·æ–°å®ƒ
              if (document.getElementById('worldbook-delete-history-modal')?.style.display !== 'none') {
                this.renderDeleteHistory();
              }
            } catch (error) {
              console.error('ç§»é™¤ç¼“å­˜æ¡ç›®å¤±è´¥:', error);
            }
          },

          // --- åˆ é™¤å†å²ç®¡ç†ç•Œé¢åŠŸèƒ½ ---
          
          // æ˜¾ç¤ºåˆ é™¤å†å²ç®¡ç†ç•Œé¢
          showDeleteHistory() {
            this.openModal('worldbook-delete-history-modal');
            this.renderDeleteHistory();
            
            // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
            setTimeout(() => {
              this.bindDeleteHistoryEvents();
            }, 100);
          },

          // æ¸²æŸ“åˆ é™¤å†å²åˆ—è¡¨
          renderDeleteHistory() {
            const listContainer = document.getElementById('delete-history-list');
            const countElement = document.getElementById('delete-history-count');
            
            if (!listContainer || !countElement) return;

            const deleteCache = this.getDeleteCache();
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            countElement.textContent = `å…±æœ‰ ${deleteCache.length} æ¡åˆ é™¤è®°å½•`;

            if (deleteCache.length === 0) {
              listContainer.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #8b7355;">
                  <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“­</div>
                  <div style="font-size: 16px; margin-bottom: 8px;">æš‚æ— åˆ é™¤è®°å½•</div>
                  <div style="font-size: 12px;">åˆ é™¤çš„æ¡ç›®ä¼šè‡ªåŠ¨ä¿å­˜åœ¨è¿™é‡Œï¼Œæ–¹ä¾¿æ‚¨éšæ—¶æ¢å¤</div>
                </div>
              `;
              return;
            }

            listContainer.innerHTML = '';

            deleteCache.forEach((cacheEntry, index) => {
              const entryDiv = document.createElement('div');
              entryDiv.className = 'delete-history-item';
              entryDiv.style.cssText = `
                background: rgba(26, 26, 46, 0.4);
                border: 1px solid #8b7355;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 12px;
                transition: all 0.3s ease;
              `;

              // é¼ æ ‡æ‚¬æµ®æ•ˆæœ
              entryDiv.addEventListener('mouseenter', () => {
                entryDiv.style.background = 'rgba(26, 26, 46, 0.6)';
                entryDiv.style.borderColor = '#c9aa71';
              });
              entryDiv.addEventListener('mouseleave', () => {
                entryDiv.style.background = 'rgba(26, 26, 46, 0.4)';
                entryDiv.style.borderColor = '#8b7355';
              });

              const deleteTime = new Date(cacheEntry.timestamp);
              const timeStr = deleteTime.toLocaleString('zh-CN');
              
              entryDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                  <div style="flex: 1;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                      <span style="background: ${cacheEntry.type === 'single' ? '#007bff' : '#9932cc'}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 10px; margin-right: 10px;">
                        ${cacheEntry.type === 'single' ? 'å•ä¸ªåˆ é™¤' : 'æ‰¹é‡åˆ é™¤'}
                      </span>
                      <span style="color: #c9aa71; font-size: 14px; font-weight: bold;">
                        ${cacheEntry.count} ä¸ªæ¡ç›®
                      </span>
                    </div>
                    <div style="color: #8b7355; font-size: 12px; margin-bottom: 8px;">
                      åˆ é™¤æ—¶é—´: ${timeStr}
                    </div>
                    <div style="color: #8b7355; font-size: 11px;">
                      ${cacheEntry.entries.map(entry => entry.comment || 'æœªå‘½åæ¡ç›®').slice(0, 3).join(', ')}
                      ${cacheEntry.entries.length > 3 ? ` ç­‰${cacheEntry.entries.length}ä¸ªæ¡ç›®` : ''}
                    </div>
                  </div>
                  <div style="display: flex; gap: 8px; flex-shrink: 0;">
                    <button class="restore-cache-btn interaction-btn" data-cache-id="${cacheEntry.id}"
                            style="background: rgba(40, 167, 69, 0.2); border-color: #28a745; color: #28a745; font-size: 11px; padding: 6px 12px;">
                      ğŸ”„ æ¢å¤
                    </button>
                    <button class="remove-cache-btn interaction-btn" data-cache-id="${cacheEntry.id}"
                            style="background: rgba(255, 107, 107, 0.2); border-color: #ff6b6b; color: #ff6b6b; font-size: 11px; padding: 6px 12px;">
                      ğŸ—‘ï¸ ç§»é™¤
                    </button>
                  </div>
                </div>
                <div class="delete-history-details" style="background: rgba(0, 0, 0, 0.2); border-radius: 4px; padding: 10px; font-size: 11px; color: #8b7355; max-height: 100px; overflow-y: auto;">
                  <strong>åŒ…å«æ¡ç›®:</strong><br>
                  ${cacheEntry.entries.map((entry, i) => `${i + 1}. ${entry.comment || 'æœªå‘½åæ¡ç›®'}`).join('<br>')}
                </div>
              `;

              listContainer.appendChild(entryDiv);
            });
          },

          // ç»‘å®šåˆ é™¤å†å²ç•Œé¢äº‹ä»¶ç›‘å¬å™¨
          bindDeleteHistoryEvents() {
            // æ¸…ç©ºå†å²æŒ‰é’®
            const clearBtn = document.getElementById('clear-delete-history-btn');
            if (clearBtn) {
              clearBtn.addEventListener('click', () => {
                this.showConfirmModal(
                  'æ¸…ç©ºåˆ é™¤å†å²',
                  'ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰åˆ é™¤å†å²å—ï¼Ÿ<br><br><span style="color: #ff6b6b; font-weight: bold;">âš ï¸ æ¸…ç©ºåå°†æ— æ³•æ¢å¤è¿™äº›è®°å½•</span>',
                  () => {
                    this.clearDeleteCache();
                  }
                );
              });
            }

            // å…³é—­æŒ‰é’®
            const closeBtn = document.getElementById('close-delete-history');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.closeModal('worldbook-delete-history-modal');
              });
            }

            // æ¨¡æ€æ¡†èƒŒæ™¯ç‚¹å‡»å…³é—­
            const modal = document.getElementById('worldbook-delete-history-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.closeModal('worldbook-delete-history-modal');
                }
              });
            }

            // æ¢å¤å’Œç§»é™¤æŒ‰é’®äº‹ä»¶å§”æ‰˜
            const listContainer = document.getElementById('delete-history-list');
            if (listContainer) {
              listContainer.addEventListener('click', (e) => {
                const target = e.target;
                
                if (target.classList.contains('restore-cache-btn')) {
                  const cacheId = parseFloat(target.dataset.cacheId);
                  this.showRestoreConfirmModal(
                    'ç¡®å®šè¦æ¢å¤è¿™äº›åˆ é™¤çš„æ¡ç›®å—ï¼Ÿ',
                    () => this.restoreFromCache(cacheId)
                  );
                } else if (target.classList.contains('remove-cache-btn')) {
                  const cacheId = parseFloat(target.dataset.cacheId);
                  this.showRemoveHistoryConfirmModal(
                    'ç¡®å®šè¦ä»å†å²è®°å½•ä¸­ç§»é™¤è¿™æ¡è®°å½•å—ï¼Ÿ<br><span style="color: #ff6b6b; font-weight: bold;">ç§»é™¤åå°†æ— æ³•æ¢å¤ã€‚</span>',
                    () => this.removeFromCache(cacheId)
                  );
                }
              });
            }
          },

          // æ‰¹é‡åˆ é™¤ç­›é€‰é¡¹ï¼ˆä¿®æ”¹ä¸ºä½¿ç”¨æ–°çš„ç¡®è®¤æµç¨‹ï¼‰
          async deleteFilteredEntries() {
            if (!this.worldbookManagerState?.filteredEntries) return;
            
            const entries = this.worldbookManagerState.filteredEntries;
            if (entries.length === 0) {
              this.showTemporaryMessage('æ²¡æœ‰éœ€è¦åˆ é™¤çš„æ¡ç›®');
              return;
            }

            // ä½¿ç”¨æ–°çš„åˆ é™¤ç¡®è®¤æ¨¡æ€æ¡†
            this.showDeleteConfirmModal('batch', entries);
          },

          async toggleWorldbookEntry(uid, enabled) {
            try {
              const bookName = '1å½’å¢Ÿ';
              await TavernHelper.setLorebookEntries(bookName, [{ uid, enabled }]);
              this.showTemporaryMessage(`ä¸–ç•Œä¹¦æ¡ç›®å·²${enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
              this.loadWorldbookEntries(); // åˆ·æ–°åˆ—è¡¨
            } catch (error) {
              console.error('åˆ‡æ¢ä¸–ç•Œä¹¦æ¡ç›®çŠ¶æ€å¤±è´¥:', error);
              this.showTemporaryMessage('æ“ä½œå¤±è´¥ï¼Œè¯·é‡è¯•');
            }
          },

          // åˆ é™¤å•ä¸ªä¸–ç•Œä¹¦æ¡ç›®ï¼ˆç®€åŒ–ä¸ºä¸€æ¬¡ç¡®è®¤ï¼‰
          async deleteWorldbookEntry(uid, comment) {
            // å•ä¸ªæ¡ç›®åˆ é™¤åªéœ€è¦ç®€å•ç¡®è®¤ï¼Œä¸éœ€è¦äºŒæ¬¡ç¡®è®¤å’Œè¾“å…¥æ–‡æœ¬
            this.showConfirmModal(
              'åˆ é™¤æ¡ç›®ç¡®è®¤',
              `ç¡®å®šè¦åˆ é™¤æ¡ç›® <strong>"${comment}"</strong> å—ï¼Ÿ<br><br><span style="color: #4a9eff;">ğŸ’¾ åˆ é™¤åå¯ä»¥åœ¨åˆ é™¤å†å²ä¸­æ¢å¤</span>`,
              async () => {
                try {
                  const bookName = '1å½’å¢Ÿ';
                  
                  // åœ¨åˆ é™¤å‰è·å–å®Œæ•´çš„æ¡ç›®æ•°æ®ç”¨äºç¼“å­˜
                  const fullEntry = this.worldbookManagerState?.allEntries?.find(entry => entry.uid === uid);
                  if (fullEntry) {
                    // æ·»åŠ åˆ°åˆ é™¤ç¼“å­˜
                    this.addToDeleteCache([fullEntry]);
                  }
                  
                  // æ‰§è¡Œåˆ é™¤
                  await TavernHelper.deleteLorebookEntries(bookName, [uid]);
                  this.showTemporaryMessage('ä¸–ç•Œä¹¦æ¡ç›®å·²åˆ é™¤');
                  
                  // åˆ·æ–°åˆ—è¡¨å¹¶è¿”å›ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
                  this.showWorldbookManager();
                } catch (error) {
                  console.error('åˆ é™¤ä¸–ç•Œä¹¦æ¡ç›®å¤±è´¥:', error);
                  this.showTemporaryMessage('åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
              }
            );
          },

          // ç»‘å®šä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢äº‹ä»¶ç›‘å¬å™¨
          bindWorldbookManagerEvents() {
            // ç­›é€‰ç±»å‹å˜åŒ–
            const filterTypeSelect = document.getElementById('worldbook-filter-type');
            if (filterTypeSelect) {
              filterTypeSelect.addEventListener('change', () => {
                this.applyWorldbookFilter();
              });
            }

            // å‰ç¼€ç­›é€‰è¾“å…¥
            const prefixFilterInput = document.getElementById('worldbook-prefix-filter');
            if (prefixFilterInput) {
              prefixFilterInput.addEventListener('input', () => {
                this.applyWorldbookFilter();
              });
            }

            // æ‰¹é‡æ“ä½œæŒ‰é’®
            const enableBtn = document.getElementById('enable-filtered-btn');
            if (enableBtn) {
              enableBtn.addEventListener('click', () => {
                this.enableFilteredEntries();
              });
            }

            const disableBtn = document.getElementById('disable-filtered-btn');
            if (disableBtn) {
              disableBtn.addEventListener('click', () => {
                this.disableFilteredEntries();
              });
            }

            // å³ä¸Šè§’åˆ é™¤æŒ‰é’®
            const deleteHeaderBtn = document.getElementById('delete-filtered-btn-header');
            if (deleteHeaderBtn) {
              deleteHeaderBtn.addEventListener('click', () => {
                this.deleteFilteredEntries();
              });
            }

            // åˆ é™¤å†å²æŒ‰é’®
            const deleteHistoryBtn = document.getElementById('show-delete-history-btn');
            if (deleteHistoryBtn) {
              deleteHistoryBtn.addEventListener('click', () => {
                this.showDeleteHistory();
              });
            }

            // å…³é—­æŒ‰é’®
            const closeBtn = document.getElementById('close-worldbook-manager');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.closeModal('worldbook-manager-modal');
              });
            }

            // æ¨¡æ€æ¡†èƒŒæ™¯ç‚¹å‡»å…³é—­
            const modal = document.getElementById('worldbook-manager-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.closeModal('worldbook-manager-modal');
                }
              });
            }
          },

          // ç»‘å®šåˆ é™¤ç¡®è®¤æ¨¡æ€æ¡†äº‹ä»¶ç›‘å¬å™¨
          bindDeleteConfirmEvents() {
            // ç¬¬ä¸€æ­¥ç¡®è®¤æŒ‰é’®
            const proceedBtn = document.getElementById('confirm-delete-step1-btn');
            if (proceedBtn) {
              proceedBtn.addEventListener('click', () => {
                this.proceedDeleteConfirm();
              });
            }

            // ç¬¬ä¸€æ­¥å–æ¶ˆæŒ‰é’®
            const cancelStep1Btn = document.getElementById('cancel-delete-btn');
            if (cancelStep1Btn) {
              cancelStep1Btn.addEventListener('click', () => {
                this.cancelDelete();
              });
            }

            // æœ€ç»ˆç¡®è®¤æŒ‰é’®
            const confirmBtn = document.getElementById('final-delete-btn');
            if (confirmBtn) {
              confirmBtn.addEventListener('click', () => {
                this.executeDelete();
              });
            }

            // è¿”å›æŒ‰é’®
            const backBtn = document.getElementById('back-delete-step-btn');
            if (backBtn) {
              backBtn.addEventListener('click', () => {
                this.deleteConfirmState.step = 1;
                this.updateDeleteConfirmContent();
              });
            }

            // è¾“å…¥æ¡†å›è½¦é”®ç¡®è®¤
            const confirmInput = document.getElementById('delete-confirmation-input');
            if (confirmInput) {
              confirmInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                  this.executeDelete();
                }
              });
            }

            // å…³é—­æŒ‰é’®
            const closeBtn = document.getElementById('close-delete-confirm');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.cancelDelete();
              });
            }

            // æ¨¡æ€æ¡†èƒŒæ™¯ç‚¹å‡»å…³é—­
            const modal = document.getElementById('worldbook-delete-confirm-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.cancelDelete();
                }
              });
            }
          },
// ===ä¸–ç•Œä¹¦ç®¡ç†æ¨¡å—ç»“æŸ===



// ===ä¸–ç•Œä¹¦é¢„è®¾æ¨¡å—å¼€å§‹===
          // æ˜¾ç¤ºé¢„è®¾ç®¡ç†ç•Œé¢
          showWorldbookPresets() {
            console.log('[é¢„è®¾ç®¡ç†] å¼€å§‹æ˜¾ç¤ºé¢„è®¾ç®¡ç†ç•Œé¢');
            this.openModal('worldbook-presets-modal');
            
            // å»¶è¿ŸåŠ è½½é¢„è®¾åˆ—è¡¨ï¼Œç¡®ä¿æ¨¡æ€æ¡†å·²æ˜¾ç¤º
            setTimeout(() => {
              this.loadWorldbookPresets();
              this.bindPresetsManagerEvents();
            }, 100);
          },

          // åŠ è½½é¢„è®¾åˆ—è¡¨
          loadWorldbookPresets() {
            try {
              const saved = localStorage.getItem('guixu_worldbook_presets');
              if (saved) {
                this.worldbookPresets = JSON.parse(saved);
              }
              this.renderPresetsList();
            } catch (error) {
              console.error('[é¢„è®¾ç®¡ç†] åŠ è½½é¢„è®¾å¤±è´¥:', error);
              this.worldbookPresets = {};
            }
          },

          // æ¸²æŸ“é¢„è®¾åˆ—è¡¨
          renderPresetsList() {
            const listContainer = document.getElementById('presets-list');
            if (!listContainer) return;

            const presets = Object.values(this.worldbookPresets);
            if (presets.length === 0) {
              listContainer.innerHTML = `
                <div style="text-align: center; color: #8b7355; padding: 40px 20px;">
                  <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“‹</div>
                  <div style="font-size: 16px; margin-bottom: 8px;">æš‚æ— é¢„è®¾</div>
                  <div style="font-size: 12px; opacity: 0.8;">ç‚¹å‡»å³ä¸Šè§’"æ–°å»ºé¢„è®¾"æŒ‰é’®åˆ›å»ºç¬¬ä¸€ä¸ªé¢„è®¾</div>
                </div>
              `;
              return;
            }

            const html = presets.map(preset => `
              <div class="preset-item" data-preset-id="${preset.id}" style="
                padding: 12px;
                margin-bottom: 8px;
                background: rgba(26, 26, 46, 0.6);
                border: 1px solid #8b7355;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                ${this.presetManagerState.selectedPresetId === preset.id ? 'border-color: #c9aa71; background: rgba(201, 170, 113, 0.1);' : ''}
              ">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 6px;">
                  <div style="color: #c9aa71; font-weight: bold; font-size: 14px;">${preset.name}</div>
                  <div style="display: flex; gap: 4px;">
                    <span style="
                      background: ${preset.enabled ? 'rgba(40, 167, 69, 0.2)' : 'rgba(108, 117, 125, 0.2)'};
                      color: ${preset.enabled ? '#28a745' : '#6c757d'};
                      padding: 2px 6px;
                      border-radius: 3px;
                      font-size: 10px;
                    ">${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}</span>
                    <span style="color: #8b7355; font-size: 10px; padding: 2px 6px; background: rgba(139, 115, 85, 0.2); border-radius: 3px;">
                      ${preset.entries.length} é¡¹
                    </span>
                  </div>
                </div>
                <div style="color: #8b7355; font-size: 12px; line-height: 1.4; margin-bottom: 8px;">
                  ${preset.description || 'æ— æè¿°'}
                </div>
                <div style="color: #666; font-size: 10px;">
                  åˆ›å»ºæ—¶é—´: ${new Date(preset.createdAt).toLocaleString()}
                </div>
              </div>
            `).join('');

            listContainer.innerHTML = html;
          },

          // æ˜¾ç¤ºé¢„è®¾è¯¦æƒ…
          showPresetDetails(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            this.presetManagerState.selectedPresetId = presetId;
            this.renderPresetsList(); // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–°é€‰ä¸­çŠ¶æ€

            const detailsContainer = document.getElementById('preset-details');
            if (!detailsContainer) return;

            const html = `
              <div style="height: 100%; display: flex; flex-direction: column;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                  <div>
                    <h3 style="color: #c9aa71; margin: 0 0 8px 0; font-size: 18px;">${preset.name}</h3>
                    <p style="color: #8b7355; margin: 0; font-size: 13px; line-height: 1.4;">
                      ${preset.description || 'æ— æè¿°'}
                    </p>
                  </div>
                  <div style="display: flex; gap: 6px;">
                    <button class="interaction-btn" onclick="GuixuManager.editPreset('${preset.id}')" style="padding: 4px 8px; font-size: 11px;">ç¼–è¾‘</button>
                    <button class="interaction-btn" onclick="GuixuManager.togglePresetStatus('${preset.id}')" style="
                      padding: 4px 8px;
                      font-size: 11px;
                      background: ${preset.enabled ? 'rgba(108, 117, 125, 0.2)' : 'rgba(40, 167, 69, 0.2)'};
                      border-color: ${preset.enabled ? '#6c757d' : '#28a745'};
                      color: ${preset.enabled ? '#6c757d' : '#28a745'};
                    ">${preset.enabled ? 'ç¦ç”¨' : 'å¯ç”¨'}</button>
                    <button class="interaction-btn" onclick="GuixuManager.deletePreset('${preset.id}')" style="
                      padding: 4px 8px;
                      font-size: 11px;
                      background: rgba(255, 107, 107, 0.2);
                      border-color: #ff6b6b;
                      color: #ff6b6b;
                    ">åˆ é™¤</button>
                  </div>
                </div>

                <div style="flex: 1; overflow-y: auto;">
                  <div style="margin-bottom: 15px;">
                    <div style="color: #c9aa71; font-size: 14px; font-weight: bold; margin-bottom: 8px;">
                      ğŸ“š åŒ…å«æ¡ç›® (${preset.entries.length})
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 4px; padding: 10px; max-height: 200px; overflow-y: auto;">
                      ${preset.entries.length > 0 ?
                        preset.entries.map(entryName => `
                          <div style="
                            padding: 6px 8px;
                            margin-bottom: 4px;
                            background: rgba(26, 26, 46, 0.6);
                            border-radius: 4px;
                            color: #e0dcd1;
                            font-size: 12px;
                            border-left: 3px solid #c9aa71;
                          ">${entryName}</div>
                        `).join('') :
                        '<div style="color: #8b7355; text-align: center; padding: 20px;">æš‚æ— æ¡ç›®</div>'
                      }
                    </div>
                  </div>

                  <div style="margin-bottom: 15px;">
                    <div style="color: #c9aa71; font-size: 14px; font-weight: bold; margin-bottom: 8px;">
                      âš™ï¸ é¢„è®¾ä¿¡æ¯
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 4px; padding: 10px;">
                      <div style="display: grid; grid-template-columns: 80px 1fr; gap: 8px; font-size: 12px;">
                        <span style="color: #8b7355;">çŠ¶æ€:</span>
                        <span style="color: ${preset.enabled ? '#28a745' : '#6c757d'};">
                          ${preset.enabled ? 'âœ… å¯ç”¨ä¸­' : 'âŒ å·²ç¦ç”¨'}
                        </span>
                        <span style="color: #8b7355;">æ¡ç›®æ•°:</span>
                        <span style="color: #e0dcd1;">${preset.entries.length} ä¸ª</span>
                        <span style="color: #8b7355;">åˆ›å»ºæ—¶é—´:</span>
                        <span style="color: #e0dcd1;">${new Date(preset.createdAt).toLocaleString()}</span>
                        <span style="color: #8b7355;">æœ€åä¿®æ”¹:</span>
                        <span style="color: #e0dcd1;">${preset.updatedAt ? new Date(preset.updatedAt).toLocaleString() : 'æœªä¿®æ”¹'}</span>
                      </div>
                    </div>
                  </div>

                  <div>
                    <div style="color: #c9aa71; font-size: 14px; font-weight: bold; margin-bottom: 8px;">
                      ğŸ¯ å¿«é€Ÿæ“ä½œ
                    </div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                      <button class="interaction-btn" onclick="GuixuManager.exportPreset('${preset.id}')" style="padding: 8px 12px; font-size: 12px;">å¯¼å‡ºé¢„è®¾</button>
                      <button class="interaction-btn" onclick="GuixuManager.duplicatePreset('${preset.id}')" style="padding: 8px 12px; font-size: 12px;">å¤åˆ¶é¢„è®¾</button>
                    </div>
                  </div>
                </div>
              </div>
            `;

            detailsContainer.innerHTML = html;
          },

          // æ˜¾ç¤ºåˆ›å»º/ç¼–è¾‘é¢„è®¾ç•Œé¢
          showCreatePresetModal(presetId = null) {
            this.currentEditingPreset = presetId;
            this.presetManagerState.isEditing = !!presetId;
            
            const modal = document.getElementById('preset-edit-modal');
            const title = document.getElementById('preset-edit-title');
            
            // å…ˆæ‰“å¼€æ¨¡æ€æ¡†
            this.openModal('preset-edit-modal');
            
            // å»¶è¿Ÿé¢„å¡«å……å†…å®¹ï¼Œç¡®ä¿DOMå·²æ¸²æŸ“
            setTimeout(() => {
              if (presetId) {
                title.textContent = 'ğŸ“ ç¼–è¾‘é¢„è®¾';
                const preset = this.worldbookPresets[presetId];
                if (preset) {
                  document.getElementById('preset-name-input').value = preset.name || '';
                  document.getElementById('preset-description-input').value = preset.description || '';
                }
              } else {
                title.textContent = 'ğŸ“ æ–°å»ºé¢„è®¾';
                document.getElementById('preset-name-input').value = '';
                document.getElementById('preset-description-input').value = '';
              }
              
              // åŠ è½½æ¡ç›®é€‰æ‹©åˆ—è¡¨
              this.loadEntriesForPresetEdit(presetId);
              this.bindPresetEditEvents();
            }, 150);
          },

          // åŠ è½½æ¡ç›®é€‰æ‹©åˆ—è¡¨
          async loadEntriesForPresetEdit(presetId = null) {
            try {
              const bookName = '1å½’å¢Ÿ';
              const entries = await TavernHelper.getLorebookEntries(bookName);
              
              if (!entries || entries.length === 0) {
                document.getElementById('preset-entries-selection').innerHTML =
                  '<div style="text-align: center; color: #8b7355; padding: 20px;">æš‚æ— å¯é€‰æ¡ç›®</div>';
                this.updatePresetFilterStats(0, 0);
                return;
              }

              // è·å–å·²é€‰æ¡ç›®åˆ—è¡¨
              let selectedEntries = [];
              if (presetId && this.worldbookPresets[presetId]) {
                selectedEntries = [...this.worldbookPresets[presetId].entries];
                console.log('[é¢„è®¾ç¼–è¾‘] åŠ è½½å·²é€‰æ¡ç›®:', selectedEntries);
              }

              // å­˜å‚¨æ‰€æœ‰æ¡ç›®ç”¨äºç­›é€‰
              this.presetEditState = {
                allEntries: entries,
                filteredEntries: entries,
                selectedEntries: selectedEntries
              };
              
              // åº”ç”¨å½“å‰ç­›é€‰å¹¶æ¸²æŸ“
              this.applyPresetFilter();
              
              // ç¡®ä¿å¤é€‰æ¡†çŠ¶æ€æ­£ç¡®æ›´æ–°
              setTimeout(() => {
                this.updateCheckboxStates();
              }, 50);
              
            } catch (error) {
              console.error('[é¢„è®¾ç®¡ç†] åŠ è½½æ¡ç›®å¤±è´¥:', error);
              document.getElementById('preset-entries-selection').innerHTML =
                '<div style="text-align: center; color: #ff6b6b; padding: 20px;">åŠ è½½æ¡ç›®å¤±è´¥</div>';
              this.updatePresetFilterStats(0, 0);
            }
          },

          // æ›´æ–°å¤é€‰æ¡†çŠ¶æ€
          updateCheckboxStates() {
            if (!this.presetEditState?.selectedEntries) return;
            
            const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
              const entryName = checkbox.dataset.entryName;
              const isSelected = this.presetEditState.selectedEntries.includes(entryName);
              checkbox.checked = isSelected;
              
              // æ›´æ–°è¾¹æ¡†é¢œè‰²
              const parentDiv = checkbox.closest('div');
              if (parentDiv) {
                parentDiv.style.borderColor = isSelected ? '#c9aa71' : '#8b7355';
              }
            });
            
            console.log('[é¢„è®¾ç¼–è¾‘] å¤é€‰æ¡†çŠ¶æ€å·²æ›´æ–°ï¼Œå·²é€‰æ¡ç›®:', this.presetEditState.selectedEntries.length);
          },

          // åº”ç”¨é¢„è®¾æ¡ç›®ç­›é€‰
          applyPresetFilter() {
            if (!this.presetEditState) return;

            const filterType = document.getElementById('preset-filter-type')?.value || 'all';
            const prefixFilter = document.getElementById('preset-prefix-filter')?.value.trim() || '';
            
            let filtered = [...this.presetEditState.allEntries];
            
            // æŒ‰ç±»å‹ç­›é€‰
            switch (filterType) {
              case 'journey':
                filtered = filtered.filter(entry =>
                  entry.comment && (entry.comment.includes('æœ¬ä¸–å†ç¨‹') || entry.comment.includes('å†ç¨‹'))
                );
                break;
              case 'pastlife':
                filtered = filtered.filter(entry =>
                  entry.comment && (entry.comment.includes('å¾€ä¸–æ¶Ÿæ¼ª') || entry.comment.includes('æ¶Ÿæ¼ª'))
                );
                break;
              case 'bracket':
                filtered = filtered.filter(entry =>
                  entry.comment && entry.comment.includes('ã€') && entry.comment.includes('ã€‘')
                );
                break;
              case 'enabled':
                filtered = filtered.filter(entry => entry.enabled);
                break;
              case 'disabled':
                filtered = filtered.filter(entry => !entry.enabled);
                break;
              case 'all':
              default:
                // ä¸ç­›é€‰
                break;
            }
            
            // æŒ‰å…³é”®è¯ç­›é€‰
            if (prefixFilter) {
              filtered = filtered.filter(entry =>
                entry.comment && entry.comment.includes(prefixFilter)
              );
            }
            
            this.presetEditState.filteredEntries = filtered;
            this.renderPresetEntries(filtered);
            this.updatePresetFilterStats(filtered.length, this.presetEditState.allEntries.length);
          },

          // æ¸²æŸ“é¢„è®¾æ¡ç›®åˆ—è¡¨
          renderPresetEntries(entries) {
            const selectedEntries = this.presetEditState.selectedEntries;
            
            const html = entries.map(entry => {
              const isSelected = selectedEntries.includes(entry.comment || entry.uid);
              return `
                <div style="
                  display: flex;
                  align-items: center;
                  padding: 8px;
                  margin-bottom: 4px;
                  background: rgba(26, 26, 46, 0.4);
                  border-radius: 4px;
                  border: 1px solid ${isSelected ? '#c9aa71' : '#8b7355'};
                ">
                  <input type="checkbox"
                         id="entry-${entry.uid}"
                         data-entry-name="${entry.comment || entry.uid}"
                         ${isSelected ? 'checked' : ''}
                         style="margin-right: 10px; cursor: pointer;">
                  <label for="entry-${entry.uid}" style="
                    flex: 1;
                    cursor: pointer;
                    color: #e0dcd1;
                    font-size: 13px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                  ">
                    <span>${entry.comment || entry.uid}</span>
                    <span style="
                      color: ${entry.enabled ? '#28a745' : '#6c757d'};
                      font-size: 10px;
                      padding: 2px 6px;
                      background: ${entry.enabled ? 'rgba(40, 167, 69, 0.2)' : 'rgba(108, 117, 125, 0.2)'};
                      border-radius: 3px;
                    ">${entry.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}</span>
                  </label>
                </div>
              `;
            }).join('');

            document.getElementById('preset-entries-selection').innerHTML = html ||
              '<div style="text-align: center; color: #8b7355; padding: 20px;">æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„æ¡ç›®</div>';
          },

          // æ›´æ–°é¢„è®¾ç­›é€‰ç»Ÿè®¡ä¿¡æ¯
          updatePresetFilterStats(filtered, total) {
            const statsElement = document.getElementById('preset-filter-stats');
            if (statsElement) {
              statsElement.textContent = `æ˜¾ç¤º: ${filtered}/${total}`;
            }
          },

          // ä¿å­˜é¢„è®¾
          savePreset() {
            const name = document.getElementById('preset-name-input').value.trim();
            const description = document.getElementById('preset-description-input').value.trim();
            
            if (!name) {
              this.showTemporaryMessage('è¯·è¾“å…¥é¢„è®¾åç§°', 'error', 3000);
              return;
            }

            // è·å–é€‰ä¸­çš„æ¡ç›®
            const selectedEntries = [];
            const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]:checked');
            checkboxes.forEach(checkbox => {
              selectedEntries.push(checkbox.dataset.entryName);
            });

            if (selectedEntries.length === 0) {
              this.showTemporaryMessage('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ¡ç›®', 'error', 3000);
              return;
            }

            const presetId = this.currentEditingPreset || this.generatePresetId();
            const now = new Date().toISOString();
            
            const preset = {
              id: presetId,
              name: name,
              description: description,
              entries: selectedEntries,
              enabled: this.currentEditingPreset ? this.worldbookPresets[this.currentEditingPreset].enabled : true,
              createdAt: this.currentEditingPreset ? this.worldbookPresets[this.currentEditingPreset].createdAt : now,
              updatedAt: now
            };

            this.worldbookPresets[presetId] = preset;
            this.saveWorldbookPresets();
            
            this.closeModal('preset-edit-modal');
            this.showWorldbookPresets(); // è¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
            this.updatePresetsInSettings();
            
            this.showTemporaryMessage(
              this.currentEditingPreset ? 'é¢„è®¾å·²æ›´æ–°' : 'é¢„è®¾å·²åˆ›å»º',
              'success',
              3000
            );
          },

          // ç”Ÿæˆé¢„è®¾ID
          generatePresetId() {
            return 'preset_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          },

          // ä¿å­˜é¢„è®¾åˆ°æœ¬åœ°å­˜å‚¨
          saveWorldbookPresets() {
            try {
              localStorage.setItem('guixu_worldbook_presets', JSON.stringify(this.worldbookPresets));
            } catch (error) {
              console.error('[é¢„è®¾ç®¡ç†] ä¿å­˜é¢„è®¾å¤±è´¥:', error);
            }
          },

          // åˆ‡æ¢é¢„è®¾çŠ¶æ€
          togglePresetStatus(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            preset.enabled = !preset.enabled;
            preset.updatedAt = new Date().toISOString();
            
            this.saveWorldbookPresets();
            this.renderPresetsList();
            this.showPresetDetails(presetId);
            this.updatePresetsInSettings();
            
            this.showTemporaryMessage(
              `é¢„è®¾å·²${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`,
              'success'
            );
          },

          // åˆ é™¤é¢„è®¾
          deletePreset(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            // showCustomConfirmçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æ¶ˆæ¯ï¼Œç¬¬äºŒä¸ªæ˜¯ç¡®è®¤å›è°ƒï¼Œç¬¬ä¸‰ä¸ªæ˜¯å–æ¶ˆå›è°ƒï¼Œç¬¬å››ä¸ªæ˜¯ä¿æŒå½“å‰æ¨¡æ€æ¡†
            this.showCustomConfirm(
              `ç¡®å®šè¦åˆ é™¤é¢„è®¾"${preset.name}"å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`,
              () => {
                // åˆ é™¤é¢„è®¾æ•°æ®
                delete this.worldbookPresets[presetId];
                this.saveWorldbookPresets();
                
                // æ›´æ–°ç•Œé¢
                this.renderPresetsList();
                this.updatePresetsInSettings();
                
                // æ¸…ç©ºè¯¦æƒ…é¢æ¿
                const detailsPanel = document.getElementById('preset-details');
                if (detailsPanel) {
                  detailsPanel.innerHTML = `
                    <div style="text-align: center; color: #8b7355; padding: 40px 20px;">
                      <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“‹</div>
                      <div style="font-size: 16px; margin-bottom: 8px;">é€‰æ‹©é¢„è®¾æŸ¥çœ‹è¯¦æƒ…</div>
                      <div style="font-size: 12px; opacity: 0.8;">ç‚¹å‡»å·¦ä¾§é¢„è®¾é¡¹ç›®æŸ¥çœ‹å’Œç¼–è¾‘è¯¦ç»†ä¿¡æ¯</div>
                    </div>
                  `;
                }
                
                // é‡ç½®é€‰ä¸­çŠ¶æ€
                if (this.presetManagerState) {
                  this.presetManagerState.selectedPresetId = null;
                }
                
                this.showTemporaryMessage('é¢„è®¾å·²åˆ é™¤', 'success', 3000);
              },
              null, // å–æ¶ˆå›è°ƒ
              true  // keepCurrentModal - ä¿æŒé¢„è®¾ç®¡ç†æ¨¡æ€æ¡†æ‰“å¼€
            );
          },

          // åº”ç”¨é¢„è®¾ï¼ˆæ‰¹é‡å¼€å¯/å…³é—­æ¡ç›®ï¼‰
          async applyPreset(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            try {
              const bookName = '1å½’å¢Ÿ';
              
              // è·å–æ‰€æœ‰ä¸–ç•Œä¹¦æ¡ç›®
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              if (!allEntries || allEntries.length === 0) {
                this.showTemporaryMessage('æœªæ‰¾åˆ°ä¸–ç•Œä¹¦æ¡ç›®', 'error');
                return;
              }

              // æ‰¾åˆ°éœ€è¦æ›´æ–°çš„æ¡ç›®
              const entriesToUpdate = [];
              let successCount = 0;
              let failCount = 0;

              for (const entryName of preset.entries) {
                const entry = allEntries.find(e => (e.comment || e.uid.toString()) === entryName);
                if (entry) {
                  entriesToUpdate.push({
                    uid: entry.uid,
                    enabled: preset.enabled
                  });
                  successCount++;
                } else {
                  console.warn(`[é¢„è®¾åº”ç”¨] æœªæ‰¾åˆ°æ¡ç›®: ${entryName}`);
                  failCount++;
                }
              }

              // æ‰¹é‡æ›´æ–°æ¡ç›®
              if (entriesToUpdate.length > 0) {
                await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
              }

              const message = failCount > 0 ?
                `é¢„è®¾åº”ç”¨å®Œæˆï¼šæˆåŠŸ ${successCount} ä¸ªï¼Œå¤±è´¥ ${failCount} ä¸ª` :
                `é¢„è®¾åº”ç”¨æˆåŠŸï¼šå·²${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'} ${successCount} ä¸ªæ¡ç›®`;
              
              this.showTemporaryMessage(message, failCount > 0 ? 'warning' : 'success', 3000);
            } catch (error) {
              console.error('[é¢„è®¾åº”ç”¨] åº”ç”¨é¢„è®¾å¤±è´¥:', error);
              this.showTemporaryMessage('åº”ç”¨é¢„è®¾å¤±è´¥', 'error', 3000);
            }
          },

          // ç¼–è¾‘é¢„è®¾
          editPreset(presetId) {
            this.showCreatePresetModal(presetId);
          },

          // å¤åˆ¶é¢„è®¾
          duplicatePreset(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            const newPresetId = this.generatePresetId();
            const now = new Date().toISOString();
            
            const newPreset = {
              ...preset,
              id: newPresetId,
              name: preset.name + ' (å‰¯æœ¬)',
              createdAt: now,
              updatedAt: now
            };

            this.worldbookPresets[newPresetId] = newPreset;
            this.saveWorldbookPresets();
            this.renderPresetsList();
            this.updatePresetsInSettings();
            
            this.showTemporaryMessage('é¢„è®¾å·²å¤åˆ¶', 'success', 3000);
          },

          // å¯¼å‡ºé¢„è®¾
          exportPreset(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            const exportData = {
              version: '1.0',
              preset: preset,
              exportTime: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `å½’å¢Ÿé¢„è®¾_${preset.name}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            this.showTemporaryMessage('é¢„è®¾å·²å¯¼å‡º', 'success', 3000);
          },

          // æ›´æ–°è®¾ç½®ç•Œé¢ä¸­çš„é¢„è®¾åˆ—è¡¨
          updatePresetsInSettings() {
            const container = document.getElementById('worldbook-presets-container');
            if (!container) return;

            const presets = Object.values(this.worldbookPresets);
            if (presets.length === 0) {
              container.innerHTML = `
                <div style="color: #8b7355; font-size: 12px; text-align: center; padding: 10px;">
                  æš‚æ— é¢„è®¾ï¼Œç‚¹å‡»ä¸Šæ–¹æŒ‰é’®åˆ›å»ºé¢„è®¾
                </div>
              `;
              return;
            }

            // åˆå§‹åŒ–æŠ˜å çŠ¶æ€ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!this.presetCollapseState) {
              this.presetCollapseState = {
                mainCollapsed: true, // ä¸»é¢æ¿é»˜è®¤æŠ˜å 
                presetDetails: {} // å„ä¸ªé¢„è®¾çš„è¯¦æƒ…æŠ˜å çŠ¶æ€
              };
            }

            const mainCollapsed = this.presetCollapseState.mainCollapsed;
            const html = `
              <!-- ä¸»æ ‡é¢˜æ  -->
              <div style="
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 8px 10px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 4px;
                cursor: pointer;
                border: 1px solid #8b7355;
              " onclick="GuixuManager.toggleMainPresetCollapse()">
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="
                    color: #c9aa71;
                    font-size: 12px;
                    font-weight: bold;
                    transform: rotate(${mainCollapsed ? '0deg' : '90deg'});
                    transition: transform 0.2s ease;
                  ">â–¶</span>
                  <span style="color: #c9aa71; font-size: 13px; font-weight: bold;">ä¸–ç•Œä¹¦é¢„è®¾</span>
                </div>
                <span style="
                  color: #8b7355;
                  font-size: 10px;
                  padding: 2px 6px;
                  background: rgba(139, 115, 85, 0.2);
                  border-radius: 2px;
                ">${presets.length} ä¸ª</span>
              </div>

              <!-- é¢„è®¾åˆ—è¡¨ -->
              <div id="preset-list-content" style="
                display: ${mainCollapsed ? 'none' : 'block'};
                margin-top: 6px;
                padding-left: 8px;
              ">
                ${presets.map(preset => this.renderPresetItem(preset)).join('')}
              </div>
            `;

            container.innerHTML = html;
          },

          // æ¸²æŸ“å•ä¸ªé¢„è®¾é¡¹
          renderPresetItem(preset) {
            const isExpanded = this.presetCollapseState.presetDetails[preset.id] || false;
            
            return `
              <div style="margin-bottom: 8px;">
                <!-- é¢„è®¾æ ‡é¢˜æ  -->
                <div style="
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  padding: 6px 8px;
                  background: rgba(26, 26, 46, 0.4);
                  border-radius: 4px;
                  border: 1px solid ${preset.enabled ? '#c9aa71' : '#8b7355'};
                ">
                  <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                    <input type="checkbox"
                           id="preset-toggle-${preset.id}"
                           ${preset.enabled ? 'checked' : ''}
                           onchange="GuixuManager.togglePresetFromSettings('${preset.id}')"
                           style="cursor: pointer;">
                    <span style="
                      color: #e0dcd1;
                      font-size: 11px;
                      cursor: pointer;
                      transform: rotate(${isExpanded ? '90deg' : '0deg'});
                      transition: transform 0.2s ease;
                    " onclick="GuixuManager.togglePresetDetails('${preset.id}')">â–¶</span>
                    <label for="preset-toggle-${preset.id}" style="
                      color: #e0dcd1;
                      font-size: 12px;
                      cursor: pointer;
                      flex: 1;
                    " onclick="GuixuManager.togglePresetDetails('${preset.id}')">${preset.name}</label>
                  </div>
                  <div style="display: flex; align-items: center; gap: 4px;">
                    <span style="
                      color: ${preset.enabled ? '#28a745' : '#8b7355'};
                      font-size: 9px;
                      padding: 1px 4px;
                      background: ${preset.enabled ? 'rgba(40, 167, 69, 0.2)' : 'rgba(139, 115, 85, 0.2)'};
                      border-radius: 2px;
                    ">${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}</span>
                    <span style="
                      color: #8b7355;
                      font-size: 10px;
                      padding: 2px 4px;
                      background: rgba(139, 115, 85, 0.2);
                      border-radius: 2px;
                    ">${preset.entries.length}</span>
                  </div>
                </div>

                <!-- é¢„è®¾è¯¦æƒ… -->
                <div id="preset-details-${preset.id}" style="
                  display: ${isExpanded ? 'block' : 'none'};
                  margin-top: 4px;
                  margin-left: 16px;
                  padding: 8px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  border-left: 2px solid #c9aa71;
                ">
                  ${preset.description ? `
                    <div style="
                      color: #8b7355;
                      font-size: 11px;
                      margin-bottom: 6px;
                      line-height: 1.3;
                    ">${preset.description}</div>
                  ` : ''}
                  
                  <div style="
                    color: #8b7355;
                    font-size: 10px;
                    font-weight: bold;
                    margin-bottom: 4px;
                  ">åŒ…å«æ¡ç›® (${preset.entries.length}):</div>
                  
                  <div style="
                    max-height: 120px;
                    overflow-y: auto;
                    font-size: 10px;
                  ">
                    ${preset.entries.length > 0 ?
                      preset.entries.map(entryName => `
                        <div style="
                          color: #e0dcd1;
                          padding: 2px 4px;
                          margin-bottom: 2px;
                          background: rgba(26, 26, 46, 0.3);
                          border-radius: 2px;
                          border-left: 2px solid #8b7355;
                        ">â€¢ ${entryName}</div>
                      `).join('') :
                      '<div style="color: #8b7355; text-align: center; padding: 8px;">æš‚æ— æ¡ç›®</div>'
                    }
                  </div>
                  
                  <div style="
                    margin-top: 6px;
                    padding-top: 6px;
                    border-top: 1px solid rgba(139, 115, 85, 0.3);
                    font-size: 9px;
                    color: #666;
                  ">
                    åˆ›å»º: ${new Date(preset.createdAt).toLocaleString('zh-CN', {
                      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
                    })}
                    ${preset.updatedAt ? ` | æ›´æ–°: ${new Date(preset.updatedAt).toLocaleString('zh-CN', {
                      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
                    })}` : ''}
                  </div>
                </div>
              </div>
            `;
          },

          // åˆ‡æ¢ä¸»é¢„è®¾é¢æ¿æŠ˜å çŠ¶æ€
          toggleMainPresetCollapse() {
            if (!this.presetCollapseState) {
              this.presetCollapseState = { mainCollapsed: true, presetDetails: {} };
            }
            
            this.presetCollapseState.mainCollapsed = !this.presetCollapseState.mainCollapsed;
            this.updatePresetsInSettings();
          },

          // åˆ‡æ¢é¢„è®¾è¯¦æƒ…æŠ˜å çŠ¶æ€
          togglePresetDetails(presetId) {
            if (!this.presetCollapseState) {
              this.presetCollapseState = { mainCollapsed: false, presetDetails: {} };
            }
            
            this.presetCollapseState.presetDetails[presetId] = !this.presetCollapseState.presetDetails[presetId];
            this.updatePresetsInSettings();
          },

          // ä»è®¾ç½®ç•Œé¢åˆ‡æ¢é¢„è®¾çŠ¶æ€
          async togglePresetFromSettings(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            // åˆ‡æ¢é¢„è®¾çŠ¶æ€
            preset.enabled = !preset.enabled;
            preset.updatedAt = new Date().toISOString();
            
            this.saveWorldbookPresets();
            this.renderPresetsList();
            this.updatePresetsInSettings();
            
            // è‡ªåŠ¨åº”ç”¨é¢„è®¾ï¼ˆæ‰¹é‡å¼€å¯/å…³é—­ç›¸å…³ä¸–ç•Œä¹¦æ¡ç›®ï¼‰
            try {
              const bookName = '1å½’å¢Ÿ';
              
              // è·å–æ‰€æœ‰ä¸–ç•Œä¹¦æ¡ç›®
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              if (!allEntries || allEntries.length === 0) {
                this.showTemporaryMessage('æœªæ‰¾åˆ°ä¸–ç•Œä¹¦æ¡ç›®', 'error', 3000);
                return;
              }

              // æ‰¾åˆ°éœ€è¦æ›´æ–°çš„æ¡ç›®
              const entriesToUpdate = [];
              let successCount = 0;
              let failCount = 0;

              for (const entryName of preset.entries) {
                const entry = allEntries.find(e => (e.comment || e.uid.toString()) === entryName);
                if (entry) {
                  entriesToUpdate.push({
                    uid: entry.uid,
                    enabled: preset.enabled
                  });
                  successCount++;
                } else {
                  console.warn(`[é¢„è®¾åº”ç”¨] æœªæ‰¾åˆ°æ¡ç›®: ${entryName}`);
                  failCount++;
                }
              }

              // æ‰¹é‡æ›´æ–°æ¡ç›®
              if (entriesToUpdate.length > 0) {
                await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
              }

              const message = failCount > 0 ?
                `é¢„è®¾"${preset.name}"å·²${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}ï¼šæˆåŠŸ ${successCount} ä¸ªï¼Œå¤±è´¥ ${failCount} ä¸ª` :
                `é¢„è®¾"${preset.name}"å·²${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}ï¼š${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}äº† ${successCount} ä¸ªæ¡ç›®`;
              
              this.showTemporaryMessage(message, failCount > 0 ? 'warning' : 'success', 3000);
            } catch (error) {
              console.error('[é¢„è®¾åº”ç”¨] åº”ç”¨é¢„è®¾å¤±è´¥:', error);
              this.showTemporaryMessage('åº”ç”¨é¢„è®¾å¤±è´¥', 'error', 3000);
            }
          },

          // ç»‘å®šé¢„è®¾ç®¡ç†äº‹ä»¶
          bindPresetsManagerEvents() {
            // é¢„è®¾åˆ—è¡¨ç‚¹å‡»äº‹ä»¶
            const listContainer = document.getElementById('presets-list');
            if (listContainer) {
              listContainer.addEventListener('click', (e) => {
                const presetItem = e.target.closest('.preset-item');
                if (presetItem) {
                  const presetId = presetItem.dataset.presetId;
                  this.showPresetDetails(presetId);
                }
              });
            }

            // æ–°å»ºé¢„è®¾æŒ‰é’®
            const createBtn = document.getElementById('create-preset-btn');
            if (createBtn) {
              createBtn.addEventListener('click', () => {
                this.showCreatePresetModal();
              });
            }

            // å…³é—­æŒ‰é’®ï¼šè¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
            const closeBtn = document.getElementById('close-presets-modal');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.closeModal('worldbook-presets-modal');
                // å¦‚æœæ˜¯ä»ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢è¿›å…¥çš„ï¼Œè¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
                if (this.isFromWorldbookManager) {
                  this.showWorldbookManager();
                  this.isFromWorldbookManager = false; // é‡ç½®æ ‡å¿—ä½
                }
              });
            }

            // æ¨¡æ€æ¡†èƒŒæ™¯ç‚¹å‡»å…³é—­ï¼šè¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
            const modal = document.getElementById('worldbook-presets-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.closeModal('worldbook-presets-modal');
                  // å¦‚æœæ˜¯ä»ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢è¿›å…¥çš„ï¼Œè¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
                  if (this.isFromWorldbookManager) {
                    this.showWorldbookManager();
                    this.isFromWorldbookManager = false; // é‡ç½®æ ‡å¿—ä½
                  }
                }
              });
            }
          },

          // ç»‘å®šé¢„è®¾ç¼–è¾‘äº‹ä»¶
          bindPresetEditEvents() {
            // å…ˆæ¸…ç†æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…é‡å¤ç»‘å®š
            this.cleanupPresetEditEvents();

            // ç­›é€‰ç±»å‹å˜åŒ–
            const filterTypeSelect = document.getElementById('preset-filter-type');
            if (filterTypeSelect) {
              filterTypeSelect.addEventListener('change', () => {
                this.applyPresetFilter();
              });
            }

            // å…³é”®è¯ç­›é€‰è¾“å…¥
            const prefixFilterInput = document.getElementById('preset-prefix-filter');
            if (prefixFilterInput) {
              prefixFilterInput.addEventListener('input', () => {
                this.applyPresetFilter();
              });
            }

            // æ¡ç›®å¤é€‰æ¡†å˜åŒ–ç›‘å¬ï¼ˆä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼‰
            const entriesContainer = document.getElementById('preset-entries-selection');
            if (entriesContainer) {
              entriesContainer.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                  const entryName = e.target.dataset.entryName;
                  if (!this.presetEditState) this.presetEditState = { selectedEntries: [] };
                  
                  if (e.target.checked) {
                    // æ·»åŠ åˆ°å·²é€‰åˆ—è¡¨
                    if (!this.presetEditState.selectedEntries.includes(entryName)) {
                      this.presetEditState.selectedEntries.push(entryName);
                    }
                  } else {
                    // ä»å·²é€‰åˆ—è¡¨ç§»é™¤
                    const index = this.presetEditState.selectedEntries.indexOf(entryName);
                    if (index > -1) {
                      this.presetEditState.selectedEntries.splice(index, 1);
                    }
                  }
                  
                  // æ›´æ–°è¾¹æ¡†é¢œè‰²
                  const parentDiv = e.target.closest('div');
                  if (parentDiv) {
                    parentDiv.style.borderColor = e.target.checked ? '#c9aa71' : '#8b7355';
                  }
                  
                  console.log('[é¢„è®¾ç¼–è¾‘] æ¡ç›®é€‰æ‹©å˜åŒ–:', entryName, e.target.checked);
                }
              });
            }

            // å…¨é€‰æŒ‰é’®
            const selectAllBtn = document.getElementById('select-all-entries');
            if (selectAllBtn) {
              selectAllBtn.addEventListener('click', () => {
                const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]');
                checkboxes.forEach(cb => {
                  cb.checked = true;
                  // è§¦å‘changeäº‹ä»¶ä»¥æ›´æ–°selectedEntries
                  cb.dispatchEvent(new Event('change', { bubbles: true }));
                });
              });
            }

            // å…¨ä¸é€‰æŒ‰é’®
            const deselectAllBtn = document.getElementById('deselect-all-entries');
            if (deselectAllBtn) {
              deselectAllBtn.addEventListener('click', () => {
                const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]');
                checkboxes.forEach(cb => {
                  cb.checked = false;
                  // è§¦å‘changeäº‹ä»¶ä»¥æ›´æ–°selectedEntries
                  cb.dispatchEvent(new Event('change', { bubbles: true }));
                });
              });
            }

            // é€‰æ‹©å·²å¯ç”¨æŒ‰é’®
            const selectEnabledBtn = document.getElementById('select-enabled-entries');
            if (selectEnabledBtn) {
              selectEnabledBtn.addEventListener('click', () => {
                if (!this.presetEditState?.filteredEntries) return;
                
                const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                  const entryName = checkbox.dataset.entryName;
                  const entry = this.presetEditState.filteredEntries.find(e => (e.comment || e.uid) === entryName);
                  const shouldCheck = entry && entry.enabled;
                  
                  if (checkbox.checked !== shouldCheck) {
                    checkbox.checked = shouldCheck;
                    // è§¦å‘changeäº‹ä»¶ä»¥æ›´æ–°selectedEntries
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                  }
                });
              });
            }

            // ä¿å­˜æŒ‰é’® - ä¼˜åŒ–ï¼šä¿å­˜åè¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
            const saveBtn = document.getElementById('save-preset');
            if (saveBtn) {
              saveBtn.addEventListener('click', () => {
                this.savePreset();
              });
            }

            // å–æ¶ˆæŒ‰é’® - ä¼˜åŒ–ï¼šè¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
            const cancelBtn = document.getElementById('cancel-preset-edit');
            if (cancelBtn) {
              cancelBtn.addEventListener('click', () => {
                this.closeModal('preset-edit-modal');
                this.showWorldbookPresets(); // è¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
              });
            }

            // å…³é—­æŒ‰é’® - ä¼˜åŒ–ï¼šè¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
            const closeBtn = document.getElementById('close-preset-edit');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.closeModal('preset-edit-modal');
                this.showWorldbookPresets(); // è¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
              });
            }

            // æ¨¡æ€æ¡†èƒŒæ™¯ç‚¹å‡»å…³é—­ - ä¼˜åŒ–ï¼šè¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
            const modal = document.getElementById('preset-edit-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.closeModal('preset-edit-modal');
                  this.showWorldbookPresets(); // è¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
                }
              });
            }
          },

          // æ¸…ç†é¢„è®¾ç¼–è¾‘äº‹ä»¶ç›‘å¬å™¨
          cleanupPresetEditEvents() {
            const elements = [
              'preset-filter-type',
              'preset-prefix-filter',
              'select-all-entries',
              'deselect-all-entries',
              'select-enabled-entries',
              'save-preset',
              'cancel-preset-edit',
              'close-preset-edit',
              'preset-edit-modal'
            ];

            elements.forEach(id => {
              const element = document.getElementById(id);
              if (element) {
                // é€šè¿‡å…‹éš†èŠ‚ç‚¹æ¥ç§»é™¤æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
                const newElement = element.cloneNode(true);
                element.parentNode.replaceChild(newElement, element);
              }
            });
          },
// ===ä¸–ç•Œä¹¦é¢„è®¾æ¨¡å—ç»“æŸ===



// === èƒŒæ™¯å›¾æ¨¡å—å¼€å§‹===
          // èƒŒæ™¯å›¾è®¾ç½®åŠŸèƒ½
          showBackgroundSettings() {
            this.openModal('background-settings-modal');
            this.renderBackgroundList();
            this.updateBackgroundModeUI();
            
            // ç¡®ä¿åœ¨æ¨¡æ€æ¡†æ‰“å¼€åç»‘å®šäº‹ä»¶
            setTimeout(() => {
              this.bindBackgroundListEvents();
            }, 100);
          },

          updateBackgroundModeUI() {
            const randomRadio = document.getElementById('bg-mode-random');
            const fixedRadio = document.getElementById('bg-mode-fixed');
            if (randomRadio && fixedRadio) {
              randomRadio.checked = this.backgroundMode === 'random';
              fixedRadio.checked = this.backgroundMode === 'fixed';
            }
          },

          renderBackgroundList() {
            const listContainer = document.getElementById('background-list');
            const countSpan = document.getElementById('background-count');
            const pageInfo = document.getElementById('gallery-page-info');
            const prevBtn = document.getElementById('gallery-prev-page');
            const nextBtn = document.getElementById('gallery-next-page');
            
            if (!listContainer || !countSpan) return;

            const allImages = this.gallerySource === 'library' ? this.backgroundImages : this.outputFolderImages;
            const totalCount = allImages.length;
            const totalPages = Math.ceil(totalCount / this.galleryPageSize);
            
            // ç¡®ä¿å½“å‰é¡µç æœ‰æ•ˆ
            if (this.galleryCurrentPage > totalPages && totalPages > 0) {
              this.galleryCurrentPage = totalPages;
            }
            if (this.galleryCurrentPage < 1) {
              this.galleryCurrentPage = 1;
            }

            countSpan.textContent = `(${totalCount}å¼ )`;
            
            // æ›´æ–°åˆ†é¡µä¿¡æ¯
            if (pageInfo) {
              pageInfo.textContent = totalPages > 0 ? `ç¬¬ ${this.galleryCurrentPage} é¡µ / å…± ${totalPages} é¡µ` : 'æš‚æ— æ•°æ®';
            }
            
            // æ›´æ–°åˆ†é¡µæŒ‰é’®çŠ¶æ€
            if (prevBtn) {
              prevBtn.disabled = this.galleryCurrentPage <= 1;
              prevBtn.style.opacity = this.galleryCurrentPage <= 1 ? '0.5' : '1';
              prevBtn.style.cursor = this.galleryCurrentPage <= 1 ? 'not-allowed' : 'pointer';
            }
            if (nextBtn) {
              nextBtn.disabled = this.galleryCurrentPage >= totalPages;
              nextBtn.style.opacity = this.galleryCurrentPage >= totalPages ? '0.5' : '1';
              nextBtn.style.cursor = this.galleryCurrentPage >= totalPages ? 'not-allowed' : 'pointer';
            }

            listContainer.innerHTML = '';

            if (totalCount === 0) {
              const message = this.gallerySource === 'library' ? 'æš‚æ— èƒŒæ™¯å›¾' : 'Outputæ–‡ä»¶å¤¹ä¸ºç©ºæˆ–æœªé€‰æ‹©';
              listContainer.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; color: #8b7355; padding: 20px;">${message}</div>`;
              return;
            }

            // è®¡ç®—å½“å‰é¡µçš„å›¾ç‰‡èŒƒå›´
            const startIndex = (this.galleryCurrentPage - 1) * this.galleryPageSize;
            const endIndex = Math.min(startIndex + this.galleryPageSize, totalCount);
            const imagesToShow = allImages.slice(startIndex, endIndex);

            imagesToShow.forEach(bg => {
              const item = document.createElement('div');
              item.className = 'background-item';
              item.dataset.bgId = bg.id;
              
              if (this.backgroundMode === 'fixed' && this.selectedBackgroundId === bg.id) {
                item.classList.add('selected');
              }

              const linkIcon = bg.isUrlImage ? '<div style="position: absolute; top: 5px; left: 5px; background: rgba(0,0,0,0.7); color: #fff; padding: 2px 6px; border-radius: 3px; font-size: 10px;">ğŸ”—</div>' : '';
              // Outputå›¾ç‰‡æ˜¾ç¤º"æ·»åŠ "æŒ‰é’®ï¼Œå…¶ä»–æ˜¾ç¤º"åˆ é™¤"æŒ‰é’®
              const actionBtn = bg.isOutput
                ? `<button class="background-item-btn add-to-library" data-bg-id="${bg.id}">æ·»åŠ åˆ°å›¾åº“</button>`
                : `<button class="background-item-btn delete" data-bg-id="${bg.id}">åˆ é™¤</button>`;

              item.innerHTML = `
                <img src="${bg.dataUrl}" alt="${bg.name}" loading="lazy" style="width: 100%; height: 100%; object-fit: cover;">
                ${linkIcon}
                <div class="background-item-overlay">
                  <div class="background-item-actions">
                    <button class="background-item-btn preview-btn" data-bg-id="${bg.id}">é¢„è§ˆ</button>
                    <button class="background-item-btn select-btn" data-bg-id="${bg.id}">é€‰æ‹©</button>
                    ${actionBtn}
                  </div>
                </div>
              `;

              if (this.backgroundMode === 'fixed' && this.selectedBackgroundId === bg.id) {
                const indicator = document.createElement('div');
                indicator.className = 'background-preview-indicator';
                indicator.textContent = 'å½“å‰';
                item.appendChild(indicator);
              }

              listContainer.appendChild(item);
            });

            this.bindBackgroundListEvents();
          },

          bindBackgroundListEvents() {
            const listContainer = document.getElementById('background-list');
            if (!listContainer) return;

            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (this.backgroundListClickHandler) {
              listContainer.removeEventListener('click', this.backgroundListClickHandler);
            }

            // åˆ›å»ºæ–°çš„äº‹ä»¶å¤„ç†å™¨å¹¶ä¿å­˜å¼•ç”¨
            this.backgroundListClickHandler = (e) => {
              const bgId = e.target.dataset.bgId;
              if (!bgId) return;

              if (e.target.classList.contains('preview-btn')) {
                this.previewBackground(bgId);
              } else if (e.target.classList.contains('select-btn')) {
                this.selectBackground(bgId);
              } else if (e.target.classList.contains('delete')) {
                this.deleteBackground(bgId);
              } else if (e.target.classList.contains('add-to-library')) {
                this.addOutputImageToLibrary(bgId);
              }
            };

            // ç»‘å®šæ–°çš„äº‹ä»¶ç›‘å¬å™¨
            listContainer.addEventListener('click', this.backgroundListClickHandler);
          },


          
          
          /**
           * é€šç”¨å›¾åº“é€‰æ‹©å™¨ - æ¨¡å—åŒ–å¯å¤ç”¨ç»„ä»¶
           * @param {Object} options - é…ç½®é€‰é¡¹
           * @param {string} options.title - æ¨¡æ€æ¡†æ ‡é¢˜
           * @param {string} options.mode - æ¨¡å¼: 'background'|'novel'|'avatar'
           * @param {Function} options.onSelect - é€‰æ‹©å›è°ƒ (imageData) => {}
           * @param {Function} options.onClose - å…³é—­å›è°ƒ () => {}
           * @param {boolean} options.enablePagination - æ˜¯å¦å¯ç”¨åˆ†é¡µï¼Œé»˜è®¤true
           * @param {number} options.pageSize - æ¯é¡µæ•°é‡ï¼Œé»˜è®¤20
           * @param {boolean} options.enableSourceSwitch - æ˜¯å¦æ˜¾ç¤ºæ•°æ®æºåˆ‡æ¢ï¼Œé»˜è®¤true
           * @param {boolean} options.enableLazyLoad - æ˜¯å¦æ‡’åŠ è½½ï¼Œé»˜è®¤true
           * @param {string} options.extraControlsHtml - é¢å¤–æ§ä»¶HTML
           * @param {Array} options.extraButtons - é¢å¤–æŒ‰é’®é…ç½® [{text, callback, style}]
           * @param {boolean} options.allowEmpty - æ˜¯å¦å…è®¸é€‰æ‹©"æ— èƒŒæ™¯"ï¼Œé»˜è®¤false
           * @param {string} options.containerStyle - è‡ªå®šä¹‰å®¹å™¨æ ·å¼
           */
          async showUnifiedGalleryPicker(options = {}) {
            // é»˜è®¤é…ç½®
            const config = {
              title: 'é€‰æ‹©å›¾ç‰‡',
              mode: 'background',
              onSelect: null,
              onClose: null,
              enablePagination: true,
              pageSize: 20,
              enableSourceSwitch: true,
              enableLazyLoad: true,
              extraControlsHtml: '',
              extraButtons: [],
              allowEmpty: false,
              containerStyle: '',
              ...options
            };

            // ç¡®ä¿å·²åŠ è½½èƒŒæ™¯è®¾ç½®
            await this.loadBackgroundSettings();

            // åˆ›å»ºå”¯ä¸€çš„æ¨¡æ€æ¡†ID
            const modalId = `unified-gallery-${config.mode}-${Date.now()}`;
            
            // åˆ›å»ºé®ç½©å±‚
            const overlay = document.createElement('div');
            overlay.id = modalId;
            overlay.className = 'unified-gallery-overlay';
            overlay.style.cssText = `
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(0, 0, 0, 0.85);
              z-index: 10000;
              display: flex;
              justify-content: center;
              align-items: center;
              animation: fadeIn 0.3s;
            `;

            // åˆ›å»ºæ¨¡æ€æ¡†å†…å®¹
            const modalContent = document.createElement('div');
            modalContent.className = 'unified-gallery-content';
            modalContent.style.cssText = `
              width: 80%;
              max-width: 900px;
              height: 80vh;
              display: flex;
              flex-direction: column;
              border-radius: 8px;
              border: 1px solid #c9aa71;
              background: rgba(26, 26, 46, 0.95);
              box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
              ${config.containerStyle}
            `;

            // ç”Ÿæˆæ•°æ®æºåˆ‡æ¢HTMLï¼ˆå¦‚æœå¯ç”¨ï¼‰
            const sourceSwitchHtml = config.enableSourceSwitch ? `
              <div style="padding: 10px; border-bottom: 1px solid rgba(201, 170, 113, 0.3);">
                <div style="display: flex; gap: 15px; justify-content: center;">
                  <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #c9aa71;">
                    <input type="radio" name="${modalId}-source" value="library" checked class="gallery-source-radio">
                    <span>ğŸ“š å›¾åº“</span>
                  </label>
                  <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #c9aa71;">
                    <input type="radio" name="${modalId}-source" value="output" class="gallery-source-radio">
                    <span>ğŸ“ Outputæ–‡ä»¶å¤¹</span>
                  </label>
                </div>
              </div>
            ` : '';

            // ç”Ÿæˆåˆ†é¡µæ§ä»¶HTMLï¼ˆå¦‚æœå¯ç”¨ï¼‰
            const paginationHtml = config.enablePagination ? `
              <div class="unified-gallery-pagination" style="padding: 10px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(139, 115, 85, 0.3);">
                <button class="unified-prev-btn interaction-btn" style="padding: 5px 15px; font-size: 12px;">
                  <i class="fas fa-chevron-left"></i> ä¸Šä¸€é¡µ
                </button>
                <span class="unified-page-info" style="color: #c9aa71; font-size: 12px;">ç¬¬ 1 é¡µ / å…± 1 é¡µ</span>
                <button class="unified-next-btn interaction-btn" style="padding: 5px 15px; font-size: 12px;">
                  ä¸‹ä¸€é¡µ <i class="fas fa-chevron-right"></i>
                </button>
              </div>
            ` : '';

            // ç”Ÿæˆ"æ— èƒŒæ™¯"é€‰é¡¹HTMLï¼ˆå¦‚æœå¯ç”¨ï¼‰
            const emptyOptionHtml = config.allowEmpty ? `
              <div class="unified-empty-option" data-empty="true" style="
                width: 100%;
                height: 80px;
                border: 2px solid #8b7355;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                background: rgba(26, 26, 46, 0.8);
                color: #8b7355;
                font-size: 11px;
                transition: border-color 0.3s ease;
              ">æ— èƒŒæ™¯</div>
            ` : '';

            // ç”Ÿæˆé¢å¤–æŒ‰é’®HTML
            const extraButtonsHtml = config.extraButtons.map(btn => `
              <button class="unified-extra-btn" data-action="${btn.action || ''}" style="${btn.style || 'padding: 8px 16px; background: #8b7355; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;'}">
                ${btn.text}
              </button>
            `).join('');

            modalContent.innerHTML = `
              <div style="padding: 15px; border-bottom: 1px solid #8b7355; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; font-size: 1.3rem; color: #c9aa71;">${config.title}</h2>
                <span class="unified-close-btn" style="font-size: 24px; color: #888; cursor: pointer;">&times;</span>
              </div>
              ${config.extraControlsHtml}
              ${sourceSwitchHtml}
              ${paginationHtml}
              <div class="unified-gallery-grid-container" style="flex-grow: 1; overflow-y: auto; padding: 15px;">
                <div class="unified-gallery-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px;">
                  ${emptyOptionHtml}
                </div>
              </div>
              <div style="padding: 10px; border-top: 1px solid #8b7355; display: flex; gap: 10px; justify-content: center;">
                ${extraButtonsHtml}
              </div>
            `;

            overlay.appendChild(modalContent);
            document.body.appendChild(overlay);

            // åˆå§‹åŒ–çŠ¶æ€
            const state = {
              currentPage: 1,
              pageSize: config.pageSize,
              currentSource: 'library',
              modalId: modalId
            };

            // æ¸²æŸ“å›¾åº“å‡½æ•°
            const renderGallery = () => {
              const grid = modalContent.querySelector('.unified-gallery-grid');
              const pageInfo = modalContent.querySelector('.unified-page-info');
              const prevBtn = modalContent.querySelector('.unified-prev-btn');
              const nextBtn = modalContent.querySelector('.unified-next-btn');
              
              if (!grid) return;

              // è·å–æ•°æ®æº
              const allImages = state.currentSource === 'library' ? this.backgroundImages : this.outputFolderImages;
              const totalCount = allImages.length;
              const totalPages = Math.ceil(totalCount / state.pageSize);

              // ç¡®ä¿å½“å‰é¡µç æœ‰æ•ˆ
              if (state.currentPage > totalPages && totalPages > 0) {
                state.currentPage = totalPages;
              }
              if (state.currentPage < 1) {
                state.currentPage = 1;
              }

              // æ›´æ–°åˆ†é¡µä¿¡æ¯
              if (pageInfo) {
                pageInfo.textContent = totalPages > 0 ? `ç¬¬ ${state.currentPage} é¡µ / å…± ${totalPages} é¡µ` : 'æš‚æ— æ•°æ®';
              }

              // æ›´æ–°åˆ†é¡µæŒ‰é’®çŠ¶æ€
              if (prevBtn) {
                prevBtn.disabled = state.currentPage <= 1;
                prevBtn.style.opacity = state.currentPage <= 1 ? '0.5' : '1';
                prevBtn.style.cursor = state.currentPage <= 1 ? 'not-allowed' : 'pointer';
              }
              if (nextBtn) {
                nextBtn.disabled = state.currentPage >= totalPages;
                nextBtn.style.opacity = state.currentPage >= totalPages ? '0.5' : '1';
                nextBtn.style.cursor = state.currentPage >= totalPages ? 'not-allowed' : 'pointer';
              }

              // æ¸…ç©ºç½‘æ ¼ï¼ˆä¿ç•™"æ— èƒŒæ™¯"é€‰é¡¹ï¼‰
              const emptyOption = grid.querySelector('[data-empty="true"]');
              grid.innerHTML = '';
              if (emptyOption && config.allowEmpty) {
                grid.appendChild(emptyOption);
              }

              // å¦‚æœæ²¡æœ‰å›¾ç‰‡
              if (totalCount === 0) {
                const message = state.currentSource === 'library' ? 'æš‚æ— å¯ç”¨å›¾ç‰‡' : 'Outputæ–‡ä»¶å¤¹ä¸ºç©ºæˆ–æœªé€‰æ‹©';
                const emptyTip = document.createElement('div');
                emptyTip.style.cssText = `
                  grid-column: 1 / -1;
                  text-align: center;
                  padding: 30px;
                  color: #8b7355;
                `;
                emptyTip.innerHTML = `
                  <i class="fas fa-image" style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;"></i>
                  <div style="color: #e8dcc6; font-size: 1rem; margin-bottom: 8px;">${message}</div>
                  <div style="font-size: 0.9rem; color: #888;">è¯·å…ˆæ·»åŠ å›¾ç‰‡æˆ–é€‰æ‹©Outputæ–‡ä»¶å¤¹</div>
                `;
                grid.appendChild(emptyTip);
                return;
              }

              // è®¡ç®—å½“å‰é¡µçš„å›¾ç‰‡èŒƒå›´
              const startIndex = (state.currentPage - 1) * state.pageSize;
              const endIndex = Math.min(startIndex + state.pageSize, totalCount);
              const imagesToShow = allImages.slice(startIndex, endIndex);

              // æ¸²æŸ“å›¾ç‰‡
              imagesToShow.forEach((img, index) => {
                const card = document.createElement('div');
                card.className = 'unified-gallery-card';
                card.dataset.imageId = img.id;
                card.dataset.imageUrl = img.dataUrl || img.url;
                card.style.cssText = `
                  position: relative;
                  aspect-ratio: 1;
                  border-radius: 6px;
                  overflow: hidden;
                  cursor: pointer;
                  border: 1px solid #8b7355;
                  transition: all 0.15s ease;
                  background-image: url('${img.dataUrl || img.url}');
                  background-size: cover;
                  background-position: center;
                `;

                const cardOverlay = document.createElement('div');
                cardOverlay.style.cssText = `
                  position: absolute;
                  top: 0;
                  left: 0;
                  right: 0;
                  bottom: 0;
                  background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
                  display: flex;
                  align-items: flex-end;
                  justify-content: center;
                  padding: 8px;
                  opacity: 0.8;
                  transition: opacity 0.15s ease;
                `;

                const nameTag = document.createElement('div');
                nameTag.style.cssText = `
                  font-size: 0.8rem;
                  color: #e8dcc6;
                  text-align: center;
                  white-space: nowrap;
                  overflow: hidden;
                  text-overflow: ellipsis;
                  max-width: 100%;
                `;
                nameTag.textContent = img.name || `å›¾ç‰‡ ${startIndex + index + 1}`;

                cardOverlay.appendChild(nameTag);
                card.appendChild(cardOverlay);

                // é¼ æ ‡æ‚¬åœæ•ˆæœ
                card.addEventListener('mouseenter', () => {
                  card.style.borderColor = '#c9aa71';
                  card.style.transform = 'translateY(-2px)';
                  cardOverlay.style.opacity = '1';
                });
                card.addEventListener('mouseleave', () => {
                  card.style.borderColor = '#8b7355';
                  card.style.transform = 'translateY(0)';
                  cardOverlay.style.opacity = '0.8';
                });

                // ç‚¹å‡»é€‰æ‹©
                card.addEventListener('click', () => {
                  if (config.onSelect) {
                    config.onSelect({
                      id: img.id,
                      name: img.name,
                      dataUrl: img.dataUrl || img.url,
                      url: img.url,
                      isOutput: img.isOutput || false,
                      source: state.currentSource
                    });
                  }
                  overlay.remove();
                });

                // æ‡’åŠ è½½
                if (config.enableLazyLoad) {
                  const bgImg = new Image();
                  bgImg.src = img.dataUrl || img.url;
                }

                grid.appendChild(card);
              });
            };

            // ç»‘å®šäº‹ä»¶
            
            // å…³é—­æŒ‰é’®
            modalContent.querySelector('.unified-close-btn').onclick = () => {
              if (config.onClose) config.onClose();
              overlay.remove();
            };

            // ç‚¹å‡»é®ç½©å±‚å…³é—­
            overlay.addEventListener('click', (e) => {
              if (e.target === overlay) {
                if (config.onClose) config.onClose();
                overlay.remove();
              }
            });

            // æ•°æ®æºåˆ‡æ¢äº‹ä»¶
            if (config.enableSourceSwitch) {
              const sourceRadios = modalContent.querySelectorAll('.gallery-source-radio');
              sourceRadios.forEach(radio => {
                radio.addEventListener('change', async (e) => {
                  const newSource = e.target.value;
                  if (newSource === state.currentSource) return;
                  
                  state.currentSource = newSource;
                  state.currentPage = 1; // åˆ‡æ¢æ•°æ®æºæ—¶é‡ç½®é¡µç 
                  
                  // å¦‚æœåˆ‡æ¢åˆ°outputä½†æ²¡æœ‰é€‰æ‹©æ–‡ä»¶å¤¹,æç¤ºç”¨æˆ·
                  if (newSource === 'output' && (!this.outputFolderHandle || this.outputFolderImages.length === 0)) {
                    this.showTemporaryMessage('è¯·å…ˆåœ¨èƒŒæ™¯è®¾ç½®ä¸­é€‰æ‹©Outputæ–‡ä»¶å¤¹', 'warning');
                  }
                  
                  renderGallery();
                });
              });
            }

            // åˆ†é¡µæŒ‰é’®äº‹ä»¶
            if (config.enablePagination) {
              const prevBtn = modalContent.querySelector('.unified-prev-btn');
              const nextBtn = modalContent.querySelector('.unified-next-btn');
              
              if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                  if (state.currentPage > 1) {
                    state.currentPage--;
                    renderGallery();
                    // æ»šåŠ¨åˆ°åˆ—è¡¨é¡¶éƒ¨
                    const gridContainer = modalContent.querySelector('.unified-gallery-grid-container');
                    if (gridContainer) gridContainer.scrollTop = 0;
                  }
                });
              }
              
              if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                  const allImages = state.currentSource === 'library' ? this.backgroundImages : this.outputFolderImages;
                  const totalPages = Math.ceil(allImages.length / state.pageSize);
                  if (state.currentPage < totalPages) {
                    state.currentPage++;
                    renderGallery();
                    // æ»šåŠ¨åˆ°åˆ—è¡¨é¡¶éƒ¨
                    const gridContainer = modalContent.querySelector('.unified-gallery-grid-container');
                    if (gridContainer) gridContainer.scrollTop = 0;
                  }
                });
              }
            }

            // "æ— èƒŒæ™¯"é€‰é¡¹äº‹ä»¶
            if (config.allowEmpty) {
              const emptyOption = modalContent.querySelector('.unified-empty-option');
              if (emptyOption) {
                emptyOption.addEventListener('click', () => {
                  if (config.onSelect) {
                    config.onSelect({
                      id: '',
                      name: 'æ— èƒŒæ™¯',
                      dataUrl: '',
                      url: '',
                      isOutput: false,
                      source: 'empty'
                    });
                  }
                  overlay.remove();
                });
                
                // æ‚¬åœæ•ˆæœ
                emptyOption.addEventListener('mouseenter', () => {
                  emptyOption.style.borderColor = '#c9aa71';
                });
                emptyOption.addEventListener('mouseleave', () => {
                  emptyOption.style.borderColor = '#8b7355';
                });
              }
            }

            // é¢å¤–æŒ‰é’®äº‹ä»¶
            if (config.extraButtons && config.extraButtons.length > 0) {
              const extraBtns = modalContent.querySelectorAll('.unified-extra-btn');
              extraBtns.forEach((btn, index) => {
                const btnConfig = config.extraButtons[index];
                if (btnConfig && btnConfig.callback) {
                  btn.addEventListener('click', () => {
                    btnConfig.callback({
                      modalId: modalId,
                      state: state,
                      overlay: overlay,
                      renderGallery: renderGallery
                    });
                  });
                }
              });
            }
            
            // åˆå§‹æ¸²æŸ“
            renderGallery();
          },

          // ===é€šç”¨å›¾åº“ç»„ä»¶ç»“æŸ===

          // æ–°å¢ï¼šå°†èƒŒæ™¯è®¾ç½®æ¨¡æ€æ¡†å†…çš„é™æ€äº‹ä»¶ç»‘å®šåˆ†ç¦»å‡ºæ¥
          bindBackgroundSettingsListeners() {
              if (this.backgroundEventsInitialized) return; // ç¡®ä¿åªç»‘å®šä¸€æ¬¡

              // ç»‘å®šä¸Šä¼ åŒºåŸŸäº‹ä»¶
              const uploadArea = document.getElementById('background-upload-area');
              const fileInput = document.getElementById('background-file-input');
              if (uploadArea && fileInput) {
                  uploadArea.addEventListener('click', () => fileInput.click());
                  fileInput.addEventListener('change', (e) => this.handleBackgroundUpload(e));
              }

              // ç»‘å®šæ¨¡å¼åˆ‡æ¢äº‹ä»¶
              const randomRadio = document.getElementById('bg-mode-random');
              const fixedRadio = document.getElementById('bg-mode-fixed');
              if (randomRadio && fixedRadio) {
                  randomRadio.addEventListener('change', () => {
                      if (randomRadio.checked) {
                          this.backgroundMode = 'random';
                          this.saveBackgroundSettings();
                          this.renderBackgroundList();
                      }
                  });
                  fixedRadio.addEventListener('change', () => {
                      if (fixedRadio.checked) {
                          this.backgroundMode = 'fixed';
                          this.saveBackgroundSettings();
                          this.renderBackgroundList();
                      }
                  });
              }

              // ç»‘å®šå¤–é“¾å›¾åºŠæŒ‰é’®äº‹ä»¶
              const addUrlBtn = document.getElementById('add-url-image-btn');
              if (addUrlBtn) {
                  addUrlBtn.addEventListener('click', () => this.handleUrlImageAdd());
              }

              // ç»‘å®šç®¡ç†å¤–é“¾æŒ‰é’®äº‹ä»¶
              const manageUrlBtn = document.getElementById('manage-url-images-btn');
              if (manageUrlBtn) {
                  manageUrlBtn.addEventListener('click', () => this.showUrlImagesManageModal());
              }

              this.bindGallerySourceControls();
              // æ ‡è®°ä¸ºå·²åˆå§‹åŒ–
              this.backgroundEventsInitialized = true;
          },

          async handleBackgroundUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) {
              console.warn('[å½’å¢ŸèƒŒæ™¯] æ²¡æœ‰é€‰æ‹©æ–‡ä»¶');
              return;
            }

            console.log(`[å½’å¢ŸèƒŒæ™¯] å¼€å§‹å¤„ç† ${files.length} ä¸ªæ–‡ä»¶`);
            this.showTemporaryMessage('æ­£åœ¨å¤„ç†å›¾ç‰‡...', 3000);

            for (let i = 0; i < files.length; i++) {
              const file = files[i];
              console.log(`[å½’å¢ŸèƒŒæ™¯] å¤„ç†æ–‡ä»¶: ${file.name}, å¤§å°: ${file.size} bytes, ç±»å‹: ${file.type}`);
              
              // æ£€æŸ¥æ–‡ä»¶ç±»å‹
              if (!file.type.startsWith('image/')) {
                console.error(`[å½’å¢ŸèƒŒæ™¯] æ–‡ä»¶ç±»å‹æ— æ•ˆ: ${file.type}`);
                this.showTemporaryMessage(`æ–‡ä»¶ ${file.name} ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ ¼å¼`);
                continue;
              }

              try {
                let processedDataUrl;
                let compressionApplied = false;

                // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼Œå¦‚æœè¶…è¿‡2MBåˆ™å°è¯•å‹ç¼©
                if (file.size > 2 * 1024 * 1024) {
                  console.log(`[å½’å¢ŸèƒŒæ™¯] æ–‡ä»¶è¿‡å¤§ (${file.size} bytes)ï¼Œå°è¯•å‹ç¼©...`);
                  try {
                    processedDataUrl = await this.compressImage(file, 0.8, 1920, 1080);
                    compressionApplied = true;
                    console.log(`[å½’å¢ŸèƒŒæ™¯] å›¾ç‰‡å‹ç¼©æˆåŠŸ`);
                  } catch (compressionError) {
                    console.error(`[å½’å¢ŸèƒŒæ™¯] å›¾ç‰‡å‹ç¼©å¤±è´¥:`, compressionError);
                    // å¦‚æœå‹ç¼©å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨Object URLæ–¹å¼
                    try {
                      processedDataUrl = await this.createObjectUrlForLargeImage(file);
                      console.log(`[å½’å¢ŸèƒŒæ™¯] ä½¿ç”¨Object URLå¤„ç†å¤§å›¾ç‰‡`);
                    } catch (objectUrlError) {
                      console.error(`[å½’å¢ŸèƒŒæ™¯] Object URLåˆ›å»ºå¤±è´¥:`, objectUrlError);
                      this.showTemporaryMessage(`æ–‡ä»¶ ${file.name} è¿‡å¤§ä¸”å¤„ç†å¤±è´¥ï¼Œè¯·é€‰æ‹©å°äº2MBçš„å›¾ç‰‡`);
                      continue;
                    }
                  }
                } else {
                  // æ–‡ä»¶å¤§å°åˆé€‚ï¼Œç›´æ¥è½¬æ¢
                  processedDataUrl = await this.fileToDataUrl(file);
                  console.log(`[å½’å¢ŸèƒŒæ™¯] ç›´æ¥è½¬æ¢ä¸ºDataURLæˆåŠŸ`);
                }

                const bgId = 'bg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                const newBackground = {
                  id: bgId,
                  name: file.name.replace(/\.[^/.]+$/, ""), // ç§»é™¤æ–‡ä»¶æ‰©å±•å
                  dataUrl: processedDataUrl,
                  uploadTime: new Date().toISOString(),
                  isPreset: false,
                  compressed: compressionApplied,
                  originalSize: file.size
                };

                // ä¸´æ—¶æ·»åŠ åˆ°æ•°ç»„ä¸­æµ‹è¯•å­˜å‚¨
                const tempImages = [...this.backgroundImages, newBackground];
                const testSettings = {
                  images: tempImages,
                  mode: this.backgroundMode,
                  selectedId: this.selectedBackgroundId
                };

                // æµ‹è¯•æ˜¯å¦èƒ½å¤ŸæˆåŠŸä¿å­˜åˆ°localStorage
                try {
                  const testData = JSON.stringify(testSettings);
                  console.log(`[å½’å¢ŸèƒŒæ™¯] æµ‹è¯•æ•°æ®å¤§å°: ${testData.length} å­—ç¬¦`);
                  
                  // æ£€æŸ¥æ•°æ®å¤§å°ï¼ˆlocalStorageé€šå¸¸é™åˆ¶ä¸º5-10MBï¼‰
                  if (testData.length > 4 * 1024 * 1024) { // 4MBé™åˆ¶
                    throw new Error('å­˜å‚¨ç©ºé—´ä¸è¶³');
                  }
                  
                  // å°è¯•ä¿å­˜æµ‹è¯•æ•°æ®
                  localStorage.setItem('guixu_background_test', testData);
                  localStorage.removeItem('guixu_background_test');
                  
                  // å¦‚æœæµ‹è¯•æˆåŠŸï¼Œæ­£å¼æ·»åŠ å›¾ç‰‡
                  this.backgroundImages.push(newBackground);
                  this.saveBackgroundSettings();
                  
                  console.log(`[å½’å¢ŸèƒŒæ™¯] æˆåŠŸä¿å­˜å›¾ç‰‡: ${file.name}, å½“å‰å›¾ç‰‡æ•°é‡: ${this.backgroundImages.length}`);
                  
                  // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯ï¼ŒåŒ…å«å‹ç¼©ä¿¡æ¯
                  if (compressionApplied) {
                    this.showTemporaryMessage(`å›¾ç‰‡ ${file.name} å·²å‹ç¼©å¹¶ä¿å­˜æˆåŠŸ`);
                  } else {
                    this.showTemporaryMessage(`å›¾ç‰‡ ${file.name} ä¿å­˜æˆåŠŸ`);
                  }
                  
                } catch (storageError) {
                  console.error('[å½’å¢ŸèƒŒæ™¯] localStorageå­˜å‚¨å¤±è´¥:', storageError);
                  this.showTemporaryMessage(`å›¾ç‰‡ ${file.name} ä¿å­˜å¤±è´¥ï¼šå­˜å‚¨ç©ºé—´ä¸è¶³æˆ–å›¾ç‰‡è¿‡å¤§`);
                  continue;
                }
                
                // å¦‚æœèƒŒæ™¯è®¾ç½®æ¨¡æ€æ¡†æ˜¯æ‰“å¼€çš„ï¼Œåˆ·æ–°åˆ—è¡¨
                if (document.getElementById('background-settings-modal').style.display === 'flex') {
                  this.renderBackgroundList();
                }
                
              } catch (error) {
                console.error('[å½’å¢ŸèƒŒæ™¯] å¤„ç†å›¾ç‰‡å¤±è´¥:', error);
                this.showTemporaryMessage(`å¤„ç†å›¾ç‰‡ ${file.name} å¤±è´¥: ${error.message}`);
              }
            }

            // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
            event.target.value = '';
            this.showTemporaryMessage('å›¾ç‰‡å¤„ç†å®Œæˆï¼');
          },

          fileToDataUrl(file) {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = (e) => {
                console.log(`[å½’å¢ŸèƒŒæ™¯] FileReaderæˆåŠŸè¯»å–æ–‡ä»¶ï¼ŒDataURLé•¿åº¦: ${e.target.result.length}`);
                resolve(e.target.result);
              };
              reader.onerror = (error) => {
                console.error(`[å½’å¢ŸèƒŒæ™¯] FileReaderè¯»å–å¤±è´¥:`, error);
                reject(error);
              };
              reader.readAsDataURL(file);
            });
          },

          // æ–°å¢ï¼šå›¾ç‰‡å‹ç¼©å‡½æ•°
          compressImage(file, quality = 0.8, maxWidth = 1920, maxHeight = 1080) {
            return new Promise((resolve, reject) => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              const img = new Image();

              img.onload = () => {
                try {
                  // è®¡ç®—å‹ç¼©åçš„å°ºå¯¸
                  let { width, height } = img;
                  
                  if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width *= ratio;
                    height *= ratio;
                  }

                  canvas.width = width;
                  canvas.height = height;

                  // ç»˜åˆ¶å‹ç¼©åçš„å›¾ç‰‡
                  ctx.drawImage(img, 0, 0, width, height);

                  // è½¬æ¢ä¸ºDataURL
                  const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                  
                  console.log(`[å½’å¢ŸèƒŒæ™¯] å›¾ç‰‡å‹ç¼©å®Œæˆ: ${img.naturalWidth}x${img.naturalHeight} -> ${width}x${height}, è´¨é‡: ${quality}`);
                  resolve(compressedDataUrl);
                } catch (error) {
                  console.error(`[å½’å¢ŸèƒŒæ™¯] å›¾ç‰‡å‹ç¼©è¿‡ç¨‹ä¸­å‡ºé”™:`, error);
                  reject(error);
                }
              };

              img.onerror = (error) => {
                console.error(`[å½’å¢ŸèƒŒæ™¯] å›¾ç‰‡åŠ è½½å¤±è´¥:`, error);
                reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
              };

              // åˆ›å»ºå›¾ç‰‡URL
              const url = URL.createObjectURL(file);
              img.src = url;
              
              // æ¸…ç†URL - ä¿®æ­£onloadå¤„ç†
              const originalOnload = img.onload;
              img.onload = () => {
                URL.revokeObjectURL(url);
                originalOnload();
              };
            });
          },

          // æ–°å¢ï¼šä¸ºå¤§å›¾ç‰‡åˆ›å»ºObject URLçš„å¤„ç†æ–¹å¼
          createObjectUrlForLargeImage(file) {
            return new Promise((resolve, reject) => {
              try {
                // åˆ›å»ºObject URL
                const objectUrl = URL.createObjectURL(file);
                
                // éªŒè¯URLæ˜¯å¦æœ‰æ•ˆ
                const img = new Image();
                img.onload = () => {
                  console.log(`[å½’å¢ŸèƒŒæ™¯] Object URLåˆ›å»ºæˆåŠŸ: ${objectUrl}`);
                  resolve(objectUrl);
                };
                img.onerror = () => {
                  URL.revokeObjectURL(objectUrl);
                  reject(new Error('Object URLéªŒè¯å¤±è´¥'));
                };
                img.src = objectUrl;
              } catch (error) {
                console.error(`[å½’å¢ŸèƒŒæ™¯] Object URLåˆ›å»ºå¤±è´¥:`, error);
                reject(error);
              }
            });
          },



          previewBackground(bgId) {
            // æ ¹æ®å½“å‰å›¾åº“æ¥æºæŸ¥æ‰¾å›¾ç‰‡
            const allImages = this.gallerySource === 'library' ? this.backgroundImages : this.outputFolderImages;
            const bg = allImages.find(b => b.id === bgId);
            if (!bg) return;

            // åˆ›å»ºé¢„è§ˆæ¨¡æ€æ¡†
            this.showImagePreviewModal(bg);
          },

          showImagePreviewModal(bg) {
            // åˆ›å»ºé¢„è§ˆæ¨¡æ€æ¡†
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.display = 'flex';
            modal.style.zIndex = '2001'; // ç¡®ä¿åœ¨èƒŒæ™¯è®¾ç½®æ¨¡æ€æ¡†ä¹‹ä¸Š
            modal.innerHTML = `
              <div class="modal-content" style="width: 90vw; height: 90vh; max-width: none; max-height: none; padding: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column;">
                <div class="modal-header" style="padding: 15px; background: rgba(26, 26, 46, 0.95); flex-shrink: 0;">
                  <h2 class="modal-title">é¢„è§ˆï¼š${bg.name}</h2>
                  <button class="modal-close-btn" id="preview-close-btn">&times;</button>
                </div>
                <div class="modal-body" style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 10px; overflow: hidden; min-height: 0;">
                  <img src="${bg.dataUrl}" alt="${bg.name}" style="max-width: calc(100% - 20px); max-height: calc(100% - 20px); object-fit: contain; border-radius: 4px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                </div>
              </div>
            `;

            const container = document.querySelector('.guixu-root-container');
            if (container) {
              container.appendChild(modal);

              // ç»‘å®šå…³é—­äº‹ä»¶
              const closeBtn = modal.querySelector('#preview-close-btn');
              const closeModal = () => {
                modal.remove();
              };

              if (closeBtn) {
                closeBtn.addEventListener('click', closeModal);
              }

              // ç‚¹å‡»èƒŒæ™¯å…³é—­
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  closeModal();
                }
              });

              // ESCé”®å…³é—­
              const handleKeydown = (e) => {
                if (e.key === 'Escape') {
                  closeModal();
                  document.removeEventListener('keydown', handleKeydown);
                }
              };
              document.addEventListener('keydown', handleKeydown);

              this.showTemporaryMessage(`æ­£åœ¨é¢„è§ˆï¼š${bg.name}`);
            }
          },

          async selectBackground(bgId) {
            // æ ¹æ®å½“å‰å›¾åº“æ¥æºæŸ¥æ‰¾å›¾ç‰‡
            const allImages = this.gallerySource === 'library' ? this.backgroundImages : this.outputFolderImages;
            const bg = allImages.find(b => b.id === bgId);
            if (!bg) return;

            // å¦‚æœæ˜¯outputå›¾ç‰‡ï¼Œéœ€è¦å…ˆå°†å…¶æ·»åŠ åˆ°backgroundImagesä¸­
            if (bg.isOutput) {
              // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆé€šè¿‡dataUrlæ¯”è¾ƒï¼‰
              const existingBg = this.backgroundImages.find(b => b.dataUrl === bg.dataUrl);
              if (!existingBg) {
                // è‡ªåŠ¨æ·»åŠ åˆ°å›¾åº“
                const newBg = await this.addOutputImageToLibrary(bgId, true);
                if (newBg) {
                  this.selectedBackgroundId = newBg.id;
                  this.showTemporaryMessage(`å·²ä»Outputæ–‡ä»¶å¤¹å¯¼å…¥å¹¶é€‰æ‹©ï¼š${bg.name}`);
                }
              } else {
                this.selectedBackgroundId = existingBg.id;
                this.showTemporaryMessage(`å·²é€‰æ‹©èƒŒæ™¯ï¼š${bg.name}`);
              }
            } else {
              this.selectedBackgroundId = bgId;
              this.showTemporaryMessage(`å·²é€‰æ‹©èƒŒæ™¯ï¼š${bg.name}`);
            }

            this.backgroundMode = 'fixed'; // é€‰æ‹©èƒŒæ™¯æ—¶è‡ªåŠ¨åˆ‡æ¢åˆ°å›ºå®šæ¨¡å¼
            this.saveBackgroundSettings();
            this.updateBackgroundModeUI();
            this.renderBackgroundList();
            this.applyRandomBackground(); // åº”ç”¨é€‰ä¸­çš„èƒŒæ™¯
          },

          // æ–°å¢ï¼šå°†Outputå›¾ç‰‡æ·»åŠ åˆ°å›¾åº“
          async addOutputImageToLibrary(bgId, returnObject = false) {
            const bg = this.outputFolderImages.find(b => b.id === bgId);
            if (!bg) return null;

            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            const existingBg = this.backgroundImages.find(b => b.dataUrl === bg.dataUrl);
            if (existingBg) {
              this.showTemporaryMessage(`å›¾ç‰‡"${bg.name}"å·²åœ¨å›¾åº“ä¸­`, 'warning');
              return returnObject ? existingBg : null;
            }

            // åˆ›å»ºæ–°çš„èƒŒæ™¯å›¾å¯¹è±¡
            const newBg = {
              id: `imported_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              name: bg.name,
              dataUrl: bg.dataUrl,
              uploadTime: Date.now(),
              isOutput: false,
              sourceFolder: bg.folder
            };

            // æ·»åŠ åˆ°æ•°ç»„å¹¶ä¿å­˜
            this.backgroundImages.push(newBg);
            await this.saveBackgroundSettings();
            
            if (!returnObject) {
              this.showTemporaryMessage(`å·²å°†"${bg.name}"æ·»åŠ åˆ°å›¾åº“`, 'success');
              // åˆ·æ–°åˆ—è¡¨
              this.renderBackgroundList();
            }

            return newBg;
          },

          deleteBackground(bgId) {
            const bg = this.backgroundImages.find(b => b.id === bgId);
            if (!bg) return;

            this.showCustomConfirm(`ç¡®å®šè¦åˆ é™¤èƒŒæ™¯å›¾"${bg.name}"å—ï¼Ÿ`, () => {
              this.backgroundImages = this.backgroundImages.filter(b => b.id !== bgId);
              
              // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é€‰ä¸­çš„èƒŒæ™¯ï¼Œæ¸…é™¤é€‰æ‹©
              if (this.selectedBackgroundId === bgId) {
                this.selectedBackgroundId = null;
              }
              
              this.saveBackgroundSettings();
              this.renderBackgroundList();
              this.applyRandomBackground(); // é‡æ–°åº”ç”¨èƒŒæ™¯
              this.showTemporaryMessage(`å·²åˆ é™¤èƒŒæ™¯å›¾ï¼š${bg.name}`);
            }, null, true); // keepCurrentModal = true
          },

          // === IndexedDBèƒŒæ™¯å›¾å­˜å‚¨å‡½æ•° ===
          async saveBackgroundToIndexedDB() {
            if (!this.dbAvailable || !this.db) {
              console.warn('[å½’å¢ŸèƒŒæ™¯] IndexedDBä¸å¯ç”¨ï¼Œæ— æ³•ä¿å­˜èƒŒæ™¯å›¾');
              return false;
            }

            try {
              // æ¸…ç©ºç°æœ‰èƒŒæ™¯å›¾æ•°æ®
              await this.db.background_images.clear();
              
              // æ‰¹é‡ä¿å­˜æ‰€æœ‰èƒŒæ™¯å›¾
              for (const bg of this.backgroundImages) {
                await this.db.background_images.put(bg);
              }
              
              // ä¿å­˜æ¨¡å¼å’Œé€‰ä¸­IDåˆ°localStorageï¼ˆå…ƒæ•°æ®è¾ƒå°ï¼‰
              const metadata = {
                mode: this.backgroundMode,
                selectedId: this.selectedBackgroundId
              };
              localStorage.setItem('guixu_background_metadata', JSON.stringify(metadata));
              
              console.log(`[å½’å¢ŸèƒŒæ™¯] å·²ä¿å­˜ ${this.backgroundImages.length} å¼ èƒŒæ™¯å›¾åˆ°IndexedDB`);
              return true;
            } catch (error) {
              console.error('[å½’å¢ŸèƒŒæ™¯] ä¿å­˜åˆ°IndexedDBå¤±è´¥:', error);
              return false;
            }
          },

          async loadBackgroundFromIndexedDB() {
            if (!this.dbAvailable || !this.db) {
              console.warn('[å½’å¢ŸèƒŒæ™¯] IndexedDBä¸å¯ç”¨ï¼Œå°è¯•ä»localStorageåŠ è½½');
              return false;
            }

            try {
              // ä»IndexedDBåŠ è½½èƒŒæ™¯å›¾åˆ—è¡¨
              const backgrounds = await this.db.background_images.toArray();
              
              if (backgrounds && backgrounds.length > 0) {
                this.backgroundImages = backgrounds;
                console.log(`[å½’å¢ŸèƒŒæ™¯] ä»IndexedDBåŠ è½½äº† ${backgrounds.length} å¼ èƒŒæ™¯å›¾`);
              } else {
                // å¦‚æœIndexedDBä¸ºç©ºï¼Œå°è¯•ä»localStorageè¿ç§»æ•°æ®
                const migrated = await this.migrateBackgroundFromLocalStorage();
                if (!migrated) {
                  this.backgroundImages = [];
                }
              }
              
              // ä»localStorageåŠ è½½å…ƒæ•°æ®
              const metadataStr = localStorage.getItem('guixu_background_metadata');
              if (metadataStr) {
                const metadata = JSON.parse(metadataStr);
                this.backgroundMode = metadata.mode || 'random';
                this.selectedBackgroundId = metadata.selectedId || null;
              } else {
                this.backgroundMode = 'random';
                this.selectedBackgroundId = null;
              }
              
              return true;
            } catch (error) {
              console.error('[å½’å¢ŸèƒŒæ™¯] ä»IndexedDBåŠ è½½å¤±è´¥:', error);
              this.backgroundImages = [];
              this.backgroundMode = 'random';
              this.selectedBackgroundId = null;
              return false;
            }
          },

          async migrateBackgroundFromLocalStorage() {
            try {
              const saved = localStorage.getItem('guixu_background_settings');
              if (saved) {
                const settings = JSON.parse(saved);
                if (settings.images && settings.images.length > 0) {
                  console.log(`[å½’å¢ŸèƒŒæ™¯] æ­£åœ¨ä»localStorageè¿ç§» ${settings.images.length} å¼ èƒŒæ™¯å›¾åˆ°IndexedDB...`);
                  
                  this.backgroundImages = settings.images;
                  this.backgroundMode = settings.mode || 'random';
                  this.selectedBackgroundId = settings.selectedId || null;
                  
                  // ä¿å­˜åˆ°IndexedDB
                  const success = await this.saveBackgroundToIndexedDB();
                  
                  if (success) {
                    // è¿ç§»æˆåŠŸåï¼Œæ¸…ç†localStorageä¸­çš„æ—§æ•°æ®ï¼ˆä¿ç•™å…ƒæ•°æ®ï¼‰
                    localStorage.removeItem('guixu_background_settings');
                    console.log('[å½’å¢ŸèƒŒæ™¯] æ•°æ®è¿ç§»æˆåŠŸï¼Œå·²æ¸…ç†localStorageæ—§æ•°æ®');
                    return true;
                  }
                }
              }
              return false;
            } catch (error) {
              console.error('[å½’å¢ŸèƒŒæ™¯] æ•°æ®è¿ç§»å¤±è´¥:', error);
              return false;
            }
          },

          async saveBackgroundSettings() {
            try {
              if (this.dbAvailable && this.db) {
                // ä½¿ç”¨IndexedDBå­˜å‚¨èƒŒæ™¯å›¾
                await this.saveBackgroundToIndexedDB();
                console.log('[å½’å¢ŸèƒŒæ™¯] èƒŒæ™¯å›¾å·²ä¿å­˜åˆ°IndexedDB');
              } else {
                // é™çº§åˆ°localStorage
                const settings = {
                  images: this.backgroundImages,
                  mode: this.backgroundMode,
                  selectedId: this.selectedBackgroundId
                };
                localStorage.setItem('guixu_background_settings', JSON.stringify(settings));
                console.log('[å½’å¢ŸèƒŒæ™¯] èƒŒæ™¯å›¾å·²ä¿å­˜åˆ°localStorageï¼ˆé™çº§æ¨¡å¼ï¼‰');
              }
            } catch (e) {
              console.error('[å½’å¢ŸèƒŒæ™¯] ä¿å­˜èƒŒæ™¯å›¾è®¾ç½®å¤±è´¥:', e);
            }
          },

          async loadBackgroundSettings() {
            try {
              if (this.dbAvailable && this.db) {
                // ä»IndexedDBåŠ è½½
                await this.loadBackgroundFromIndexedDB();
                console.log('[å½’å¢ŸèƒŒæ™¯] ä»IndexedDBåŠ è½½èƒŒæ™¯å›¾æˆåŠŸ');
              } else {
                // é™çº§åˆ°localStorage
                const saved = localStorage.getItem('guixu_background_settings');
                if (saved) {
                  const settings = JSON.parse(saved);
                  this.backgroundImages = settings.images || [];
                  this.backgroundMode = settings.mode || 'random';
                  this.selectedBackgroundId = settings.selectedId || null;
                }
              }
            } catch (e) {
              console.error('[å½’å¢ŸèƒŒæ™¯] åŠ è½½èƒŒæ™¯å›¾è®¾ç½®å¤±è´¥:', e);
              this.backgroundImages = [];
              this.backgroundMode = 'random';
              this.selectedBackgroundId = null;
            }
          },

          // --- æ–°å¢ï¼šå¤„ç†å¤–é“¾å›¾åºŠæ·»åŠ  ---
          async handleUrlImageAdd() {
            const urlInput = document.getElementById('image-url-input');
            
            if (!urlInput) {
              this.showTemporaryMessage('æ‰¾ä¸åˆ°URLè¾“å…¥æ¡†');
              return;
            }
            
            const inputText = urlInput.value.trim();
            const baseName = ''; // ä½¿ç”¨ç©ºå­—ç¬¦ä¸²ï¼Œè®©ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆåç§°
            
            // éªŒè¯è¾“å…¥
            if (!inputText) {
              this.showTemporaryMessage('è¯·è¾“å…¥å›¾ç‰‡é“¾æ¥');
              return;
            }
            
            // åˆ†å‰²å¤šè¡Œè¾“å…¥ï¼Œæ”¯æŒå¤šä¸ªé“¾æ¥
            const imageUrls = inputText.split('\n')
              .map(url => url.trim())
              .filter(url => url.length > 0);
            
            if (imageUrls.length === 0) {
              this.showTemporaryMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„å›¾ç‰‡é“¾æ¥');
              return;
            }
            
            // éªŒè¯æ‰€æœ‰é“¾æ¥æ ¼å¼
            const invalidUrls = imageUrls.filter(url => !this.isValidImageUrl(url));
            if (invalidUrls.length > 0) {
              this.showTemporaryMessage(`ä»¥ä¸‹é“¾æ¥æ ¼å¼æ— æ•ˆï¼ˆéœ€è¦ä»¥ https:// å¼€å¤´ï¼‰ï¼š\n${invalidUrls.slice(0, 3).join('\n')}${invalidUrls.length > 3 ? '\n...' : ''}`);
              return;
            }
            
            // æ£€æŸ¥é‡å¤é“¾æ¥
            const existingUrls = imageUrls.filter(url =>
              this.backgroundImages.some(bg => bg.dataUrl === url)
            );
            if (existingUrls.length > 0) {
              this.showTemporaryMessage(`ä»¥ä¸‹é“¾æ¥å·²å­˜åœ¨ï¼š\n${existingUrls.slice(0, 3).join('\n')}${existingUrls.length > 3 ? '\n...' : ''}`);
              return;
            }
            
            this.showTemporaryMessage(`æ­£åœ¨éªŒè¯ ${imageUrls.length} ä¸ªå›¾ç‰‡é“¾æ¥...`, 5000);
            
            let successCount = 0;
            let failedUrls = [];
            
            // æ‰¹é‡å¤„ç†å›¾ç‰‡é“¾æ¥
            for (let i = 0; i < imageUrls.length; i++) {
              const imageUrl = imageUrls[i];
              
              try {
                // éªŒè¯å›¾ç‰‡é“¾æ¥æ˜¯å¦æœ‰æ•ˆ
                const isValid = await this.validateImageUrl(imageUrl);
                if (!isValid) {
                  failedUrls.push(imageUrl);
                  continue;
                }
                
                // ç”Ÿæˆå›¾ç‰‡åç§°
                let finalName;
                if (baseName) {
                  finalName = imageUrls.length > 1 ? `${baseName}_${i + 1}` : baseName;
                } else {
                  finalName = this.extractNameFromUrl(imageUrl);
                }
                
                // åˆ›å»ºæ–°çš„èƒŒæ™¯å›¾å¯¹è±¡
                const bgId = 'url_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const newBackground = {
                  id: bgId,
                  name: finalName,
                  dataUrl: imageUrl,
                  uploadTime: new Date().toISOString(),
                  isPreset: false,
                  isUrlImage: true, // æ ‡è®°ä¸ºå¤–é“¾å›¾ç‰‡
                  originalUrl: imageUrl
                };
                
                // æµ‹è¯•å­˜å‚¨ç©ºé—´
                const tempImages = [...this.backgroundImages, newBackground];
                const testSettings = {
                  images: tempImages,
                  mode: this.backgroundMode,
                  selectedId: this.selectedBackgroundId
                };
                
                try {
                  const testData = JSON.stringify(testSettings);
                  if (testData.length > 4 * 1024 * 1024) {
                    throw new Error('å­˜å‚¨ç©ºé—´ä¸è¶³');
                  }
                  
                  localStorage.setItem('guixu_background_test', testData);
                  localStorage.removeItem('guixu_background_test');
                  
                  // ä¿å­˜æˆåŠŸ
                  this.backgroundImages.push(newBackground);
                  successCount++;
                  
                  console.log(`[å½’å¢ŸèƒŒæ™¯] æˆåŠŸæ·»åŠ å¤–é“¾å›¾ç‰‡: ${finalName}, URL: ${imageUrl}`);
                  
                } catch (storageError) {
                  console.error('[å½’å¢ŸèƒŒæ™¯] å­˜å‚¨å¤–é“¾å›¾ç‰‡å¤±è´¥:', storageError);
                  failedUrls.push(imageUrl);
                }
                
              } catch (error) {
                console.error('[å½’å¢ŸèƒŒæ™¯] éªŒè¯å¤–é“¾å›¾ç‰‡å¤±è´¥:', error);
                failedUrls.push(imageUrl);
              }
            }
            
            // ä¿å­˜è®¾ç½®
            if (successCount > 0) {
              this.saveBackgroundSettings();
              
              // æ¸…ç©ºè¾“å…¥æ¡†
              urlInput.value = '';
              
              // åˆ·æ–°åˆ—è¡¨
              if (document.getElementById('background-settings-modal').style.display === 'flex') {
                this.renderBackgroundList();
              }
            }
            
            // æ˜¾ç¤ºç»“æœæ¶ˆæ¯
            if (successCount === imageUrls.length) {
              this.showTemporaryMessage(`æˆåŠŸæ·»åŠ  ${successCount} å¼ å¤–é“¾å›¾ç‰‡ï¼`);
            } else if (successCount > 0) {
              this.showTemporaryMessage(`æˆåŠŸæ·»åŠ  ${successCount} å¼ å›¾ç‰‡ï¼Œ${failedUrls.length} å¼ å¤±è´¥`);
            } else {
              this.showTemporaryMessage('æ‰€æœ‰å›¾ç‰‡é“¾æ¥éƒ½æ·»åŠ å¤±è´¥ï¼Œè¯·æ£€æŸ¥é“¾æ¥æ˜¯å¦æ­£ç¡®');
            }
          },

          // --- æ–°å¢ï¼šéªŒè¯å›¾ç‰‡URLæ ¼å¼ ---
          isValidImageUrl(url) {
            try {
              const urlObj = new URL(url);
              // å¿…é¡»æ˜¯ https åè®®
              if (urlObj.protocol !== 'https:') {
                return false;
              }
              // æ£€æŸ¥æ˜¯å¦æ˜¯å¸¸è§çš„å›¾ç‰‡æ‰©å±•åæˆ–å›¾åºŠåŸŸå
              const pathname = urlObj.pathname.toLowerCase();
              const hostname = urlObj.hostname.toLowerCase();
              
              // å¸¸è§å›¾ç‰‡æ‰©å±•å
              const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
              const hasImageExtension = imageExtensions.some(ext => pathname.endsWith(ext));
              
              // å¸¸è§å›¾åºŠåŸŸå
              const imagehostDomains = [
                'imgur.com', 'i.imgur.com',
                'postimg.cc', 'i.postimg.cc',
                'sm.ms', 'i.loli.net',
                'github.com', 'raw.githubusercontent.com',
                'cdn.jsdelivr.net', 'unpkg.com'
              ];
              const isImagehostDomain = imagehostDomains.some(domain =>
                hostname === domain || hostname.endsWith('.' + domain)
              );
              
              return hasImageExtension || isImagehostDomain;
            } catch (e) {
              return false;
            }
          },

          // --- éªŒè¯å›¾ç‰‡é“¾æ¥æ˜¯å¦å¯è®¿é—® ---
          validateImageUrl(url) {
            return new Promise((resolve) => {
              const img = new Image();
              const timeout = setTimeout(() => {
                resolve(false);
              }, 10000); // 10ç§’è¶…æ—¶
              
              img.onload = () => {
                clearTimeout(timeout);
                resolve(true);
              };
              
              img.onerror = () => {
                clearTimeout(timeout);
                resolve(false);
              };
              
              // è®¾ç½®è·¨åŸŸå±æ€§ä»¥é¿å…CORSé—®é¢˜
              img.crossOrigin = 'anonymous';
              img.src = url;
            });
          },

          // --- ä»URLæå–æ–‡ä»¶å ---
          extractNameFromUrl(url) {
            try {
              const urlObj = new URL(url);
              const pathname = urlObj.pathname;
              const filename = pathname.split('/').pop();
              
              if (filename && filename.includes('.')) {
                // ç§»é™¤æ‰©å±•å
                return filename.replace(/\.[^/.]+$/, '') || 'å¤–é“¾å›¾ç‰‡';
              }
              
              // å¦‚æœæ— æ³•æå–æ–‡ä»¶åï¼Œä½¿ç”¨åŸŸå
              return urlObj.hostname.replace('www.', '') || 'å¤–é“¾å›¾ç‰‡';
            } catch (e) {
              return 'å¤–é“¾å›¾ç‰‡';
            }
          },

          // --- æ˜¾ç¤ºå›¾åºŠé“¾æ¥ç®¡ç†æ¨¡æ€æ¡† ---
          showUrlImagesManageModal() {
            this.openModal('url-images-manage-modal');
            this.renderUrlImagesList();
          },

          // --- æ–°å¢ï¼šæ¸²æŸ“å¤–é“¾å›¾ç‰‡åˆ—è¡¨ ---
          renderUrlImagesList() {
            const listContainer = document.getElementById('url-images-list');
            const countSpan = document.getElementById('url-images-count');
            if (!listContainer || !countSpan) return;

            // ç­›é€‰å‡ºå¤–é“¾å›¾ç‰‡
            const urlImages = this.backgroundImages.filter(bg => bg.isUrlImage);
            countSpan.textContent = `(${urlImages.length}å¼ )`;

            if (urlImages.length === 0) {
              listContainer.innerHTML = '<div style="text-align: center; color: #8b7355; padding: 40px 20px;">æš‚æ— å¤–é“¾å›¾ç‰‡</div>';
              return;
            }

            listContainer.innerHTML = '';

            urlImages.forEach(bg => {
              const item = document.createElement('div');
              item.className = 'url-image-item';
              item.style.cssText = `
                display: flex; align-items: center; padding: 12px; margin-bottom: 8px;
                background: rgba(26, 26, 46, 0.6); border: 1px solid rgba(201, 170, 113, 0.2);
                border-radius: 6px; transition: all 0.2s ease;
              `;

              item.innerHTML = `
                <div style="flex-shrink: 0; width: 60px; height: 60px; margin-right: 12px; border-radius: 4px; overflow: hidden; background: rgba(0,0,0,0.3);">
                  <img src="${bg.dataUrl}" alt="${bg.name}" style="width: 100%; height: 100%; object-fit: cover;">
                </div>
                <div style="flex: 1; min-width: 0;">
                  <div style="color: #e0dcd1; font-size: 14px; font-weight: 500; margin-bottom: 4px; word-break: break-all;">
                    ${bg.name}
                  </div>
                  <div style="color: #8b7355; font-size: 11px; word-break: break-all; line-height: 1.3;">
                    ${bg.originalUrl}
                  </div>
                  <div style="color: #8b7355; font-size: 10px; margin-top: 2px;">
                    æ·»åŠ æ—¶é—´: ${new Date(bg.uploadTime).toLocaleString('zh-CN')}
                  </div>
                </div>
                <div style="flex-shrink: 0; display: flex; gap: 6px; margin-left: 12px;">
                  <button class="url-image-btn edit-name-btn" data-bg-id="${bg.id}" 
                          style="padding: 4px 8px; font-size: 11px; background: rgba(201, 170, 113, 0.2); 
                                 border: 1px solid rgba(201, 170, 113, 0.3); border-radius: 3px; 
                                 color: #c9aa71; cursor: pointer; transition: all 0.2s ease;">
                    é‡å‘½å
                  </button>
                  <button class="url-image-btn preview-btn" data-bg-id="${bg.id}"
                          style="padding: 4px 8px; font-size: 11px; background: rgba(76, 175, 80, 0.2); 
                                 border: 1px solid rgba(76, 175, 80, 0.3); border-radius: 3px; 
                                 color: #4caf50; cursor: pointer; transition: all 0.2s ease;">
                    é¢„è§ˆ
                  </button>
                  <button class="url-image-btn delete-btn" data-bg-id="${bg.id}"
                          style="padding: 4px 8px; font-size: 11px; background: rgba(244, 67, 54, 0.2); 
                                 border: 1px solid rgba(244, 67, 54, 0.3); border-radius: 3px; 
                                 color: #f44336; cursor: pointer; transition: all 0.2s ease;">
                    åˆ é™¤
                  </button>
                </div>
              `;

              // æ·»åŠ æ‚¬åœæ•ˆæœ
              item.addEventListener('mouseenter', () => {
                item.style.background = 'rgba(26, 26, 46, 0.8)';
                item.style.borderColor = 'rgba(201, 170, 113, 0.4)';
              });

              item.addEventListener('mouseleave', () => {
                item.style.background = 'rgba(26, 26, 46, 0.6)';
                item.style.borderColor = 'rgba(201, 170, 113, 0.2)';
              });

              listContainer.appendChild(item);
            });

            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            this.bindUrlImageListEvents();
          },

          // --- æ–°å¢ï¼šç»‘å®šå¤–é“¾å›¾ç‰‡åˆ—è¡¨äº‹ä»¶ ---
          bindUrlImageListEvents() {
            const listContainer = document.getElementById('url-images-list');
            if (!listContainer) return;

            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
            if (this.urlImageListClickHandler) {
              listContainer.removeEventListener('click', this.urlImageListClickHandler);
            }

            // åˆ›å»ºæ–°çš„äº‹ä»¶å¤„ç†å™¨
            this.urlImageListClickHandler = (e) => {
              const bgId = e.target.dataset.bgId;
              if (!bgId) return;

              if (e.target.classList.contains('edit-name-btn')) {
                this.showEditImageNameModal(bgId);
              } else if (e.target.classList.contains('preview-btn')) {
                this.previewBackground(bgId);
              } else if (e.target.classList.contains('delete-btn')) {
                this.deleteUrlImage(bgId);
              }
            };

            // ç»‘å®šæ–°çš„äº‹ä»¶ç›‘å¬å™¨
            listContainer.addEventListener('click', this.urlImageListClickHandler);
          },

          // æ˜¾ç¤ºç¼–è¾‘å›¾ç‰‡åç§°æ¨¡æ€æ¡†
          showEditImageNameModal(bgId) {
            const bg = this.backgroundImages.find(b => b.id === bgId);
            if (!bg) return;

            const input = document.getElementById('edit-image-name-input');
            const saveBtn = document.getElementById('save-image-name-btn');
            
            if (!input || !saveBtn) return;

            // è®¾ç½®å½“å‰åç§°
            input.value = bg.name;
            
            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
            if (this.saveImageNameHandler) {
              saveBtn.removeEventListener('click', this.saveImageNameHandler);
            }

            // åˆ›å»ºæ–°çš„ä¿å­˜äº‹ä»¶å¤„ç†å™¨
            this.saveImageNameHandler = () => {
              const newName = input.value.trim();
              if (!newName) {
                this.showTemporaryMessage('å›¾ç‰‡åç§°ä¸èƒ½ä¸ºç©º');
                return;
              }

              // æ›´æ–°å›¾ç‰‡åç§°
              bg.name = newName;
              this.saveBackgroundSettings();
              
              // åˆ·æ–°åˆ—è¡¨
              this.renderUrlImagesList();
              
              // å¦‚æœèƒŒæ™¯è®¾ç½®æ¨¡æ€æ¡†ä¹Ÿæ˜¯æ‰“å¼€çš„ï¼Œä¹Ÿåˆ·æ–°é‚£ä¸ªåˆ—è¡¨
              if (document.getElementById('background-settings-modal').style.display === 'flex') {
                this.renderBackgroundList();
              }
              
              // åˆ·æ–°UIç•Œé¢çš„èƒŒæ™¯å›¾åˆ—è¡¨
              this.renderBackgroundList();

              this.closeModal('edit-image-name-modal');
              this.showTemporaryMessage(`å›¾ç‰‡åç§°å·²æ›´æ–°ä¸ºï¼š${newName}`);
            };

            // ç»‘å®šä¿å­˜äº‹ä»¶
            saveBtn.addEventListener('click', this.saveImageNameHandler);

            // ç»‘å®šå›è½¦é”®ä¿å­˜
            const handleEnterKey = (e) => {
              if (e.key === 'Enter') {
                this.saveImageNameHandler();
                input.removeEventListener('keypress', handleEnterKey);
              }
            };
            input.addEventListener('keypress', handleEnterKey);

            // æ‰“å¼€æ¨¡æ€æ¡†å¹¶èšç„¦è¾“å…¥æ¡†
            this.openModal('edit-image-name-modal');
            setTimeout(() => {
              input.focus();
              input.select();
            }, 100);
          },

          // --- æ–°å¢ï¼šåˆ é™¤å¤–é“¾å›¾ç‰‡ ---
          deleteUrlImage(bgId) {
            const bg = this.backgroundImages.find(b => b.id === bgId);
            if (!bg) return;

            this.showCustomConfirm(`ç¡®å®šè¦åˆ é™¤å¤–é“¾å›¾ç‰‡"${bg.name}"å—ï¼Ÿ`, () => {
              this.backgroundImages = this.backgroundImages.filter(b => b.id !== bgId);
              
              // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é€‰ä¸­çš„èƒŒæ™¯ï¼Œæ¸…é™¤é€‰æ‹©
              if (this.selectedBackgroundId === bgId) {
                this.selectedBackgroundId = null;
              }
              
              this.saveBackgroundSettings();
              this.renderUrlImagesList();
              
              // å¦‚æœèƒŒæ™¯è®¾ç½®æ¨¡æ€æ¡†ä¹Ÿæ˜¯æ‰“å¼€çš„ï¼Œä¹Ÿåˆ·æ–°é‚£ä¸ªåˆ—è¡¨
              if (document.getElementById('background-settings-modal').style.display === 'flex') {
                this.renderBackgroundList();
              }
              
              this.applyRandomBackground(); // é‡æ–°åº”ç”¨èƒŒæ™¯
              this.showTemporaryMessage(`å·²åˆ é™¤å¤–é“¾å›¾ç‰‡ï¼š${bg.name}`);
            }, null, true); // keepCurrentModal = true
          },

          bindGallerySourceControls() {
            const libraryRadio = document.getElementById('gallery-source-library');
            const outputRadio = document.getElementById('gallery-source-output');
            const outputFolderControls = document.getElementById('output-folder-controls');
            const selectOutputFolderBtn = document.getElementById('select-output-folder-btn');
            const refreshOutputFolderBtn = document.getElementById('refresh-output-folder-btn');

            const toggleOutputControls = (show) => {
                outputFolderControls.style.display = show ? 'block' : 'none';
            };

            libraryRadio.addEventListener('change', () => {
                if (libraryRadio.checked) {
                    this.gallerySource = 'library';
                    toggleOutputControls(false);
                    this.galleryCurrentPage = 1; // åˆ‡æ¢å›¾åº“æ—¶é‡ç½®é¡µç 
                    this.renderBackgroundList();
                    this.saveGallerySource();
                }
            });

            outputRadio.addEventListener('change', () => {
                if (outputRadio.checked) {
                    this.gallerySource = 'output';
                    toggleOutputControls(true);
                    this.galleryCurrentPage = 1; // åˆ‡æ¢å›¾åº“æ—¶é‡ç½®é¡µç 
                    this.renderBackgroundList();
                    this.saveGallerySource();
                }
            });

            selectOutputFolderBtn.addEventListener('click', async () => {
                await this.selectOutputFolder();
            });

            refreshOutputFolderBtn.addEventListener('click', async () => {
                await this.loadOutputFolderImages();
            });

            // ç»‘å®šåˆ†é¡µæŒ‰é’®äº‹ä»¶
            const prevPageBtn = document.getElementById('gallery-prev-page');
            const nextPageBtn = document.getElementById('gallery-next-page');

            if (prevPageBtn) {
                prevPageBtn.addEventListener('click', () => {
                    if (this.galleryCurrentPage > 1) {
                        this.galleryCurrentPage--;
                        this.renderBackgroundList();
                        // æ»šåŠ¨åˆ°åˆ—è¡¨é¡¶éƒ¨
                        const listContainer = document.getElementById('background-list');
                        if (listContainer) {
                            listContainer.scrollTop = 0;
                        }
                    }
                });
            }

            if (nextPageBtn) {
                nextPageBtn.addEventListener('click', () => {
                    const allImages = this.gallerySource === 'library' ? this.backgroundImages : this.outputFolderImages;
                    const totalPages = Math.ceil(allImages.length / this.galleryPageSize);
                    if (this.galleryCurrentPage < totalPages) {
                        this.galleryCurrentPage++;
                        this.renderBackgroundList();
                        // æ»šåŠ¨åˆ°åˆ—è¡¨é¡¶éƒ¨
                        const listContainer = document.getElementById('background-list');
                        if (listContainer) {
                            listContainer.scrollTop = 0;
                        }
                    }
                });
            }
          },

          async selectOutputFolder() {
              try {
                  this.outputFolderHandle = await window.showDirectoryPicker();
                  await this.saveOutputFolderHandle();
                  await this.loadOutputFolderImages();
                  this.updateOutputFolderStatus();
              } catch (error) {
                  console.error('é€‰æ‹©æ–‡ä»¶å¤¹æ—¶å‡ºé”™:', error);
                  this.showTemporaryMessage('æœªèƒ½é€‰æ‹©æ–‡ä»¶å¤¹', 'error');
              }
          },

          async loadOutputFolderImages() {
              if (!this.outputFolderHandle) {
                  this.showTemporaryMessage('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶å¤¹', 'warning');
                  return;
              }

              try {
                  const permission = await this.verifyPermission(this.outputFolderHandle, true);
                  if (!permission) {
                      this.showTemporaryMessage('éœ€è¦æ–‡ä»¶å¤¹è¯»å–æƒé™', 'error');
                      return;
                  }

                  // æ¸…ç©ºä¹‹å‰çš„æ•°æ®
                  this.outputFolderImages = [];
                  await this.recursiveLoadImages(this.outputFolderHandle, '');
                  // æŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼ˆæ–°çš„åœ¨å‰ï¼‰ï¼Œåªæ’åºä¸€æ¬¡
                  this.outputFolderImages.sort((a, b) => b.lastModified - a.lastModified);
                  
                  // é‡ç½®åˆ°ç¬¬ä¸€é¡µ
                  this.galleryCurrentPage = 1;
                  
                  // åªåœ¨gallerySourceä¸ºoutputæ—¶æ‰æ¸²æŸ“
                  if (this.gallerySource === 'output') {
                      this.renderBackgroundList();
                  }
                  
                  this.showTemporaryMessage(`ä»æ–‡ä»¶å¤¹åŠ è½½äº† ${this.outputFolderImages.length} å¼ å›¾ç‰‡`, 'success');
                  
                  // å¯åŠ¨è‡ªåŠ¨åˆ·æ–°ç›‘å¬
                  this.startOutputFolderMonitoring();
              } catch (error) {
                  console.error('ä»æ–‡ä»¶å¤¹è¯»å–å›¾ç‰‡æ—¶å‡ºé”™:', error);
                  this.showTemporaryMessage('è¯»å–å›¾ç‰‡å¤±è´¥', 'error');
              }
          },

          async recursiveLoadImages(dirHandle, path) {
              const imageExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.bmp'];
              
              for await (const entry of dirHandle.values()) {
                  const fullPath = path ? `${path}/${entry.name}` : entry.name;
                  
                  if (entry.kind === 'file') {
                      // æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡æ–‡ä»¶
                      const isImage = imageExtensions.some(ext => entry.name.toLowerCase().endsWith(ext));
                      if (isImage) {
                          try {
                              const file = await entry.getFile();
                              this.outputFolderImages.push({
                                  id: `output_${fullPath.replace(/[\/\\]/g, '_')}`,
                                  name: entry.name,
                                  folder: path || 'æ ¹ç›®å½•',
                                  fullPath: fullPath,
                                  dataUrl: URL.createObjectURL(file),
                                  isOutput: true,
                                  lastModified: file.lastModified,
                              });
                          } catch (error) {
                              console.warn(`æ— æ³•è¯»å–æ–‡ä»¶ ${fullPath}:`, error);
                          }
                      }
                  } else if (entry.kind === 'directory') {
                      // é€’å½’è¯»å–å­æ–‡ä»¶å¤¹
                      try {
                          await this.recursiveLoadImages(entry, fullPath);
                      } catch (error) {
                          console.warn(`æ— æ³•è®¿é—®å­æ–‡ä»¶å¤¹ ${fullPath}:`, error);
                      }
                  }
              }
          },

          startOutputFolderMonitoring() {
              // åœæ­¢ä¹‹å‰çš„ç›‘å¬
              if (this.outputFolderMonitoringInterval) {
                  clearInterval(this.outputFolderMonitoringInterval);
              }

              // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡æ–‡ä»¶å¤¹å˜åŒ–
              this.outputFolderMonitoringInterval = setInterval(async () => {
                  if (this.outputFolderHandle && this.gallerySource === 'output') {
                      await this.checkAndRefreshOutputFolder();
                  }
              }, 30000); // 30ç§’åˆ·æ–°ä¸€æ¬¡

              console.log('[å½’å¢ŸèƒŒæ™¯] Outputæ–‡ä»¶å¤¹ç›‘å¬å·²å¯åŠ¨');
          },

          stopOutputFolderMonitoring() {
              if (this.outputFolderMonitoringInterval) {
                  clearInterval(this.outputFolderMonitoringInterval);
                  this.outputFolderMonitoringInterval = null;
                  console.log('[å½’å¢ŸèƒŒæ™¯] Outputæ–‡ä»¶å¤¹ç›‘å¬å·²åœæ­¢');
              }
          },

          async checkAndRefreshOutputFolder() {
              try {
                  const oldCount = this.outputFolderImages.length;
                  const oldImages = new Set(this.outputFolderImages.map(img => img.fullPath));
                  
                  // é‡æ–°åŠ è½½æ–‡ä»¶å¤¹å†…å®¹
                  this.outputFolderImages = [];
                  await this.recursiveLoadImages(this.outputFolderHandle, '');
                  // æŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼ˆæ–°çš„åœ¨å‰ï¼‰
                  this.outputFolderImages.sort((a, b) => b.lastModified - a.lastModified);
                  
                  const newCount = this.outputFolderImages.length;
                  const newImages = new Set(this.outputFolderImages.map(img => img.fullPath));
                  
                  // æ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
                  const hasChanges = oldCount !== newCount ||
                                    ![...oldImages].every(img => newImages.has(img)) ||
                                    ![...newImages].every(img => oldImages.has(img));
                  
                  if (hasChanges) {
                      this.renderBackgroundList();
                      const diff = newCount - oldCount;
                      const message = diff > 0
                          ? `æ£€æµ‹åˆ°æ–°å¢ ${diff} å¼ å›¾ç‰‡`
                          : diff < 0
                          ? `æ£€æµ‹åˆ°ç§»é™¤ ${Math.abs(diff)} å¼ å›¾ç‰‡`
                          : 'æ£€æµ‹åˆ°æ–‡ä»¶å¤¹å†…å®¹å˜åŒ–';
                      this.showTemporaryMessage(message, 'info');
                      console.log(`[å½’å¢ŸèƒŒæ™¯] ${message}ï¼Œå½“å‰å…± ${newCount} å¼ å›¾ç‰‡`);
                  }
              } catch (error) {
                  console.error('[å½’å¢ŸèƒŒæ™¯] æ£€æŸ¥æ–‡ä»¶å¤¹æ›´æ–°æ—¶å‡ºé”™:', error);
              }
          },
          
          updateOutputFolderStatus() {
              const statusDiv = document.getElementById('output-folder-status');
              const refreshBtn = document.getElementById('refresh-output-folder-btn');
              if (this.outputFolderHandle) {
                  statusDiv.textContent = `å·²é€‰æ‹©: ${this.outputFolderHandle.name}`;
                  refreshBtn.style.display = 'block';
              } else {
                  statusDiv.textContent = 'æœªé€‰æ‹©æ–‡ä»¶å¤¹';
                  refreshBtn.style.display = 'none';
              }
          },

          async saveOutputFolderHandle() {
              if (this.dbAvailable && this.outputFolderHandle) {
                  await this.db.setItem('outputFolderHandle', this.outputFolderHandle);
              }
          },

          async loadOutputFolderHandle() {
              if (!this.dbAvailable) {
                  console.warn('[å½’å¢ŸèƒŒæ™¯] IndexedDBä¸å¯ç”¨ï¼Œæ— æ³•åŠ è½½æ–‡ä»¶å¤¹å¥æŸ„');
                  return;
              }

              try {
                  this.outputFolderHandle = await this.db.getItem('outputFolderHandle');
                  
                  if (this.outputFolderHandle) {
                      // éªŒè¯å¥æŸ„æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
                      try {
                          const permission = await this.verifyPermission(this.outputFolderHandle, false);
                          
                          if (permission) {
                              console.log(`[å½’å¢ŸèƒŒæ™¯] å·²åŠ è½½outputæ–‡ä»¶å¤¹: ${this.outputFolderHandle.name}`);
                              this.updateOutputFolderStatus();
                              await this.loadOutputFolderImages();
                          } else {
                              console.warn('[å½’å¢ŸèƒŒæ™¯] æ–‡ä»¶å¤¹æƒé™å·²å¤±æ•ˆï¼Œéœ€è¦é‡æ–°é€‰æ‹©');
                              this.outputFolderHandle = null;
                              this.updateOutputFolderStatus();
                          }
                      } catch (error) {
                          console.warn('[å½’å¢ŸèƒŒæ™¯] æ–‡ä»¶å¤¹å¥æŸ„æ— æ•ˆï¼Œå¯èƒ½å·²è¢«åˆ é™¤æˆ–ç§»åŠ¨:', error);
                          this.outputFolderHandle = null;
                          await this.db.setItem('outputFolderHandle', null);
                          this.updateOutputFolderStatus();
                      }
                  } else {
                      console.log('[å½’å¢ŸèƒŒæ™¯] æœªæ‰¾åˆ°ä¿å­˜çš„outputæ–‡ä»¶å¤¹');
                  }
              } catch (error) {
                  console.error('[å½’å¢ŸèƒŒæ™¯] åŠ è½½æ–‡ä»¶å¤¹å¥æŸ„æ—¶å‡ºé”™:', error);
                  this.outputFolderHandle = null;
                  this.updateOutputFolderStatus();
              }
          },

          async verifyPermission(fileHandle, readWrite) {
              const options = {};
              if (readWrite) {
                  options.mode = 'readwrite';
              }
              if ((await fileHandle.queryPermission(options)) === 'granted') {
                  return true;
              }
              if ((await fileHandle.requestPermission(options)) === 'granted') {
                  return true;
              }
              return false;
          },

          saveGallerySource() {
              localStorage.setItem('guixu_gallery_source', this.gallerySource);
          },

          loadGallerySource() {
              const source = localStorage.getItem('guixu_gallery_source');
              if (source) {
                  this.gallerySource = source;
                  document.getElementById(source === 'library' ? 'gallery-source-library' : 'gallery-source-output').checked = true;
                  document.getElementById('output-folder-controls').style.display = source === 'output' ? 'block' : 'none';
              }
          },

// === èƒŒæ™¯å›¾æ¨¡å—ç»“æŸ===


// ===å¿«æ·é”®æ¨¡å—å¼€å§‹===
          // æ–°å¢ï¼šç»‘å®šé”®ç›˜å¿«æ·é”®
          bindKeyboardShortcuts() {
            this.boundHandleKeydown = (e) => {
              // æ£€æŸ¥å¿«æ·é”®æ˜¯å¦å·²å¯ç”¨
              if (!this.isKeyboardShortcutsEnabled) {
                return; // å¿«æ·é”®å·²ç¦ç”¨
              }

              // æ£€æŸ¥æ˜¯å¦åœ¨è¾“å…¥æ¡†ä¸­ï¼Œå¦‚æœæ˜¯åˆ™ä¸å¤„ç†å¿«æ·é”®
              const activeElement = document.activeElement;
              const isInputField = activeElement && (
                activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.contentEditable === 'true' ||
                activeElement.isContentEditable
              );

              if (isInputField) {
                return; // åœ¨è¾“å…¥æ¡†ä¸­æ—¶ä¸å¤„ç†å¿«æ·é”®
              }

              // å¤„ç†å¸¦ä¿®é¥°é”®çš„å¿«æ·é”®
              if (e.ctrlKey && !e.altKey && !e.metaKey) {
                switch (e.key.toLowerCase()) {
                  case 'a':
                    e.preventDefault();
                    this.toggleLeftPanel();
                    console.log('[å½’å¢Ÿå¿«æ·é”®] Ctrl+A - åˆ‡æ¢å·¦ä¾§é¢æ¿');
                    break;
                  case 'd':
                    e.preventDefault();
                    this.toggleRightPanel();
                    console.log('[å½’å¢Ÿå¿«æ·é”®] Ctrl+D - åˆ‡æ¢å³ä¾§é¢æ¿');
                    break;
                }
                return; // å¤„ç†å®Œä¿®é¥°é”®å¿«æ·é”®åè¿”å›
              }

              // é˜²æ­¢å…¶ä»–ä¿®é¥°é”®ç»„åˆå¹²æ‰°
              const isModifierPressed = e.ctrlKey || e.altKey || e.metaKey;
              if (isModifierPressed) {
                return; // æœ‰å…¶ä»–ä¿®é¥°é”®æ—¶ä¸å¤„ç†
              }

              switch (e.key.toLowerCase()) {
                case 'e':
                  e.preventDefault();
                  this.toggleModal('inventory-modal', () => this.showInventory());
                  console.log('[å½’å¢Ÿå¿«æ·é”®] Eé”® - åˆ‡æ¢ç‰©å“æ ');
                  break;
                case 'r':
                  e.preventDefault();
                  this.toggleModal('relationships-modal', () => this.showRelationships());
                  console.log('[å½’å¢Ÿå¿«æ·é”®] Ré”® - åˆ‡æ¢äººç‰©å…³ç³»');
                  break;
                case 'c':
                  e.preventDefault();
                  this.toggleModal('save-load-modal', () => this.showNewSaveLoadManager());
                  console.log('[å½’å¢Ÿå¿«æ·é”®] Cé”® - åˆ‡æ¢å­˜æ¡£ç®¡ç†å™¨');
                  break;
                case 't':
                  e.preventDefault();
                  this.toggleModal('settings-modal', () => this.showSettings());
                  console.log('[å½’å¢Ÿå¿«æ·é”®] Té”® - åˆ‡æ¢è®¾ç½®ç•Œé¢');
                  break;
                // --- æ–°å¢å¿«æ·é”® ---
                case 'y': // è‡ªåŠ¨é˜…è¯»
                    e.preventDefault();
                    document.getElementById('auto-read-checkbox')?.click();
                    console.log('[å½’å¢Ÿå¿«æ·é”®] Yé”® - åˆ‡æ¢è‡ªåŠ¨é˜…è¯»');
                    break;
                case 'f': // åˆ†æ®µè®°å¿†
                    e.preventDefault();
                    this.toggleModal('segmented-memory-modal', () => this.showSegmentedMemoryModal());
                    console.log('[å½’å¢Ÿå¿«æ·é”®] Fé”® - åˆ‡æ¢åˆ†æ®µè®°å¿†');
                    break;
                case '1': // å›é¡¶
                    e.preventDefault();
                    document.getElementById('scroll-to-top-btn')?.click();
                    console.log('[å½’å¢Ÿå¿«æ·é”®] 1é”® - å›é¡¶');
                    break;
                case '2': // æœ¬ç« 
                    e.preventDefault();
                    document.getElementById('scroll-to-bottom-btn')?.click();
                    console.log('[å½’å¢Ÿå¿«æ·é”®] 2é”® - æœ¬ç« ');
                    break;
                case '3': // å›åº•
                    e.preventDefault();
                    document.getElementById('scroll-to-real-bottom-btn')?.click();
                    console.log('[å½’å¢Ÿå¿«æ·é”®] 3é”® - å›åº•');
                    break;
                case '5': // ä¸Šä¸€ç« 
                    e.preventDefault();
                    document.getElementById('prev-chapter-btn')?.click();
                    console.log('[å½’å¢Ÿå¿«æ·é”®] 5é”® - ä¸Šä¸€ç« ');
                    break;
                case '6': // ä¸‹ä¸€ç« 
                    e.preventDefault();
                    document.getElementById('next-chapter-btn')?.click();
                    console.log('[å½’å¢Ÿå¿«æ·é”®] 6é”® - ä¸‹ä¸€ç« ');
                    break;
                case 'g': // å½’å¢Ÿç³»ç»Ÿ
                    e.preventDefault();
                    this.toggleModal('guixu-system-modal', () => this.showGuixuSystem());
                    console.log('[å½’å¢Ÿå¿«æ·é”®] Gé”® - åˆ‡æ¢å½’å¢Ÿç³»ç»Ÿ');
                    break;
                case 'b': // èƒŒæ™¯å›¾è®¾ç½®
                    e.preventDefault();
                    this.toggleModal('background-settings-modal', () => this.showBackgroundSettings());
                    console.log('[å½’å¢Ÿå¿«æ·é”®] Bé”® - åˆ‡æ¢èƒŒæ™¯å›¾è®¾ç½®');
                    break;
                case '4': // å˜é‡ç¼–è¾‘å™¨
                    e.preventDefault();
                    this.toggleModal('variable-editor-modal', () => this.showVariableEditor());
                    console.log('[å½’å¢Ÿå¿«æ·é”®] 4é”® - åˆ‡æ¢å˜é‡ç¼–è¾‘å™¨');
                    break;
                case 'z': // æŒ‡ä»¤ä¸­å¿ƒ
                    e.preventDefault();
                    this.toggleModal('command-center-modal', () => this.showCommandCenter());
                    console.log('[å½’å¢Ÿå¿«æ·é”®] Zé”® - åˆ‡æ¢æŒ‡ä»¤ä¸­å¿ƒ');
                    break;
                case 'l': // æŸ¥çœ‹æå–å†…å®¹
                    e.preventDefault();
                    this.toggleModal('extracted-content-modal', () => this.showExtractedContent());
                    console.log('[å½’å¢Ÿå¿«æ·é”®] Lé”® - åˆ‡æ¢æŸ¥çœ‹æå–å†…å®¹');
                    break;
                case 'x': // å°è¯´æ¨¡å¼
                    e.preventDefault();
                    this.toggleModal('novel-mode-modal', () => this.showNovelMode());
                    console.log('[å½’å¢Ÿå¿«æ·é”®] Xé”® - åˆ‡æ¢å°è¯´æ¨¡å¼');
                    break;
       }
            };
            document.addEventListener('keydown', this.boundHandleKeydown);

            console.log('[å½’å¢Ÿå¿«æ·é”®] é”®ç›˜å¿«æ·é”®ç»‘å®šå®Œæˆ');
            console.log('[å½’å¢Ÿå¿«æ·é”®] Y-è‡ªåŠ¨é˜…è¯», F-åˆ†æ®µè®°å¿†, G-å½’å¢Ÿç³»ç»Ÿ, B-èƒŒæ™¯è®¾ç½®, 4-å˜é‡ç¼–è¾‘, Z-æŒ‡ä»¤ä¸­å¿ƒ, L-æŸ¥çœ‹æå–, X-å°è¯´æ¨¡å¼');
            console.log('[å½’å¢Ÿå¿«æ·é”®] 1-å›é¡¶, 2-æœ¬ç« , 3-å›åº•, 5-ä¸Šä¸€ç« , 6-ä¸‹ä¸€ç« ');
            console.log('[å½’å¢Ÿå¿«æ·é”®] E-èƒŒåŒ…, R-äººç‰©å…³ç³», C-å­˜æ¡£è¯»æ¡£, T-è®¾ç½®, Ctrl+A/D-é¢æ¿æŠ˜å ');
          },

          // æ–°å¢ï¼šæ¨¡æ€æ¡†åˆ‡æ¢å‡½æ•°
          toggleModal(modalId, showFunction) {
            const modal = document.getElementById(modalId);
            if (modal && modal.style.display === 'flex') {
              // å¦‚æœæ¨¡æ€æ¡†å·²ç»æ‰“å¼€ï¼Œåˆ™å…³é—­å®ƒ
              this.closeModal(modalId);
            } else {
              // å¦‚æœæ¨¡æ€æ¡†æœªæ‰“å¼€ï¼Œåˆ™æ‰“å¼€å®ƒ
              showFunction();
            }
          },

          // æ–°å¢ï¼šé”®ç›˜å¿«æ·é”®è¯¦æƒ…æŠ˜å /å±•å¼€å‡½æ•°
          toggleKeyboardShortcutsDetails() {
            const details = document.getElementById('keyboard-shortcuts-details');
            const toggleButton = document.getElementById('keyboard-shortcuts-toggle');
            
            if (details && toggleButton) {
              if (details.style.display === 'none' || details.style.display === '') {
                details.style.display = 'block';
                toggleButton.textContent = 'â–²';
                toggleButton.style.transform = 'rotate(180deg)';
              } else {
                details.style.display = 'none';
                toggleButton.textContent = 'â–¼';
                toggleButton.style.transform = 'rotate(0deg)';
              }
            }
          },
// ===å¿«æ·é”®æ¨¡å—ç»“æŸ===



// ===è¾“å…¥æ³•é€‚é…æ¨¡å—å¼€å§‹===
          setupInputKeyboardHandling() {
            const inputField = document.getElementById('quick-send-input');
            if (!inputField) {
              return;
            }
            if (this.isMobileInputAdaptEnabled) {
              this.setupFloatingInput();
            } else {
              this.setupViewportAdjustment();
            }
          },
          reinitializeInputKeyboardHandling() {
            const inputField = document.getElementById('quick-send-input');
            this.cleanupInputKeyboardHandling();
            this.setupInputKeyboardHandling();
          },
          cleanupInputKeyboardHandling() {
            const inputField = document.getElementById('quick-send-input');
            if (!inputField) return;
            const newInputField = inputField.cloneNode(true);
            inputField.parentNode.replaceChild(newInputField, inputField);
          },
          setupFloatingInput() {
            const inputField = document.getElementById('quick-send-input');
            const sendButton = document.getElementById('btn-quick-send');
            const bottomBar = document.querySelector('.bottom-status-bar');
            this.originalParent = inputField.parentElement;
            this.originalNextSibling = inputField.nextSibling;
            this.moveInputToTop = () => {              
              const container = this.createFloatingContainer();
              const inputValue = inputField.value;
              container.appendChild(inputField);
              inputField.style.cssText = `
                background: rgba(0, 0, 0, 0.5) !important;
                border: 1px solid #8b7355 !important;
                border-radius: 4px !important;
                color: #e0dcd1 !important;
                padding: 5px 10px !important;
                font-size: 12px !important;
                width: 100% !important;
                flex-grow: 1 !important;
                max-width: 500px !important;
                height: 32px !important;
                resize: none !important;
                line-height: 1.5 !important;
                font-family: inherit !important;
                margin: 0 !important;
              `;
              inputField.onfocus = null;
              inputField.onblur = null;
              inputField.value = inputValue;
              if (sendButton && sendButton.parentElement !== container) {
                const sendBtnClone = document.createElement('button');
                sendBtnClone.textContent = 'å‘é€';
                sendBtnClone.style.cssText = `
                  padding: 6px 4px !important;
                  background: linear-gradient(45deg, #1a1a2e, #2d1b3d) !important;
                  border: 1px solid #c9aa71 !important;
                  border-radius: 5px !important;
                  color: #c9aa71 !important;
                  font-size: 10px !important;
                  cursor: pointer !important;
                  text-align: center !important;
                  transition: all 0.3s ease !important;
                  white-space: nowrap !important;
                `;
                sendBtnClone.onmouseover = () => {
                  sendBtnClone.style.background = 'linear-gradient(45deg, #2d1b3d, #3d2b4d)';
                };
                sendBtnClone.onmouseout = () => {
                  sendBtnClone.style.background = 'linear-gradient(45deg, #1a1a2e, #2d1b3d)';
                };
                sendBtnClone.onclick = () => {
                  sendButton.click();
                };
                container.appendChild(sendBtnClone);
              }
              setTimeout(() => {
                container.style.top = '0px';
                container.style.opacity = '1';
              }, 10);
              setTimeout(() => {
                inputField.focus();
              }, 100);
            };
            inputField.addEventListener('focus', (e) => {
              if (this.isMobileInputAdaptEnabled) {
                if (!this.floatingInputContainer || !this.floatingInputContainer.parentElement) {
                  this.moveInputToTop();
                } 
              } 
            });
            inputField.addEventListener('blur', (e) => {
              if (this.isMobileInputAdaptEnabled && this.floatingInputContainer) {
                setTimeout(() => {
                  const activeElement = document.activeElement;
                  const isInFloatingContainer = this.floatingInputContainer &&
                    (this.floatingInputContainer.contains(activeElement) || activeElement === inputField);                  
                  if (!isInFloatingContainer) {
                    this.resetInputPosition();
                  }
                }, 200);
              }
            });
          },
          createFloatingContainer() {
            if (this.floatingInputContainer && this.floatingInputContainer.parentElement) {
              return this.floatingInputContainer;
            }            
            this.floatingInputContainer = document.createElement('div');
            this.floatingInputContainer.className = 'floating-input-container';
            this.floatingInputContainer.style.cssText = `
              position: fixed !important;
              top: -60px !important;
              left: 0 !important;
              right: 0 !important;
              width: 100% !important;
              z-index: 999999 !important;
              background: transparent !important;
              padding: 10px 15px !important;
              display: flex !important;
              gap: 8px !important;
              align-items: center !important;
              opacity: 0 !important;
              visibility: visible !important;
              pointer-events: auto !important;
              transform: translateY(0) !important;
              transition: all 0.3s ease !important;
            `;
            const isFullscreen = document.fullscreenElement !== null;
            const rootContainer = document.querySelector('.guixu-root-container');            
            if (isFullscreen && rootContainer) {
              rootContainer.appendChild(this.floatingInputContainer);
            } else {
              document.body.appendChild(this.floatingInputContainer);
            }
            this.floatingInputContainer.offsetHeight;    
            return this.floatingInputContainer;
          },
          resetInputPosition() {            
            const inputField = document.getElementById('quick-send-input');
            if (!this.floatingInputContainer || !inputField) return;  
            this.floatingInputContainer.style.opacity = '0';
            this.floatingInputContainer.style.visibility = 'hidden';
            setTimeout(() => {
              const inputValue = inputField.value;
              if (this.originalNextSibling) {
                this.originalParent.insertBefore(inputField, this.originalNextSibling);
              } else {
                this.originalParent.appendChild(inputField);
              }
              inputField.style.cssText = '';
              inputField.className = 'quick-send-input';
              inputField.value = inputValue;
              const clonedButton = this.floatingInputContainer.querySelector('button:not(.close-floating-input)');
              if (clonedButton) {
                clonedButton.remove();
              }
              if (this.floatingInputContainer && this.floatingInputContainer.parentElement) {
                this.floatingInputContainer.remove();
              }
              this.floatingInputContainer = null;
            }, 300);
          },
          setupViewportAdjustment() {
            const inputField = document.getElementById('quick-send-input');
            let isKeyboardOpen = false;
            let originalHeight = window.innerHeight;
            let lastScrollPosition = 0;
            const getViewportHeight = () => {
              if (window.visualViewport) {
                return window.visualViewport.height;
              }
              return window.innerHeight;
            };
            const handleKeyboardToggle = () => {
              const currentHeight = getViewportHeight();
              const heightDiff = originalHeight - currentHeight;
              if (heightDiff > 100 && !isKeyboardOpen) {
                isKeyboardOpen = true;
                this.adjustForKeyboard(true, heightDiff);
              }
              else if (heightDiff < 50 && isKeyboardOpen) {
                isKeyboardOpen = false;
                this.adjustForKeyboard(false, 0);
              }
            };
            inputField.addEventListener('focus', () => {
              lastScrollPosition = window.scrollY;
              setTimeout(() => {
                handleKeyboardToggle();
                this.ensureInputVisible();
              }, 300);
            });

            inputField.addEventListener('blur', () => {
              // å»¶è¿Ÿå¤„ç†é”®ç›˜æ”¶èµ·
              setTimeout(() => {
                if (document.activeElement !== inputField) {
                  isKeyboardOpen = false;
                  this.adjustForKeyboard(false, 0);
                  // æ¢å¤æ»šåŠ¨ä½ç½®
                  window.scrollTo(0, lastScrollPosition);
                }
              }, 300);
            });

            // ç›‘å¬è§†å£å˜åŒ–
            if (window.visualViewport) {
              window.visualViewport.addEventListener('resize', handleKeyboardToggle);
              window.visualViewport.addEventListener('scroll', () => {
                if (isKeyboardOpen) {
                  this.ensureInputVisible();
                }
              });
            } else {
              window.addEventListener('resize', handleKeyboardToggle);
            }
            window.addEventListener('orientationchange', () => {
              setTimeout(() => {
                originalHeight = window.innerHeight;
                handleKeyboardToggle();
              }, 500);
            });
          },
          adjustForKeyboard(keyboardOpen, keyboardHeight) {
            const bottomBar = document.querySelector('.bottom-status-bar');
            const chatContainer = document.querySelector('.chat-container');
            const rootContainer = document.querySelector('.guixu-root-container');  
            if (keyboardOpen && keyboardHeight > 0) {
              if (rootContainer && rootContainer.classList.contains('mobile-view')) {
                if (bottomBar) {
                  bottomBar.style.position = 'fixed';
                  bottomBar.style.bottom = `${keyboardHeight}px`;
                  bottomBar.style.left = '0';
                  bottomBar.style.right = '0';
                  bottomBar.style.zIndex = '10000';
                  bottomBar.style.transition = 'bottom 0.3s ease';
                }
                if (chatContainer) {
                  const bottomBarHeight = bottomBar ? bottomBar.offsetHeight : 0;
                  chatContainer.style.paddingBottom = `${keyboardHeight + bottomBarHeight + 10}px`;
                  chatContainer.style.transition = 'padding-bottom 0.3s ease';
                }
              } else {
                if (bottomBar) {
                  bottomBar.style.position = 'fixed';
                  bottomBar.style.bottom = '0';
                  bottomBar.style.zIndex = '10000';
                }
                if (chatContainer) {
                  chatContainer.style.paddingBottom = '150px';
                }
              }
            } else {
              if (bottomBar) {
                bottomBar.style.position = '';
                bottomBar.style.bottom = '';
                bottomBar.style.left = '';
                bottomBar.style.right = '';
                bottomBar.style.zIndex = '';
                bottomBar.style.transition = '';
              }
              if (chatContainer) {
                chatContainer.style.paddingBottom = '';
                chatContainer.style.transition = '';
              }
            }
          },
          ensureInputVisible() {
            const inputField = document.getElementById('quick-send-input');
            const bottomBar = document.querySelector('.bottom-status-bar');
            if (inputField && bottomBar) {
              const inputRect = inputField.getBoundingClientRect();
              const viewportHeight = this.getViewportHeight();
              if (inputRect.bottom > viewportHeight || inputRect.top < 0) {
                const scrollTarget = window.scrollY + inputRect.top - (viewportHeight / 2);
                window.scrollTo({
                  top: scrollTarget,
                  behavior: 'smooth'
                });
              }
            }
          },
          getViewportHeight() {
            if (window.visualViewport) {
              return window.visualViewport.height;
            }
            return window.innerHeight;
          },
// ===è¾“å…¥æ³•é€‚é…æ¨¡å—ç»“æŸ===



// ===è¡æ¢¦å°˜/æŠ½å¡/Gachaç³»ç»Ÿå¼€å§‹===
          showGachaSystem() {
              this.isFromGuixuSystem = true;
              this.openModal('gacha-modal', true); 
              this.renderSummonTab(); 
          },

          loadGachaState() {
              const defaultState = {
                  pitySSR_char: 0, pitySR_char: 0,
                  pitySSR_item: 0, pitySR_item: 0, pitySSR_talent: 0, pitySR_talent: 0,
                  redeemedCodes: [],
                  activeCompanions: [],
                  activatedItems: [],
              };
              const savedState = AppStorage.loadData('gacha_state', defaultState);
              this.gachaState = Object.assign({}, defaultState, savedState);
              if (this.gachaState.mengChen) {
                  delete this.gachaState.mengChen;
              }
              this.gachaCollection = AppStorage.loadData('gacha_collection', {});
              this.gachaHistory = AppStorage.loadData('gacha_history', []);
          },

          saveGachaState() {
              AppStorage.saveData('gacha_state', this.gachaState);
              AppStorage.saveData('gacha_collection', this.gachaCollection);
              AppStorage.saveData('gacha_history', this.gachaHistory);
          },
          _updateGachaBackground(bgUrl) {
              const modalContent = document.getElementById('gacha-modal-content');
              if (modalContent && bgUrl) {
                  const img = new Image();
                  img.onload = () => {
                      modalContent.style.backgroundImage = `url('${bgUrl}')`;
                  };
                  img.src = bgUrl;
              }
          },
          _renderGachaPool(poolType) {
              this.currentGachaPoolType = poolType;
              const displayContainer = document.getElementById('gacha-pool-display');
              if (!displayContainer) return;

              const poolData = {
                  character: { title: 'é•œèŠ±æ°´æœˆ (è§’è‰²æ± )', cost: 320, pitySSR: this.gachaState.pitySSR_char, pitySR: this.gachaState.pitySR_char, bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
                  item: { title: 'ä¸‡è±¡å¥‡ç (é“å…·æ± )', cost: 160, pitySSR: this.gachaState.pitySSR_item, pitySR: this.gachaState.pitySR_item, bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
                  talent: { title: 'å¤©å‘½çµæ ¹ (å¤©èµ‹æ± )', cost: 160, pitySSR: this.gachaState.pitySSR_talent, pitySR: this.gachaState.pitySR_talent, bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
              };
              const currentPool = poolData[poolType];

              this._updateGachaBackground(currentPool.bg);

              displayContainer.innerHTML = `
                  <div class="summon-container">
                      <div class="summon-header-info"></div> 
                      <div class="summon-main-controls">
                          <h3 class="pool-title">${currentPool.title}</h3>
                          <p style="font-size:12px; color:#a09c91;">SSRä¿åº•: ${currentPool.pitySSR}/90 | SRä¿åº•: ${currentPool.pitySR}/10</p>
                          <div class="summon-buttons">
                              <button id="gacha-pull-1" class="interaction-btn">å¬å”¤1æ¬¡ (${currentPool.cost} æ¢¦å°˜)</button>
                              <button id="gacha-pull-10" class="interaction-btn primary-btn">å¬å”¤10æ¬¡ (${currentPool.cost * 10} æ¢¦å°˜)</button>
                          </div>
                      </div>
                  </div>
              `;

              document.getElementById('gacha-pull-1').addEventListener('click', () => this.handlePull(1, poolType));
              document.getElementById('gacha-pull-10').addEventListener('click', () => this.handlePull(10, poolType));

              document.querySelectorAll('.pool-switch-btn').forEach(btn => {
                  btn.classList.toggle('active', btn.dataset.pool === poolType);
              });
              const galleryBtn = document.getElementById('btn-gacha-gallery-new');
              if (galleryBtn) {
                  const newBtn = galleryBtn.cloneNode(true); 
                  galleryBtn.parentNode.replaceChild(newBtn, galleryBtn);
                  newBtn.addEventListener('click', () => this.showGachaGalleryPopup(poolType));
              }
          },

     // æ˜¾ç¤ºå›¾é‰´å¼¹çª—
          showGachaGalleryPopup(poolType) { 
              if (!poolType) {
                  console.error('showGachaGalleryPopup è°ƒç”¨æ—¶ç¼ºå°‘ poolType');
                  poolType = this.currentGachaPoolType; 
              }
              this.openModal('gacha-gallery-popup', true);
               // const poolType = this.currentGachaPoolType; // ä¸å†ä»å…¨å±€çŠ¶æ€è¯»å–
              const poolData = {
                  character: { title: 'é•œèŠ±æ°´æœˆ', bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
                  item: { title: 'ä¸‡è±¡å¥‡ç', bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
                  talent: { title: 'å¤©å‘½çµæ ¹', bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
              };
              const currentPool = poolData[poolType];

              document.getElementById('gacha-gallery-title').textContent = `${currentPool.title} å›¾é‰´`;

              const previewContainer = document.getElementById('gallery-pool-preview');
              previewContainer.innerHTML = `<div class="summon-container" style="background-image: url('${currentPool.bg}');"><h3 class="pool-title">${currentPool.title}</h3></div>`;

              const gridContainer = document.getElementById('gallery-obtained-grid');
              const allItems = [...(this.gachaPools[poolType]?.ssr || []), ...(this.gachaPools[poolType]?.sr || []), ...(this.gachaPools[poolType]?.r || [])];

              const renderContent = (isObtainedOnly) => {
                  const itemsToRender = isObtainedOnly ? allItems.filter(item => this.gachaCollection[item.id]) : allItems;

                  if (itemsToRender.length === 0) {
                      gridContainer.innerHTML = `<p style='text-align:center; color:#8b7355; padding-top: 40px;'>${isObtainedOnly ? 'æ­¤å¡æ± æš‚æ— å·²è·å¾—çš„é¡¹ç›®' : 'æ­¤å¡æ± å†…å®¹ä¸ºç©º'}</p>`;
                      return;
                  }

                  let gridHtml = '';
                  if (poolType === 'character') {
                      itemsToRender.forEach(item => {
                          const isUnlocked = this.gachaCollection[item.id];
                          const isActive = this.gachaState.activeCompanions.some(c => c.id === item.id);
                          const isQueued = this.pendingActions.some(a => a.itemName === item.åç§°);
                          let buttonHtml = '';
                          if (isUnlocked) {
                              if (isActive) buttonHtml = `<button class="gallery-join-world-btn" disabled>å·²åŠ å…¥</button>`;
                              else if (isQueued) buttonHtml = `<button class="gallery-join-world-btn" disabled>æŒ‡ä»¤é˜Ÿåˆ—ä¸­</button>`;
                              else buttonHtml = `<button class="gallery-join-world-btn" data-item-id="${item.id}">åŠ å…¥ä¸–ç•Œ</button>`;
                          }
                          const bgImageStyle = item.å›¾ç‰‡ ? `background-image: url('${item.å›¾ç‰‡}');` : '';
                          gridHtml += `
                              <div class="gallery-card rarity-${item.ç¨€æœ‰åº¦} ${isUnlocked ? 'unlocked' : 'gallery-card-locked'}" data-item-id="${item.id}">
                                  <div class="gallery-card-name">${item.åç§°}</div>
                                  ${buttonHtml}
                              </div>
                          `;
                      });
                      gridContainer.innerHTML = `<div class="gallery-grid">${gridHtml}</div>`;
                  } else {
                      itemsToRender.forEach(item => {
                          const isUnlocked = this.gachaCollection[item.id];
                          const isActive = this.gachaState.activatedItems.includes(item.id);
                          const isQueued = this.pendingActions.some(a => a.itemName === item.åç§°);
                          let buttonHtml = '';
                          if (isUnlocked) {
                              if (isActive) buttonHtml = `<button class="gallery-join-world-btn" disabled>å·²æ¿€æ´»</button>`;
                              else if (isQueued) buttonHtml = `<button class="gallery-join-world-btn" disabled>æŒ‡ä»¤é˜Ÿåˆ—ä¸­</button>`;
                              else buttonHtml = `<button class="gallery-join-world-btn" data-item-id="${item.id}" style="position: static; transform: none; opacity: 1; background: rgba(139,115,85,0.4);">åŠ å…¥æŒ‡ä»¤</button>`;
                          }

                          gridHtml += `
                              <div class="gallery-text-item ${isUnlocked ? '' : 'gallery-text-item-locked'}" data-item-id="${item.id}">
                                  <div class="gallery-text-item-header">
                                      <span class="gallery-text-item-name rarity-${item.ç¨€æœ‰åº¦}">${item.åç§°} ${item.ç±»å‹ ? `(${item.ç±»å‹})` : ''}</span>
                                      <span class="gallery-text-item-rarity rarity-${item.ç¨€æœ‰åº¦}">${item.ç¨€æœ‰åº¦}</span>
                                  </div>
                                  <p class="gallery-text-item-desc">${item.æè¿°}</p>
                                  ${isUnlocked ? `<div style="text-align: right; margin-top: 8px;">${buttonHtml}</div>` : ''}
                              </div>
                          `;
                      });
                      gridContainer.innerHTML = `<div class="gallery-text-grid">${gridHtml}</div>`;
                  }

                  gridContainer.querySelectorAll('.gallery-join-world-btn[data-item-id]').forEach(btn => {
                      btn.addEventListener('click', (e) => {
                          e.stopPropagation();
                          const itemId = e.target.dataset.itemId;
                          const itemData = allItems.find(i => i.id === itemId);
                          if(itemData) this.handleJoinWorld(itemData, poolType);
                      });
                  });
              };

              const container = document.querySelector('.gallery-obtained-container');
              const oldTabs = container.querySelector('.gallery-tab-nav');
              if (oldTabs) oldTabs.remove();
              const tabsHtml = `
                  <div class="gallery-tab-nav">
                      <button class="gallery-tab-btn" data-view="overview">å¡æ± æ€»è§ˆ</button>
                      <button class="gallery-tab-btn" data-view="collection">æˆ‘çš„æ”¶è—</button>
                  </div>
              `;
              container.insertAdjacentHTML('afterbegin', tabsHtml);

              const tabButtons = container.querySelectorAll('.gallery-tab-btn');
              tabButtons.forEach(btn => {
                  btn.addEventListener('click', () => {
                      tabButtons.forEach(b => b.classList.remove('active'));
                      btn.classList.add('active');
                      renderContent(btn.dataset.view === 'collection');
                  });
              });

              container.querySelector('.gallery-tab-btn[data-view="overview"]').click();
          },

          // è¡æ¢¦å°˜è®¾ç½®é¢æ¿
          showGachaSettingsPopup() {
              this.openModal('gacha-settings-popup', true);
              const container = document.querySelector('#gacha-settings-popup .modal-body');
              if (!container) return;
              const archiveTab = container.querySelector('.gacha-settings-tab[data-tab="archives"]');
              if (archiveTab) archiveTab.textContent = 'å¡æ± æ¡£æ¡ˆ';
              container.querySelectorAll('.gacha-settings-tab').forEach(tab => {
                  tab.addEventListener('click', () => {
                      container.querySelectorAll('.gacha-settings-tab').forEach(t => t.classList.remove('active'));
                      tab.classList.add('active');
                      this._renderGachaSettingsTab(tab.dataset.tab);
                  });
              });
              this._renderGachaSettingsTab('command_center');
          },

          _renderGachaSettingsTab(tabName) {
              const contentContainer = document.getElementById('gacha-settings-content-container');
              if (!contentContainer) return;
              contentContainer.innerHTML = '<p style="color: #a09c91; padding: 20px;">æ­£åœ¨åŠ è½½...</p>';

              switch (tabName) {
                  case 'command_center':
                      this._renderSettingsCommandCenter(contentContainer);
                      break;
                  case 'archives':
                      this._renderSettingsArchives(contentContainer);
                      break;
                  case 'redeem':
                      this._renderSettingsRedeem(contentContainer);
                      break;
                  case 'pool_editor':
                      this._renderSettingsPoolEditor(contentContainer);
                      break;
              }
          },

          _renderSettingsCommandCenter(container) {
              let contentHtml = '<h3 class="settings-section-title">å¾…å¤„ç†æŒ‡ä»¤</h3>';
              if (this.pendingActions.length === 0) {
                  contentHtml += '<p style="color: #a09c91; font-size: 13px;">å½“å‰æ²¡æœ‰å¾…å¤„ç†çš„æŒ‡ä»¤ã€‚</p>';
              } else {
                  contentHtml += '<ul class="command-center-list">';
                  this.pendingActions.forEach(cmd => {
                      const actionText = this._formatActionText(cmd); 
                      if(actionText) contentHtml += `<li>${actionText}</li>`;
                  });
                  contentHtml += '</ul>';
                  contentHtml += '<button id="gacha-clear-pending" class="interaction-btn btn-danger" style="margin-top: 15px;">æ¸…ç©ºæŒ‡ä»¤</button>';
              }
              container.innerHTML = contentHtml;

              const clearBtn = document.getElementById('gacha-clear-pending');
              if(clearBtn) {
                  clearBtn.addEventListener('click', () => {
                      this.pendingActions = [];
                      this.savePendingActions();
                      this._renderGachaSettingsTab('command_center'); 
                      this.showTemporaryMessage('æŒ‡ä»¤ä¸­å¿ƒå·²æ¸…ç©º');
                  });
              }
          },
          _renderSettingsArchives(container) {
              container.innerHTML = '<p style="color: #a09c91;">æ­£åœ¨åŠ è½½å¡æ± é¡¹ç›®...</p>';
              
              const allPoolItems = [
                  ...Object.values(this.gachaPools.character || {}).flat(),
                  ...Object.values(this.gachaPools.item || {}).flat(),
                  ...Object.values(this.gachaPools.talent || {}).flat()
              ].filter(Boolean);

              if (allPoolItems.length === 0) {
                  container.innerHTML = '<p style="color: #a09c91; font-size: 13px;">â€œã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± â€ä¸ºç©ºæˆ–æœªåŠ è½½ï¼Œè¯·å…ˆåœ¨ä¸–ç•Œä¹¦ä¸­å®šä¹‰å¡æ± å†…å®¹ã€‚</p>';
                  return;
              }
              
              let contentHtml = '<h3 class="settings-section-title">å¡æ± é¡¹ç›®é¢„è§ˆ</h3>';
              contentHtml += '<p style="font-size: 12px; color: #a09c91; margin-top: -5px; margin-bottom: 15px;">æ­¤å¤„åˆ—å‡ºæ‰€æœ‰åœ¨â€œã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± â€ä¸–ç•Œä¹¦ä¸­å®šä¹‰çš„é¡¹ç›®ã€‚</p>';

              for (const item of allPoolItems) {
                  contentHtml += `
                      <div class="character-archive-item">
                          <div class="archive-header">
                              <span class="archive-char-name" style="color: ${item.ç¨€æœ‰åº¦ === 'SSR' ? '#FFD700' : item.ç¨€æœ‰åº¦ === 'SR' ? '#C0C0C0' : '#CD7F32'};">${item.åç§°}</span>
                              <span style="font-size: 12px; color: #a09c91;">${item.ç±»å‹} - ${item.ç¨€æœ‰åº¦}</span>
                          </div>
                          <div style="padding: 10px 15px; font-size: 13px; color: #d4d2c8;">${item.æè¿°}</div>
                      </div>
                  `;
              }
              container.innerHTML = contentHtml;
          },

          // å¡æ± ç¼–è¾‘å™¨UIæ¸²æŸ“å‡½æ•°
          _renderSettingsPoolEditor(container) {
              let contentHtml = `
                  <div class="pool-editor-container">
                      <h3 class="settings-section-title">å¡æ± ç¼–è¾‘å™¨</h3>
                      <p style="font-size: 12px; color: #a09c91; margin-top: -5px; margin-bottom: 15px;">åœ¨æ­¤ç®¡ç†â€œã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± â€ä¸–ç•Œä¹¦çš„å†…å®¹ã€‚</p>
                      <div class="pool-editor-controls">
                          <select id="pool-editor-select" class="quick-send-input">
                              <option value="character">[è§’è‰²æ± ]</option>
                              <option value="item">[é“å…·æ± ]</option>
                              <option value="talent">[å¤©èµ‹æ± ]</option>
                          </select>
                          <button id="pool-editor-add-btn" class="interaction-btn primary-btn">æ·»åŠ æ–°é¡¹ç›®</button>
                      </div>
                      <div id="pool-editor-list-container" class="pool-editor-list">
                          <!-- é¡¹ç›®åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                      </div>
                  </div>
              `;
              container.innerHTML = contentHtml;
              const selectEl = document.getElementById('pool-editor-select');
              const addBtn = document.getElementById('pool-editor-add-btn');

              if (selectEl) {
                  selectEl.addEventListener('change', () => {
                      this._loadPoolEditorList(selectEl.value);
                  });
              }

              if (addBtn) {
                  addBtn.addEventListener('click', () => {
                      const poolType = selectEl ? selectEl.value : 'character';
                      this._addNewItemToEditor(poolType);
                  });
              }
              // åˆå§‹åŠ è½½é»˜è®¤å¡æ± 
              this._loadPoolEditorList(selectEl ? selectEl.value : 'character');
          },

          // åŠ è½½å¹¶æ¸²æŸ“æŒ‡å®šå¡æ± çš„ç¼–è¾‘å™¨åˆ—è¡¨
          async _loadPoolEditorList(poolType) {
              const listContainer = document.getElementById('pool-editor-list-container');
              if (!listContainer) return;

              listContainer.innerHTML = '<p style="color: #a09c91;">æ­£åœ¨ä»ä¸–ç•Œä¹¦åŠ è½½é¡¹ç›®...</p>';
              
              const poolCommentMapping = {
                  character: '[è§’è‰²æ± ]',
                  item: '[é“å…·æ± ]',
                  talent: '[å¤©èµ‹æ± ]'
              };
              const targetComment = poolCommentMapping[poolType];
              
              try {
                  const bookName = 'ã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± ';
                  const allEntries = await TavernHelper.getLorebookEntries(bookName);
                  const targetEntry = allEntries.find(e => e.comment === targetComment && e.enabled === false);

                  if (!targetEntry || !targetEntry.content) {
                      listContainer.innerHTML = '<p style-style="color: #8b7355;">æœªæ‰¾åˆ°æˆ–å¡æ± ä¸ºç©ºã€‚æ‚¨å¯ä»¥ç‚¹å‡»â€œæ·»åŠ æ–°é¡¹ç›®â€æ¥åˆ›å»ºç¬¬ä¸€ä¸ªæ¡ç›®ã€‚</p>';
                      return;
                  }

                  const itemBlocks = targetEntry.content.split(/\n*\s*åç§°:/).filter(block => block.trim() !== '');
                  if (itemBlocks.length === 0) {
                       listContainer.innerHTML = '<p style-style="color: #8b7355;">å¡æ± ä¸ºç©ºã€‚æ‚¨å¯ä»¥ç‚¹å‡»â€œæ·»åŠ æ–°é¡¹ç›®â€æ¥åˆ›å»ºç¬¬ä¸€ä¸ªæ¡ç›®ã€‚</p>';
                      return;
                  }

                  listContainer.innerHTML = ''; // æ¸…ç©º
                  itemBlocks.forEach(block => {
                      const item = this._parseGachaPoolEntry('åç§°:' + block);
                      if (item) {
                          const itemElement = this._createEditorItemElement(item, poolType);
                          listContainer.appendChild(itemElement);
                      }
                  });

              } catch (e) {
                  console.error(`åŠ è½½å¡æ±  [${targetComment}] å¤±è´¥:`, e);
                  listContainer.innerHTML = `<p style="color: #ff6b6b;">åŠ è½½å¤±è´¥: ${e.message}</p>`;
              }
          },

          // ä»ä¸–ç•Œä¹¦ä¸­åˆ é™¤å¡æ± é¡¹ç›®
          async _deletePoolItem(itemName, poolType) {
              this.showTemporaryMessage(`æ­£åœ¨åˆ é™¤â€œ${itemName}â€...`, 'info');
              const poolCommentMapping = {
                  character: '[è§’è‰²æ± ]',
                  item: '[é“å…·æ± ]',
                  talent: '[å¤©èµ‹æ± ]'
              };
              const targetComment = poolCommentMapping[poolType];

              try {
                  const bookName = 'ã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± ';
                  const allEntries = await TavernHelper.getLorebookEntries(bookName);
                  const targetEntry = allEntries.find(e => e.comment === targetComment && e.enabled === false);

                  if (!targetEntry) {
                      throw new Error('æœªæ‰¾åˆ°å¯¹åº”çš„å¡æ± æ¡ç›®ã€‚');
                  }

                  const itemBlocks = targetEntry.content.split(/\n*\s*åç§°:/).filter(block => block.trim() !== '');
                  const newBlocks = itemBlocks.filter(block => !('åç§°:' + block).trim().startsWith(`åç§°: ${itemName}`));
                  
                  if (newBlocks.length === itemBlocks.length) {
                      throw new Error('åœ¨å¡æ± å†…å®¹ä¸­æœªæ‰¾åˆ°è¦åˆ é™¤çš„é¡¹ç›®ã€‚');
                  }

                  const newContent = newBlocks.map(b => 'åç§°: ' + b.trim()).join('\n\n');
                  
                  await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: newContent }]);
                  
                  this.showTemporaryMessage('åˆ é™¤æˆåŠŸï¼', 'success');
                  this._loadPoolEditorList(poolType);
                  this.loadCharacterPoolFromLorebook();

              } catch (e) {
                  console.error('åˆ é™¤å¡æ± é¡¹ç›®å¤±è´¥:', e);
                  this.showTemporaryMessage(`åˆ é™¤å¤±è´¥: ${e.message}`, 'error');
              }
          },
          _addNewItemToEditor(poolType) {
              const listContainer = document.getElementById('pool-editor-list-container');
              if (!listContainer) return;

              if (document.getElementById('new-item-editor')) {
                  this.showTemporaryMessage('è¯·å…ˆä¿å­˜æˆ–å–æ¶ˆå½“å‰æ­£åœ¨åˆ›å»ºçš„é¡¹ç›®ã€‚', 'warning');
                  return;
              }

              const newItemElement = this._createEditorItemElement(null, poolType);
              newItemElement.id = 'new-item-editor';
              listContainer.prepend(newItemElement);
              newItemElement.querySelector('details').open = true; 
          },
          
          _createEditorItemElement(item, poolType) {
              const isNew = !item;
              const originalName = isNew ? '' : item.åç§°;
              const element = document.createElement('div');
              element.className = 'pool-editor-item';

              const rarityColor = `var(--tier-${(isNew ? 'R' : item.ç¨€æœ‰åº¦).toLowerCase()}, '#CD7F32')`;

              element.innerHTML = `
                  <details class="pool-editor-card" ${isNew ? 'open' : ''}>
                      <summary class="card-summary-header">
                          <div class="summary-info">
                            <span class="item-name-display">${isNew ? 'ã€æ–°é¡¹ç›®ã€‘' : _.escape(item.åç§°)}</span>
                            <p class="item-description-display-summary">${isNew ? 'ç‚¹å‡»æ­¤å¤„æŠ˜å ' : _.escape(item.æè¿°)}</p>
                          </div>
                          <span class="item-rarity-display" style="color: ${rarityColor};">${isNew ? 'R' : _.escape(item.ç¨€æœ‰åº¦)}</span>
                      </summary>
                      <div class="card-editor-form">
                          <form class="pool-editor-form-inline">
                              <input type="hidden" name="originalName" value="${_.escape(originalName)}">
                              <input type="hidden" name="poolType" value="${poolType}">
                              <label><span>åç§°:</span> <input type="text" name="åç§°" class="stylish-input" value="${isNew ? '' : _.escape(item.åç§°)}" required></label>
                              <label><span>ç¨€æœ‰åº¦:</span>
                                  <div class="stylish-select-wrapper">
                                      <select name="ç¨€æœ‰åº¦" class="stylish-select" required>
                                          <option value="SSR" ${!isNew && item.ç¨€æœ‰åº¦ === 'SSR' ? 'selected' : ''}>SSR</option>
                                          <option value="SR" ${!isNew && item.ç¨€æœ‰åº¦ === 'SR' ? 'selected' : ''}>SR</option>
                                          <option value="R" ${!isNew && item.ç¨€æœ‰åº¦ === 'R' ? 'selected' : ''}>R</option>
                                      </select>
                                      <i class="arrow down"></i>
                                  </div>
                              </label>
                              <label><span>ç±»å‹:</span> <input type="text" name="ç±»å‹" class="stylish-input" value="${isNew ? '' : _.escape(item.ç±»å‹)}" required></label>
                              <label><span>æè¿°:</span> <textarea name="æè¿°" class="stylish-input" rows="2" required>${isNew ? '' : _.escape(item.æè¿°)}</textarea></label>
                              <label><span>è¯¦ç»†ä¿¡æ¯ (ä¸–ç•Œä¹¦å†…å®¹):</span> <textarea name="worldbookContent" class="stylish-input" rows="4">${isNew ? '' : _.escape(item.worldbookContent || '')}</textarea></label>
                              <div class="pool-editor-item-actions">
                                  ${!isNew ? `<button type="button" class="stylish-btn danger-btn btn-delete-item" data-name="${_.escape(item.åç§°)}">åˆ é™¤</button>` : ''}
                                  <button type="submit" class="stylish-btn primary-btn btn-save-item">ä¿å­˜</button>
                              </div>
                          </form>
                      </div>
                  </details>
              `;

              const details = element.querySelector('details');
              const form = element.querySelector('form');

              details.addEventListener('toggle', (event) => {
                  if (isNew && !details.open) {
                      element.remove();
                  }
              });

              form.addEventListener('submit', async (e) => {
                  e.preventDefault();
                  const formData = new FormData(form);
                  const saveData = Object.fromEntries(formData.entries());
                  const success = await this._savePoolItem(saveData);
                  if (success && !isNew) {
                      // æ›´æ–°æˆåŠŸåï¼ŒåŒæ­¥UIå’Œè¡¨å•å†…çš„åŸå§‹åç§°
                      const summaryView = element.querySelector('.card-summary-header');
                      summaryView.querySelector('.item-name-display').textContent = saveData.åç§°;
                      summaryView.querySelector('.item-description-display-summary').textContent = saveData.æè¿°;
                      summaryView.querySelector('.item-rarity-display').textContent = saveData.ç¨€æœ‰åº¦;
                      
                      const newRarityColor = `var(--tier-${saveData.ç¨€æœ‰åº¦.toLowerCase()}, '#CD7F32')`;
                      summaryView.querySelector('.item-rarity-display').style.color = newRarityColor;

                      // æ ¸å¿ƒä¿®å¤ï¼šæ›´æ–°éšè—çš„originalNameå­—æ®µï¼Œä»¥ä¾¿ä¸‹æ¬¡ç¼–è¾‘
                      form.querySelector('input[name="originalName"]').value = saveData.åç§°;
                      
                      details.open = false;
                  } else if (success && isNew) {
                      // å¦‚æœæ˜¯æ–°å»ºé¡¹ç›®ä¸”æˆåŠŸï¼Œåˆ—è¡¨ä¼šè¢«åˆ·æ–°ï¼Œè¿™é‡Œä¸éœ€è¦é¢å¤–æ“ä½œ
                  }
              });

              const deleteBtn = element.querySelector('.btn-delete-item');
              if (deleteBtn) {
                  deleteBtn.addEventListener('click', (e) => {
                      e.preventDefault();
                      const itemName = deleteBtn.dataset.name;
                      if (confirm(`æ‚¨ç¡®å®šè¦ä» [${poolType}] æ± ä¸­åˆ é™¤â€œ${itemName}â€å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
                          this._deletePoolItem(itemName, poolType);
                      }
                  });
              }
              return element;
          },

          // ä¿å­˜å¡æ± é¡¹ç›®åˆ°ä¸–ç•Œä¹¦
          async _savePoolItem(saveData) {
              this.showTemporaryMessage('æ­£åœ¨ä¿å­˜åˆ°ä¸–ç•Œä¹¦...', 'info');
              const poolCommentMapping = {
                  character: '[è§’è‰²æ± ]',
                  item: '[é“å…·æ± ]',
                  talent: '[å¤©èµ‹æ± ]'
              };
              const targetComment = poolCommentMapping[saveData.poolType];
              if (!targetComment) {
                  this.showTemporaryMessage('é”™è¯¯ï¼šæ— æ•ˆçš„å¡æ± ç±»å‹ï¼', 'error');
                  return false;
              }

              try {
                  const bookName = 'ã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± ';
                  const allEntries = await TavernHelper.getLorebookEntries(bookName);
                  let targetEntry = allEntries.find(e => e.comment === targetComment && e.enabled === false);
                  
                  if (targetEntry && saveData.åç§° !== saveData.originalName) {
                      const existingNames = (targetEntry.content.match(/åç§°:\s*(.*)/g) || []).map(line => line.substring(line.indexOf(':') + 1).trim());
                      if (existingNames.includes(saveData.åç§°)) {
                          const overwrite = await this.showCustomConfirm(`å·²å­˜åœ¨åä¸ºâ€œ${saveData.åç§°}â€çš„é¡¹ç›®ã€‚æ‚¨æƒ³è¦è¦†ç›–å®ƒå—ï¼Ÿ`);
                          if (!overwrite) {
                              this.showTemporaryMessage('æ“ä½œå·²å–æ¶ˆ', 'info');
                              return false;
                          }
                      }
                  }
                  let newContent = '';
                  const newItemBlock = `åç§°: ${saveData.åç§°}\nç¨€æœ‰åº¦: ${saveData.ç¨€æœ‰åº¦}\nç±»å‹: ${saveData.ç±»å‹}\næè¿°: ${saveData.æè¿°}\n<è¯¦ç»†ä¿¡æ¯>\n${saveData.worldbookContent}\n</è¯¦ç»†ä¿¡æ¯>`;

                  if (targetEntry) {
                      const itemBlocks = targetEntry.content.split(/\n*\s*åç§°:/).filter(block => block.trim() !== '');
                      let itemFound = false;
                      const filteredBlocks = itemBlocks.filter(block => {
                          const currentName = ('åç§°:' + block).trim().match(/åç§°:\s*(.*?)\n/)[1];
                          return currentName !== saveData.åç§° && currentName !== saveData.originalName;
                      });

                      const finalBlocks = filteredBlocks.map(b => 'åç§°: ' + b.trim());
                      finalBlocks.push(newItemBlock);
                      newContent = finalBlocks.join('\n\n');
                      
                      await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: newContent }]);
                  } else {
                      newContent = newItemBlock;
                      await TavernHelper.createLorebookEntries(bookName, [{ comment: targetComment, content: newContent, enabled: false }]);
                  }
                  
                  this.showTemporaryMessage('ä¿å­˜æˆåŠŸï¼', 'success');
                  this._loadPoolEditorList(saveData.poolType);
                  this.loadCharacterPoolFromLorebook();
                  return true;

              } catch (e) {
                  console.error('ä¿å­˜å¡æ± é¡¹ç›®å¤±è´¥:', e);
                  this.showTemporaryMessage(`ä¿å­˜å¤±è´¥: ${e.message}`, 'error');
                  return false;
              }
          },

          _renderSettingsRedeem(container) {
              container.innerHTML = `
                  <div class="redeem-container">
                      <h3 class="settings-section-title" style="text-align:center;">å¤©é“é¦ˆèµ </h3>
                      <p style="color: #a09c91; font-size: 13px; max-width: 400px; margin: 15px auto;">åœ¨æ­¤è¾“å…¥ç¥ç§˜çš„çœŸè¨€ä»¥æ¢å–å¤©é“çš„é¦ˆèµ ã€‚</p>
                      <div style="display: flex; gap: 10px; align-items: center; justify-content: center;">
                          <input type="text" id="redeem-code-input-settings" placeholder="è¾“å…¥å…‘æ¢ç " class="quick-send-input" style="width: 300px; height: 40px; text-align: center; font-size: 14px;">
                          <button id="btn-redeem-code-settings" class="interaction-btn primary-btn" style="padding: 10px 20px;">å…‘æ¢</button>
                      </div>

                      
                      <div style="margin-top: 40px; padding-top: 20px; border-top: 1px dashed rgba(201, 170, 113, 0.3);">
                          <label style="display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; color: #ff6b6b;">
                              <input type="checkbox" id="gacha-cheat-mode-toggle" ${this.isGachaCheatMode ? 'checked' : ''}>
                              <strong>å¼€å¯å†…æµ‹ä½œå¼Šæ¨¡å¼ (æ— é™æ¢¦å°˜)</strong>
                          </label>
                      </div>
                  </div>
              `;
              
              const redeemBtn = document.getElementById('btn-redeem-code-settings');
              const redeemInput = document.getElementById('redeem-code-input-settings');
              const cheatToggle = document.getElementById('gacha-cheat-mode-toggle'); 

              redeemBtn.addEventListener('click', () => {
                  this.handleRedeemCode(redeemInput.value, () => {
                      redeemInput.value = ''; 
                      // æˆåŠŸå…‘æ¢åï¼Œåˆ·æ–°æ•´ä¸ªå¬å”¤ç•Œé¢çš„UIä»¥æ˜¾ç¤ºæœ€æ–°çš„å½’å¢Ÿç‚¹
                      this.renderSummonTab(this.currentGachaPoolType);
                  });
              });
              redeemInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') redeemBtn.click(); });
              if (cheatToggle) {
                  cheatToggle.addEventListener('change', (e) => {
                      this.isGachaCheatMode = e.target.checked;
                      this.saveGachaCheatState(); 
                      this.showTemporaryMessage(`ä½œå¼Šæ¨¡å¼å·²${this.isGachaCheatMode ? 'å¼€å¯' : 'å…³é—­'}`);
                  });
              }
          },
         // ä¸»å‡½æ•° (ç¬¬ä¸‰æ­¥)
          renderSummonTab(activePool = 'character') {
              if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                  console.error('[è¡æ¢¦å°˜] æ— æ³•æ¸²æŸ“å¬å”¤ç•Œé¢ï¼šä¸»æ¸¸æˆçŠ¶æ€ (MVU) æœªåŠ è½½ã€‚');
                  const container = document.getElementById('gacha-main-container');
                  if (container) {
                      container.innerHTML = '<p style="text-align:center; color:#8b7355; padding: 50px;">æ— æ³•åŠ è½½è§’è‰²æ•°æ®ï¼Œè¯·å…ˆå¼€å§‹æ¸¸æˆæˆ–å‘é€ä¸€æ¡æ¶ˆæ¯ä»¥åˆå§‹åŒ–çŠ¶æ€ã€‚</p>';
                  }
                  const switcher = document.getElementById('gacha-pool-switcher-header');
                  const currency = document.getElementById('gacha-currency-header');
                  if(switcher) switcher.style.display = 'none';
                  if(currency) currency.style.display = 'none';
              }
              const switcher = document.getElementById('gacha-pool-switcher-header');
              const currency = document.getElementById('gacha-currency-header');
              if(switcher) switcher.style.display = 'flex';
              if(currency) currency.style.display = 'block';

              const mainContainer = document.getElementById('gacha-main-container');
              const switcherContainer = document.getElementById('gacha-pool-switcher-header');
              const currencyContainer = document.getElementById('gacha-currency-header');
              if (!mainContainer || !switcherContainer || !currencyContainer) return;

              const poolInfo = {
                  character: { title: 'é•œèŠ±æ°´æœˆ', bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
                  item: { title: 'ä¸‡è±¡å¥‡ç', bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
                  talent: { title: 'å¤©å‘½çµæ ¹', bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
              };

              let switcherHtml = '';
              for (const [poolType, data] of Object.entries(poolInfo)) {
                  switcherHtml += `<button class="pool-switch-btn" data-pool="${poolType}" data-title="${data.title}" style="background-image: url('${data.bg}');"></button>`;
              }
              switcherContainer.innerHTML = switcherHtml;

              const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, 'å½’å¢Ÿç‚¹', 0);
              currencyContainer.innerHTML = `å½’å¢Ÿç‚¹: <strong>${guixuPoints}</strong>`;

              mainContainer.innerHTML = `
                  <div id="gacha-pool-display" style="flex-grow: 1; display: flex;"></div>
                  <button id="btn-gacha-settings-new" class="gacha-corner-btn" title="è®¾ç½®">âš™ï¸</button>
                  <button id="btn-gacha-gallery-new" class="gacha-corner-btn" title="å›¾é‰´">ğŸ–¼ï¸</button>
              `;

              switcherContainer.querySelectorAll('.pool-switch-btn').forEach(btn => {
                  btn.addEventListener('click', () => {
                      this._renderGachaPool(btn.dataset.pool);
                  });
              });

              document.getElementById('btn-gacha-settings-new').addEventListener('click', () => this.showGachaSettingsPopup());
              document.getElementById('btn-gacha-gallery-new').addEventListener('click', () => this.showGachaGalleryPopup(this.currentGachaPoolType));
              
              this._renderGachaPool(activePool);
          },
          _renderTextBasedGrid(poolType) {
              const allItems = [...(this.gachaPools[poolType]?.ssr || []), ...(this.gachaPools[poolType]?.sr || []), ...(this.gachaPools[poolType]?.r || [])];
              if(allItems.length === 0) return '<p style="color: #a09c91; text-align: center; margin-top: 20px;">æ­¤å›¾é‰´æš‚æ— å†…å®¹</p>';
              
              allItems.sort((a,b) => (b.ç¨€æœ‰åº¦ === 'SSR' ? 3 : b.ç¨€æœ‰åº¦ === 'SR' ? 2 : 1) - (a.ç¨€æœ‰åº¦ === 'SSR' ? 3 : a.ç¨€æœ‰åº¦ === 'SR' ? 2 : 1));
              
              let gridHtml = '';
              allItems.forEach(item => {
                  const isUnlocked = this.gachaCollection[item.id];
                  const rarity = item.ç¨€æœ‰åº¦ || 'R';
                  const name = item.åç§° || 'æœªçŸ¥';
                  const desc = item.æè¿° || 'æš‚æ— æè¿°';
                  const type = item.ç±»å‹ || '';

                  if (isUnlocked) {
                      gridHtml += `
                          <div class="gallery-text-item" data-item-id="${item.id}" data-pool-type="${poolType}">
                              <div class="gallery-text-item-header">
                                  <span class="gallery-text-item-name rarity-${rarity}">${name} ${type ? `(${type})` : ''}</span>
                                  <span class="gallery-text-item-rarity rarity-${rarity}">${rarity}</span>
                              </div>
                              <p class="gallery-text-item-desc">${desc}</p>
                          </div>
                      `;
                  } else {
                      gridHtml += `
                          <div class="gallery-text-item gallery-text-item-locked">
                              <div class="gallery-text-item-header">
                                  <span class="gallery-text-item-name">ï¼Ÿï¼Ÿï¼Ÿ</span>
                                  <span class="gallery-text-item-rarity rarity-${rarity}">${rarity}</span>
                              </div>
                              <p class="gallery-text-item-desc">å°šæœªè·å¾—</p>
                          </div>
                      `;
                  }
              });
              return `<div class="gallery-text-grid">${gridHtml}</div>`;
          },

          renderGalleryTab() {
              const container = document.getElementById('gacha-tab-gallery');
              if(!container) return;
              const renderGrid = (poolType) => {
                  const allItems = [...(this.gachaPools[poolType]?.ssr || []), ...(this.gachaPools[poolType]?.sr || []), ...(this.gachaPools[poolType]?.r || [])];
                  if(allItems.length === 0) return '<p style="color: #a09c91; text-align: center; margin-top: 20px;">æ­¤å›¾é‰´æš‚æ— å†…å®¹</p>';
                  allItems.sort((a,b) => (a.ç¨€æœ‰åº¦ === 'SSR' ? 3 : a.ç¨€æœ‰åº¦ === 'SR' ? 2 : 1) - (b.ç¨€æœ‰åº¦ === 'SSR' ? 3 : b.ç¨€æœ‰åº¦ === 'SR' ? 2 : 1));
                  let gridHtml = '';
                  allItems.forEach(item => {
                      const isUnlocked = this.gachaCollection[item.id];
                      const cardClass = `gallery-card rarity-${item.ç¨€æœ‰åº¦} ${isUnlocked ? 'unlocked' : 'gallery-card-locked'}`;
                      const bgImageStyle = isUnlocked && item.å›¾ç‰‡ ? `background-image: url('${item.å›¾ç‰‡}');` : '';
                      gridHtml += `<div class="${cardClass}" title="${item.åç§°}" data-item-id="${item.id}" data-pool-type="${poolType}" style="${bgImageStyle}">${isUnlocked ? `<div class="gallery-card-name">${item.åç§°}</div>` : ''}</div>`;
                  });
                  return `<div class="gallery-grid">${gridHtml}</div>`;
              }
              container.innerHTML = `
                  <details class="gallery-section" open><summary class="section-title">è§’è‰²å›¾é‰´</summary>${renderGrid('character')}</details>
                  <details class="gallery-section" open><summary class=\"section-title\">é“å…·å›¾é‰´</summary>${this._renderTextBasedGrid('item')}</details>
                  <details class=\"gallery-section\" open><summary class=\"section-title\">å¤©èµ‹å›¾é‰´</summary>${this._renderTextBasedGrid('talent')}</details>
              `;
             
              container.querySelectorAll('.gallery-grid, .gallery-text-grid').forEach(grid => {
                  grid.addEventListener('click', e => {
                      const card = e.target.closest('.gallery-card.unlocked, .gallery-text-item:not(.gallery-text-item-locked)');
                      if (!card) return;
                      const itemId = card.dataset.itemId;
                      const poolType = card.dataset.poolType;
                      const allItems = [...this.gachaPools[poolType].ssr, ...this.gachaPools[poolType].sr, ...this.gachaPools[poolType].r];
                      const itemData = allItems.find(i => i.id === itemId);
                      if (itemData) this.showGachaItemDetails(itemData, poolType);
                  });
              });
          },

          renderShopTab() {
              const container = document.getElementById('gacha-tab-shop');
              if (!container) return;
              container.innerHTML = `
                  <div class="shop-container" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; gap: 25px; padding: 20px; text-align: center;">
                      <h3 class="pool-title">å¤©é“é¦ˆèµ </h3>
                      <p style="color: #a09c91; font-size: 13px; max-width: 400px;">åœ¨æ­¤è¾“å…¥ç¥ç§˜çš„çœŸè¨€ä»¥æ¢å–å¤©é“çš„é¦ˆèµ ã€‚æŸäº›çœŸè¨€æˆ–è®¸ä½è¯­ç€å¤§èƒ½çš„åè®³ï¼Œè•´å«ç€è«å¤§çš„æœºç¼˜ã€‚</p>
                      <div style="display: flex; gap: 10px; align-items: center;">
                          <input type="text" id="redeem-code-input" placeholder="è¾“å…¥å…‘æ¢ç " class="quick-send-input" style="width: 300px; height: 40px; text-align: center; font-size: 14px;">
                          <button id="btn-redeem-code" class="interaction-btn primary-btn" style="padding: 10px 20px;">å…‘æ¢</button>
                      </div>
                      
                  <div class="gacha-currency">å½“å‰æ¢¦å°˜: <strong>${this.gachaState.mengChen}</strong></div>
                  <div style="margin-top: 20px; padding-top: 20px; border-top: 1px dashed rgba(201, 170, 113, 0.3);">
                      <label style="display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; color: #ff6b6b;">
                          <input type="checkbox" id="gacha-cheat-mode-toggle" ${this.isGachaCheatMode ? 'checked' : ''}>
                          <strong>å¼€å¯å†…æµ‹ä½œå¼Šæ¨¡å¼ (æ— é™æ¢¦å°˜)</strong>
                      </label>
                  </div>
              </div>
              `;
              document.getElementById('btn-redeem-code').addEventListener('click', () => this.handleRedeemCode());
              document.getElementById('redeem-code-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') { document.getElementById('btn-redeem-code').click(); } });
 
              document.getElementById('gacha-cheat-mode-toggle').addEventListener('change', (e) => {
                  this.isGachaCheatMode = e.target.checked;
                  this.saveGachaCheatState();
                  this.showTemporaryMessage(`ä½œå¼Šæ¨¡å¼å·²${this.isGachaCheatMode ? 'å¼€å¯' : 'å…³é—­'}`);
              });
         },

          async handlePull(count, poolType) {
              if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                  this.showTemporaryMessage('é”™è¯¯ï¼šè§’è‰²æ•°æ®æœªåŠ è½½ï¼Œæ— æ³•è¿›è¡Œå¬å”¤ã€‚');
                  return;
              }

              const costs = { character: 320, item: 160, talent: 160 };
              const cost = count * costs[poolType];
              const initialPoints = parseInt(Mvu.getMvuVariable(this.currentMvuState, 'å½’å¢Ÿç‚¹', { default_value: 0 }), 10);

              if (!this.isGachaCheatMode && initialPoints < cost) {
                  this.showTemporaryMessage('å½’å¢Ÿç‚¹ä¸è¶³ï¼');
                  return;
              }

              // --- æŠ½å¡é€»è¾‘ ---
              const results = [];
              let gotSR_or_above = false;
              for (let i = 0; i < count; i++) {
                  const result = this.getGachaRoll(poolType);
                  results.push(result);
                  if (result.rarity === 'SR' || result.rarity === 'SSR') gotSR_or_above = true;
              }
              if (count === 10 && !gotSR_or_above) {
                  results[Math.floor(Math.random() * 10)] = this.getRandomItemFromPool(poolType, ['sr']);
              }
              // --- æŠ½å¡é€»è¾‘ç»“æŸ ---

              // --- å½’å¢Ÿç‚¹è®¡ç®—ä¸åŒæ­¥ ---
              let totalReward = 0;
              if (!this.isGachaCheatMode) {
                  results.forEach(res => {
                      const isDuplicate = !!this.gachaCollection[res.id];
                      if (isDuplicate) {
                          totalReward += res.ç¨€æœ‰åº¦ === 'SSR' ? 80 : res.ç¨€æœ‰åº¦ === 'SR' ? 20 : 5;
                      }
                  });

                  const netChange = totalReward - cost;
                  const mvuData = this.currentMvuState;
                  const path = 'å½’å¢Ÿç‚¹';
                  const currentPoints = parseInt(Mvu.getMvuVariable(mvuData, path, { default_value: 0 }), 10);
                  
                  await Mvu.setMvuVariable(mvuData, path, currentPoints + netChange, { reason: `è¡æ¢¦å°˜å¬å”¤, æ¶ˆè€—${cost}, è¡¥å¿${totalReward}` });
                  await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });

                  this.showTemporaryMessage(`å¬å”¤å®Œæˆï¼æ¶ˆè€—${cost}, è¡¥å¿${totalReward}å½’å¢Ÿç‚¹ã€‚`);
              }
              // --- å½’å¢Ÿç‚¹è®¡ç®—ä¸åŒæ­¥ç»“æŸ ---
              
              this.processPullResults(results, poolType); // ç°åœ¨åªè´Ÿè´£å¤„ç†ç‰©å“å’ŒUI
              this.saveGachaState();
              this.renderSummonTab(poolType); // åˆ·æ–°UIä»¥æ˜¾ç¤ºæœ€æ–°çš„å½’å¢Ÿç‚¹
          },

          getGachaRoll(poolType) {
              const pitySRKey = `pitySR_${poolType}`;
              const pitySSRKey = `pitySSR_${poolType}`;
              this.gachaState[pitySRKey]++;
              this.gachaState[pitySSRKey]++;
              if (this.gachaState[pitySSRKey] >= 90) return this.getSSRItem(poolType);
              if (this.gachaState[pitySRKey] >= 10) return this.getSRItem(poolType);
              const rand = Math.random();
              let softPityRate = this.gachaState[pitySSRKey] >= 74 ? (this.gachaState[pitySSRKey] - 73) * 0.06 : 0;
              if (rand < 0.006 + softPityRate) return this.getSSRItem(poolType);
              if (rand < 0.006 + softPityRate + 0.051) return this.getSRItem(poolType);
              return this.getRandomItemFromPool(poolType, ['r']);
          },

          getSSRItem(poolType) {
              this.gachaState[`pitySSR_${poolType}`] = 0;
              this.gachaState[`pitySR_${poolType}`] = 0;
              return this.getRandomItemFromPool(poolType, ['ssr']);
          },

          getSRItem(poolType) {
              this.gachaState[`pitySR_${poolType}`] = 0;
              return this.getRandomItemFromPool(poolType, ['sr']);
          },

          getRandomItemFromPool(poolType, rarities) {
              const pool = rarities.flatMap(r => this.gachaPools[poolType][r.toLowerCase()] || []);
              if (pool.length === 0) {
                  console.error(`[è¡æ¢¦å°˜] è­¦å‘Š: å¡æ±  (${poolType} - ${rarities.join(', ')}) ä¸ºç©ºã€‚`);
                  return { id: 'fallback', åç§°: 'è™šæ— ä¹‹å½±', ç¨€æœ‰åº¦: 'R', ç±»å‹: 'é”™è¯¯' }; 
              }
              return pool[Math.floor(Math.random() * pool.length)];
          },

          processPullResults(results, poolType) {
              this.openModal('gacha-results-modal', true);
              const gridContainer = document.getElementById('gacha-results-grid');
              if (!gridContainer) return;
              gridContainer.innerHTML = '';
              gridContainer.className = results.length === 1 ? 'gacha-results-grid single-pull' : 'gacha-results-grid';
              results.forEach((res) => {
                  const isDuplicate = !!this.gachaCollection[res.id];
                  if (!isDuplicate) {
                      this.gachaCollection[res.id] = { acquired: new Date().toISOString() };
                  }
                  
                  // å½’å¢Ÿç‚¹é€»è¾‘å·²ç§»è‡³ handlePull, è¿™é‡Œåªå¤„ç†éé‡å¤ç‰©å“çš„æŒ‡ä»¤æ·»åŠ 
                  if (!isDuplicate) {
                      // å°†éé‡å¤è·å¾—çš„ç‰©å“ä¿¡æ¯ï¼Œæ„é€ æˆä¸€ä¸ªæ ¼å¼åŒ–çš„<user>æ¶ˆæ¯ï¼Œå¹¶æ·»åŠ åˆ°æŒ‡ä»¤ä¸­å¿ƒ
                      const loreContent = Object.entries(res)
                          .filter(([key, value]) => !['id', '$meta'].includes(key) && value)
                          .map(([key, value]) => `${key}: ${value}`)
                          .join('\n');
                      const command = `<user>é€šè¿‡è¡æ¢¦å°˜è·å¾—äº†æ–°çš„[${res.ç±»å‹ || 'ç‰©å“'}]ï¼š${res.åç§°}\n${loreContent}`;
                      this.addCommand(command);
                      this.showTemporaryMessage(`[${res.åç§°}] (æ–°)ï¼Œè·å¾—æŒ‡ä»¤å·²å…¥é˜Ÿ`);
                  }

                  const card = document.createElement('div');
                  
                  if (poolType === 'character') {
                      card.className = `gacha-results-card rarity-${res.ç¨€æœ‰åº¦.toUpperCase()}`;
                      if (res.å›¾ç‰‡) card.style.backgroundImage = `url('${res.å›¾ç‰‡}')`;
                      
                      const infoContainer = document.createElement('div');
                      infoContainer.className = 'gacha-results-card-info';
                      infoContainer.innerHTML = `<div class="item-name">${res.åç§°}</div><div class="item-rarity">${res.ç¨€æœ‰åº¦}</div>`;
                      if (isDuplicate) {
                          infoContainer.innerHTML += `<div class="gacha-results-duplicate-tag">é‡å¤</div>`;
                      }
                      card.appendChild(infoContainer);

                      if (!isDuplicate) {
                          const newTag = document.createElement('div');
                          newTag.className = 'gacha-results-new-tag';
                          newTag.textContent = 'NEW';
                          card.appendChild(newTag);
                      }
                  } else {
                      card.className = `gacha-results-card-text rarity-${res.ç¨€æœ‰åº¦.toUpperCase()}`;
                      let cardContentHtml = `<div class="item-name">${res.åç§°}</div>`;
                      cardContentHtml += `<div class="item-rarity">${res.ç¨€æœ‰åº¦}</div>`;
                      if (res.ç±»å‹) {
                          cardContentHtml += `<div class="item-type">${res.ç±»å‹}</div>`;
                      }
                      if (isDuplicate) {
                          cardContentHtml += `<div class="gacha-results-duplicate-tag" style="margin-top: 10px;">é‡å¤</div>`;
                      }
                      card.innerHTML = cardContentHtml;

                      if (!isDuplicate) {
                          const newTag = document.createElement('div');
                          newTag.className = 'gacha-results-new-tag';
                          newTag.textContent = 'NEW';
                          card.appendChild(newTag);
                      }
                  }
                  gridContainer.appendChild(card);
              });
              this.gachaHistory.unshift({ timestamp: new Date().toISOString(), results: results, poolType: poolType });
              if (this.gachaHistory.length > 200) this.gachaHistory.pop();
              this.saveGachaState();
          },

          showGachaHistory(page = 1) {
              this.openModal('gacha-history-modal', true);
              const listContainer = document.getElementById('gacha-history-list');
              const indicatorEl = document.getElementById('gacha-history-page-indicator');
              const prevBtn = document.getElementById('gacha-history-prev-btn');
              const nextBtn = document.getElementById('gacha-history-next-btn');

              if (!listContainer || !indicatorEl || !prevBtn || !nextBtn) {
                  console.error('è¡æ¢¦å°˜å†å²è®°å½•ç•Œé¢UIå…ƒç´ ç¼ºå¤±!');
                  return;
              }

              const itemsPerPage = 5;
              const totalPages = Math.ceil(this.gachaHistory.length / itemsPerPage);
              const currentPage = Math.max(1, Math.min(page, totalPages || 1));
              const pageItems = this.gachaHistory.slice((currentPage - 1) * itemsPerPage, currentPage * itemsPerPage);
              let html = pageItems.length > 0 ? '' : '<p style=\"color:#a09c91; text-align:center; padding: 40px 0;\">æš‚æ— å¬å”¤è®°å½•</p>';
              pageItems.forEach(entry => {
                  // å®‰å…¨æ£€æŸ¥ (1): å¦‚æœè®°å½•æ¡ç›®æˆ–å…¶ç»“æœæ•°ç»„ä¸å­˜åœ¨ï¼Œåˆ™è·³è¿‡æ­¤æ¡è®°å½•ï¼Œé¿å…ç¨‹åºå´©æºƒ
                  if (!entry || !entry.results) { 
                      console.warn('å‘ç°å¹¶è·³è¿‡ä¸€æ¡æŸåçš„å¬å”¤å†å²è®°å½•:', entry);
                      return; 
                  }
                  const poolType = entry.poolType || 'character';
                  const poolNames = { character: 'é•œèŠ±æ°´æœˆ', item: 'ä¸‡è±¡å¥‡ç', talent: 'å¤©å‘½çµæ ¹' };
                  const poolName = poolNames[poolType] || 'æœªçŸ¥å¡æ± ';

                  const resultsHtml = entry.results.map(res => {
                      // å®‰å…¨æ£€æŸ¥ (2): å¦‚æœç»“æœæ•°ç»„ä¸­çš„æŸä¸ªç‰©å“ä¸å­˜åœ¨ï¼Œä¹Ÿè·³è¿‡å®ƒ
                      if (!res) return '';
                      const rarity = res.ç¨€æœ‰åº¦ || 'R';
                      const name = res.åç§° || 'æœªçŸ¥ç‰©å“';
                      return `<div class=\"gacha-history-item-card rarity-${rarity.toUpperCase()}\" title=\"${name}\">${name}</div>`;
                  }).join('');
                  html += `
                      <div class=\"gacha-history-entry\">
                          <div class=\"gacha-history-header\">
                              <span class=\"gacha-history-timestamp\">${new Date(entry.timestamp).toLocaleString('zh-CN')}</span>
                              <span class=\"gacha-history-pool\">${poolName}</span>
                          </div>
                          <div class=\"gacha-history-results-grid\">
                              ${resultsHtml}
                          </div>
                      </div>
                  `;
              });

              listContainer.className = 'gacha-history-list';
              listContainer.innerHTML = html;

              indicatorEl.textContent = `ç¬¬ ${currentPage} / ${totalPages || 1} é¡µ`;

              const newPrevBtn = prevBtn.cloneNode(true);
              prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
              const newNextBtn = nextBtn.cloneNode(true);
              nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
              
              newPrevBtn.disabled = currentPage <= 1;
              newNextBtn.disabled = currentPage >= totalPages;

              if (!newPrevBtn.disabled) newPrevBtn.onclick = () => this.showGachaHistory(currentPage - 1);
              if (!newNextBtn.disabled) newNextBtn.onclick = () => this.showGachaHistory(currentPage + 1);
          },          
          showGachaItemDetails(itemData, poolType) {
              const titleEl = document.getElementById('gacha-details-title');
              const bodyEl = document.getElementById('gacha-details-body');
              const footerEl = document.getElementById('gacha-details-footer');
              if (!titleEl || !bodyEl || !footerEl) return;

              titleEl.textContent = itemData.åç§°;
              let imageHtml = poolType === 'character' ? `<div class="gacha-details-image-large" style="background-image: url('${itemData.å›¾ç‰‡ || ''}');"></div>` : '';
              let infoHtml = `<div class="gacha-details-info">
                  <p><strong>ç¨€æœ‰åº¦:</strong> ${itemData.ç¨€æœ‰åº¦ || 'æœªçŸ¥'}</p>
                  <p><strong>ç±»å‹:</strong> ${itemData.ç±»å‹ || itemData.ç³»åˆ— || 'æœªçŸ¥'}</p>
                  <p><strong>æè¿°:</strong> ${itemData.æè¿° || 'æš‚æ— è¯¦ç»†æè¿°'}</p>
              </div>`;
              bodyEl.innerHTML = imageHtml + infoHtml;

              const companions = this.gachaState.activeCompanions || [];
              const isAlreadyActive = companions.some(c => c.id === itemData.id);
              const isAlreadyQueued = this.pendingActions.some(command => command.includes(`[è§’è‰²åŠ å…¥] ${itemData.åç§°}`));

              let joinButtonHtml = '';
              if (isAlreadyActive) {
                  joinButtonHtml = `<button class="interaction-btn primary-btn" disabled>å·²åœ¨ä¸–ç•Œä¸­</button>`;
              } else if (isAlreadyQueued) {
                  joinButtonHtml = `<button class="interaction-btn primary-btn" disabled>å·²åœ¨æŒ‡ä»¤é˜Ÿåˆ—</button>`;
              } else {
                  let isDisabled = false;
                  let disabledReason = '';
                  if (poolType === 'character') {
                      const totalLimitReached = companions.length >= 3;
                      const ssrLimitReached = companions.filter(c => c.rarity === 'SSR').length >= 1;
                      const isCharSSR = itemData.ç¨€æœ‰åº¦ === 'SSR';

                      if (totalLimitReached) { isDisabled = true; disabledReason = `ä¼™ä¼´å·²æ»¡ (${companions.length}/3)`; }
                      else if (isCharSSR && ssrLimitReached) { isDisabled = true; disabledReason = `SSRä¼™ä¼´å·²æ»¡ (1/1)`; }
                  }
                  
                  if (isDisabled) {
                      joinButtonHtml = `<button class="interaction-btn primary-btn" disabled>${disabledReason}</button>`;
                  } else {
                      joinButtonHtml = `<button id="btn-gacha-join-world" class="interaction-btn primary-btn">åŠ å…¥å½“å‰ä¸–ç•Œ</button>`;
                  }
              }

              footerEl.innerHTML = `
                  <button onclick="GuixuManager.closeModal('gacha-details-modal')" class="interaction-btn">å…³é—­</button>
                  ${joinButtonHtml}
              `;

              const joinButton = document.getElementById('btn-gacha-join-world');
              if (joinButton) {
                  joinButton.onclick = () => this.handleJoinWorld(itemData, poolType);
              }

              this.openModal('gacha-details-modal', true);
          },

          _parseLorebookCharacter(contentBlock, poolType) {
              const item = {};
              const lines = contentBlock.split('\n');
              lines.forEach(line => {
                  const parts = line.split(':');
                  if (parts.length < 2) return;
                  const key = parts[0].trim();
                  const value = parts.slice(1).join(':').trim();
                  switch (key) {
                      case 'åç§°': item.åç§° = value; break;
                      case 'ç³»åˆ—': item.ç³»åˆ— = value; break;
                      case 'å›¾ç‰‡': item.å›¾ç‰‡ = value; break;
                      case 'ç¨€æœ‰åº¦': item.ç¨€æœ‰åº¦ = value.toUpperCase(); break;
                      case 'ç±»å‹': item.ç±»å‹ = value; break;
                      case 'æè¿°': item.æè¿° = value; break;
                  }
              });
              if (item.åç§° && item.ç¨€æœ‰åº¦) return item;
              return null;
          },

          async loadCharacterPoolFromLorebook() {
              const bookName = 'ã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± ';
              const newPools = { character: { ssr: [], sr: [], r: [] }, item: { ssr: [], sr: [], r: [] }, talent: { ssr: [], sr: [], r: [] } };
              try {
                  const entries = await TavernHelper.getLorebookEntries(bookName);
                  if (!entries || entries.length === 0) { this.showTemporaryMessage(`è­¦å‘Šï¼šæœªæ‰¾åˆ°æˆ–â€œ${bookName}â€ä¸–ç•Œä¹¦ä¸ºç©ºã€‚`, 3000); return; }
                  let count = 0;
                  const poolMapping = { '[è§’è‰²æ± ]': 'character', '[é“å…·æ± ]': 'item', '[å¤©èµ‹æ± ]': 'talent' };
                  for (const entry of entries) {
                      const poolType = poolMapping[entry.comment];
                      if (poolType && entry.enabled === false) {
                          const itemBlocks = entry.content.split(/\n*\s*åç§°:/).filter(block => block.trim() !== '');
                          for (const block of itemBlocks) {
                              const fullBlock = 'åç§°:' + block;
                              const item = this._parseGachaPoolEntry(fullBlock);
                              if (item) {
                                  item.id = `${poolType}_${item.åç§°}`.replace(/\s/g, '_');
                                  const rarityKey = item.ç¨€æœ‰åº¦.toLowerCase();
                                  if (newPools[poolType][rarityKey]) {
                                      newPools[poolType][rarityKey].push(item);
                                      count++;
                                  }
                              }
                          }
                      }
                  }
                  this.gachaPools = newPools;
                  console.log(`[è¡æ¢¦å°˜] æˆåŠŸä»ä¸–ç•Œä¹¦åŠ è½½ ${count} ä¸ªé¡¹ç›®ã€‚`);
                  if (count === 0) this.showTemporaryMessage('æœªåœ¨ç¦ç”¨çš„æ¡ç›®ä¸­æ‰¾åˆ°ä»»ä½•æ ¼å¼æ­£ç¡®çš„å¡æ± é¡¹ç›®ã€‚', 4000);
              } catch (e) {
                  console.error('åŠ è½½è¡æ¢¦å°˜å¡æ± å¤±è´¥:', e);
                  this.showTemporaryMessage('é”™è¯¯ï¼šåŠ è½½å¡æ± å¤±è´¥ï¼Œè¯·æ£€æŸ¥ä¸–ç•Œä¹¦ã€‚', 3000);
              }
          },

          _parseGachaPoolEntry(blockText) {
              const item = {};
              const lines = blockText.trim().split('\n');
              let worldbookContent = '';
              let isDetailSection = false;

              for (const line of lines) {
                  if (line.trim() === '<è¯¦ç»†ä¿¡æ¯>') {
                      isDetailSection = true;
                      continue;
                  }
                  if (line.trim() === '</è¯¦ç»†ä¿¡æ¯>') {
                      isDetailSection = false;
                      continue;
                  }

                  if (isDetailSection) {
                      worldbookContent += line + '\n';
                  } else {
                      const match = line.match(/^([^:]+):\s*(.*)$/);
                      if (match) {
                          const key = match[1].trim();
                          const value = match[2].trim();
                          item[key] = value;
                      }
                  }
              }

              item.worldbookContent = worldbookContent.trim();

              if (item.åç§° && item.ç¨€æœ‰åº¦ && item.ç±»å‹ && item.æè¿°) {
                  return item;
              }
              return null;
          },

          async handleRedeemCode(code, onSuccessCallback) {
              if (!code || !code.trim()) {
                  this.showTemporaryMessage('è¯·è¾“å…¥å…‘æ¢ç ã€‚');
                  return;
              }
              const upperCaseCode = code.trim().toUpperCase();
              
              const manualCodeDB = {
                  'GUIXU666': { reward: 1600, type: 'mengChen' },
                  'MENGXING888': { reward: 3200, type: 'mengChen' }
              };
              const manualEntry = manualCodeDB[upperCaseCode];
              
              if (manualEntry) {
                  if (this.gachaState.redeemedCodes.includes(upperCaseCode)) {
                      this.showTemporaryMessage('æ‚¨å·²ç»å…‘æ¢è¿‡è¿™ä¸ªç¤¼åŒ…äº†ã€‚');
                      if (onSuccessCallback) onSuccessCallback();
                      return;
                  }
                  // 1. è·å–çŠ¶æ€
                  const mvuData = this.currentMvuState;
                  if (!mvuData) {
                      this.showTemporaryMessage('å‘ç”Ÿå†…éƒ¨é”™è¯¯ï¼Œå…‘æ¢å¤±è´¥', 'error');
                      return;
                  }
                  
                  // 2. åŸå­åŒ–ä¿®æ”¹
                  const path = 'å½’å¢Ÿç‚¹';
                  const currentPoints = parseInt(Mvu.getMvuVariable(mvuData, path, { default_value: 0 }), 10);
                  await Mvu.setMvuVariable(mvuData, path, currentPoints + manualEntry.reward, { reason: `å…‘æ¢ç  ${upperCaseCode}` });

                  // 3. åŒæ­¥å›åç«¯
                  await Mvu.replaceMvuData(mvuData, { type: 'message', message_id: 'latest' });
                  // --- MVU API é‡æ„ç»“æŸ ---

                  this.gachaState.redeemedCodes.push(upperCaseCode);
                  this.saveGachaState(); // åªä¿å­˜å…‘æ¢ç ä½¿ç”¨è®°å½•
                  this.showTemporaryMessage(`å…‘æ¢æˆåŠŸï¼è·å¾— ${manualEntry.reward} å½’å¢Ÿç‚¹ï¼`, 3000);
                  
                  // 4. åˆ·æ–°UI
                  this.renderSummonTab(this.currentGachaPoolType);
                  if (onSuccessCallback) onSuccessCallback();
                  return;
              }
               this.showTemporaryMessage('æ— æ•ˆçš„å…‘æ¢ç ã€‚');
          },
     

          saveGachaCheatState() {
              AppStorage.saveData('gacha_cheat_mode', this.isGachaCheatMode);
          },

          loadGachaCheatState() {
              this.isGachaCheatMode = AppStorage.loadData('gacha_cheat_mode', false);
          },

          _loadGachaDataFromSave(saveData) {
              if (saveData && saveData.gacha_data) {
                  this.gachaState = saveData.gacha_data.state;
                  this.gachaCollection = saveData.gacha_data.collection;
                  this.gachaHistory = saveData.gacha_data.history;
                  console.log('[è¡æ¢¦å°˜] å·²æˆåŠŸä»å­˜æ¡£æ–‡ä»¶åŠ è½½Gachaæ•°æ®ã€‚');
              } else {
                  // å¦‚æœæ˜¯æ—§å­˜æ¡£æˆ–æ–°æ¸¸æˆï¼Œåˆ™é‡ç½®ä¸ºåˆå§‹çŠ¶æ€
                  this.gachaState = { mengChen: 1600, pitySSR_char: 0, pitySR_char: 0, pitySSR_item: 0, pitySR_item: 0, pitySSR_talent: 0, pitySR_talent: 0, redeemedCodes: [] };
                  this.gachaCollection = {};
                  this.gachaHistory = [];
                  console.log('[è¡æ¢¦å°˜] æœªåœ¨å­˜æ¡£ä¸­æ‰¾åˆ°Gachaæ•°æ®ï¼Œå·²é‡ç½®ä¸ºåˆå§‹çŠ¶æ€ã€‚');
              }
              // å°†ä»å­˜æ¡£åŠ è½½çš„çŠ¶æ€ï¼Œç«‹åˆ»ä¿å­˜ä¸ºå½“å‰çš„å®æ—¶çŠ¶æ€ï¼Œä»¥ä¾¿åˆ·æ–°åèƒ½æ­£ç¡®ä¿ç•™
              this.saveGachaState();
          },
          async handleJoinWorld(itemData, poolType) {
              const isAlreadyQueued = this.pendingActions.some(action => action.itemName === itemData.åç§°);
              if (isAlreadyQueued) {
                  this.showTemporaryMessage(`[${itemData.åç§°}] å·²åœ¨æŒ‡ä»¤é˜Ÿåˆ—ä¸­ã€‚`, 'info');
                  return;
              }
              const isAlreadyActive = poolType === 'character' ?
                  this.gachaState.activeCompanions.some(c => c.id === itemData.id) :
                  this.gachaState.activatedItems.includes(itemData.id);
              if (isAlreadyActive) {
                  this.showTemporaryMessage(`[${itemData.åç§°}] å·²åŠ å…¥æˆ–å·²æ¿€æ´»ã€‚`, 'info');
                  return;
              }
              if (!itemData.worldbookContent || itemData.worldbookContent.trim() === '') {
                  this.showTemporaryMessage(`â€œ${itemData.åç§°}â€æ²¡æœ‰è¯¦ç»†ä¿¡æ¯ï¼Œæ— æ³•å†™å…¥ä¸–ç•Œä¹¦ã€‚`, 'warning');
              } else {
                  this.showTemporaryMessage(`æ­£åœ¨ä¸ºâ€œ${itemData.åç§°}â€å†™å…¥ä¸–ç•Œä¹¦...`, 'info');
                  try {
                      const bookName = '1å½’å¢Ÿ';
                      const allEntries = await TavernHelper.getLorebookEntries(bookName);
                      const existingEntry = allEntries.find(entry => entry.comment === itemData.åç§°);

                      if (existingEntry) {
                          await TavernHelper.setLorebookEntries(bookName, [{
                              uid: existingEntry.uid,
                              content: itemData.worldbookContent,
                              enabled: true
                          }]);
                          this.showTemporaryMessage(`å·²æˆåŠŸè¦†ç›–â€œ${itemData.åç§°}â€çš„ä¸–ç•Œä¹¦æ¡ç›®ï¼`, 'success');
                      } else {
                          await TavernHelper.createLorebookEntries(bookName, [{
                              comment: itemData.åç§°,
                              content: itemData.worldbookContent,
                              enabled: true
                          }]);
                          this.showTemporaryMessage(`å·²ä¸ºâ€œ${itemData.åç§°}â€åˆ›å»ºæ–°çš„ä¸–ç•Œä¹¦æ¡ç›®ï¼`, 'success');
                      }
                  } catch (e) {
                      console.error('å†™å…¥ä¸–ç•Œä¹¦æ¡ç›®å¤±è´¥:', e);
                      this.showTemporaryMessage('å†™å…¥ä¸–ç•Œä¹¦æ¡ç›®å¤±è´¥', 'error');
                      return; // å†™å…¥å¤±è´¥åˆ™ä¸­æ­¢
                  }
              }
              if (poolType === 'character') {
                  this.gachaState.activeCompanions.push({ id: itemData.id, name: itemData.åç§°, rarity: itemData.ç¨€æœ‰åº¦ });
              } else {
                  this.gachaState.activatedItems.push(itemData.id);
              }
              this.saveGachaState();
              const type = itemData.ç±»å‹ || 'è§’è‰²';
              const description = itemData.æè¿° || 'æ— ç®€ä»‹';
              const commandText = `[ç³»ç»Ÿæç¤º] "æˆ‘"é€šè¿‡è¡æ¢¦å°˜è·å¾—äº†åä¸ºã€${itemData.åç§°}ã€‘çš„${type}ã€‚æè¿°ï¼š${description}`;
              this.addCommand(commandText);
              if (document.getElementById('gacha-gallery-popup').style.display === 'flex') {
                  this.showGachaGalleryPopup(poolType);
              }
              this.closeModal('gacha-details-modal');
          },
       applyPanelWidths() {
           const gameContainer = document.querySelector('.game-container');
           if (gameContainer) {
               const leftWidth = this.leftPanelCollapsed ? '0px' : `${this.leftPanelWidth}%`;
               const rightWidth = this.rightPanelCollapsed ? '0px' : `${this.rightPanelWidth}%`;
               gameContainer.style.gridTemplateColumns = `${leftWidth} 1fr ${rightWidth}`;
           }
       },

       savePanelWidths() {
           try {
               localStorage.setItem('guixu_leftPanelWidth', this.leftPanelWidth);
               localStorage.setItem('guixu_rightPanelWidth', this.rightPanelWidth);
           } catch (e) {
               console.error('Failed to save panel widths to localStorage', e);
           }
       },

       loadPanelWidths() {
           try {
               const left = localStorage.getItem('guixu_leftPanelWidth');
               const right = localStorage.getItem('guixu_rightPanelWidth');
               if (left !== null) this.leftPanelWidth = parseInt(left, 10);
               if (right !== null) this.rightPanelWidth = parseInt(right, 10);
               
               this.applyPanelWidths();
           } catch (e) {
               console.error('Failed to load panel widths from localStorage', e);
           }
       },

       initPanelWidthSliders() {
           const leftSlider = document.getElementById('left-panel-width-slider');
           const leftValue = document.getElementById('left-panel-width-value');
           const rightSlider = document.getElementById('right-panel-width-slider');
           const rightValue = document.getElementById('right-panel-width-value');

           if (leftSlider && leftValue) {
               leftSlider.value = this.leftPanelWidth;
               leftValue.textContent = `${this.leftPanelWidth}%`;
               leftSlider.addEventListener('input', (e) => {
                   this.leftPanelWidth = e.target.value;
                   leftValue.textContent = `${e.target.value}%`;
                   this.applyPanelWidths();
                   this.savePanelWidths();
               });
           }

           if (rightSlider && rightValue) {
               rightSlider.value = this.rightPanelWidth;
               rightValue.textContent = `${this.rightPanelWidth}%`;
               rightSlider.addEventListener('input', (e) => {
                   this.rightPanelWidth = e.target.value;
                   rightValue.textContent = `${e.target.value}%`;
                   this.applyPanelWidths();
                   this.savePanelWidths();
               });
           }
       },
     };
// ===è¡æ¢¦å°˜/æŠ½å¡/Gachaç³»ç»Ÿç»“æŸ===



// ===é¿å…å†…å­˜æ³„æ¼ä¸GuixuManagerå…¨å±€æš´éœ²===
          if (window.GuixuManager && typeof window.GuixuManager.destroy === 'function') {
          window.GuixuManager.destroy();
        }
        window.GuixuManager = GuixuManager;
          eventOn(tavern_events.APP_READY, () => {
            GuixuManager.init();
// ===é¿å…å†…å­˜æ³„æ¼ä¸GuixuManagerå…¨å±€æš´éœ²===    

        
// ===è¿‡æ»¤æ— å…³çš„æ§åˆ¶å°é”™è¯¯ï¼Œé¿å…å¹²æ‰°è°ƒè¯•===
            const originalConsoleError = console.error;
            console.error = function(...args) {
              const message = args.join(' ');
              if (message.includes('ui-icons') ||
                  message.includes('MIME type') ||
                  message.includes('stylesheet MIME type') ||
                  message.includes('404 (Not Found)')) {
                return; // é™é»˜å¤„ç†è¿™äº›é”™è¯¯
              }
              originalConsoleError.apply(console, args);
            };
          });
// ===è¿‡æ»¤æ— å…³çš„æ§åˆ¶å°é”™è¯¯ï¼Œé¿å…å¹²æ‰°è°ƒè¯•==


// ===è®¾ç½®ç•Œé¢æ¨¡å—å¼€å§‹===
          // --- è®¾ç½®ç•Œé¢é¢æ¿åˆ‡æ¢åŠŸèƒ½ ---
          function initSettingsPanelSwitcher() {
            setTimeout(() => {
              // è·å–æ‰€æœ‰å¯¼èˆªæŒ‰é’®å’Œé¢æ¿
              const navButtons = document.querySelectorAll('.sidebar-nav-btn');
              const panels = document.querySelectorAll('.settings-panel');                      
              if (navButtons.length === 0 || panels.length === 0) {
                return;
              }
              // åˆ‡æ¢é¢æ¿çš„å‡½æ•°
              function switchPanel(targetCategory) {            
                panels.forEach(panel => {
                  panel.classList.remove('active');
                });                
                navButtons.forEach(btn => {
                  btn.classList.remove('active');
                });
                const targetPanel = document.getElementById(targetCategory + '-panel');
                if (targetPanel) {
                  targetPanel.classList.add('active');
                } else {
                }                
                const targetButton = document.querySelector(`[data-category="${targetCategory}"]`);
                if (targetButton) {
                  targetButton.classList.add('active');
                }              
                if (targetCategory === 'interface') {
                  setTimeout(() => {
                    const widthSlider = document.getElementById('width-slider');
                    const heightSlider = document.getElementById('height-slider');
                    const resetSizeBtn = document.getElementById('reset-size-btn');
                    
                    if (widthSlider && !widthSlider.hasAttribute('data-bound')) {
                      widthSlider.addEventListener('input', (e) => {
                        if (window.GuixuManager) {
                          window.GuixuManager.updateWidthDisplay(e.target.value);
                        }
                      });
                      widthSlider.setAttribute('data-bound', 'true');
                    }
                    
                    if (heightSlider && !heightSlider.hasAttribute('data-bound')) {
                      heightSlider.addEventListener('input', (e) => {
                        if (window.GuixuManager) {
                          window.GuixuManager.updateHeightDisplay(e.target.value);
                        }
                      });
                      heightSlider.setAttribute('data-bound', 'true');
                    }
                    
                    if (resetSizeBtn && !resetSizeBtn.hasAttribute('data-bound')) {
                      resetSizeBtn.addEventListener('click', () => {
                        if (window.GuixuManager) {
                          window.GuixuManager.resetWindowSize();
                        }
                      });
                      resetSizeBtn.setAttribute('data-bound', 'true');
                    }                    
                    const modalWidthSlider = document.getElementById('modal-width-slider');
                    const modalHeightSlider = document.getElementById('modal-height-slider');
                    const resetModalSizeBtn = document.getElementById('reset-modal-size-btn');
                    
                    if (modalWidthSlider && !modalWidthSlider.hasAttribute('data-bound')) {
                      modalWidthSlider.addEventListener('input', (e) => {
                        if (window.GuixuManager) {
                          window.GuixuManager.updateModalWidthDisplay(e.target.value);
                        }
                      });
                      modalWidthSlider.setAttribute('data-bound', 'true');
                    }
                    
                    if (modalHeightSlider && !modalHeightSlider.hasAttribute('data-bound')) {
                      modalHeightSlider.addEventListener('input', (e) => {
                        if (window.GuixuManager) {
                          window.GuixuManager.updateModalHeightDisplay(e.target.value);
                        }
                      });
                      modalHeightSlider.setAttribute('data-bound', 'true');
                    }
                    
                    if (resetModalSizeBtn && !resetModalSizeBtn.hasAttribute('data-bound')) {
                      resetModalSizeBtn.addEventListener('click', () => {
                        if (window.GuixuManager) {
                          window.GuixuManager.resetModalSize();
                        }
                      });
                      resetModalSizeBtn.setAttribute('data-bound', 'true');
                    }
                  }, 100);
                }
              }
              navButtons.forEach(button => {
                button.addEventListener('click', function() {
                  const category = this.getAttribute('data-category');
                  if (category) {
                    switchPanel(category);
                  }
                });
              });
              switchPanel('interface');
            }, 100);
          }
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initSettingsPanelSwitcher);
          } else {
            initSettingsPanelSwitcher();
          }
// ===è®¾ç½®ç•Œé¢æ¨¡å—ç»“æŸ===



      })();
  
